fantasy land specification aka algebraic javascript specification this project specifies interoperability of common algebraic structures setoid ord semigroupoid category semigroup monoid group filterable functor contravariant apply applicative alt plus alternative foldable traversable chain chainrec monad extend comonad bifunctor profunctor general an algebra is a set of values a set of operators that it is closed under and some laws it must obey each fantasy land algebra is a separate specification an algebra may have dependencies on other algebras which must be implemented terminology value is any javascript value including any which have the structures defined below equivalent is an appropriate definition of equivalence for the given value the definition should ensure that the two values can be safely swapped out in a program that respects abstractions for example two lists are equivalent if they are equivalent at all indices two plain old javascript objects interpreted as dictionaries are equivalent when they are equivalent for all keys two promises are equivalent when they yield equivalent values two functions are equivalent if they yield equivalent outputs for equivalent inputs type signature notation the type signature notation used in this document is described below 1 is a member of e t can be read as the expression e is a member of type t true boolean true is a member of type boolean 42 integer number 42 is a member of type integer and number new types can be created via type constructors type constructors can take zero or more type arguments array is a type constructor which takes one type argument array string is the type of all arrays of strings each of the following has type array string foo bar baz array array string is the type of all arrays of arrays of strings each of the following has type array array string foo bar baz lowercase letters stand for type variables type variables can take any type unless they have been restricted by means of type constraints see fat arrow below arrow function type constructor is an infix type constructor that takes two type arguments where left argument is the input type and the right argument is the output type s input type can be a grouping of types to create the type of a function which accepts zero or more arguments the syntax is input types output type where input types comprises zero or more comma–space separated type representations and parens may be omitted for unary functions string array string is a type satisfied by functions which take a string and return an array string string array string array string is a type satisfied by functions which take a string and return a function which takes an array string and returns an array string string array string array string is a type satisfied by functions which take a string and an array string as arguments and return an array string number is a type satisfied by functions which do not take arguments and return a number squiggly arrow method type constructor when a function is a property of an object it is called a method all methods have an implicit parameter type the type of which they are a property a a a is a type satisfied by methods on objects of type a which take a type a as an argument and return a value of type a fat arrow expresses constraints on type variables in a a a see squiggly arrow above a can be of any type semigroup a a a a adds a constraint such that the type a must now satisfy the semigroup typeclass to satisfy a typeclass means to lawfully implement all functions methods specified by that typeclass for example traverse applicative f traversable t t a typerep f a f b f t b type constraints argument types return type method name method target type see the types section in sanctuarys docs for more info ↩ prefixed method names in order for a data type to be compatible with fantasy land its values must have certain properties these properties are all prefixed by fantasy land for example js mytype fantasy land map mytype a a b mytype b mytype prototype fantasy land map further in this document unprefixed names are used just to reduce noise for convenience you can use fantasy land package js var fl require fantasy land mytype prototype fl map var foo barfl map type representatives certain behaviours are defined from the perspective of a member of a type other behaviours do not require a member thus certain algebras require a type to provide a value level representative with certain properties the identity type for example could provide id as its type representative id typerep identity if a type provides a type representative each member of the type must have a constructor property which is a reference to the type representative algebras setoid a equals a true reflexivity a equals b b equals a symmetry if a equals b and b equals c then a equals c transitivity equals method hs equals setoid a a a boolean a value which has a setoid must provide an equals method the equals method takes one argument a equals b b must be a value of the same setoid if b is not the same setoid behaviour of equals is unspecified returning false is recommended equals must return a boolean true or false ord a value that implements the ord specification must also implement the setoid specification a lte b or b lte a totality if a lte b and b lte a then a equals b antisymmetry if a lte b and b lte c then a lte c transitivity lte method hs lte ord a a a boolean a value which has an ord must provide a lte method the lte method takes one argument a lte b b must be a value of the same ord if b is not the same ord behaviour of lte is unspecified returning false is recommended lte must return a boolean true or false semigroupoid a compose b compose c a compose b compose c associativity compose method hs compose semigroupoid c c i j c j k c i k a value which has a semigroupoid must provide a compose method the compose method takes one argument a compose b b must be a value of the same semigroupoid if b is not the same semigroupoid behaviour of compose is unspecified compose must return a value of the same semigroupoid category a value that implements the category specification must also implement the semigroupoid specification a compose c id is equivalent to a right identity c id compose a is equivalent to a left identity id method hs id category c c a a a value which has a category must provide an id function on its type representative c id given a value c one can access its type representative via the constructor property c constructor id id must return a value of the same category semigroup a concat b concat c is equivalent to a concat b concat c associativity concat method hs concat semigroup a a a a a value which has a semigroup must provide a concat method the concat method takes one argument s concat b b must be a value of the same semigroup if b is not the same semigroup behaviour of concat is unspecified concat must return a value of the same semigroup monoid a value that implements the monoid specification must also implement the semigroup specification m concat m empty is equivalent to m right identity m empty concat m is equivalent to m left identity empty method hs empty monoid m m a value which has a monoid must provide an empty function on its type representative m empty given a value m one can access its type representative via the constructor property m constructor empty empty must return a value of the same monoid group a value that implements the group specification must also implement the monoid specification g concat g invert is equivalent to g constructor empty right inverse g invert concat g is equivalent to g constructor empty left inverse invert method hs invert group g g g a value which has a group must provide an invert method the invert method takes no arguments g invert invert must return a value of the same group filterable v filter x p x q x is equivalent to v filter p filter q distributivity v filter x true is equivalent to v identity v filter x false is equivalent to w filter x false if v and w are values of the same filterable annihilation filter method hs filter filterable f f a a boolean f a a value which has a filterable must provide a filter method the filter method takes one argument v filter p p must be a function if p is not a function the behaviour of filter is unspecified p must return either true or false if it returns any other value the behaviour of filter is unspecified filter must return a value of the same filterable functor u map a a is equivalent to u identity u map x f g x is equivalent to u map g map f composition map method hs map functor f f a a b f b a value which has a functor must provide a map method the map method takes one argument u map f f must be a function if f is not a function the behaviour of map is unspecified f can return any value no parts of fs return value should be checked map must return a value of the same functor contravariant u contramap a a is equivalent to u identity u contramap x f g x is equivalent to u contramap f contramap g composition contramap method hs contramap contravariant f f a b a f b a value which has a contravariant must provide a contramap method the contramap method takes one argument u contramap f f must be a function if f is not a function the behaviour of contramap is unspecified f can return any value no parts of fs return value should be checked contramap must return a value of the same contravariant apply a value that implements the apply specification must also implement the functor specification v ap u ap a map f g x f g x is equivalent to v ap u ap a composition ap method hs ap apply f f a f a b f b a value which has an apply must provide an ap method the ap method takes one argument a ap b b must be an apply of a function if b does not represent a function the behaviour of ap is unspecified b must be same apply as a a must be an apply of any value ap must apply the function in apply b to the value in apply a no parts of return value of that function should be checked the apply returned by ap must be the same as a and b applicative a value that implements the applicative specification must also implement the apply specification v ap a of x x is equivalent to v identity a of x ap a of f is equivalent to a of f x homomorphism a of y ap u is equivalent to u ap a of f f y interchange of method hs of applicative f a f a a value which has an applicative must provide an of function on its type representative the of function takes one argument f of a given a value f one can access its type representative via the constructor property f constructor of a of must provide a value of the same applicative no parts of a should be checked alt a value that implements the alt specification must also implement the functor specification a alt b alt c is equivalent to a alt b alt c associativity a alt b map f is equivalent to a map f alt b map f distributivity alt method hs alt alt f f a f a f a a value which has a alt must provide a alt method the alt method takes one argument a alt b b must be a value of the same alt if b is not the same alt behaviour of alt is unspecified a and b can contain any value of same type no parts of as and bs containing value should be checked alt must return a value of the same alt plus a value that implements the plus specification must also implement the alt specification x alt a zero is equivalent to x right identity a zero alt x is equivalent to x left identity a zero map f is equivalent to a zero annihilation zero method hs zero plus f f a a value which has a plus must provide an zero function on its type representative a zero given a value x one can access its type representative via the constructor property x constructor zero zero must return a value of the same plus alternative a value that implements the alternative specification must also implement the applicative and plus specifications x ap f alt g is equivalent to x ap f alt x ap g distributivity x ap a zero is equivalent to a zero annihilation foldable u reduce is equivalent to u reduce acc x acc concat x reduce reduce method hs reduce foldable f f a b a b b b a value which has a foldable must provide a reduce method the reduce method takes two arguments u reduce f x f must be a binary function if f is not a function the behaviour of reduce is unspecified the first argument to f must be the same type as x f must return a value of the same type as x no parts of fs return value should be checked x is the initial accumulator value for the reduction no parts of x should be checked traversable a value that implements the traversable specification must also implement the functor and foldable specifications t u traverse f x x is equivalent to u traverse g t for any t such that t a map f is equivalent to t a map f naturality u traverse f f of is equivalent to f of u for any applicative f identity u traverse compose x new compose x is equivalent to new compose u traverse f x x map x x traverse g x x for compose defined below and any applicatives f and g composition js var compose function c this c c compose of function x return new compose f of g of x compose prototype ap function f return new compose this c ap f c map u y y ap u compose prototype map function f return new compose this c map y y map f traverse method hs traverse applicative f traversable t t a typerep f a f b f t b a value which has a traversable must provide a traverse method the traverse method takes two arguments u traverse a f a must be the type representative of an applicative f must be a function which returns a value if f is not a function the behaviour of traverse is unspecified f must return a value of the type represented by a traverse must return a value of the type represented by a chain a value that implements the chain specification must also implement the apply specification m chain f chain g is equivalent to m chain x f x chain g associativity chain method hs chain chain m m a a m b m b a value which has a chain must provide a chain method the chain method takes one argument m chain f f must be a function which returns a value if f is not a function the behaviour of chain is unspecified f must return a value of the same chain chain must return a value of the same chain chainrec a value that implements the chainrec specification must also implement the chain specification m chainrec next done v p v d v map done n v map next i is equivalent to function step v return p v d v n v chain step i equivalence stack usage of m chainrec f i must be at most a constant multiple of the stack usage of f itself chainrec method hs chainrec chainrec m a c b c a m c a m b a type which has a chainrec must provide a chainrec function on its type representative the chainrec function takes two arguments m chainrec f i given a value m one can access its type representative via the constructor property m constructor chainrec f i f must be a function which returns a value if f is not a function the behaviour of chainrec is unspecified f takes three arguments next done value next is a function which takes one argument of same type as i and can return any value done is a function which takes one argument and returns the same type as the return value of next value is some value of the same type as i f must return a value of the same chainrec which contains a value returned from either done or next chainrec must return a value of the same chainrec which contains a value of same type as argument of done monad a value that implements the monad specification must also implement the applicative and chain specifications m of a chain f is equivalent to f a left identity m chain m of is equivalent to m right identity extend a value that implements the extend specification must also implement the functor specification w extend g extend f is equivalent to w extend w f w extend g extend method hs extend extend w w a w a b w b an extend must provide an extend method the extend method takes one argument w extend f f must be a function which returns a value if f is not a function the behaviour of extend is unspecified f must return a value of type v for some variable v contained in w no parts of fs return value should be checked extend must return a value of the same extend comonad a value that implements the comonad specification must also implement the extend specification w extend w w extract is equivalent to w left identity w extend f extract is equivalent to f w right identity extract method hs extract comonad w w a a a value which has a comonad must provide an extract method on itself the extract method takes no arguments w extract extract must return a value of type v for some variable v contained in w v must have the same type that f returns in extend bifunctor a value that implements the bifunctor specification must also implement the functor specification p bimap a a b b is equivalent to p identity p bimap a f g a b h i b is equivalent to p bimap g i bimap f h composition bimap method hs bimap bifunctor f f a c a b c d f b d a value which has a bifunctor must provide a bimap method the bimap method takes two arguments c bimap f g f must be a function which returns a value if f is not a function the behaviour of bimap is unspecified f can return any value no parts of fs return value should be checked g must be a function which returns a value if g is not a function the behaviour of bimap is unspecified g can return any value no parts of gs return value should be checked bimap must return a value of the same bifunctor profunctor a value that implements the profunctor specification must also implement the functor specification p promap a a b b is equivalent to p identity p promap a f g a b h i b is equivalent to p promap f i promap g h composition promap method hs promap profunctor p p b c a b c d p a d a value which has a profunctor must provide a promap method the profunctor method takes two arguments c promap f g f must be a function which returns a value if f is not a function the behaviour of promap is unspecified f can return any value no parts of fs return value should be checked g must be a function which returns a value if g is not a function the behaviour of promap is unspecified g can return any value no parts of gs return value should be checked promap must return a value of the same profunctor derivations when creating data types which satisfy multiple algebras authors may choose to implement certain methods then derive the remaining methods derivations equals may be derived from lte js function other return this lte other other lte this map may be derived from ap and of js function f return this ap this of f map may be derived from chain and of js function f return this chain a this of f a map may be derived from bimap js function f return this bimap a a f map may be derived from promap js function f return this promap a a f ap may be derived from chain js function m return m chain f this map f reduce may be derived as follows js function f acc function const value this value value const of function return new const acc const prototype map function return this const prototype ap function b return new const f b value this value return this traverse x new const x const of value map may be derived as follows js function f function id value this value value id of function x return new id x id prototype map function f return new id f this value id prototype ap function b return new id this value b value return this traverse x id of f x id of value filter may be derived from of chain and zero js function pred var f this constructor return this chain x pred x f of x f zero filter may be derived from concat of zero and reduce js function pred var f this constructor return this reduce f x pred x f concat f of x f f zero if a data type provides a method which could be derived its behaviour must be equivalent to that of the derivation or derivations notes if theres more than a single way to implement the methods and laws the implementation should choose one and provide wrappers for other uses its discouraged to overload the specified methods it can easily result in broken and buggy behaviour it is recommended to throw an exception on unspecified behaviour an identity container which implements many of the methods is provided by sanctuary identity alternatives there also exists static land specification with exactly the same ideas as fantasy land but based on static methods instead of instance methods