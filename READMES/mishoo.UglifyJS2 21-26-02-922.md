uglifyjs 3 uglifyjs is a javascript parser minifier compressor and beautifier toolkit note uglify js 3 has a simplified api and cli that is not backwards compatible with uglify js 2 documentation for uglifyjs 2 x releases can be found here uglify js only supports javascript ecmascript 5 to minify ecmascript 2015 or above transpile using tools like babel install first make sure you have installed the latest version of node js you may need to restart your computer after this step from npm for use as a command line app npm install uglify js g from npm for programmatic use npm install uglify js command line usage uglifyjs input files options uglifyjs can take multiple input files its recommended that you pass the input files first then pass the options uglifyjs will parse input files in sequence and apply any compression options the files are parsed in the same global scope that is a reference from a file to some variable function declared in another file will be matched properly if no input file is specified uglifyjs will read from stdin if you wish to pass your options before the input files separate the two with a double dash to prevent input files being used as option arguments uglifyjs compress mangle input js command line options h help print usage information help options for details on available options v version print version number p parse options specify parser options acorn use acorn for parsing bare returns allow return outside of functions useful when minifying commonjs modules and userscripts that may be anonymous function wrapped iife by the user js engine caller expression parse a single expression rather than a program for parsing json spidermonkey assume input files are spidermonkey ast format as json c compress options enable compressor specify compressor options pure funcs list of functions that can be safely removed when their return values are not used m mangle options mangle names specify mangler options reserved list of names that should not be mangled mangle props options mangle properties specify mangler options builtins mangle property names that overlaps with standard javascript globals debug add debug prefix and suffix domprops mangle property names that overlaps with dom properties keep quoted only mangle unquoted properties regex only mangle matched property names reserved list of names that should not be mangled b beautify options beautify output specify output options beautify enabled with beautify by default preamble preamble to prepend to the output you can use this to insert a comment for example for licensing information this will not be parsed but the source map will adjust for its presence quote style quote style 0 auto 1 single 2 double 3 original wrap iife wrap iifes in parenthesis note you may want to disable negate iife under compressor options o output file output file path default stdout specify ast or spidermonkey to write uglifyjs or spidermonkey ast as json to stdout respectively comments filter preserve copyright comments in the output by default this works like google closure keeping jsdoc style comments that contain license or preserve you can optionally pass one of the following arguments to this flag all to keep all comments a valid js regexp like foo or to keep only matching comments note that currently not all comments can be kept when compression is on because of dead code removal or cascading statements into sequences config file file read minify options from json file d define expr value global definitions e enclose arg value embed everything in a big function with configurable argument s value s ie8 support non standard internet explorer 8 equivalent to setting ie8 true in minify for compress mangle and output options by default uglifyjs will not try to be ie proof keep fnames do not mangle drop function names useful for code relying on function prototype name name cache file file to hold mangled name mappings self build uglifyjs as a library implies wrap uglifyjs source map options enable source map specify source map options base path to compute relative paths from input files content input source map useful if youre compressing js that was generated from some other original code specify inline if the source map is included within the sources filename filename and or location of the output source sets file attribute in source map includesources pass this flag if you want to include the content of source files in the source map as sourcescontent property root path to the original source to be included in the source map url if specified path to the source map to append in sourcemappingurl timings display operations run time on stderr toplevel compress and or mangle variables in top level scope verbose print diagnostic messages warn print warning messages wrap name embed everything in a big function making the “exports” and “global” variables available you need to pass an argument to this option to specify the name that your module will take when included in say a browser specify output o to declare the output file otherwise the output goes to stdout cli source map options uglifyjs can generate a source map file which is highly useful for debugging your compressed javascript to get a source map pass source map output output js source map will be written out to output js map additional options source map filename name to specify the name of the source map the value of filename is only used to set file attribute see the spec in source map file source map root url to pass the url where the original files can be found source map url url to specify the url where the source map can be found otherwise uglifyjs assumes http x sourcemap is being used and will omit the sourcemappingurl directive for example uglifyjs js file1 js js file2 js \ o foo min js c m \ source map root http foo com src url foo min js map the above will compress and mangle file1 js and file2 js will drop the output in foo min js and the source map in foo min js map the source mapping will refer to http foo com src js file1 js and http foo com src js file2 js in fact it will list http foo com src as the source map root and the original files as js file1 js and js file2 js composed source map when youre compressing js code that was output by a compiler such as coffeescript mapping to the js code wont be too helpful instead youd like to map back to the original code i e coffeescript uglifyjs has an option to take an input source map assuming you have a mapping from coffeescript → compiled js uglifyjs can generate a map from coffeescript → compressed js by mapping every token in the compiled js to its original location to use this feature pass source map content path to input source map or source map content inline if the source map is included inline with the sources cli compress options you need to pass compress c to enable the compressor optionally you can pass a comma separated list of compress options options are in the form foo bar or just foo the latter implies a boolean option that you want to set true its effectively a shortcut for foo true example uglifyjs file js c toplevel sequences false cli mangle options to enable the mangler you need to pass mangle m the following comma separated options are supported toplevel default false mangle names declared in the top level scope eval default false mangle names visible in scopes where eval or with are used when mangling is enabled but you want to prevent certain names from being mangled you can declare those names with mangle reserved — pass a comma separated list of names for example uglifyjs m reserved require exports to prevent the require exports and names from being changed cli mangling property names mangle props note this will probably break your code mangling property names is a separate step different from variable name mangling pass mangle props to enable it it will mangle all properties in the input code with the exception of built in dom properties and properties in core javascript classes for example javascript example js var x baz 0 foo 1 calc function return this foo this baz x bar 2 x baz 3 console log x calc mangle all properties except for javascript builtins bash uglifyjs example js c m mangle props javascript var x o 0 1 l function return this this o x t 2 x o 3 console log x l mangle all properties except for reserved properties bash uglifyjs example js c m mangle props reserved foo bar javascript var x o 0 foo 1 function return this foo this o x bar 2 x o 3 console log x mangle all properties matching a regex bash uglifyjs example js c m mangle props regex javascript var x o 0 1 calc function return this this o x l 2 x o 3 console log x calc combining mangle properties options bash uglifyjs example js c m mangle props regex reserved bar javascript var x o 0 1 calc function return this this o x bar 2 x o 3 console log x calc in order for this to be of any use we avoid mangling standard js names by default mangle props builtins to override a default exclusion file is provided in tools domprops json which should cover most standard js and dom properties defined in various browsers pass mangle props domprops to disable this feature a regular expression can be used to define which property names should be mangled for example mangle props regex will only mangle property names that start with an underscore when you compress multiple files using this option in order for them to work together in the end we need to ensure somehow that one property gets mangled to the same name in all of them for this pass name cache filename json and uglifyjs will maintain these mappings in a file which can then be reused it should be initially empty example bash rm f tmp cache json start fresh uglifyjs file1 js file2 js mangle props name cache tmp cache json o part1 js uglifyjs file3 js file4 js mangle props name cache tmp cache json o part2 js now part1 js and part2 js will be consistent with each other in terms of mangled property names using the name cache is not necessary if you compress all your files in a single call to uglifyjs mangling unquoted names mangle props keep quoted using quoted property name o foo reserves the property name foo so that it is not mangled throughout the entire script even when used in an unquoted style o foo example javascript stuff js var o foo 1 bar 3 o foo o bar console log o foo bash uglifyjs stuff js mangle props keep quoted c m javascript var o foo 1 o 3 o foo o o console log o foo debugging property name mangling you can also pass mangle props debug in order to mangle property names without completely obscuring them for example the property o foo would mangle to o foo with this option this allows property mangling of a large codebase while still being able to debug the code and identify where mangling is breaking things bash uglifyjs stuff js mangle props debug c m javascript var o foo 1 bar 3 o foo o bar console log o foo you can also pass a custom suffix using mangle props debug xyz this would then mangle o foo to o foo xyz you can change this each time you compile a script to identify how a property got mangled one technique is to pass a random number on every compile to simulate mangling changing with different inputs e g as you update the input script with new properties and to help identify mistakes like writing mangled keys to storage api reference assuming installation via npm you can load uglifyjs in your application like this javascript var uglifyjs require uglify js there is a single high level function minify code options which will perform all minification phases in a configurable manner by default minify will enable the options compress and mangle example javascript var code function add first second return first second var result uglifyjs minify code console log result error runtime error or undefined if no error console log result code minified output function add n d return n d you can minify more than one javascript file at a time by using an object for the first argument where the keys are file names and the values are source code javascript var code file1 js function add first second return first second file2 js console log add 1 2 3 4 var result uglifyjs minify code console log result code function add d n return d n console log add 3 7 the toplevel option javascript var code file1 js function add first second return first second file2 js console log add 1 2 3 4 var options toplevel true var result uglifyjs minify code options console log result code console log 3 7 the namecache option javascript var options mangle toplevel true namecache var result1 uglifyjs minify file1 js function add first second return first second options var result2 uglifyjs minify file2 js console log add 1 2 3 4 options console log result1 code function n n r return n r console log result2 code console log n 3 7 you may persist the name cache to the file system in the following way javascript var cachefilename tmp cache json var options mangle properties true namecache json parse fs readfilesync cachefilename utf8 fs writefilesync part1 js uglifyjs minify file1 js fs readfilesync file1 js utf8 file2 js fs readfilesync file2 js utf8 options code utf8 fs writefilesync part2 js uglifyjs minify file3 js fs readfilesync file3 js utf8 file4 js fs readfilesync file4 js utf8 options code utf8 fs writefilesync cachefilename json stringify options namecache utf8 an example of a combination of minify options javascript var code file1 js function add first second return first second file2 js console log add 1 2 3 4 var options toplevel true compress global defs console log alert passes 2 output beautify false preamble uglified var result uglifyjs minify code options console log result code uglified alert 10 to produce warnings javascript var code function f var u return 2 3 var options warnings true var result uglifyjs minify code options console log result error runtime error undefined in this case console log result warnings dropping unused variable u 0 1 18 console log result code function f return 5 an error example javascript var result uglifyjs minify foo js if 0 else console log 1 console log json stringify result error message unexpected token keyword else filename foo js line 1 col 7 pos 7 note unlike uglify js 2 x the 3 x api does not throw errors to achieve a similar effect one could do the following javascript var result uglifyjs minify code options if result error throw result error minify options warnings default false — pass true to return compressor warnings in result warnings use the value verbose for more detailed warnings parse default — pass an object if you wish to specify some additional parse options compress default — pass false to skip compressing entirely pass an object to specify custom compress options mangle default true — pass false to skip mangling names or pass an object to specify mangle options see below mangle properties default false — a subcategory of the mangle option pass an object to specify custom mangle property options output default null — pass an object if you wish to specify additional output options the defaults are optimized for best compression sourcemap default false pass an object if you wish to specify source map options toplevel default false set to true if you wish to enable top level variable and function name mangling and to drop unused variables and functions namecache default null pass an empty object or a previously used namecache object if you wish to cache mangled variable and property names across multiple invocations of minify note this is a read write property minify will read the name cache state of this object and update it during minification so that it may be reused or externally persisted by the user ie8 default false set to true to support ie8 keep fnames default false pass true to prevent discarding or mangling of function names useful for code relying on function prototype name minify options structure javascript parse parse options compress compress options mangle mangle options properties mangle property options output output options sourcemap source map options namecache null or specify a name cache object toplevel false ie8 false warnings false source map options to generate a source map javascript var result uglifyjs minify file1 js var a function sourcemap filename out js url out js map console log result code minified output console log result map source map note that the source map is not saved in a file its just returned in result map the value passed for sourcemap url is only used to set sourcemappingurl out js map in result code the value of filename is only used to set file attribute see the spec in source map file you can set option sourcemap url to be inline and source map will be appended to code you can also specify sourceroot property to be included in source map javascript var result uglifyjs minify file1 js var a function sourcemap root http example com src url out js map if youre compressing compiled javascript and have a source map for it you can use sourcemap content javascript var result uglifyjs minify compiled js compiled code sourcemap content content from compiled js map url minified js map same as before it returns code and map if youre using the x sourcemap header instead you can just omit sourcemap url parse options bare returns default false support top level return statements html5 comments default true shebang default true support command as the first line compress options arguments default true replace arguments index with function parameter name whenever possible booleans default true various optimizations for boolean context for example a b c → a b c collapse vars default true collapse single use non constant variables side effects permitting comparisons default true apply certain optimizations to binary nodes e g a b → a b attempts to negate binary nodes e g a b c d e → a b c d e etc conditionals default true apply optimizations for if s and conditional expressions dead code default true remove unreachable code directives default true remove redundant or non standard directives drop console default false pass true to discard calls to console functions if you wish to drop a specific function call such as console info and or retain side effects from function arguments after dropping the function call then use pure funcs instead drop debugger default true remove debugger statements evaluate default true attempt to evaluate constant expressions expression default false pass true to preserve completion values from terminal statements without return e g in bookmarklets global defs default see conditional compilation hoist funs default false hoist function declarations hoist props default true hoist properties from constant object and array literals into regular variables subject to a set of constraints for example var o p 1 q 2 f o p o q is converted to f 1 2 note hoist props works best with mangle enabled the compress option passes set to 2 or higher and the compress option toplevel enabled hoist vars default false hoist var declarations this is false by default because it seems to increase the size of the output in general if return default true optimizations for if return and if continue inline default true inline calls to function with simple return statement false same as 0 0 disabled inlining 1 inline simple functions 2 inline functions with arguments 3 inline functions with arguments and variables true same as 3 join vars default true join consecutive var statements keep fargs default true prevents the compressor from discarding unused function arguments you need this for code which relies on function length keep fnames default false pass true to prevent the compressor from discarding function names useful for code relying on function prototype name see also the keep fnames mangle option keep infinity default false pass true to prevent infinity from being compressed into 1 0 which may cause performance issues on chrome loops default true optimizations for do while and for loops when we can statically determine the condition negate iife default true negate immediately called function expressions where the return value is discarded to avoid the parens that the code generator would insert passes default 1 the maximum number of times to run compress in some cases more than one pass leads to further compressed code keep in mind more passes will take more time properties default true rewrite property access using the dot notation for example foo bar → foo bar pure funcs default null you can pass an array of names and uglifyjs will assume that those functions do not produce side effects danger will not check if the name is redefined in scope an example case here for instance var q math floor a b if variable q is not used elsewhere uglifyjs will drop it but will still keep the math floor a b not knowing what it does you can pass pure funcs math floor to let it know that this function wont produce any side effect in which case the whole statement would get discarded the current implementation adds some overhead compression will be slower make sure symbols under pure funcs are also under mangle reserved to avoid mangling pure getters default strict if you pass true for this uglifyjs will assume that object property access e g foo bar or foo bar doesnt have any side effects specify strict to treat foo bar as side effect free only when foo is certain to not throw i e not null or undefined reduce funcs default true allows single use functions to be inlined as function expressions when permissible allowing further optimization enabled by default option depends on reduce vars being enabled some code runs faster in the chrome v8 engine if this option is disabled does not negatively impact other major browsers reduce vars default true improve optimization on variables assigned with and used as constant values sequences default true join consecutive simple statements using the comma operator may be set to a positive integer to specify the maximum number of consecutive comma sequences that will be generated if this option is set to true then the default sequences limit is 200 set option to false or 0 to disable the smallest sequences length is 2 a sequences value of 1 is grandfathered to be equivalent to true and as such means 200 on rare occasions the default sequences limit leads to very slow compress times in which case a value of 20 or less is recommended side effects default true pass false to disable potentially dropping functions marked as pure a function call is marked as pure if a comment annotation pure or pure immediately precedes the call for example pure foo switches default true de duplicate and remove unreachable switch branches toplevel default false drop unreferenced functions funcs and or variables vars in the top level scope false by default true to drop both unreferenced functions and variables top retain default null prevent specific toplevel functions and variables from unused removal can be array comma separated regexp or function implies toplevel typeofs default true transforms typeof foo undefined into foo void 0 note recommend to set this value to false for ie10 and earlier versions due to known issues unsafe default false apply unsafe transformations discussion below unsafe comps default false compress expressions like a b assuming none of the operands can be coerced to nan unsafe function default false compress and mangle function args code when both args and code are string literals unsafe math default false optimize numerical expressions like 2 x 3 into 6 x which may give imprecise floating point results unsafe proto default false optimize expressions like array prototype slice call a into slice call a unsafe regexp default false enable substitutions of variables with regexp values the same way as if they are constants unsafe undefined default false substitute void 0 if there is a variable named undefined in scope variable name will be mangled typically reduced to a single character unused default true drop unreferenced functions and variables simple direct variable assignments do not count as references unless set to keep assign warnings default false display warnings when dropping unreachable code or unused declarations etc mangle options eval default false pass true to mangle names visible in scopes where eval or with are used keep fnames default false pass true to not mangle function names useful for code relying on function prototype name see also the keep fnames compress option reserved default pass an array of identifiers that should be excluded from mangling example foo bar toplevel default false pass true to mangle names declared in the top level scope examples javascript test js var globalvar function funcname firstlongname anotherlongname var myvariable firstlongname anotherlongname javascript var code fs readfilesync test js utf8 uglifyjs minify code code function funcname a n var globalvar uglifyjs minify code mangle reserved firstlongname code function funcname firstlongname a var globalvar uglifyjs minify code mangle toplevel true code function n n a var a mangle properties options builtins default false use true to allow the mangling of builtin dom properties not recommended to override this setting debug default false — mangle names with the original name still present pass an empty string to enable or a non empty string to set the debug suffix keep quoted default false — only mangle unquoted property names regex default null — pass a regexp literal to only mangle property names matching the regular expression reserved default do not mangle property names listed in the reserved array output options the code generator tries to output shortest code possible by default in case you want beautified output pass beautify b optionally you can pass additional arguments that control the code output ascii only default false escape unicode characters in strings and regexps affects directives with non ascii characters becoming invalid beautify default true whether to actually beautify the output passing b will set this to true but you might need to pass b even when you want to generate minified code in order to specify additional arguments so you can use b beautify false to override it braces default false always insert braces in if for do while or with statements even if their body is a single statement comments default false pass true or all to preserve all comments some to preserve some comments a regular expression string e g or a function indent level default 4 indent start default 0 prefix all lines by that many spaces inline script default true escape html comments and the slash in occurrences of script in strings keep quoted props default false when turned on prevents stripping quotes from property names in object literals max line len default false maximum line length for uglified code preamble default null when passed it must be a string and it will be prepended to the output literally the source map will adjust for this text can be used to insert a comment containing licensing information for example preserve line default false pass true to preserve lines but it only works if beautify is set to false quote keys default false pass true to quote all keys in literal objects quote style default 0 preferred quote style for strings affects quoted property names and directives as well 0 prefers double quotes switches to single quotes when there are more double quotes in the string itself 0 is best for gzip size 1 always use single quotes 2 always use double quotes 3 always use the original quotes semicolons default true separate statements with semicolons if you pass false then whenever possible we will use a newline instead of a semicolon leading to more readable output of uglified code size before gzip could be smaller size after gzip insignificantly larger shebang default true preserve shebang in preamble bash scripts webkit default false enable workarounds for webkit bugs phantomjs users should set this option to true width default 80 only takes effect when beautification is on this specifies an orientative line width that the beautifier will try to obey it refers to the width of the line text excluding indentation it doesnt work very well currently but it does make the code generated by uglifyjs more readable wrap iife default false pass true to wrap immediately invoked function expressions see 640 for more details miscellaneous keeping copyright notices or other comments you can pass comments to retain certain comments in the output by default it will keep jsdoc style comments that contain preserve license or cc on conditional compilation for ie you can pass comments all to keep all the comments or a valid javascript regexp to keep only comments that match this regexp for example comments will keep comments like copyright notice note however that there might be situations where comments are lost for example javascript function f preserve foo bar function g this function is never called return something even though it has preserve the comment will be lost because the inner function g which is the ast node to which the comment is attached to is discarded by the compressor as not referenced the safest comments where to place copyright information or other info that needs to be kept in the output are comments attached to toplevel nodes the unsafe compress option it enables some transformations that might break code logic in certain contrived cases but should be fine for most code you might want to try it on your own code it should reduce the minified size heres what happens when this flag is on new array 1 2 3 or array 1 2 3 → 1 2 3 new object → string exp or exp tostring → exp new object regexp function error array → we discard the new conditional compilation you can use the define d switch in order to declare global variables that uglifyjs will assume to be constants unless defined in scope for example if you pass define debug false then coupled with dead code removal uglifyjs will discard the following from the output javascript if debug console log debug stuff you can specify nested constants in the form of define env debug false uglifyjs will warn about the condition being always false and about dropping unreachable code for now there is no option to turn off only this specific warning you can pass warnings false to turn off all warnings another way of doing that is to declare your globals as constants in a separate file and include it into the build for example you can have a build defines js file with the following javascript var debug false var production true etc and build your code like this uglifyjs build defines js js foo js js bar js c uglifyjs will notice the constants and since they cannot be altered it will evaluate references to them to the value itself and drop unreachable code as usual the build will contain the const declarations if you use them if you are targeting es6 environments which does not support const using var with reduce vars enabled by default should suffice conditional compilation api you can also use conditional compilation via the programmatic api with the difference that the property name is global defs and is a compressor property javascript var result uglifyjs minify fs readfilesync input js utf8 compress dead code true global defs debug false to replace an identifier with an arbitrary non constant expression it is necessary to prefix the global defs key with to instruct uglifyjs to parse the value as an expression javascript uglifyjs minify alert hello compress global defs alert console log code returns console log hello otherwise it would be replaced as string literal javascript uglifyjs minify alert hello compress global defs alert console log code returns console log hello using native uglify ast with minify javascript example parse only produce native uglify ast var result uglifyjs minify code parse compress false mangle false output ast true code false optional faster if false result ast contains native uglify ast javascript example accept native uglify ast input and then compress and mangle to produce both code and native ast var result uglifyjs minify ast compress mangle output ast true code true optional faster if false result ast contains native uglify ast result code contains the minified code in string form working with uglify ast transversal and transformation of the native ast can be performed through treewalker and treetransformer respectively estree spidermonkey ast uglifyjs has its own abstract syntax tree format for practical reasons we cant easily change to using the spidermonkey ast internally however uglifyjs now has a converter which can import a spidermonkey ast for example acorn is a super fast parser that produces a spidermonkey ast it has a small cli utility that parses one file and dumps the ast in json on the standard output to use uglifyjs to mangle and compress that acorn file js uglifyjs p spidermonkey m c the p spidermonkey option tells uglifyjs that all input files are not javascript but js code described in spidermonkey ast in json therefore we dont use our own parser in this case but just transform that ast into our internal ast use acorn for parsing more for fun i added the p acorn option which will use acorn to do all the parsing if you pass this option uglifyjs will require acorn acorn is really fast e g 250ms instead of 380ms on some 650k code but converting the spidermonkey tree that acorn produces takes another 150ms so in total its a bit more than just using uglifyjss own parser uglify fast minify mode its not well known but whitespace removal and symbol mangling accounts for 95 of the size reduction in minified code for most javascript not elaborate code transforms one can simply disable compress to speed up uglify builds by 3 to 4 times in this fast mangle only mode uglify has comparable minify speeds and gzip sizes to butternut d3 js minify size gzip size minify time seconds original 451 131 108 733 uglify js 3 0 24 mangle false compress false 316 600 85 245 0 70 uglify js 3 0 24 mangle true compress false 220 216 72 730 1 13 butternut 0 4 6 217 568 72 738 1 41 uglify js 3 0 24 mangle true compress true 212 511 71 560 3 36 babili 0 1 4 210 713 72 140 12 64 to enable fast minify mode from the cli use uglifyjs file js m to enable fast minify mode with the api use js uglifyjs minify code compress false mangle true source maps and debugging various compress transforms that simplify rearrange inline and remove code are known to have an adverse effect on debugging with source maps this is expected as code is optimized and mappings are often simply not possible as some code no longer exists for highest fidelity in source map debugging disable the uglify compress option and just use mangle compiler assumptions to allow for better optimizations the compiler makes various assumptions tostring and valueof dont have side effects and for built in objects they have not been overridden undefined nan and infinity have not been externally redefined arguments callee arguments caller and function prototype caller are not used the code doesnt expect the contents of function prototype tostring or error prototype stack to be anything in particular getting and setting properties on a plain object does not cause other side effects using watch or proxy object properties can be added removed and modified not prevented with object defineproperty object defineproperties object freeze object preventextensions or object seal