vegeta vegeta is a versatile http load testing tool built out of a need to drill http services with a constant request rate it can be used both as a command line utility and a library install pre compiled executables get them here homebrew on mac os x you can install vegeta using the homebrew package manager on mac os x shell brew update brew install vegeta source you need go installed and gobin in your path once that is done run the command shell go get u github com tsenart vegeta versioning both the library and the cli are versioned with semver v2 0 0 after v8 0 0 the two components are versioned separately to better isolate breaking changes to each cli releases are tagged with cli vmajor minor patch and published on the github releases page as for the library new versions are tagged with lib vmajor minor patch but not published as a release contributing see contributing md usage manual console usage vegeta global flags command flags global flags cpus int number of cpus to use default 8 profile string enable profiling of cpu heap version print version and exit attack command body string requests body file cert string tls client pem encoded certificate file connections int max open idle connections per target host default 10000 duration duration duration of the test 0 forever format string targets format http json default http h2c send http 2 requests without tls encryption header value request header http2 send http 2 requests when supported by the server default true insecure ignore invalid server tls certificates keepalive use persistent connections default true key string tls client pem encoded private key file laddr value local ip address default 0 0 0 0 lazy read targets lazily name string attack name output string output file default stdout rate uint requests per second default 50 redirects int number of redirects to follow 1 will not follow but marks as success default 10 root certs value tls root certificate files comma separated list targets string targets file default stdin timeout duration requests timeout default 30s workers uint initial number of workers default 10 report command inputs string input files comma separated default stdin output string output file default stdout reporter string reporter text json plot hist buckets default text dump command dumper string dumper json csv default json inputs string input files comma separated default stdin output string output file default stdout examples echo get http localhost vegeta attack duration 5s tee results bin vegeta report vegeta attack targets targets txt results bin vegeta report inputs results bin reporter json metrics json cat results bin vegeta report reporter plot plot html cat results bin vegeta report reporter hist 0 100ms 200ms 300ms cpus specifies the number of cpus to be used internally it defaults to the amount of cpus available in the system profile specifies which profiler to enable during execution both cpu and heap profiles are supported it defaults to none version prints the version and exits attack command body specifies the file whose content will be set as the body of every request unless overridden per attack target see targets cert specifies the pem encoded tls client certificate file to be used with https requests if key isnt specified it will be set to the value of this flag connections specifies the maximum number of idle open connections per target host duration specifies the amount of time to issue request to the targets the internal concurrency structures setup has this value as a variable the actual run time of the test can be longer than specified due to the responses delay use 0 for an infinite attack format specifies the targets format to decode json format the json format makes integration with programs that produce targets dynamically easier each target is one json object in its own line the method and url fields are required if present the body field must be base64 encoded the generated json schema defines the format in detail bash jq ncm method get url http goku body punch base64 header content type text plain vegeta attack format json rate 100 vegeta dump http format the http format almost resembles the plain text http message format defined in rfc 2616 but it doesnt support in line http bodies only references to files that are loaded and used as request bodies as exemplified below although targets in this format can be produced by other programs it was originally meant to be used by people writing targets by hand for simple use cases here are a few examples of valid targets files in the http format simple targets get http goku 9090 path to dragon item ball get http user password goku 9090 path to head http goku 9090 path to success targets with custom headers get http user password goku 9090 path to x account id 8675309 delete http goku 9090 path to remove confirmation token 90215 authorization token deadbeef targets with custom bodies post http goku 9090 things path to newthing json patch http goku 9090 thing 71988591 path to thing 71988591 json targets with custom bodies and headers post http goku 9090 things x account id 99 path to newthing json h2c specifies that http2 requests are to be sent over tcp without tls encryption header specifies a request header to be used in all targets defined see targets you can specify as many as needed by repeating the flag http2 specifies whether to enable http 2 requests to servers which support it insecure specifies whether to ignore invalid server tls certificates keepalive specifies whether to reuse tcp connections between http requests key specifies the pem encoded tls client certificate private key file to be used with https requests laddr specifies the local ip address to be used lazy specifies whether to read the input targets lazily instead of eagerly this allows streaming targets into the attack command and reduces memory footprint the trade off is one of added latency in each hit against the targets output specifies the output file to which the binary results will be written to made to be piped to the report command input defaults to stdout rate specifies the requests per second rate to issue against the targets the actual request rate can vary slightly due to things like garbage collection but overall it should stay very close to the specified redirects specifies the max number of redirects followed on each request the default is 10 when the value is 1 redirects are not followed but the response is marked as successful root certs specifies the trusted tls root cas certificate files as a comma separated list if unspecified the default system cas certificates will be used targets specifies the attack targets in a line separated file defaulting to stdin the format should be as follows combining any or all of the following timeout specifies the timeout for each request the default is 0 which disables timeouts workers specifies the initial number of workers used in the attack the actual number of workers will increase if necessary in order to sustain the requested rate report command inputs specifies the input files to generate the report of defaulting to stdin these are the output of vegeta attack you can specify more than one comma separated and they will be merged and sorted before being used by the reports output specifies the output file to which the report will be written to reporter specifies the kind of report to be generated it defaults to text text console requests total rate 1200 120 00 duration total attack wait 10 094965987s 9 949883921s 145 082066ms latencies mean 50 95 99 max 113 172398ms 108 272568ms 140 18235ms 247 771566ms 264 815246ms bytes in total mean 3714690 3095 57 bytes out total mean 0 0 00 success ratio 55 42 status codes code count 0 535 200 665 error set get http localhost 6060 dial tcp 127 0 0 1 6060 connection refused get http localhost 6060 read tcp 127 0 0 1 6060 connection reset by peer get http localhost 6060 dial tcp 127 0 0 1 6060 connection reset by peer get http localhost 6060 write tcp 127 0 0 1 6060 broken pipe get http localhost 6060 net http transport closed before response was received get http localhost 6060 http cant write http request on broken connection json json latencies total 237119463 mean 2371194 50th 2854306 95th 3478629 99th 3530000 max 3660505 bytes in total 606700 mean 6067 bytes out total 0 mean 0 earliest 2015 09 19t14 45 50 645818631 02 00 latest 2015 09 19t14 45 51 635818575 02 00 end 2015 09 19t14 45 51 639325797 02 00 duration 989999944 wait 3507222 requests 100 rate 101 01010672380401 success 1 status codes 200 100 errors plot generates an html5 page with an interactive plot based on dygraphs click and drag to select a region to zoom into double click to zoom out input a different number on the bottom left corner input field to change the moving average window size in data points each point on the plot shows a request the x axis represents the time at the start of the request and the y axis represents the time taken to complete that request hist computes and prints a text based histogram for the given buckets each bucket upper bound is non inclusive console cat results bin vegeta report reporter hist 0 2ms 4ms 6ms bucket histogram 0 2ms 6007 32 65 2ms 4ms 5505 29 92 4ms 6ms 2117 11 51 6ms inf 4771 25 93 dump command inputs specifies the input files containing attack results to be dumped you can specify more than one comma separated output specifies the output file to which the dump will be written to dumper specifies the dump format json dumps attack results as json objects csv dumps attack results as csv records with six columns the columns are unix timestamp in ns since epoch http status code request latency in ns bytes out bytes in and lastly the error usage distributed attacks whenever your load test cant be conducted due to vegeta hitting machine limits such as open files memory cpu or network bandwidth its a good idea to use vegeta in a distributed manner in a hypothetical scenario where the desired attack rate is 60k requests per second lets assume we have 3 machines with vegeta installed make sure open file descriptor and process limits are set to a high number for your user on each machine using the ulimit command were ready to start the attack all we need to do is to divide the intended rate by the number of machines and use that number on each attack here well use pdsh for orchestration shell pdsh rcmd type ssh pdsh b w 10 0 1 1 10 0 2 1 10 0 3 1 \ echo get http target vegeta attack rate 20000 duration 60s result bin after the previous command finishes we can gather the result files to use on our report shell for machine in 10 0 1 1 10 0 2 1 10 0 3 1 do scp machine result bin machine bin done the report command accepts multiple result files in a comma separated list itll read and sort them by timestamp before generating reports console vegeta report inputs 10 0 1 1 bin 10 0 2 1 bin 10 0 3 1 bin requests total rate 3600000 60000 00 latencies mean 95 99 max 223 340085ms 326 913687ms 416 537743ms 7 788103259s bytes in total mean 3714690 3095 57 bytes out total mean 0 0 00 success ratio 100 0 status codes code count 200 3600000 error set usage real time analysis if you are a happy user of iterm you can integrate vegeta with jplot using jaggr to plot a vegeta report in real time in the comfort of you terminal echo get http localhost 8080 \ vegeta attack rate 5000 duration 10m vegeta dump \ jaggr count rps \ hist\ 100 200 300 400 500\ code \ p25 p50 p95 latency \ sum bytes in \ sum bytes out \ jplot rps code hist 100 code hist 200 code hist 300 code hist 400 code hist 500 \ latency p95 latency p50 latency p25 \ bytes in sum bytes out sum usage library the library versioning follows semver v2 0 0 since lib v9 0 0 the library and cli are versioned separately to better isolate breaking changes to each component go package main import fmt time vegeta github com tsenart vegeta lib func main rate uint64 100 per second duration 4 time second targeter vegeta newstatictargeter vegeta target method get url http localhost 9100 attacker vegeta newattacker var metrics vegeta metrics for res range attacker attack targeter rate duration metrics add res metrics close fmt printf 99th percentile s\n metrics latencies p99 limitations there will be an upper bound of the supported rate which varies on the machine being used you could be cpu bound unlikely memory bound more likely or have system resource limits being reached which ought to be tuned for the process execution the important limits for us are file descriptors and processes on a unix system you can get and set the current soft limit values for a user shell ulimit n file descriptors 2560 ulimit u processes threads 709 just pass a new number as the argument to change it license see license donate if you use and love vegeta please consider sending some satoshi to 1mdmkc51ve7upxt75konm6x1qdxhfk6iw2 in case you want to be mentioned as a sponsor let me know