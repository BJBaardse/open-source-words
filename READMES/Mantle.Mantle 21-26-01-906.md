mantle mantle makes it easy to write a simple model layer for your cocoa or cocoa touch application the typical model object whats wrong with the way model objects are usually written in objective c lets use the github api for demonstration how would one typically represent a github issue in objective c objc typedef enum nsuinteger ghissuestateopen ghissuestateclosed ghissuestate interface ghissue nsobject property nonatomic copy readonly nsurl url property nonatomic copy readonly nsurl htmlurl property nonatomic copy readonly nsnumber number property nonatomic assign readonly ghissuestate state property nonatomic copy readonly nsstring reporterlogin property nonatomic copy readonly nsdate updatedat property nonatomic strong readonly ghuser assignee property nonatomic copy readonly nsdate retrievedat property nonatomic copy nsstring title property nonatomic copy nsstring body id initwithdictionary nsdictionary dictionary end objc implementation ghissue nsdateformatter dateformatter nsdateformatter dateformatter nsdateformatter alloc init dateformatter locale nslocale alloc initwithlocaleidentifier en us posix dateformatter dateformat yyyy mm ddthh mm ssz return dateformatter id initwithdictionary nsdictionary dictionary self self init if self nil return nil url nsurl urlwithstring dictionary url htmlurl nsurl urlwithstring dictionary html url number dictionary number if dictionary state isequaltostring open state ghissuestateopen else if dictionary state isequaltostring closed state ghissuestateclosed title dictionary title copy retrievedat nsdate date body dictionary body copy reporterlogin dictionary user login copy assignee ghuser alloc initwithdictionary dictionary assignee updatedat self class dateformatter datefromstring dictionary updated at return self id initwithcoder nscoder coder self self init if self nil return nil url coder decodeobjectforkey url htmlurl coder decodeobjectforkey htmlurl number coder decodeobjectforkey number state coder decodeunsignedintegerforkey state title coder decodeobjectforkey title retrievedat nsdate date body coder decodeobjectforkey body reporterlogin coder decodeobjectforkey reporterlogin assignee coder decodeobjectforkey assignee updatedat coder decodeobjectforkey updatedat return self void encodewithcoder nscoder coder if self url nil coder encodeobject self url forkey url if self htmlurl nil coder encodeobject self htmlurl forkey htmlurl if self number nil coder encodeobject self number forkey number if self title nil coder encodeobject self title forkey title if self body nil coder encodeobject self body forkey body if self reporterlogin nil coder encodeobject self reporterlogin forkey reporterlogin if self assignee nil coder encodeobject self assignee forkey assignee if self updatedat nil coder encodeobject self updatedat forkey updatedat coder encodeunsignedinteger self state forkey state id copywithzone nszone zone ghissue issue self class allocwithzone zone init issue url self url issue htmlurl self htmlurl issue number self number issue state self state issue reporterlogin self reporterlogin issue assignee self assignee issue updatedat self updatedat issue title self title issue retrievedat nsdate date issue body self body return issue nsuinteger hash return self number hash bool isequal ghissue issue if issue iskindofclass ghissue class return no return self number isequal issue number self title isequal issue title self body isequal issue body end whew thats a lot of boilerplate for something so simple and even then there are some problems that this example doesnt address theres no way to update a ghissue with new data from the server theres no way to turn a ghissue back into json ghissuestate shouldnt be encoded as is if the enum changes in the future existing archives might break if the interface of ghissue changes down the road existing archives might break why not use core data core data solves certain problems very well if you need to execute complex queries across your data handle a huge object graph with lots of relationships or support undo and redo core data is an excellent fit it does however come with a couple of pain points theres still a lot of boilerplate managed objects reduce some of the boilerplate seen above but core data has plenty of its own correctly setting up a core data stack with a persistent store and persistent store coordinator and executing fetches can take many lines of code its hard to get right even experienced developers can make mistakes when using core data and the framework is not forgiving if youre just trying to access some json objects core data can be a lot of work for little gain nonetheless if youre using or want to use core data in your app already mantle can still be a convenient translation layer between the api and your managed model objects mtlmodel enter mtlmodel this is what ghissue looks like inheriting from mtlmodel objc typedef enum nsuinteger ghissuestateopen ghissuestateclosed ghissuestate interface ghissue mtlmodel property nonatomic copy readonly nsurl url property nonatomic copy readonly nsurl htmlurl property nonatomic copy readonly nsnumber number property nonatomic assign readonly ghissuestate state property nonatomic copy readonly nsstring reporterlogin property nonatomic strong readonly ghuser assignee property nonatomic copy readonly nsdate updatedat property nonatomic copy nsstring title property nonatomic copy nsstring body property nonatomic copy readonly nsdate retrievedat end objc implementation ghissue nsdateformatter dateformatter nsdateformatter dateformatter nsdateformatter alloc init dateformatter locale nslocale alloc initwithlocaleidentifier en us posix dateformatter dateformat yyyy mm ddthh mm ssz return dateformatter nsdictionary jsonkeypathsbypropertykey return url url htmlurl html url number number state state reporterlogin user login assignee assignee updatedat updated at nsvaluetransformer urljsontransformer return nsvaluetransformer valuetransformerforname mtlurlvaluetransformername nsvaluetransformer htmlurljsontransformer return nsvaluetransformer valuetransformerforname mtlurlvaluetransformername nsvaluetransformer statejsontransformer return nsvaluetransformer mtl valuemappingtransformerwithdictionary open ghissuestateopen closed ghissuestateclosed nsvaluetransformer assigneejsontransformer return mtljsonadapter dictionarytransformerwithmodelclass ghuser class nsvaluetransformer updatedatjsontransformer return mtlvaluetransformer transformerusingforwardblock id nsstring datestring bool success nserror autoreleasing error return self dateformatter datefromstring datestring reverseblock id nsdate date bool success nserror autoreleasing error return self dateformatter stringfromdate date instancetype initwithdictionary nsdictionary dictionaryvalue error nserror error self super initwithdictionary dictionaryvalue error error if self nil return nil store a value that needs to be determined locally upon initialization retrievedat nsdate date return self end notably absent from this version are implementations of nscoding nscopying isequal and hash by inspecting the property declarations you have in your subclass mtlmodel can provide default implementations for all these methods the problems with the original example all happen to be fixed as well theres no way to update a ghissue with new data from the server mtlmodel has an extensible mergevaluesforkeysfrommodel method which makes it easy to specify how new model data should be integrated theres no way to turn a ghissue back into json this is where reversible transformers really come in handy mtljsonadapter jsondictionaryfrommodel error can transform any model object conforming to mtljsonserializing back into a json dictionary mtljsonadapter jsonarrayfrommodels error is the same but turns an array of model objects into an json array of dictionaries if the interface of ghissue changes down the road existing archives might break mtlmodel automatically saves the version of the model object that was used for archival when unarchiving decodevalueforkey withcoder modelversion will be invoked if overridden giving you a convenient hook to upgrade old data mtljsonserializing in order to serialize your model objects from or into json you need to implement mtljsonserializing in your mtlmodel subclass this allows you to use mtljsonadapter to convert your model objects from json and back objc nserror error nil xyuser user mtljsonadapter modelofclass xyuser class fromjsondictionary jsondictionary error error objc nserror error nil nsdictionary jsondictionary mtljsonadapter jsondictionaryfrommodel user error error jsonkeypathsbypropertykey the dictionary returned by this method specifies how your model objects properties map to the keys in the json representation for example objc interface xyuser mtlmodel property readonly nonatomic copy nsstring name property readonly nonatomic strong nsdate createdat property readonly nonatomic assign getter ismeuser bool meuser property readonly nonatomic strong xyhelper helper end implementation xyuser nsdictionary jsonkeypathsbypropertykey return name name createdat created at instancetype initwithdictionary nsdictionary dictionaryvalue error nserror error self super initwithdictionary dictionaryvalue error error if self nil return nil helper xyhelper helperwithname self name createdat self createdat return self end in this example the xyuser class declares four properties that mantle handles in different ways name is mapped to a key of the same name in the json representation createdat is converted to its snake case equivalent meuser is not serialized into json helper is initialized exactly once after json deserialization use nsdictionary mtl dictionarybyaddingentriesfromdictionary if your models superclass also implements mtljsonserializing to merge their mappings if youd like to map all properties of a model class to themselves you can use the nsdictionary mtl identitypropertymapwithmodel helper method when deserializing json using mtljsonadapter modelofclass fromjsondictionary error json keys that dont correspond to a property name or have an explicit mapping are ignored objc nsdictionary jsondictionary name john created at 2013 07 02 16 40 00 0000 plan lite xyuser user mtljsonadapter modelofclass xyuser class fromjsondictionary jsondictionary error error here the plan would be ignored since it neither matches a property name of xyuser nor is it otherwise mapped in jsonkeypathsbypropertykey jsontransformerforkey implement this optional method to convert a property from a different type when deserializing from json nsvaluetransformer jsontransformerforkey nsstring key if key isequaltostring createdat return nsvaluetransformer valuetransformerforname xydatevaluetransformername return nil key is the key that applies to your model object not the original json key keep this in mind if you transform the key names using jsonkeypathsbypropertykey for added convenience if you implement key jsontransformer mtljsonadapter will use the result of that method instead for example dates that are commonly represented as strings in json can be transformed to nsdates like so objc return mtlvaluetransformer transformerusingforwardblock id nsstring datestring bool success nserror autoreleasing error return self dateformatter datefromstring datestring reverseblock id nsdate date bool success nserror autoreleasing error return self dateformatter stringfromdate date if the transformer is reversible it will also be used when serializing the object into json classforparsingjsondictionary if you are implementing a class cluster implement this optional method to determine which subclass of your base class should be used when deserializing an object from json objc interface xymessage mtlmodel end interface xytextmessage xymessage property readonly nonatomic copy nsstring body end interface xypicturemessage xymessage property readonly nonatomic strong nsurl imageurl end implementation xymessage class classforparsingjsondictionary nsdictionary jsondictionary if jsondictionary image url nil return xypicturemessage class if jsondictionary body nil return xytextmessage class nsassert no no matching class for the json dictionary jsondictionary return self end mtljsonadapter will then pick the class based on the json dictionary you pass in objc nsdictionary textmessage id 1 body hello world nsdictionary picturemessage id 2 image url http example com lolcat gif xytextmessage messagea mtljsonadapter modelofclass xymessage class fromjsondictionary textmessage error null xypicturemessage messageb mtljsonadapter modelofclass xymessage class fromjsondictionary picturemessage error null persistence mantle doesnt automatically persist your objects for you however mtlmodel does conform to nscoding so model objects can be archived to disk using nskeyedarchiver if you need something more powerful or want to avoid keeping your whole model in memory at once core data may be a better choice system requirements mantle supports os x 10 9 and ios 8 0 importing mantle to add mantle to your application add the mantle repository as a submodule of your applications repository run git submodule update init recursive from within the mantle folder drag and drop mantle xcodeproj into your applications xcode project on the general tab of your application target add mantle framework to the embedded binaries carthage users can simply add mantle to their cartfile github mantle mantle if you would prefer to use cocoapods there are some mantle podspecs that have been generously contributed by third parties if youre instead developing mantle on its own use the mantle xcworkspace file license mantle is released under the mit license see license md more info have a question please open an issue