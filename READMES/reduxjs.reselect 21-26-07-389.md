reselect simple “selector” library for redux and others inspired by getters in nuclearjs subscriptions in re frame and this proposal from speedskater selectors can compute derived data allowing redux to store the minimal possible state selectors are efficient a selector is not recomputed unless one of its arguments changes selectors are composable they can be used as input to other selectors you can play around with the following example in this codepen js import createselector from reselect const shopitemsselector state state shop items const taxpercentselector state state shop taxpercent const subtotalselector createselector shopitemsselector items items reduce acc item acc item value 0 const taxselector createselector subtotalselector taxpercentselector subtotal taxpercent subtotal taxpercent 100 export const totalselector createselector subtotalselector taxselector subtotal tax total subtotal tax let examplestate shop taxpercent 8 items name apple value 1 20 name orange value 0 95 console log subtotalselector examplestate 2 15 console log taxselector examplestate 0 172 console log totalselector examplestate total 2 322 table of contents installation example motivation for memoized selectors creating a memoized selector composing selectors connecting a selector to the redux store accessing react props in selectors sharing selectors with props across multiple component instances api createselector defaultmemoize createselectorcreator createstructuredselector faq why isnt my selector recomputing when the input state changes why is my selector recomputing when the input state stays the same can i use reselect without redux the default memoization function is no good can i use a different one how do i test a selector how do i create a selector that takes an argument how do i use reselect with immutable js can i share a selector across multiple component instances are there typescript typings how can i make a curried selector related projects license installation npm install reselect example if you prefer a video tutorial you can find one here motivation for memoized selectors the examples in this section are based on the redux todos list example containers visibletodolist js js import connect from react redux import toggletodo from actions import todolist from components todolist const getvisibletodos todos filter switch filter case show all return todos case show completed return todos filter t t completed case show active return todos filter t t completed const mapstatetoprops state return todos getvisibletodos state todos state visibilityfilter const mapdispatchtoprops dispatch return ontodoclick id dispatch toggletodo id const visibletodolist connect mapstatetoprops mapdispatchtoprops todolist export default visibletodolist in the above example mapstatetoprops calls getvisibletodos to calculate todos this works great but there is a drawback todos is calculated every time the state tree is updated if the state tree is large or the calculation expensive repeating the calculation on every update may cause performance problems reselect can help to avoid these unnecessary recalculations creating a memoized selector we would like to replace getvisibletodos with a memoized selector that recalculates todos when the value of state todos or state visibilityfilter changes but not when changes occur in other unrelated parts of the state tree reselect provides a function createselector for creating memoized selectors createselector takes an array of input selectors and a transform function as its arguments if the redux state tree is mutated in a way that causes the value of an input selector to change the selector will call its transform function with the values of the input selectors as arguments and return the result if the values of the input selectors are the same as the previous call to the selector it will return the previously computed value instead of calling the transform function lets define a memoized selector named getvisibletodos to replace the non memoized version above selectors index js js import createselector from reselect const getvisibilityfilter state state visibilityfilter const gettodos state state todos export const getvisibletodos createselector getvisibilityfilter gettodos visibilityfilter todos switch visibilityfilter case show all return todos case show completed return todos filter t t completed case show active return todos filter t t completed in the example above getvisibilityfilter and gettodos are input selectors they are created as ordinary non memoized selector functions because they do not transform the data they select getvisibletodos on the other hand is a memoized selector it takes getvisibilityfilter and gettodos as input selectors and a transform function that calculates the filtered todos list composing selectors a memoized selector can itself be an input selector to another memoized selector here is getvisibletodos being used as an input selector to a selector that further filters the todos by keyword js const getkeyword state state keyword const getvisibletodosfilteredbykeyword createselector getvisibletodos getkeyword visibletodos keyword visibletodos filter todo todo text includes keyword connecting a selector to the redux store if you are using react redux you can call selectors as regular functions inside mapstatetoprops containers visibletodolist js js import connect from react redux import toggletodo from actions import todolist from components todolist import getvisibletodos from selectors const mapstatetoprops state return todos getvisibletodos state const mapdispatchtoprops dispatch return ontodoclick id dispatch toggletodo id const visibletodolist connect mapstatetoprops mapdispatchtoprops todolist export default visibletodolist accessing react props in selectors this section introduces a hypothetical extension to our app that allows it to support multiple todo lists please note that a full implementation of this extension requires changes to the reducers components actions etc that arent directly relevant to the topics discussed and have been omitted for brevity so far we have only seen selectors receive the redux store state as an argument but a selector can receive props too here is an app component that renders three visibletodolist component instances each of which has a listid prop components app js js import react from react import footer from footer import addtodo from containers addtodo import visibletodolist from containers visibletodolist const app each visibletodolist container should select a different slice of the state depending on the value of the listid prop so lets modify getvisibilityfilter and gettodos to accept a props argument selectors todoselectors js js import createselector from reselect const getvisibilityfilter state props state todolists props listid visibilityfilter const gettodos state props state todolists props listid todos const getvisibletodos createselector getvisibilityfilter gettodos visibilityfilter todos switch visibilityfilter case show completed return todos filter todo todo completed case show active return todos filter todo todo completed default return todos export default getvisibletodos props can be passed to getvisibletodos from mapstatetoprops js const mapstatetoprops state props return todos getvisibletodos state props so now getvisibletodos has access to props and everything seems to be working fine but there is a problem using the getvisibletodos selector with multiple instances of the visibletodolist container will not correctly memoize containers visibletodolist js js import connect from react redux import toggletodo from actions import todolist from components todolist import getvisibletodos from selectors const mapstatetoprops state props return warning the following selector does not correctly memoize todos getvisibletodos state props const mapdispatchtoprops dispatch return ontodoclick id dispatch toggletodo id const visibletodolist connect mapstatetoprops mapdispatchtoprops todolist export default visibletodolist a selector created with createselector has a cache size of 1 and only returns the cached value when its set of arguments is the same as its previous set of arguments if we alternate between rendering visibletodolist listid 1 and visibletodolist listid 2 the shared selector will alternate between receiving listid 1 and listid 2 as its props argument this will cause the arguments to be different on each call so the selector will always recompute instead of returning the cached value well see how to overcome this limitation in the next section sharing selectors with props across multiple component instances the examples in this section require react redux v4 3 0 or greater an alternative approach can be found in re reselect to share a selector across multiple visibletodolist instances while passing in props and retaining memoization each instance of the component needs its own private copy of the selector lets create a function named makegetvisibletodos that returns a new copy of the getvisibletodos selector each time it is called selectors todoselectors js js import createselector from reselect const getvisibilityfilter state props state todolists props listid visibilityfilter const gettodos state props state todolists props listid todos const makegetvisibletodos return createselector getvisibilityfilter gettodos visibilityfilter todos switch visibilityfilter case show completed return todos filter todo todo completed case show active return todos filter todo todo completed default return todos export default makegetvisibletodos we also need a way to give each instance of a container access to its own private selector the mapstatetoprops argument of connect can help with this if the mapstatetoprops argument supplied to connect returns a function instead of an object it will be used to create an individual mapstatetoprops function for each instance of the container in the example below makemapstatetoprops creates a new getvisibletodos selector and returns a mapstatetoprops function that has exclusive access to the new selector js const makemapstatetoprops const getvisibletodos makegetvisibletodos const mapstatetoprops state props return todos getvisibletodos state props return mapstatetoprops if we pass makemapstatetoprops to connect each instance of the visibletodolist container will get its own mapstatetoprops function with a private getvisibletodos selector memoization will now work correctly regardless of the render order of the visibletodolist containers containers visibletodolist js js import connect from react redux import toggletodo from actions import todolist from components todolist import makegetvisibletodos from selectors const makemapstatetoprops const getvisibletodos makegetvisibletodos const mapstatetoprops state props return todos getvisibletodos state props return mapstatetoprops const mapdispatchtoprops dispatch return ontodoclick id dispatch toggletodo id const visibletodolist connect makemapstatetoprops mapdispatchtoprops todolist export default visibletodolist api createselector inputselectors inputselectors resultfunc takes one or more selectors or an array of selectors computes their values and passes them as arguments to resultfunc createselector determines if the value returned by an input selector has changed between calls using reference equality inputs to selectors created with createselector should be immutable selectors created with createselector have a cache size of 1 this means they always recalculate when the value of an input selector changes as a selector only stores the preceding value of each input selector js const myselector createselector state state values value1 state state values value2 value1 value2 value1 value2 you can also pass an array of selectors const totalselector createselector state state values value1 state state values value2 value1 value2 value1 value2 it can be useful to access the props of a component from within a selector when a selector is connected to a component with connect the component props are passed as the second argument to the selector js const abselector state props state a props b props only ignoring state argument const cselector props props c state only props argument omitted as not required const dselector state state d const totalselector createselector abselector cselector dselector ab c d total ab c d defaultmemoize func equalitycheck defaultequalitycheck defaultmemoize memoizes the function passed in the func parameter it is the memoize function used by createselector defaultmemoize has a cache size of 1 this means it always recalculates when the value of an argument changes defaultmemoize determines if an argument has changed by calling the equalitycheck function as defaultmemoize is designed to be used with immutable data the default equalitycheck function checks for changes using reference equality js function defaultequalitycheck currentval previousval return currentval previousval defaultmemoize can be used with createselectorcreator to customize the equalitycheck function createselectorcreator memoize memoizeoptions createselectorcreator can be used to make a customized version of createselector the memoize argument is a memoization function to replace defaultmemoize the memoizeoptions rest parameters are zero or more configuration options to be passed to memoizefunc the selectors resultfunc is passed as the first argument to memoize and the memoizeoptions are passed as the second argument onwards js const customselectorcreator createselectorcreator custommemoize function to be used to memoize resultfunc option1 option1 will be passed as second argument to custommemoize option2 option2 will be passed as third argument to custommemoize option3 option3 will be passed as fourth argument to custommemoize const customselector customselectorcreator input1 input2 resultfunc resultfunc will be passed as first argument to custommemoize internally customselector calls the memoize function as follows js custommemoize resultfunc option1 option2 option3 here are some examples of how you might use createselectorcreator customize equalitycheck for defaultmemoize js import createselectorcreator defaultmemoize from reselect import isequal from lodash isequal create a selector creator that uses lodash isequal instead of const createdeepequalselector createselectorcreator defaultmemoize isequal use the new selector creator to create a selector const myselector createdeepequalselector state state values filter val val 5 values values reduce acc val acc val 0 use memoize function from lodash for an unbounded cache js import createselectorcreator from reselect import memoize from lodash memoize let called 0 const hashfn args args reduce acc val acc json stringify val const customselectorcreator createselectorcreator memoize hashfn const selector customselectorcreator state state a state state b a b called return a b createstructuredselector inputselectors selectorcreator createselector createstructuredselector is a convenience function for a common pattern that arises when using reselect the selector passed to a connect decorator often just takes the values of its input selectors and maps them to keys in an object js const myselectora state state a const myselectorb state state b the result function in the following selector is simply building an object from the input selectors const structuredselector createselector myselectora myselectorb myselectorc a b c a b c createstructuredselector takes an object whose properties are input selectors and returns a structured selector the structured selector returns an object with the same keys as the inputselectors argument but with the selectors replaced with their values js const myselectora state state a const myselectorb state state b const structuredselector createstructuredselector x myselectora y myselectorb const result structuredselector a 1 b 2 will produce x 1 y 2 structured selectors can be nested js const nestedselector createstructuredselector suba createstructuredselector selectora selectorb subb createstructuredselector selectorc selectord faq q why isnt my selector recomputing when the input state changes a check that your memoization function is compatible with your state update function i e the reducer if you are using redux for example a selector created with createselector will not work with a state update function that mutates an existing object instead of creating a new one each time createselector uses an identity check to detect that an input has changed so mutating an existing object will not trigger the selector to recompute because mutating an object does not change its identity note that if you are using redux mutating the state object is almost certainly a mistake the following example defines a simple selector that determines if the first todo item in an array of todos has been completed js const isfirsttodocompleteselector createselector state state todos 0 todo todo todo completed the following state update function will not work with isfirsttodocompleteselector js export default function todos state initialstate action switch action type case complete all const areallmarked state every todo todo completed bad mutating an existing object return state map todo todo completed areallmarked return todo default return state the following state update function will work with isfirsttodocompleteselector js export default function todos state initialstate action switch action type case complete all const areallmarked state every todo todo completed good returning a new object each time with object assign return state map todo object assign todo completed areallmarked default return state if you are not using redux and have a requirement to work with mutable data you can use createselectorcreator to replace the default memoization function and or use a different equality check function see here and here for examples q why is my selector recomputing when the input state stays the same a check that your memoization function is compatible with your state update function i e the reducer if you are using redux for example a selector created with createselector that recomputes unexpectedly may be receiving a new object on each update whether the values it contains have changed or not createselector uses an identity check to detect that an input has changed so returning a new object on each update means that the selector will recompute on each update js import remove old from constants actiontypes const initialstate text use redux completed false id 0 timestamp date now export default function todos state initialstate action switch action type case remove old return state filter todo return todo timestamp 30 24 60 60 1000 date now default return state the following selector is going to recompute every time remove old is invoked because array filter always returns a new object however in the majority of cases the remove old action will not change the list of todos so the recomputation is unnecessary js import createselector from reselect const todosselector state state todos export const visibletodosselector createselector todosselector todos you can eliminate unnecessary recomputations by returning a new object from the state update function only when a deep equality check has found that the list of todos has actually changed js import remove old from constants actiontypes import isequal from lodash isequal const initialstate text use redux completed false id 0 timestamp date now export default function todos state initialstate action switch action type case remove old const updatedstate state filter todo return todo timestamp 30 24 60 60 1000 date now return isequal updatedstate state state updatedstate default return state alternatively the default equalitycheck function in the selector can be replaced by a deep equality check js import createselectorcreator defaultmemoize from reselect import isequal from lodash isequal const todosselector state state todos create a selector creator that uses lodash isequal instead of const createdeepequalselector createselectorcreator defaultmemoize isequal use the new selector creator to create a selector const myselector createdeepequalselector todosselector todos always check that the cost of an alternative equalitycheck function or deep equality check in the state update function is not greater than the cost of recomputing every time if recomputing every time does work out to be the cheaper option it may be that for this case reselect is not giving you any benefit over passing a plain mapstatetoprops function to connect q can i use reselect without redux a yes reselect has no dependencies on any other package so although it was designed to be used with redux it can be used independently it is currently being used successfully in traditional flux apps if you create selectors using createselector make sure its arguments are immutable see here q how do i create a selector that takes an argument a keep in mind that selectors can access react props so if your arguments are or can be made available as react props you can use that functionality see here for details otherwise reselect doesnt have built in support for creating selectors that accepts arguments but here are some suggestions for implementing similar functionality if the argument is not dynamic you can use a factory function js const expensiveitemselectorfactory minvalue return createselector shopitemsselector items items filter item item value minvalue const subtotalselector createselector expensiveitemselectorfactory 200 items items reduce acc item acc item value 0 the general consensus here and over at nuclear js is that if a selector needs a dynamic argument then that argument should probably be state in the store if you decide that you do require a selector with a dynamic argument then a selector that returns a memoized function may be suitable js import createselector from reselect import memoize from lodash memoize const expensiveselector createselector state state items items memoize minvalue items filter item item value minvalue const expensivefilter expensiveselector state const slightlyexpensive expensivefilter 100 const veryexpensive expensivefilter 1000000 q the default memoization function is no good can i use a different one a we think it works great for a lot of use cases but sure see these examples q how do i test a selector a for a given input a selector should always produce the same output for this reason they are simple to unit test js const selector createselector state state a state state b a b c a 2 d b 3 test selector unit test assert deepequal selector a 1 b 2 c 2 d 6 assert deepequal selector a 2 b 3 c 4 d 9 it may also be useful to check that the memoization function for a selector works correctly with the state update function i e the reducer if you are using redux each selector has a recomputations method that will return the number of times it has been recomputed js suite selector let state a 1 b 2 const reducer state action a action state a b action state b const selector createselector state state a state state b a b c a 2 d b 3 const plusone x x 1 const id x x test selector unit test state reducer state plusone assert deepequal selector state c 4 d 9 state reducer state id assert deepequal selector state c 4 d 9 assert equal selector recomputations 1 state reducer state plusone assert deepequal selector state c 6 d 12 assert equal selector recomputations 2 additionally selectors keep a reference to the last result function as resultfunc if you have selectors composed of many other selectors this can help you test each selector without coupling all of your tests to the shape of your state for example if you have a set of selectors like this selectors js js export const firstselector createselector export const secondselector createselector export const thirdselector createselector export const mycomposedselector createselector firstselector secondselector thirdselector first second third first second third and then a set of unit tests like this test selectors js js tests for the first three selectors test firstselector unit test test secondselector unit test test thirdselector unit test we have already tested the previous three selector outputs so we can just call resultfunc with the values we want to test directly test mycomposedselector unit test here instead of calling selector we just call selector resultfunc assert mycomposedselector resultfunc 1 2 3 true assert mycomposedselector resultfunc 2 2 1 false finally each selector has a resetrecomputations method that sets recomputations back to 0 the intended use is for a complex selector that may have many independent tests and you dont want to manually manage the computation count or create a dummy selector for each test q how do i use reselect with immutable js a selectors created with createselector should work just fine with immutable js data structures if your selector is recomputing and you dont think the state has changed make sure you are aware of which immutable js update methods always return a new object and which update methods only return a new object when the collection actually changes js import immutable from immutable let mymap immutable map a 1 b 2 c 3 set merge and others only return a new obj when update changes collection let newmap mymap set a 1 assert equal mymap newmap newmap mymap merge a 1 assert equal mymap newmap map reduce filter and others always return a new obj newmap mymap map a a 1 assert notequal mymap newmap if a selectors input is updated by an operation that always returns a new object it may be performing unnecessary recomputations see here for a discussion on the pros and cons of using a deep equality check like immutable is to eliminate unnecessary recomputations q can i share a selector across multiple component instances a selectors created using createselector only have a cache size of one this can make them unsuitable for sharing across multiple instances if the arguments to the selector are different for each instance of the component there are a couple of ways to get around this create a factory function which returns a new selector for each instance of the component there is built in support for factory functions in react redux v4 3 or higher see here for an example create a custom selector with a cache size greater than one q are there typescript typings a yes they are included and referenced in package json they should just work™ q how can i make a curried selector a try these helper functions courtesy of mattspalmer related projects re reselect enhances reselect selectors by wrapping createselector and returning a memoized collection of selectors indexed with the cache key returned by a custom resolver function useful to reduce selectors recalculation when the same selector is repeatedly called with one few different arguments reselect tools chrome extension and companion lib for debugging selectors measure selector recomputations across the app and identify performance bottlenecks check selector dependencies inputs outputs and recomputations at any time with the chrome extension statically export a json representation of your selector graph for further analysis reselect map can be useful when doing very expensive computations on elements of a collection because reselect might not give you the granularity of caching that you need check out the reselect maps readme for examples the optimizations in reselect map only apply in a small number of cases if you are unsure whether you need it you dont license mit