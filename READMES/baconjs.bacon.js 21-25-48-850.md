bacon js a small functional reactive programming lib for javascript turns your event spaghetti into clean and declarative feng shui bacon by switching from imperative to functional its like replacing nested for loops with functional programming concepts like map and filter stop working on individual events and work with event streams instead combine your data with merge and combine then switch to the heavier weapons and wield flatmap and combinetemplate like a boss its the of events too bad the symbol is not allowed in javascript heres the stuff homepage source files generated javascript specs examples wiki with more docs related projects and more cheat sheet my blog with some baconful and reactive postings along with a bacon js tutorial bacon js blog bacon js google group for discussion and questions todomvc with bacon js and jquery stack overflow for well formed questions use the bacon js tag gitter chat for developers of bacon migrating to 2 0 and remember to give me feedback on the bacon let me know if youve used it tell me how it worked for you whats missing whats wrong please contribute table of contents bacon js table of contents install intro api creating streams bacon frombinder for custom streams common methods in eventstreams and properties eventstream property combining multiple streams and properties function construction rules lazy evaluation latest value of property or eventstream bus event event properties errors join patterns join patterns as a chemical machine join patterns and properties join patterns and bacon bus introspection and metadata cleaning up eventstream and property semantics atomic updates for rxjs users examples build test dependencies compatibility with other libs compatibility with browsers node js amd why bacon contribute sponsors install if youre targeting to node js you can npm install baconjs for bower users bower install bacon both minified and unminified versions available on cdnjs starting from 0 7 45 you can build your own bacon js bundle with selected features only see instructions here prefer to drink from the firehose download from github master intro the idea of functional reactive programming is quite well described by conal elliot at stack overflow bacon js is a library for functional reactive programming or lets say its a library for working with events and dynamic values which are called properties in bacon js anyways you can wrap an event source say mouse clicks on an element into an eventstream by saying js var clicks h1 aseventstream click each eventstream represents a stream of events it is an observable object meaning that you can listen to events in the stream using for instance the onvalue method with a callback like this js clicks onvalue function alert you clicked the h1 element but you can do neater stuff too the bacon of bacon js is in that you can transform filter and combine these streams in a multitude of ways see api below the methods map filter for example are similar to same functions in functional list programming like underscore so if you say js var plus plus aseventstream click map 1 var minus minus aseventstream click map 1 var both plus merge minus youll have a stream that will output the number 1 when the plus button is clicked and another stream outputting 1 when the minus button is clicked the both stream will be a merged stream containing events from both the plus and minus streams this allows you to subscribe to both streams with one handler js both onvalue function val val will be 1 or 1 in addition to eventstreams bacon js has a thing called property that is almost like an eventstream but has a current value so things that change and have a current state are properties while things that consist of discrete events are eventstreams you could think mouse clicks as an eventstream and mouse position as a property you can create properties from an eventstream with scan or toproperty methods so lets say js function add x y return x y var counter both scan 0 add counter onvalue function sum sum text sum the counter property will contain the sum of the values in the both stream so its practically a counter that can be increased and decreased using the plus and minus buttons the scan method was used here to calculate the current sum of events in the both stream by giving a seed value 0 and an accumulator function add the scan method creates a property that starts with the given seed value and on each event in the source stream applies the accumulator function to the current property value and the new value from the stream properties can be very conveniently used for assigning values and attributes to dom elements with jquery here we assign the value of a property as the text of a span element whenever it changes js property assign span text hiding and showing the same span depending on the content of the property value is equally straightforward js function hiddenforemptyvalue value return value hidden visible property map hiddenforemptyvalue assign span css visibility in the example above a property value of hello would be mapped to visible which in turn would result in bacon calling js span css visibility visible for an actual tutorial please check out my blog posts api creating streams aseventstream eventname creates an eventstream from events on a jquery or zepto js object you can pass optional arguments to add a jquery live selector and or a function that processes the jquery event and its parameters if given like this js my div aseventstream click more specific selector my div aseventstream click more specific selector function event args return args 0 my div aseventstream click function event args return args 0 bacon frompromise promise abort eventtransformer creates an eventstream from a promise object such as jquery ajax this stream will contain a single value or an error followed immediately by stream end you can use the optional abort flag i e ´frompromise p true ´ to have the abort method of the given promise be called when all subscribers have been removed from the created stream you can also pass an optional function that transforms the promise value into events the default is to transform the value into new bacon next value new bacon end check out this example bacon fromevent target eventsource eventtransformer creates an eventstream from events on a dom eventtarget or node js eventemitter object or an object that supports event listeners using on off methods you can also pass an optional function that transforms the emitted events parameters js bacon fromevent document body click onvalue function alert bacon bacon fromevent window function binder listener binder scroll listener passive true onvalue function console log window scrolly bacon fromcallback f args creates an eventstream from a function that accepts a callback the function is supposed to call its callback just once for example js bacon fromcallback function callback settimeout function callback bacon 1000 this would create a stream that outputs a single value bacon and ends after that the use of settimeout causes the value to be delayed by 1 second you can also give any number of arguments to fromcallback which will be passed to the function these arguments can be simple variables bacon eventstreams or properties for example the following will output bacon rules js bacon bacon constant bacon bacon fromcallback function a b callback callback a b bacon rules log bacon fromcallback object methodname args a variant of fromcallback which calls the named method of a given object bacon fromnodecallback f args behaves the same way as bacon fromcallback except that it expects the callback to be called in the node js convention callback error data where error is null if everything is fine for example js var bacon require baconjs bacon fs require fs var read bacon fromnodecallback fs readfile input txt read onerror function error console log reading failed error read onvalue function value console log read contents value bacon fromesobservable observable creates an eventstream from an es observable input can be any es observable implementation including rxjs and kefir bacon fromnodecallback object methodname args a variant of fromnodecallback which calls the named method of a given object bacon frompoll interval f polls given function with given interval function should return events either bacon next or bacon end polling occurs only when there are subscribers to the stream polling ends permanently when f returns bacon end bacon once value creates an eventstream that delivers the given single value for the first subscriber the stream will end immediately after this value you can also send an bacon error event instead of a value bacon once new bacon error fail bacon fromarray values creates an eventstream that delivers the given series of values given as array to the first subscriber the stream ends after these values have been delivered you can also send bacon error events or any combination of pure values and error events like this bacon fromarray 1 new bacon error bacon interval interval value repeats the single element indefinitely with the given interval in milliseconds bacon sequentially interval values creates a stream containing given values given as array delivered with given interval in milliseconds bacon repeatedly interval values repeats given elements indefinitely with given interval in milliseconds for example repeatedly 10 1 2 3 would lead to 1 2 3 1 2 3 to be repeated indefinitely bacon repeat fn calls generator function which is expected to return an observable the returned eventstream contains values and errors from the spawned observable when the spawned observable ends the generator is called again to spawn a new observable this is repeated until the generator returns a falsy value such as undefined or false the generator function is called with one argument — iteration number starting from 0 heres an example js bacon repeat function i if i 3 return bacon once i else return false log the example will produce values 0 1 and 2 bacon never creates an eventstream that immediately ends bacon later delay value creates a single element stream that produces given value after given delay milliseconds new bacon eventstream subscribe creates an eventstream with the given subscribe function property changes creates a stream of changes to the property the stream does not include an event for the current value of the property at the time this method was called property toeventstream creates an eventstream based on this property the stream contains also an event for the current value of this property at the time this method was called new bacon bus creates a pushable pluggable stream see bus section below pro tip you can also put errors into streams created with the constructors above by using an bacon error object instead of a plain value bacon frombinder for custom streams if none of the factory methods above apply you may of course roll your own eventstream by using bacon frombinder bacon frombinder subscribe the parameter subscribe is a function that accepts a sink which is a function that your subscribe function can push events to for example js var stream bacon frombinder function sink sink first value sink new bacon next 2nd new bacon next 3rd sink new bacon error oops an error sink new bacon end return function unsub functionality here this ones a no op stream log as shown in the example you can push a plain value like first value an event object including bacon error wraps an error and bacon end indicates stream end an array of event objects at once other examples can be found on jsfiddle and the bacon js blog the subscribe function must return a function lets call that function unsubscribe the returned function can be used by the subscriber directly or indirectly to unsubscribe from the eventstream it should release all resources that the subscribe function reserved the sink function may return bacon nomore as well as bacon more or any other value if it returns bacon nomore no further events will be consumed by the subscriber the subscribe function may choose to clean up all resources at this point e g by calling unsubscribe this is usually not necessary because further calls to sink are ignored but doing so can increase performance in rare cases the eventstream will wrap your subscribe function so that it will only be called when the first stream listener is added and the unsubscribe function is called only after the last listener has been removed the subscribe unsubscribe cycle may of course be repeated indefinitely so prepare for multiple calls to the subscribe function bacon nomore the opaque value sink function may return see bacon frombinder bacon more the opaque value sink function may return see bacon frombinder common methods in eventstreams and properties both eventstream and property share the observable interface and hence share a lot of methods methods typically return observables so that methods can be chained exceptions are noted common methods are listed below observable subscribe f subscribes given handler function to event stream function will receive event objects for all new value end and error events in the stream the subscribe call returns a unsubscribe function that you can call to unsubscribe you can also unsubscribe by returning bacon nomore from the handler function as a reply to an event stream subscribe and property subscribe behave similarly except that the latter also pushes the initial value of the property in case there is one observable onvalue f subscribes a given handler function to the observable function will be called for each new value this is the simplest way to assign a side effect to an observable the difference to the subscribe method is that the actual stream values are received instead of event objects the function construction rules below apply here just like subscribe this method returns a function for unsubscribing stream onvalue and property onvalue behave similarly except that the latter also pushes the initial value of the property in case there is one observable onvalues f like onvalue but splits the value assuming its an array as function arguments to f observable onerror f subscribes a callback to error events the function will be called for each error in the stream just like subscribe this method returns a function for unsubscribing observable onend f subscribes a callback to stream end the function will be called when the stream ends just like subscribe this method returns a function for unsubscribing observable topromise promisectr returns a promise which will be resolved with the last event coming from an observable the global es6 promise implementation will be used unless a promise constructor is given use a shim if you need to support legacy browsers or platforms caniuse promises observable firsttopromise promisectr returns a promise which will be resolved with the first event coming from an observable like topromise the global es6 promise implementation will be used unless a promise constructor is given observable toesobservable aliased as observable symbol observable returns an es observable containing the events from bacon observable this allows bacon observables to be used with observable from and provides interoperability with other es observable implementations such as rxjs and kefir observable map f maps values using given function returning a new stream property instead of a function you can also provide a constant value further you can use a property extractor string like keycode so if f is a string starting with a dot the elements will be mapped to the corresponding field function in the event value for instance map keycode will pluck the keycode field from the input values if keycode was a function the result stream would contain the values returned by the function the function construction rules below apply here stream map property maps the stream events to the current value of the given property this is equivalent to property sampledby stream observable maperror f maps errors using given function more specifically feeds the error field of the error event to the function and produces a next event based on the return value the function construction rules below apply here you can omit the argument to produce a next event with undefined value observable errors returns a stream containing error events only same as filtering with a function that always returns false observable skiperrors skips all errors observable mapend f adds an extra next event just before end the value is created by calling the given function when the source stream ends instead of a function a static value can be used you can omit the argument to produce a next event with undefined value observable filter f filters values using given predicate function instead of a function you can use a constant value true to include all false to exclude all or a property extractor string like isvaluable instead just like with map indeed observable filter property filters values based on the value of a property event will be included in output if and only if the property holds true at the time of the event observable skipduplicates isequal drops consecutive equal elements so from 1 2 2 1 youd get 1 2 1 uses the operator for equality checking by default if the isequal argument is supplied checks by calling isequal oldvalue newvalue for instance to do a deep comparison you can use the isequal function from underscore js like stream skipduplicates isequal observable take n takes at most n values from the stream and then ends the stream if the stream has fewer than n values then it is unaffected equal to bacon never if n 0 observable takeuntil stream takes elements from source until a next event appears in the other stream if other stream ends without value it is ignored observable takewhile f takes while given predicate function holds true and then ends function construction rules apply observable takewhile property takes values while the value of a property holds true and then ends observable first takes the first element from the stream essentially observable take 1 observable last takes the last element from the stream none if stream is empty note neverendingstream last creates the stream which doesnt produce any events and never ends observable skip n skips the first n elements from the stream observable concat other concatenates two streams properties into one stream property so that it will deliver events from observable until it ends and then deliver events from other this means too that events from other occurring before the end of observable will not be included in the result stream property observable delay delay delays the stream property by given amount of milliseconds does not delay the initial value of a property js var delayed source delay 2 source asdf asdf delayed asdf asdf observable throttle delay throttles stream property by given amount of milliseconds events are emitted with the minimum interval of delay the implementation is based on stream bufferwithtime does not affect emitting the initial value of a property example js var throttled source throttle 2 source asdf asdf throttled s f s f observable debounce delay throttles stream property by given amount of milliseconds but so that event is only emitted after the given quiet period does not affect emitting the initial value of a property the difference of throttle and debounce is the same as it is in the same methods in jquery example source asdf asdf source debounce 2 f f observable debounceimmediate delay passes the first event in the stream through but after that only passes events after a given number of milliseconds have passed since previous output example source asdf asdf source debounceimmediate 2 a d a d observable bufferingthrottle minimuminterval throttles the observable using a buffer so that at most one value event in minimuminterval is issued unlike throttle it doesnt discard the excessive events but buffers them instead outputting them with a rate of at most one value per minimuminterval example js var throttled source bufferingthrottle 2 source asdf asdf throttled a s d f a s d f observable doaction f returns a stream property where the function f is executed for each value before dispatching to subscribers this is useful for debugging but also for stuff like calling the preventdefault method for events in fact you can also use a property extractor string instead of a function as in preventdefault please note that for properties its not guaranteed that the function will be called exactly once per event when a property loses all of its subscribers it will re emit its current value when a new subscriber is added observable doerror f returns a stream property where the function f is executed for each error before dispatching to subscribers that is same as doaction but for errors observable not returns a stream property that inverts boolean values observable flatmap f for each element in the source stream spawn a new stream using the function f collect events from each of the spawned streams into the result eventstream property note that instead of a function you can provide a stream property too also the return value of function f can be either an observable stream property or a constant value the result of flatmap is of the same type as the source stream the function construction rules below apply here stream flatmap can be used conveniently with bacon once and bacon never for converting and filtering at the same time including only some of the results example converting strings to integers skipping empty values js stream flatmap function text return text parseint text bacon never observable flatmaplatest f like flatmap but instead of including events from all spawned streams only includes them from the latest spawned stream you can think this as switching from stream to stream note that instead of a function you can provide a stream property too the function construction rules below apply here observable flatmapfirst f like flatmap but only spawns a new stream if the previously spawned stream has ended the function construction rules below apply here observable flatmaperror f like flatmap but is applied only on error events returned values go into the value stream unless an error event is returned as an example one type of error could result in a retry and another just passed through which can be implemented using flatmaperror observable flatmapwithconcurrencylimit limit f a super method of flatmap family it limits the number of open spawned streams and buffers incoming events flatmapconcat is flatmapwithconcurrencylimit 1 only one input active and flatmap is flatmapwithconcurrencylimit ∞ all inputs are piped to output the function construction rules below apply here observable flatmapconcat f a flatmapwithconcurrencylimit with limit of 1 the function construction rules below apply here observable scan seed f scans stream property with given seed value and accumulator function resulting to a property for example you might use zero as seed and a plus function as the accumulator to create an integral property instead of a function you can also supply a method name such as concat in which case this method is called on the accumulator value and the new stream value is used as argument example js var plus function a b return a b bacon sequentially 1 1 2 3 scan 0 plus this would result to following elements in the result stream seed value 0 0 1 1 1 2 3 3 3 6 when applied to a property as in r p scan seed f theres a hopefully insignificant catch the starting value for r depends on whether p has an initial value when scan is applied if theres no initial value this works identically to eventstream scan the seed will be the initial value of r however if r already has a current initial value x the seed wont be output as is instead the initial value of r will be f seed x this makes sense because there can only be 1 initial value for a property at a time observable fold seed f is like scan but only emits the final value i e the value just before the observable ends returns a property observable reduce seed f synonym for fold observable diff start f returns a property that represents the result of a comparison between the previous and current value of the observable for the initial value of the observable the previous value will be the given start example js var distance function a b return math abs b a bacon sequentially 1 1 2 3 diff 0 distance this would result to following elements in the result stream 1 0 1 2 1 1 3 2 1 observable zip other f return an eventstream with elements pair wise lined up with events from this and the other eventstream or property a zipped stream will publish only when it has a value from each source and will only produce values up to when any single source ends the given function f is used to create the result value from value in the two sources if no function is given the values are zipped into an array be careful not to have too much drift between streams if one stream produces many more values than some other excessive buffering will occur inside the zipped observable example 1 js var x bacon fromarray 1 2 var y bacon fromarray 3 4 x zip y function x y return x y produces values 4 6 see also zipwith and zipasarray for zipping more than 2 sources observable slidingwindow max min returns a property that represents a sliding window into the history of the values of the observable the result property will have a value that is an array containing the last n values of the original observable where n is at most the value of the max argument and at least the value of the min argument if the min argument is omitted theres no lower limit of values for example if you have a stream s with value a sequence 1 2 3 4 5 the respective values in s slidingwindow 2 would be 1 1 2 2 3 3 4 4 5 the values of s slidingwindow 2 2 would be 1 2 2 3 3 4 4 5 observable log logs each value of the observable to the console it optionally takes arguments to pass to console log alongside each value to assist with chaining it returns the original observable note that as a side effect the observable will have a constant listener and will not be garbage collected so use this for debugging only and remove from production code for example js mystream log new event in mystream or just js mystream log observable dolog logs each value of the observable to the console dolog behaves like log but does not subscribe to the event stream you can think of dolog as a logger function that – unlike log – is safe to use in production dolog is safe because it does not cause the same surprising side effects as log does observable combine property2 f combines the latest values of the two streams or properties using a two arg function similarly to scan you can use a method name instead so you could do a combine b concat for two properties with array value the result is a property observable withstatemachine initstate f lets you run a state machine on an observable give it an initial state object and a state transformation function that processes each incoming event and returns an array containing the next state and an array of output events heres an example where we calculate the total sum of all numbers in the stream and output the value on stream end js bacon fromarray 1 2 3 withstatemachine 0 function sum event if event hasvalue return sum event value else if event isend return undefined new bacon next sum event else return sum event observable decode mapping decodes input using the given mapping is a bit like a switch case or the decode function in oracle sql for example the following would map the value 1 into the string mike and the value 2 into the value of the who property js property decode 1 mike 2 who this is actually based on combinetemplate so you can compose static and dynamic data quite freely as in js property decode 1 type mike 2 type other whothen who the return value of decode is always a property observable awaiting otherobservable creates a property that indicates whether observable is awaiting otherobservable i e has produced a value after the latest value from otherobservable this is handy for keeping track whether we are currently awaiting an ajax response js var showajaxindicator ajaxrequest awaiting ajaxresponse observable endonerror ends the observable on first error event the error is included in the output of the returned observable observable endonerror f ends the observable on first error event for which the given predicate function returns true the error is included in the output of the returned observable the function construction rules apply so you can do for example endonerror serious observable withhandler f lets you do more custom event handling you get all events to your function and you can output any number of events and end the stream if you choose for example to send an error and end the stream in case a value is below zero js if event hasvalue event value 0 this push new bacon error value below zero return this push end else return this push event note that its important to return the value from this push so that the connection to the underlying stream will be closed when no more events are needed observable name newname sets the name of the observable overrides the default implementation of tostring and inspect returns itself observable withdescription param sets the structured description of the observable the tostring and inspect methods use this data recursively to create a string representation for the observable this method is probably useful for bacon core library plugin development only for example var src bacon once 1 var obs src map function x return x console log obs tostring bacon once 1 map function obs withdescription src times 1 console log obs tostring bacon once 1 times 1 observable groupby keyf limitf groups stream events to new streams by keyf optional limitf can be provided to limit grouped stream life stream transformed by limitf is passed on if provided limitf gets grouped stream and the original event causing the stream to start as parameters calculator for grouped consecutive values until group is cancelled var events id 1 type add val 3 id 2 type add val 1 id 1 type add val 2 id 2 type cancel id 3 type add val 2 id 3 type cancel id 1 type add val 1 id 1 type add val 2 id 1 type cancel function keyf event return event id function limitf groupedstream groupstartingevent var cancel groupedstream filter function x return x type cancel take 1 var adds groupedstream filter function x return x type add return adds takeuntil cancel map val bacon sequentially 2 events groupby keyf limitf flatmap function groupedstream return groupedstream fold 0 function acc x return acc x onvalue function sum console log sum returns 1 2 8 in an order eventstream bacon eventstream a stream of events see methods below stream merge otherstream merges two streams into one stream that delivers events from both stream holdwhen valve pauses and buffers the event stream if last event in valve is truthy all buffered events are released when valve becomes falsy stream startwith value adds a starting value to the stream i e concats a single element stream contains value with this stream stream skipwhile f skips elements until the given predicate function returns falsy once and then lets all events pass through the function construction rules below apply here stream skipwhile property skips elements until the value of the given property is falsy once and then lets all events pass through stream skipuntil stream2 skips elements from stream until a next event appears in stream2 in other words starts delivering values from stream after first event appears in stream2 stream bufferwithtime delay buffers stream events with given delay the buffer is flushed at most once in the given delay so if your input contains 1 2 3 4 5 6 7 then you might get two events containing 1 2 3 4 and 5 6 7 respectively given that the flush occurs between numbers 4 and 5 stream bufferwithtime f works with a given defer function instead of a delay heres a simple example which is equivalent to stream bufferwithtime 10 js stream bufferwithtime function f settimeout f 10 stream bufferwithcount count buffers stream events with given count the buffer is flushed when it contains the given number of elements so if you buffer a stream of 1 2 3 4 5 with count 2 youll get output events with values 1 2 3 4 and 5 stream bufferwithtimeorcount delay count buffers stream events and flushes when either the buffer contains the given number elements or the given amount of milliseconds has passed since last buffered event stream toproperty creates a property based on the eventstream without arguments youll get a property without an initial value the property will get its first actual value from the stream and after that itll always have a current value stream toproperty initialvalue creates a property based on the eventstream with the given initial value that will be used as the current value until the first value comes from the stream stream flatscan seed f scans stream with given seed value and accumulator function resulting to a property difference to scan is that the function f can return an eventstream or a property instead of a pure value meaning that you can use flatscan for asynchronous updates of state it serializes updates so that that the next update will be queued until the previous one has completed property bacon property a reactive property has the concept of current value you can create a property from an eventstream by using either toproperty or scan method note depending on how a property is created it may or may not have an initial value the current value stays as its last value after the stream has ended bacon constant x creates a constant property with value x property assign obj method param calls the method of the given object with each value of this property you can optionally supply arguments which will be used as the first arguments of the method call for instance if you want to assign your property to the disabled attribute of a jquery object you can do this js myproperty assign my button attr disabled a simpler example would be to toggle the visibility of an element based on a property js myproperty assign my button toggle note that the assign method is actually just a synonym for onvalue and the function construction rules below apply to both property sample interval creates an eventstream by sampling the property value at given interval in milliseconds property sampledby stream creates an eventstream by sampling the property value at each event from the given stream the result eventstream will contain the property value at each event in the source stream property sampledby property creates a property by sampling the property value at each event from the given property the result property will contain the property value at each event in the source property property sampledby streamorproperty f samples the property on stream events the result values will be formed using the given function f propertyvalue samplervalue you can use a method name such as concat instead of a function too property changes returns an eventstream of property value changes returns exactly the same events as the property itself except any initial events note that property changes does not skip duplicate values use skipduplicates for that property and other combines properties with the operator property or other combines properties with the operator property startwith value adds an initial default value for the property if the property doesnt have an initial value of its own the given value will be used as the initial value if the property has an initial value of its own the given value will be ignored combining multiple streams and properties bacon combineasarray streams combines properties eventstreams and constant values so that the result property will have an array of all property values as its value the input array may contain both properties and eventstreams in the latter case the stream is first converted into a property and then combined with the other properties bacon combineasarray s1 s2 just like above but with streams provided as a list of arguments as opposed to a single array js property bacon constant 1 stream bacon once 2 constant 3 bacon combineasarray property stream constant produces the value 1 2 3 bacon combinewith f stream1 stream2 combines given n properties eventstreams and constant values using the given n ary function f v1 v2 to calculate the current sum of three numeric properties you can do js function sum3 x y z return x y z bacon combinewith sum3 p1 p2 p3 bacon combinewith f streams like above but with streams provided as a single array as opposed to a list of arguments js streams bacon constant 1 bacon constant 2 bacon combinewith math max streams bacon combinewith streams f like above bacon combinewith stream1 stream2 f like above bacon combinetemplate template combines properties eventstreams and constant values using a template object for instance assuming youve got streams or properties named password username firstname and lastname you can do js var password username firstname lastname properties or streams var logininfo bacon combinetemplate magicnumber 3 userid username passwd password name first firstname last lastname and your new logininfo property will combine values from all these streams using that template whenever any of the streams properties get a new value for instance it could yield a value such as js magicnumber 3 userid juha passwd easy name first juha last paananen in addition to combining data from streams you can include constant values in your templates note that all bacon combine methods produce a property instead of an eventstream if you need the result as an eventstream you might want to use property changes js bacon combinewith function v1 v2 stream1 stream2 changes bacon mergeall streams merges given array of eventstreams or properties returns an eventstream see merge bacon mergeall stream1 stream2 merges given eventstreams bacon concatall streams concatenates given array of eventstreams or properties returns an eventstream see concat bacon concatall stream1 stream2 concatenates given eventstreams bacon zipasarray streams zips the array of eventstreams properties in to a new eventstream that will have an array of values from each source as its value zipping means that events from each source are combined pairwise so that the 1st event from each source is published first then the 2nd event from each the results will be published as soon as there is a value from each source be careful not to have too much drift between streams if one stream produces many more values than some other excessive buffering will occur inside the zipped observable example js x bacon fromarray 1 2 3 y bacon fromarray 10 20 30 z bacon fromarray 100 200 300 bacon zipasarray x y z produces values 1 10 100 2 20 200 and 3 30 300 bacon zipasarray stream1 stream2 just like above but with sources provided as a list of arguments as opposed to a single array bacon zipwith streams f like zipasarray but uses the given n ary function to combine the n values from n sources instead of returning them in an array bacon zipwith f streams like zipasarray but uses the given n ary function to combine the n values from n sources instead of returning them in an array bacon zipwith f stream1 stream1 like above bacon zipwith stream1 stream1 f like above bacon onvalues a b c f is a shorthand for combining multiple sources streams properties constants as array and assigning the side effect function f for the values the following example would log the number 3 js function f a b console log a b bacon onvalues bacon constant 1 bacon constant 2 f function construction rules many methods in bacon have a single function as their argument many of these actually accept a wider range of different arguments that they use for constructing the function here are the different forms you can use with examples the basic form would be stream map f maps values using the function f x as an extension to the basic form you can use partial application stream map f bacon maps values using the function f x y using bacon as the first argument and stream value as the second argument stream map f pow smack maps values using the function f x y z using pow and smack as the first two arguments and stream value as the third argument then you can create method calls like this stream onvalue object method calls the method having the given name with stream value as the argument titletext onvalue title text which would call the text method of the jquery object matching to the html element with the id title disablebutton onvalue send attr disabled which would call the attr method of the send element with disabled as the first argument so if your property has the value true it would call send attr disabled true you can call methods or return field values using a property extractor syntax with this syntax bacon checks the type of the field and if its indeed a method it calls it otherwise it just returns field value for example stream map length would return the value of the length field of stream values would make sense for a stream of arrays so youd get 2 for cat dog stream map stuffs length would pick the length of the stuffs array that is a field in the stream value for example youd get 2 for stuffs thing object stream map dudes 1 would pick the second object from the nested dudes array for example youd get jack for dudes john jack stream doaction preventdefault would call the preventdefault method of stream values stream filter attr disabled not would call attr disabled on stream values and filter by the return value this would practically inlude only disabled jquery elements to the result stream if none of the above applies bacon will return a constant value for instance mouseclicks map ismouseclick true would map all events to the object ismouseclick true methods that support function construction include at least onvalue onerror onend map filter assign takewhile maperror and doaction lazy evaluation lazy evaluation of event values has been removed in version 2 0 latest value of property or eventstream one of the common first questions people ask is how do i get the latest value of a stream or a property there is no getlatestvalue method available and will not be either you get the value by subscribing to the stream property and handling the values in your callback if you need the value of more than one source use one of the combine methods bus bus is an eventstream that allows you to push values into the stream it also allows plugging other streams into the bus the bus practically merges all plugged in streams and the values pushed using the push method new bacon bus returns a new bus bus push x pushes the given value to the stream bus end ends the stream sends an end event to all subscribers after this call therell be no more events to the subscribers also the bus push and bus plug methods have no effect bus error e sends an error with given message to all subscribers bus plug stream plugs the given stream to the bus all events from the given stream will be delivered to the subscribers of the bus returns a function that can be used to unplug the same stream the plug method practically allows you to merge in other streams after the creation of the bus ive found bus quite useful as an event broadcast mechanism in the worzone game for instance event bacon event has subclasses bacon next bacon end bacon error and bacon initial bacon next next value in an eventstream or a property check event isnext to distinguish a next event from other events bacon end an end of stream event of eventstream or property check event isend to distinguish an end from other events bacon error an error event check event iserror to distinguish these events in your subscriber or use onerror to react to error events only errorevent error returns the associated error object usually string bacon initial the initial current value of a property check event isinitial to distinguish from other events only sent immediately after subscription to a property event properties event value the value associated with a next or initial event event hasvalue true for events of type initial and next event isnext true for next events event isinitial true for initial events event iserror true for error events event isend true for end events event error the error value of error events errors bacon error events are always passed through all stream combinators so even if you filter all values out the error events will pass through if you use flatmap the result stream will contain error events from the source as well as all the spawned stream you can take action on errors by using the observable onerror f callback see documentation on onerror maperror errors skiperrors bacon retry and flatmaperror above in case you want to convert some value events into error events you may use flatmap like this js stream bacon fromarray 1 2 3 4 flatmap function x if x 2 return new bacon error too big else return x conversely if you want to convert some error events into value events you may use flatmaperror js mystream flatmaperror function error return isnoncriticalerror error handlenoncriticalerror error new bacon error error note also that bacon js combinators do not catch errors that are thrown especially map doesnt do so if you want to map things and wrap caught errors into error events you can do the following js wrapped source flatmap bacon try dangerousoperation for example you can use bacon try to handle json parse errors js var jsonstream bacon once this is invalid json flatmap bacon try json parse jsonstream onerror function err console error failed to parse json err an error does not terminate the stream the method observable endonerror returns a stream property that ends immediately after first error bacon js doesnt currently generate any error events itself except when converting errors using bacon frompromise error events definitely would be generated by streams derived from io sources such as ajax calls bacon retry options is used to retry the call when there is an error event in the stream produced by the source function the two required option parameters are source a function that produces an observable the function gets attempt number starting from zero as its argument retries the number of times to retry the source function in addition to the initial attempt use the value o zero for retrying indefinitely additionally one may pass in one or both of the following callbacks isretryable a function returning true to continue retrying false to stop defaults to true the error that occurred is given as a parameter for example there is usually no reason to retry a 404 http error whereas a 500 or a timeout might work on the next attempt delay a function that returns the time in milliseconds to wait before retrying defaults to 0 the function is given a context object with the keys error the error that occurred and retriesdone the number of retries already performed to help determine the appropriate delay e g for an incremental backoff js var triggeringstream ajaxcall ajaxcall gives errors on network or server errors ajaxresult triggeringstream flatmap function url return bacon retry source function attemptnumber return ajaxcall url retries 5 isretryable function error return error httpstatuscode 404 delay function context return 100 just use the same delay always join patterns join patterns are a generalization of the zip function while zip synchronizes events from multiple streams pairwse join patterns allow for implementation of more advanced synchronization patterns bacon js uses the bacon when function to convert a list of synchronization patterns into a resulting eventstream bacon when consider implementing a game with discrete time ticks we want to handle key events synchronized on tick events with at most one key event handled per tick if there are no key events we want to just process a tick js bacon when tick keyevent function k handlekeyevent k return handletick tick handletick order is important here if the tick patterns had been written first this would have been tried first and preferred at each tick join patterns are indeed a generalization of zip and for eventstreams zip is equivalent to a single rule join pattern the following observables have the same output assuming that all sources are eventstreams js bacon zipwith a b c combine bacon when a b c combine note that bacon when does not trigger updates for events from properties though if you use a property in your pattern its value will be just sampled when all the other sources eventstreams have a value this is useful when you need a value of a property in your calculations if you want your pattern to fire for a property too you can convert it into an eventstream using property changes or property toeventstream bacon update creates a property from an initial value and updates the value based on multiple inputs the inputs are defined similarly to bacon when like this js var result bacon update initial x y z function previous x y z x y function previous x y as input each function above will get the previous value of the result property along with values from the listed observables the value returned by the function will be used as the next value of result just like in bacon when only eventstreams will trigger an update while properties will be just sampled so if you list a single eventstream and several properties the value will be updated only when an event occurs in the eventstream heres a simple gaming example js var scoremultiplier bacon constant 1 var hitufo new bacon bus var hitmothership new bacon bus var score bacon update 0 hitufo scoremultiplier function score multiplier return score 100 multiplier hitmothership function score return score 2000 in the example the score property is updated when either hitufo or hitmothership occur the scoremultiplier property is sampled to take multiplier into account when hitufo occurs join patterns as a chemical machine a quick way to get some intuition for join patterns is to understand them through an analogy in terms of atoms and molecules a join pattern can here be regarded as a recipe for a chemical reaction lets say we have observables oxygen carbon and hydrogen where an event in these spawns an atom of that type into a mixture we can state reactions js make water function oxygen hydrogen hydrogen consume oxygen and hydrogen make carbon monoxide function oxygen carbon consume oxygen and carbon bacon when oxygen hydrogen hydrogen make water oxygen carbon make carbon monoxide now every time a new atom is spawned from one of the observables this atom is added to the mixture if at any time there are two hydrogen atoms and an oxygen atom the corresponding atoms are consumed and output is produced via make water the same semantics apply for the second rule to create carbon monoxide the rules are tried at each point from top to bottom join patterns and properties properties are not part of the synchronization pattern but are instead just sampled the following example take three input streams price quantity and total e g coming from input fields and defines mutally recursive behaviours in properties price quantity and total such that updating price sets total to price quantity updating quantity sets total to price quantity updating total sets price to total quantity js var price total quantity var quantity quantity toproperty 1 var price bacon when price id total quantity function x y return x y toproperty 0 var total bacon when total id price quantity function x y return xy price quantity function x y return xy toproperty 0 join patterns and bacon bus the result functions of join patterns are allowed to push values onto a bus that may in turn be in one of its patterns for instance an implementation of the dining philosophers problem can be written as follows http en wikipedia org wiki dining philosophers problem example js availability of chopsticks are implemented using bus var chopsticks new bacon bus new bacon bus new bacon bus hungry could be any type of observable but well use bus here var hungry new bacon bus new bacon bus new bacon bus a philosopher eats for one second then makes the chopsticks available again by pushing values onto their bus var eat function i return function settimeout function console log done chopsticks i push chopsticks i 1 3 push 1000 return philosopher i eating we use bacon when to make sure a hungry philosopher can eat only when both his chopsticks are available var dining bacon when hungry 0 chopsticks 0 chopsticks 1 eat 0 hungry 1 chopsticks 1 chopsticks 2 eat 1 hungry 2 chopsticks 2 chopsticks 0 eat 2 dining log make all chopsticks initially available chopsticks 0 push chopsticks 1 push chopsticks 2 push make philosophers hungry in some way in this case we just push to their bus for var i 0 i 3 i hungry 0 push hungry 1 push hungry 2 push introspection and metadata bacon js provides ways to get some descriptive metadata about all observables observable tostring returns a textual description of the observable for instance bacon once 1 map function would return bacon once 1 map function observable deps returns the an array of dependencies that the observable has for instance for a map function deps would return a this method returns the visible dependencies only skipping internal details this method is thus suitable for visualization tools internally many combinator functions depend on other combinators to create intermediate observables that the result will actually depend on the deps method will skip these internal dependencies observable internaldeps returns the true dependencies of the observable including the intermediate hidden observables this method is for bacon js internal purposes but could be useful for debugging analysis tools as well observable desc contains a structured version of what tostring returns the structured description is an object that contains the fields context method and args for example for bacon fromarray 1 2 3 desc youd get context bacon method fromarray args 1 2 3 notice that this is a field not a function bacon spy f adds your function as a spy that will get notified on all new observables this will allow a visualization analytis tool to spy on all bacon activity cleaning up as described above a subscriber can signal the loss of interest in new events in any of these two ways return bacon nomore from the handler function call the dispose function that was returned by the subscribe call based on my experience on rxjs coding an actual side effect subscriber in application code never does this so the business of unsubscribing is mostly internal business and you can ignore it unless youre working on a custom stream implementation or a stream combinator in that case i welcome you to contribute your stuff to bacon js eventstream and property semantics the state of an eventstream can be defined as t os where t is time and os the list of current subscribers this state should define the behavior of the stream in the sense that when a next event is emitted the same event is emitted to all subscribers after an event has been emitted it will never be emitted again even if a new subscriber is registered a new event with the same value may of course be emitted later when a new subscriber is registered it will get exactly the same events as the other subscriber after registration this means that the stream cannot emit any initial events to the new subscriber unless it emits them to all of its subscribers a stream must never emit any other events after end not even another end the rules are deliberately redundant explaining the constraints from different perspectives the contract between an eventstream and its subscriber is as follows for each new value the subscriber function is called the new value is wrapped into a next event the subscriber function returns a result which is either bacon nomore or bacon more the undefined value is handled like bacon more in case of bacon nomore the source must never call the subscriber again when the stream ends the subscriber function will be called with and bacon end event the return value of the subscribe function is ignored in this case a property behaves similarly to an eventstream except that on a call to subscribe it will deliver its current value if any to the provided subscriber function wrapped into an initial event this means that if the property has previously emitted the value x to its subscribers and that is the latest value emitted it will deliver this value to the new subscriber property may or may not have a current value to start with depends on how the property was created atomic updates from version 0 4 0 bacon js supports atomic updates to properties with known limitations assume you have properties a and b and property c a b assume that both a and b depend on d so that when d changes both a and b will change too when d changes d1 d2 the value of a a1 a2 and b changes b1 b2 simultaneously youd like c to update atomically so that it would go directly a1 b1 a2 b2 and in fact it does exactly that prior to version 0 4 0 c would have an additional transitional state like a1 b1 a2 b1 a2 b2 atomic updates are limited to properties only meaning that simultaneous events in eventstreams will not be recognized as simultaneous and may cause extra transitional states to properties but as long as youre just combining properties youll updates will be atomic for rxjs users bacon js is quite similar to rxjs so it should be pretty easy to pick up the major difference is that in bacon there are two distinct kinds of observables the eventstream and the property the former is for discrete events while the latter is for observable properties that have the concept of current value also there are no cold observables which means also that all eventstreams and properties are consistent among subscribers when as event occurs all subscribers will observe the same event if youre experienced with rxjs youve probably bumped into some wtfs related to cold observables and inconsistent output from streams constructed using scan and startwith none of that will happen with bacon js error handling is also a bit different the error event does not terminate a stream so a stream may contain multiple errors to me this makes more sense than always terminating the stream on error this way the application developer has more direct control over error handling you can always use stream endonerror to get a stream that ends on error examples see examples see specs see worzone demo and source build first check out the bacon js repository and run npm install then build the coffeescript sources into javascript npm run dist result javascript files will be generated in dist directory if your planning to develop bacon js yourself youll want to run tests too you can also build a bundle with selected features only for instance scripts dist flatmap combine takeuntil the build system will do its best to determine the dependencies of the selected features and include those into the bundle too you can also test the integrity of the bundle with your selected features using scripts runtests flatmap combine takeuntil todo partial testing currently broken test run all unit tests test run limited set of unit tests test core frompromise the names correspond to the file names under spec specs the library will be built with the listed features only you can also test all features individually test individually js this will loop thru all files under spec specs and build the library with the single feature and run the test run browser tests using testem npm install npm install g testem testem run browser without testem npm install browsertest browserify open browsertest mocha runner html run performance tests performance performancetest coffee performance performancetest coffee flatmap run memory usage tests coffee nodejs expose gc performance memorytest coffee dependencies runtime jquery or zepto js optional just for jq zepto bindings build test node js npm coffeescript compatibility with other libs bacon js doesnt mess with prototypes or the global object only exceptions below it exports the bacon object except in node js in a browser this is added to the window object if jquery is defined it adds the aseventstream method to jquery similarly to zepto so it should be pretty much compatible and a nice citizen im not sure how it works in case some other lib adds stuff to say array prototype though maybe add test for this later compatibility with browsers tldr good bacon js is not browser dependent because it is not a ui library i have personally used it bacon js with chrome firefox safari ie 6 iphone ipad automatically tested on each commit on modern browsers node js sure works try it out npm install baconjs then type node and try the following js bacon require baconjs bacon bacon sequentially 1000 b a c o n log amd yep currently exports bacon through amd and assigns to window for backwards compatibility if you would like to use it with jquery and amd you should monkey patch jquery explicitly so that module loading order does not matter js define function require var require jquery bacon require bacon fn aseventstream bacon aseventstream document aseventstream click onvalue function e console log e clientx e clienty why bacon bacon js exists largely because i got frustrated with rxjs which is a good library but at that time didnt have very good documentation and wasnt open source things have improved a lot in the rx world since that yet there are still compelling reasons to use bacon js instead like for instance more consistent stream property behavior and arguably simplicity of use contribute use github issues and pull requests note this readme is generated from readme src coffee after updating the src file run npm run readme sponsors thanks to browserstack for kindly providing me with free of charge automatic testing time thanks also to reaktor for supporting bacon js development and letting me use some of my working hours on open source development