futuristic test runner even though javascript is single threaded io in node js can happen in parallel due to its async nature ava takes advantage of this and runs your tests concurrently which is especially beneficial for io heavy tests in addition test files are run in parallel as separate processes giving you even better performance and an isolated environment for each test file switching from mocha to ava in pageres brought the test time down from 31 to 11 seconds having tests run concurrently forces you to write atomic tests meaning tests dont depend on global state or the state of other tests which is a great thing read our contributing guide if youre looking to contribute issues prs etc follow the ava twitter account for updates this documentation covers the 1 0 beta releases which use babel 7 the last release that uses babel 6 is v0 25 0 translations español français italiano 日本語 한국어 português русский 简体中文 contents usage cli usage debugging reporters configuration documentation api assertions snapshot testing tips faq recipes support related links team why ava minimal and fast simple test syntax runs tests concurrently enforces writing atomic tests no implicit globals includes typescript flow type definitions magic assert isolated environment for each test file write your tests using the latest javascript syntax promise support generator function support async function support observable support enhanced assertion messages tap reporter automatic migration from other test runners test syntax js import test from ava test arrays are equal t t deepequal 1 2 1 2 usage add ava to your project to install and set up ava run console npx create ava next your package json will then look like this json name awesome package scripts test ava devdependencies ava 1 0 0 beta 4 initialization will work with npm and yarn but running npx requires npm 5 2 0 or greater to be installed otherwise youll have to manually install ava and configure the test script in your package json as per above console npm install save dev save exact ava next or if you prefer using yarn console yarn add ava next dev exact create your test file create a file named test js in the project root directory js import test from ava test foo t t pass test bar async t const bar promise resolve bar t is await bar bar run it console npm test watch it console npm test watch ava comes with an intelligent watch mode learn more in its recipe supported node js versions ava supports the latest release of any major version that is supported by node js itself read more in our support statement cli console ava help usage ava options watch w re run tests when tests and source files change match m only run tests with matching title can be repeated update snapshots u update snapshots fail fast stop after first test failure timeout t set global timeout serial s run tests serially concurrency c max number of test files running at the same time default cpu cores verbose v enable verbose output tap t generate tap output color force color output no color disable color output examples ava ava test js test2 js ava test js ava test default patterns when no arguments test js test js test js tests js test js note that the cli will use your local install of ava when available even when run globally directories are recursed with all js files being treated as test files directories named fixtures helpers and node modules are always ignored so are files starting with which allows you to place helpers in the same directory as your test files when using npm test you can pass positional arguments directly npm test test2 js but flags needs to be passed like npm test verbose debugging ava runs tests in child processes so to debug tests you need to do this workaround console node inspect node modules ava profile js some test file js debugger specific tips chrome devtools webstorm visual studio code reporters mini reporter the mini reporter is the default reporter verbose reporter use the verbose flag to enable the verbose reporter this is always used in ci environments unless the tap reporter is enabled tap reporter ava supports the tap format and thus is compatible with any tap reporter use the tap flag to enable tap output console ava tap tap nyan please note that the tap reporter is unavailable when using watch mode magic assert ava adds code excerpts and clean diffs for actual and expected values if values in the assertion are objects or arrays only a diff is displayed to remove the noise and focus on the problem the diff is syntax highlighted too if you are comparing strings both single and multi line ava displays a different kind of output highlighting the added or missing characters clean stack traces ava automatically removes unrelated lines in stack traces allowing you to find the source of an error much faster as seen above configuration all of the cli options can be configured in the ava section of either your package json or an ava config js file this allows you to modify the default behavior of the ava command so you dont have to repeatedly type the same options on the command prompt to ignore a file or directory prefix the pattern with an exclamation mark json ava files my test directory js my test directory exclude this directory js exclude this file js sources js jsx dist match oo foo cache true concurrency 5 failfast true failwithoutassertions false tap true compileenhancements false require babel register babel extensions jsx testoptions babelrc false arguments passed to the cli will always take precedence over the configuration in package json options files file directory paths and glob patterns that select which files ava will run tests from files with an underscore prefix are ignored all matched files in selected directories are run by default only selects files with js extensions even if the glob pattern matches other files specify extensions and babel extensions to allow other file extensions source files that when changed cause tests to be re run in watch mode see the watch mode recipe for details match not typically useful in the package json configuration but equivalent to specifying match on the cli cache cache compiled test and helper files under node modules cache ava if false files are cached in a temporary directory instead failfast stop running further tests once a test fails failwithoutassertions if false does not fail a test if it doesnt run assertions tap if true enables the tap reporter snapshotdir specifies a fixed location for storing snapshot files use this if your snapshots are ending up in the wrong location compileenhancements if false disables power assert — which otherwise helps provide more descriptive error messages — and detection of improper use of the t throws assertion extensions extensions of test files that are not precompiled using avas babel presets note that files are still compiled to enable power assert and other features so you may also need to set compileenhancements to false if your files are not valid javascript setting this overrides the default js value so make sure to include that extension in the list as long as its not included in babel extensions require extra modules to require before tests are run modules are required in the worker processes babel test file specific babel options see our babel recipe for more details babel extensions extensions of test files that will be precompiled using avas babel presets setting this overrides the default js value so make sure to include that extension in the list note that providing files on the cli overrides the files option if youve configured a glob pattern for instance test test js you may want to repeat it when using the cli ava test integration test js using ava config js to use an ava config js file it must be in the same directory as your package json your package json must not contain an ava property or if it does it must be an empty object the config file must have a default export using es modules it can either be a plain object or a factory function which returns a plain object js export default require esm js export default function factory return require esm the factory function is called with an object containing a projectdir property which you could use to change the returned configuration js export default projectdir if projectdir users username projects my project return config a return config b note that the final configuration must not be a promise documentation tests are run concurrently you can specify synchronous and asynchronous tests tests are considered synchronous unless you return a promise or observable we highly recommend the use of async functions they make asynchronous code concise and readable and they implicitly return a promise so you dont have to if youre unable to use promises or observables you may enable callback mode by defining your test with test cb title fn tests declared this way must be manually ended with t end this mode is mainly intended for testing callback style apis however we would strongly recommend promisifying callback style apis instead of using callback mode as this results in more correct and readable tests you must define all tests synchronously they cant be defined inside settimeout setimmediate etc ava tries to run test files with their current working directory set to the directory that contains your package json file creating tests to create a test you call the test function you imported from ava provide the required title and implementation function titles must be unique within each test file the function will be called when your test is run its passed an execution object as its first argument note in order for the enhanced assertion messages to behave correctly the first argument must be named t js import test from ava test my passing test t t pass assertion planning assertion plans ensure tests only pass when a specific number of assertions have been executed theyll help you catch cases where tests exit too early theyll also cause tests to fail if too many assertions are executed which can be useful if you have assertions inside callbacks or loops if you do not specify an assertion plan your test will still fail if no assertions are executed set the failwithoutassertions option to false in avas package json configuration to disable this behavior note that unlike tap and tape ava does not automatically end a test when the planned assertion count is reached these examples will result in a passed test js test resolves with 3 t t plan 1 return promise resolve 3 then n t is n 3 test cb invokes callback t t plan 1 someasyncfunction t pass t end these wont js test loops twice t t plan 2 for let i 0 i 3 i t true i 3 fails 3 assertions are executed which is too many test invokes callback synchronously t t plan 1 someasyncfunction t pass fails the test ends synchronously before the assertion is executed running tests serially tests are run concurrently by default however sometimes you have to write tests that cannot run concurrently in these rare cases you can use the serial modifier it will force those tests to run serially before the concurrent ones js test serial passes serially t t pass note that this only applies to tests within a particular test file ava will still run multiple tests files at the same time unless you pass the serial cli flag you can use the serial modifier with all tests hooks and even todo but its only available on the test function running specific tests during development it can be helpful to only run a few specific tests this can be accomplished using the only modifier js test will not be run t t fail test only will be run t t pass you can use the only modifier with all tests it cannot be used with hooks or todo note the only modifier applies to the test file its defined in so if you run multiple test files tests in other files will still run if you want to only run the test only test provide just that test file to ava running tests with matching titles the match flag allows you to run just the tests that have a matching title this is achieved with simple wildcard patterns patterns are case insensitive see matcher for more details match titles ending with foo console ava match foo match titles starting with foo console ava match foo match titles containing foo console ava match foo match titles that are exactly foo albeit case insensitively console ava match foo match titles not containing foo console ava match foo match titles starting with foo and ending with bar console ava match foo bar match titles starting with foo or ending with bar console ava match foo match bar note that a match pattern takes precedence over the only modifier only tests with an explicit title are matched tests without titles or whose title is derived from the implementation function will be skipped when match is used heres what happens when you run ava with a match pattern of oo and the following tests js test foo will run t t pass test moo will also run t t pass test only boo will run but not exclusively t t pass wont run no title test function t t fail wont run no explicit title test function foo t t fail skipping tests sometimes failing tests can be hard to fix you can tell ava to skip these tests using the skip modifier theyll still be shown in the output as having been skipped but are never run js test skip will not be run t t fail you must specify the implementation function you can use the skip modifier with all tests and hooks but not with todo you can not apply further modifiers to skip test placeholders todo you can use the todo modifier when youre planning to write a test like skipped tests these placeholders are shown in the output they only require a title you cannot specify the implementation function js test todo will think about writing this later you can signal that you need to write a serial test js test serial todo will think about writing this later failing tests you can use the failing modifier to document issues with your code that need to be fixed failing tests are run just like normal ones but they are expected to fail and will not break your build when they do if a test marked as failing actually passes it will be reported as an error and fail the build with a helpful message instructing you to remove the failing modifier this allows you to merge failing tests before a fix is implemented without breaking ci this is a great way to recognize good bug report prs with a commit credit even if the reporter is unable to actually fix the problem js see github com user repo issues 1234 test failing demonstrate some bug t t fail test will count as passed before after hooks ava lets you register hooks that are run before and after your tests this allows you to run setup and or teardown code test before registers a hook to be run before the first test in your test file similarly test after registers a hook to be run after the last test use test after always to register a hook that will always run once your tests and other hooks complete always hooks run regardless of whether there were earlier failures so they are ideal for cleanup tasks note however that uncaught exceptions unhandled rejections or timeouts will crash your tests possibly preventing always hooks from running test beforeeach registers a hook to be run before each test in your test file similarly test aftereach a hook to be run after each test use test aftereach always to register an after hook that is called even if other test hooks or the test itself fail if a test is skipped with the skip modifier the respective beforeeach aftereach and aftereach always hooks are not run likewise if all tests in a test file are skipped before after and after always hooks for the file are not run like test these methods take an optional title and an implementation function the title is shown if your hook fails to execute the implementation is called with an execution object you can use assertions in your hooks you can also pass a macro function and additional arguments before hooks execute before beforeeach hooks aftereach hooks execute before after hooks within their category the hooks execute in the order they were defined by default hooks execute concurrently but you can use test serial to ensure only that single hook is run at a time unlike with tests serial hooks are not run before other hooks js test before t this runs before all tests test before t this runs concurrently with the above test serial before t this runs after the above test serial before t this too runs after the above and before tests test after cleanup t this runs after all tests test after always guaranteed cleanup t this will always run regardless of earlier failures test beforeeach t this runs before each test test aftereach t this runs after each test test aftereach always t this runs after each test and other test hooks even if they failed test title t regular test hooks can be synchronous or asynchronous just like tests to make a hook asynchronous return a promise or observable use an async function or enable callback mode via test before cb test beforeeach cb etc js test before async t await promisefn test after t return new promise test beforeeach cb t settimeout t end test aftereach cb t settimeout t end keep in mind that the beforeeach and aftereach hooks run just before and after a test is run and that by default tests run concurrently this means each multiple beforeeach hooks may run concurrently using test serial beforeeach does not change this if you need to set up global state for each test like spying on console log for example youll need to make sure the tests themselves are run serially remember that ava runs each test file in its own process you may not have to clean up global state in a after hook since thats only called right before the process exits test context hooks can share context with the test js test beforeeach t t context data generateuniquedata test context data is foo t t is t context data bar foobar context created in before hooks is cloned before it is passed to beforeeach hooks and or tests the after and after always hooks receive the original context value for beforeeach aftereach and aftereach always hooks the context is not shared between different tests allowing you to set up data such that it will not leak to other tests by default t context is an object but you can reassign it js test before t t context unicorn test context is unicorn t t is t context unicorn test macros additional arguments passed to the test declaration will be passed to the test implementation this is useful for creating reusable test macros js function macro t input expected t is eval input expected test 2 2 4 macro 2 2 4 test 2 3 6 macro 2 3 6 you can build the test title programmatically by attaching a title function to the macro js function macro t input expected t is eval input expected macro title providedtitle input expected providedtitle input expected trim test macro 2 2 4 test macro 2 3 6 test providedtitle macro 3 3 9 the providedtitle argument defaults to an empty string if the user does not supply a string title this allows for easy concatenation without having to worry about null undefined it is worth remembering that the empty string is considered a falsy value so you can still use if providedtitle you can also pass arrays of macro functions js const safeeval require safe eval function evalmacro t input expected t is eval input expected function safeevalmacro t input expected t is safeeval input expected test evalmacro safeevalmacro 2 2 4 test evalmacro safeevalmacro 2 3 6 we encourage you to use macros instead of building your own test generators here is an example of code that should be replaced with a macro macros are designed to perform static analysis of your code which can lead to better performance ide integration and linter rules custom assertions you can use any assertion library instead of or in addition to the built in one provided it throws exceptions when the assertion fails this wont give you as nice an experience as youd get with the built in assertions though and you wont be able to use the assertion planning see 25 youll have to configure ava to not fail tests if no assertions are executed because ava cant tell if custom assertions pass set the failwithoutassertions option to false in avas package json configuration js import assert from assert test custom assertion t assert true latest javascript support ava uses babel 7 so you can use the latest javascript syntax in your tests there is no extra setup required you dont need to be using babel in your own project for this to work either we aim support all finished syntax proposals as well as all syntax from ratified javascript versions e g es2017 see our ava stage 4 preset for the currently supported proposals please note that we do not add or modify built ins for example if you use object entries in your tests they will crash in node js 6 which does not implement this method you can disable this syntax support or otherwise customize avas babel pipeline see our babel recipe for more details typescript support ava includes typings for typescript you have to set up transpilation yourself when you set module to commonjs in your tsconfig json file typescript will automatically find the type definitions for ava you should set target to es2015 to use promises and async functions see avas typescript recipe for a more detailed explanation transpiling imported modules ava currently only transpiles the tests you ask it to run as well as test helpers files starting with or in helpers directory inside the test directory it will not transpile modules you import from outside of the test this may be unexpected but there are workarounds if you use babel you can use its require hook to transpile imported modules on the fly to add it configure it in your package json you can also transpile your modules in a separate process and refer to the transpiled files rather than the sources from your tests example here promise support if you return a promise in the test you dont need to explicitly end the test as it will end when the promise resolves js test resolves with unicorn t return somepromise then result t is result unicorn generator function support ava comes with built in support for generator functions js test function t const value yield generatorfn t true value async function support ava comes with built in support for async functions async await js test async function t const value await promisefn t true value async arrow function test promises the truth async t const value await promisefn t true value observable support ava comes with built in support for observables if you return an observable from a test ava will automatically consume it to completion before ending the test you do not need to use callback mode or call t end js test handles observables t t plan 3 return observable of 1 2 3 4 5 6 filter n only even numbers return n 2 0 map t pass callback support ava supports using t end as the final callback when using node style error first callback apis ava will consider any truthy value passed as the first argument to t end to be an error note that t end requires callback mode which can be enabled by using the test cb chain js test cb data txt can be read t t end automatically checks for error as first argument fs readfile data txt t end global timeout a global timeout can be set via the timeout option timeout in ava behaves differently than in other test frameworks ava resets a timer after each test forcing tests to quit if no new test results were received within the specified timeout this can be used to handle stalled tests you can set timeouts in a human readable way console ava timeout 10s 10 seconds ava timeout 2m 2 minutes ava timeout 100 100 milliseconds api test title implementation test serial title implementation test cb title implementation test only title implementation test skip title implementation test todo title test failing title implementation test before title implementation test after title implementation test beforeeach title implementation test aftereach title implementation title type string test title implementation t type function should contain the actual test t type object the execution object of a particular test each test implementation receives a different object contains the assertions as well as plan count and end methods t context can contain shared state from hooks t title returns the tests title t plan count plan how many assertion there are in the test the test will fail if the actual assertion count doesnt match the number of planned assertions see assertion planning t end end the test only works with test cb t log values log values contextually alongside the test result instead of immediately printing them to stdout behaves somewhat like console log but without support for placeholder tokens assertions assertions are mixed into the execution object provided to each test implementation js test unicorns are truthy t t truthy unicorn assertion assertions are bound to their test so you can assign them to a variable or pass them around js test unicorns are truthy t const truthy t truthy truthy unicorn assertions can be skipped by adding skip js test unicorns are truthy t t truthy skip unicorn if multiple assertion failures are encountered within a single test ava will only display the first one pass message passing assertion fail message failing assertion truthy value message assert that value is truthy falsy value message assert that value is falsy true value message assert that value is true false value message assert that value is false is value expected message assert that value is the same as expected this is based on object is not value expected message assert that value is not the same as expected this is based on object is deepequal value expected message assert that value is deeply equal to expected see concordance for details works with react elements and react test renderer notdeepequal value expected message assert that value is not deeply equal to expected the inverse of deepequal throws thrower expected message assert that an error is thrown thrower can be a function which should throw or return a promise that should reject or an observable that should error alternatively a promise or observable can be passed directly the thrown value must be an error it is returned so you can run more assertions against it expected can be a constructor in which case the thrown error must be an instance of the constructor it can be a string which is compared against the thrown errors message or a regular expression which is matched against this message you can also specify a matcher object with one or more of the following properties instanceof a constructor the thrown error must be an instance of is the thrown error must be strictly equal to expected is message either a string which is compared against the thrown errors message or a regular expression which is matched against this message name the expected name value of the thrown error code the expected code value of the thrown error expected does not need to be specified if you dont need it but do want to set an assertion message you have to specify null example js const fn throw new typeerror 🦄 test throws t const error t throws fn typeerror t is error message 🦄 js const promise promise reject new typeerror 🦄 test rejects async t const error await t throws promise t is error message 🦄 when testing an observable or promise you must wait for the assertion to complete js test rejects async t await t throws promise when testing an asynchronous function you must also wait for the assertion to complete js test throws async t await t throws async throw new typeerror 🦄 instanceof typeerror message 🦄 notthrows nonthrower message assert that no error is thrown thrower can be a function which shouldnt throw or return a promise that should resolve or an observable that should complete alternatively a promise or an observable can be passed directly like the throws assertion when testing a promise or an observable you must wait for the assertion to complete js test resolves async t await t notthrows promise regex contents regex message assert that contents matches regex notregex contents regex message assert that contents does not match regex snapshot expected message snapshot expected options message compares the expected value with a previously recorded snapshot snapshots are stored for each test so ensure you give your tests unique titles alternatively pass an options object to select a specific snapshot for instance id my snapshot snapshot assertions cannot be skipped when snapshots are being updated snapshot testing ava supports snapshot testing as introduced by jest through its assertions interface you can snapshot any value as well as react elements js your component const helloworld hello world export default helloworld js your test import test from ava import render from react test renderer import helloworld from test helloworld component t const tree render create tojson t snapshot tree try it out in this example project snapshots are stored alongside your test files if your tests are in a test or tests folder the snapshots will be stored in a snapshots folder if your tests are in a tests folder then they theyll be stored in a snapshots folder say you have project test main js which contains snapshot assertions ava will create two files project test snapshots main js snap project test snapshots main js md the first file contains the actual snapshot and is required for future comparisons the second file contains your snapshot report its regenerated when you update your snapshots if you commit it to source control you can diff it to see the changes to your snapshot ava will show why your snapshot assertion failed you can then check your code if the change was intentional you can use the update snapshots or u flag to update the snapshots console ava update snapshots you can specify a fixed location for storing the snapshot files in avas package json configuration json ava snapshotdir custom directory the snapshot files will be saved in a directory structure that mirrors that of your test files if you are running ava against precompiled test files ava will try and use source maps to determine the location of the original files snapshots will be stored next to these files following the same rules as if ava had executed the original files directly this is great if youre writing your tests in typescript see our typescript recipe skipping assertions any assertion can be skipped using the skip modifier skipped assertions are still counted so there is no need to change your planned assertion count js test skip assertion t t plan 2 t is skip foo 5 no need to change your plan count when skipping t is 1 1 enhanced assertion messages ava comes with power assert built in giving you more descriptive assertion messages it reads your test and tries to infer more information from the code lets take this example using nodes standard assert library js const a foo const b bar const c baz require assert ok a test b b c if you paste that into a node repl itll return assertionerror false true in ava however this test js test enhanced assertions t const a foo const b bar const c baz t true a test b b c will output t true a test b b c bar bar baz false process isolation each test file is run in a separate node js process this allows you to change the global state or overriding a built in in one test file without affecting another its also great for performance on modern multi core processors allowing multiple test files to execute in parallel ava will set process env node env to test unless the node env environment variable has been set this is useful if the code youre testing has test defaults for example when picking what database to connect to or environment specific babel options it may cause your code or its dependencies to behave differently though note that node env in process env will always be true tips temp files running tests concurrently comes with some challenges doing file io is one usually serial tests create temp directories in the current test directory and clean them up at the end this wont work when you run tests concurrently as tests will conflict with each other the correct way to do it is to use a new temp directory for each test the tempfile and temp write modules can be helpful code coverage you cant use istanbul for code coverage as ava spawns the test files you can use nyc instead which is basically istanbul with support for subprocesses as of version 5 0 0 it uses source maps to report coverage for your actual code regardless of transpilation make sure that the code youre testing includes an inline source map or references a source map file if you use babel register you can set the sourcemaps option in your babel config to inline common pitfalls we have a growing list of common pitfalls you may experience while using ava if you encounter any issues you think are common comment in this issue faq why not mocha tape tap mocha requires you to use implicit globals like describe and it with the default interface which most people use its not very opinionated and executes tests serially without process isolation making it slow tape and tap are pretty good ava is highly inspired by their syntax they too execute tests serially their default tap output isnt very user friendly though so you always end up using an external tap reporter in contrast ava is highly opinionated and runs tests concurrently with a separate process for each test file its default reporter is easy on the eyes and yet ava still supports tap output through a cli flag how is the name written and pronounced ava not ava or ava pronounced ˈeɪvə ay və what is the header background its the andromeda galaxy what is the difference between concurrency and parallelism concurrency is not parallelism it enables parallelism recipes test setup code coverage watch mode endpoint testing when to use t plan browser testing typescript flow configuring babel using es modules passing arguments to your test files testing react components testing vue js components jspm and systemjs debugging tests with chrome devtools debugging tests with webstorm precompiling source files with webpack isolated mongodb integration tests support stack overflow spectrum twitter related eslint plugin ava lint rules for ava tests sublime ava snippets for ava tests atom ava snippets for ava tests vscode ava snippets for ava tests gulp ava run tests with gulp grunt ava run tests with grunt more… links ava stickers t shirts etc awesome list ava casts more… team mark wubben sindre sorhus vadim demedes former kevin mårtensson james talmage juan soto jeroen engels