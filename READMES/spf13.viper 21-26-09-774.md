go configuration with fangs many go projects are built using viper including hugo emc rexray imgurs incus nanobox nanopack docker notary bloomapi doctl clairctl what is viper viper is a complete configuration solution for go applications including 12 factor apps it is designed to work within an application and can handle all types of configuration needs and formats it supports setting defaults reading from json toml yaml hcl and java properties config files live watching and re reading of config files optional reading from environment variables reading from remote config systems etcd or consul and watching changes reading from command line flags reading from buffer setting explicit values viper can be thought of as a registry for all of your applications configuration needs why viper when building a modern application you dont want to worry about configuration file formats you want to focus on building awesome software viper is here to help with that viper does the following for you find load and unmarshal a configuration file in json toml yaml hcl or java properties formats provide a mechanism to set default values for your different configuration options provide a mechanism to set override values for options specified through command line flags provide an alias system to easily rename parameters without breaking existing code make it easy to tell the difference between when a user has provided a command line or config file which is the same as the default viper uses the following precedence order each item takes precedence over the item below it explicit call to set flag env config key value store default viper configuration keys are case insensitive putting values into viper establishing defaults a good configuration system will support default values a default value is not required for a key but its useful in the event that a key hasnt been set via config file environment variable remote configuration or flag examples go viper setdefault contentdir content viper setdefault layoutdir layouts viper setdefault taxonomies map string string tag tags category categories reading config files viper requires minimal configuration so it knows where to look for config files viper supports json toml yaml hcl and java properties files viper can search multiple paths but currently a single viper instance only supports a single configuration file viper does not default to any configuration search paths leaving defaults decision to an application here is an example of how to use viper to search for and read a configuration file none of the specific paths are required but at least one path should be provided where a configuration file is expected go viper setconfigname config name of config file without extension viper addconfigpath etc appname path to look for the config file in viper addconfigpath home appname call multiple times to add many search paths viper addconfigpath optionally look for config in the working directory err viper readinconfig find and read the config file if err nil handle errors reading the config file panic fmt errorf fatal error config file s \n err watching and re reading config files viper supports the ability to have your application live read a config file while running gone are the days of needing to restart a server to have a config take effect viper powered applications can read an update to a config file while running and not miss a beat simply tell the viper instance to watchconfig optionally you can provide a function for viper to run each time a change occurs make sure you add all of the configpaths prior to calling watchconfig go viper watchconfig viper onconfigchange func e fsnotify event fmt println config file changed e name reading config from io reader viper predefines many configuration sources such as files environment variables flags and remote k v store but you are not bound to them you can also implement your own required configuration source and feed it to viper go viper setconfigtype yaml or viper setconfigtype yaml any approach to require this configuration into your program var yamlexample byte hacker true name steve hobbies skateboarding snowboarding go clothing jacket leather trousers denim age 35 eyes brown beard true viper readconfig bytes newbuffer yamlexample viper get name this would be steve setting overrides these could be from a command line flag or from your own application logic go viper set verbose true viper set logfile logfile registering and using aliases aliases permit a single value to be referenced by multiple keys go viper registeralias loud verbose viper set verbose true same result as next line viper set loud true same result as prior line viper getbool loud true viper getbool verbose true working with environment variables viper has full support for environment variables this enables 12 factor applications out of the box there are four methods that exist to aid working with env automaticenv bindenv string error setenvprefix string setenvkeyreplacer string strings replacer when working with env variables its important to recognize that viper treats env variables as case sensitive viper provides a mechanism to try to ensure that env variables are unique by using setenvprefix you can tell viper to use a prefix while reading from the environment variables both bindenv and automaticenv will use this prefix bindenv takes one or two parameters the first parameter is the key name the second is the name of the environment variable the name of the environment variable is case sensitive if the env variable name is not provided then viper will automatically assume that the key name matches the env variable name but the env variable is in all caps when you explicitly provide the env variable name it does not automatically add the prefix one important thing to recognize when working with env variables is that the value will be read each time it is accessed viper does not fix the value when the bindenv is called automaticenv is a powerful helper especially when combined with setenvprefix when called viper will check for an environment variable any time a viper get request is made it will apply the following rules it will check for a environment variable with a name matching the key uppercased and prefixed with the envprefix if set setenvkeyreplacer allows you to use a strings replacer object to rewrite env keys to an extent this is useful if you want to use or something in your get calls but want your environmental variables to use delimiters an example of using it can be found in viper test go env example go setenvprefix spf will be uppercased automatically bindenv id os setenv spf id 13 typically done outside of the app id get id 13 working with flags viper has the ability to bind to flags specifically viper supports pflags as used in the cobra library like bindenv the value is not set when the binding method is called but when it is accessed this means you can bind as early as you want even in an init function for individual flags the bindpflag method provides this functionality example go servercmd flags int port 1138 port to run application server on viper bindpflag port servercmd flags lookup port you can also bind an existing set of pflags pflag flagset example go pflag int flagname 1234 help message for flagname pflag parse viper bindpflags pflag commandline i viper getint flagname retrieve values from viper instead of pflag the use of pflag in viper does not preclude the use of other packages that use the flag package from the standard library the pflag package can handle the flags defined for the flag package by importing these flags this is accomplished by a calling a convenience function provided by the pflag package called addgoflagset example go package main import flag github com spf13 pflag func main using standard library flag package flag int flagname 1234 help message for flagname pflag commandline addgoflagset flag commandline pflag parse viper bindpflags pflag commandline i viper getint flagname retrieve value from viper flag interfaces viper provides two go interfaces to bind other flag systems if you dont use pflags flagvalue represents a single flag this is a very simple example on how to implement this interface go type myflag struct func f myflag haschanged bool return false func f myflag name string return my flag name func f myflag valuestring string return my flag value func f myflag valuetype string return string once your flag implements this interface you can simply tell viper to bind it go viper bindflagvalue my flag name myflag flagvalueset represents a group of flags this is a very simple example on how to implement this interface go type myflagset struct flags myflag func f myflagset visitall fn func flagvalue for flag range flags fn flag once your flag set implements this interface you can simply tell viper to bind it go fset myflagset flags myflag myflag myflag viper bindflagvalues my flags fset remote key value store support to enable remote support in viper do a blank import of the viper remote package import github com spf13 viper remote viper will read a config string as json toml yaml or hcl retrieved from a path in a key value store such as etcd or consul these values take precedence over default values but are overridden by configuration values retrieved from disk flags or environment variables viper uses crypt to retrieve configuration from the k v store which means that you can store your configuration values encrypted and have them automatically decrypted if you have the correct gpg keyring encryption is optional you can use remote configuration in conjunction with local configuration or independently of it crypt has a command line helper that you can use to put configurations in your k v store crypt defaults to etcd on http 127 0 0 1 4001 bash go get github com xordataexchange crypt bin crypt crypt set plaintext config hugo json users hugo settings config json confirm that your value was set bash crypt get plaintext config hugo json see the crypt documentation for examples of how to set encrypted values or how to use consul remote key value store example unencrypted go viper addremoteprovider etcd http 127 0 0 1 4001 config hugo json viper setconfigtype json because there is no file extension in a stream of bytes supported extensions are json toml yaml yml properties props prop err viper readremoteconfig remote key value store example encrypted go viper addsecureremoteprovider etcd http 127 0 0 1 4001 config hugo json etc secrets mykeyring gpg viper setconfigtype json because there is no file extension in a stream of bytes supported extensions are json toml yaml yml properties props prop err viper readremoteconfig watching changes in etcd unencrypted go alternatively you can create a new viper instance var runtime viper viper new runtime viper addremoteprovider etcd http 127 0 0 1 4001 config hugo yml runtime viper setconfigtype yaml because there is no file extension in a stream of bytes supported extensions are json toml yaml yml properties props prop read from remote config the first time err runtime viper readremoteconfig unmarshal config runtime viper unmarshal runtime conf open a goroutine to watch remote changes forever go func for time sleep time second 5 delay after each request currently only tested with etcd support err runtime viper watchremoteconfig if err nil log errorf unable to read remote config v err continue unmarshal new config into our runtime config struct you can also use channel to implement a signal to notify the system of the changes runtime viper unmarshal runtime conf getting values from viper in viper there are a few ways to get a value depending on the values type the following functions and methods exist get key string interface getbool key string bool getfloat64 key string float64 getint key string int getstring key string string getstringmap key string map string interface getstringmapstring key string map string string getstringslice key string string gettime key string time time getduration key string time duration isset key string bool allsettings map string interface one important thing to recognize is that each get function will return a zero value if its not found to check if a given key exists the isset method has been provided example go viper getstring logfile case insensitive setting getting if viper getbool verbose fmt println verbose enabled accessing nested keys the accessor methods also accept formatted paths to deeply nested keys for example if the following json file is loaded json host address localhost port 5799 datastore metric host 127 0 0 1 port 3099 warehouse host 198 0 0 1 port 2112 viper can access a nested field by passing a delimited path of keys go getstring datastore metric host returns 127 0 0 1 this obeys the precedence rules established above the search for the path will cascade through the remaining configuration registries until found for example given this configuration file both datastore metric host and datastore metric port are already defined and may be overridden if in addition datastore metric protocol was defined in the defaults viper would also find it however if datastore metric was overridden by a flag an environment variable the set method … with an immediate value then all sub keys of datastore metric become undefined they are “shadowed” by the higher priority configuration level lastly if there exists a key that matches the delimited key path its value will be returned instead e g json datastore metric host 0 0 0 0 host address localhost port 5799 datastore metric host 127 0 0 1 port 3099 warehouse host 198 0 0 1 port 2112 getstring datastore metric host returns 0 0 0 0 extract sub tree extract sub tree from viper for example viper represents json app cache1 max items 100 item size 64 cache2 max items 200 item size 80 after executing go subv viper sub app cache1 subv represents json max items 100 item size 64 suppose we have go func newcache cfg viper cache which creates a cache based on config information formatted as subv now its easy to create these 2 caches separately as go cfg1 viper sub app cache1 cache1 newcache cfg1 cfg2 viper sub app cache2 cache2 newcache cfg2 unmarshaling you also have the option of unmarshaling all or a specific value to a struct map etc there are two methods to do this unmarshal rawval interface error unmarshalkey key string rawval interface error example go type config struct port int name string pathmap stringmapstructure path map var c config err unmarshal c if err nil t fatalf unable to decode into struct v err marshalling to string you may need to marhsal all the settings held in viper into a string rather than write them to a file you can use your favorite formats marshaller with the config returned by allsettings go import yaml gopkg in yaml v2 func yamlstringsettings string c viper allsettings bs err yaml marshal c if err nil t fatalf unable to marshal config to yaml v err return string bs viper or vipers viper comes ready to use out of the box there is no configuration or initialization needed to begin using viper since most applications will want to use a single central repository for their configuration the viper package provides this it is similar to a singleton in all of the examples above they demonstrate using viper in its singleton style approach working with multiple vipers you can also create many different vipers for use in your application each will have its own unique set of configurations and values each can read from a different config file key value store etc all of the functions that viper package supports are mirrored as methods on a viper example go x viper new y viper new x setdefault contentdir content y setdefault contentdir foobar when working with multiple vipers it is up to the user to keep track of the different vipers q a q why not ini files a ini files are pretty awful theres no standard format and they are hard to validate viper is designed to work with json toml or yaml files if someone really wants to add this feature id be happy to merge it its easy to specify which formats your application will permit q why is it called “viper” a viper is designed to be a companion to cobra while both can operate completely independently together they make a powerful pair to handle much of your application foundation needs q why is it called “cobra” a is there a better name for a commander