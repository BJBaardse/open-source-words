this readme is just a fast quick start document you can find more detailed documentation at redis io what is redis redis is often referred as a data structures server what this means is that redis provides access to mutable data structures via a set of commands which are sent using a server client model with tcp sockets and a simple protocol so different processes can query and modify the same data structures in a shared way data structures implemented into redis have a few special properties redis cares to store them on disk even if they are always served and modified into the server memory this means that redis is fast but that is also non volatile implementation of data structures stress on memory efficiency so data structures inside redis will likely use less memory compared to the same data structure modeled using an high level programming language redis offers a number of features that are natural to find in a database like replication tunable levels of durability cluster high availability another good example is to think of redis as a more complex version of memcached where the operations are not just sets and gets but operations to work with complex data types like lists sets ordered data structures and so forth if you want to know more this is a list of selected starting points introduction to redis data types http redis io topics data types intro try redis directly inside your browser http try redis io the full list of redis commands http redis io commands there is much more inside the redis official documentation http redis io documentation building redis redis can be compiled and used on linux osx openbsd netbsd freebsd we support big endian and little endian architectures and both 32 bit and 64 bit systems it may compile on solaris derived systems for instance smartos but our support for this platform is best effort and redis is not guaranteed to work as well as in linux osx and bsd there it is as simple as make you can run a 32 bit redis binary using make 32bit after building redis it is a good idea to test it using make test fixing build problems with dependencies or cached build options redis has some dependencies which are included into the deps directory make does not automatically rebuild dependencies even if something in the source code of dependencies changes when you update the source code with git pull or when code inside the dependencies tree is modified in any other way make sure to use the following command in order to really clean everything and rebuild from scratch make distclean this will clean jemalloc lua hiredis linenoise also if you force certain build options like 32bit target no c compiler optimizations for debugging purposes and other similar build time options those options are cached indefinitely until you issue a make distclean command fixing problems building 32 bit binaries if after building redis with a 32 bit target you need to rebuild it with a 64 bit target or the other way around you need to perform a make distclean in the root directory of the redis distribution in case of build errors when trying to build a 32 bit binary of redis try the following steps install the packages libc6 dev i386 also try g multilib try using the following command line instead of make 32bit make cflags m32 march native ldflags m32 allocator selecting a non default memory allocator when building redis is done by setting the malloc environment variable redis is compiled and linked against libc malloc by default with the exception of jemalloc being the default on linux systems this default was picked because jemalloc has proven to have fewer fragmentation problems than libc malloc to force compiling against libc malloc use make malloc libc to compile against jemalloc on mac os x systems use make malloc jemalloc verbose build redis will build with a user friendly colorized output by default if you want to see a more verbose output use the following make v 1 running redis to run redis with the default configuration just type cd src redis server if you want to provide your redis conf you have to run it using an additional parameter the path of the configuration file cd src redis server path to redis conf it is possible to alter the redis configuration by passing parameters directly as options using the command line examples redis server port 9999 slaveof 127 0 0 1 6379 redis server etc redis 6379 conf loglevel debug all the options in redis conf are also supported as options using the command line with exactly the same name playing with redis you can use redis cli to play with redis start a redis server instance then in another terminal try the following cd src redis cli redis ping pong redis set foo bar ok redis get foo bar redis incr mycounter integer 1 redis incr mycounter integer 2 redis you can find the list of all the available commands at http redis io commands installing redis in order to install redis binaries into usr local bin just use make install you can use make prefix some other directory install if you wish to use a different destination make install will just install binaries in your system but will not configure init scripts and configuration files in the appropriate place this is not needed if you want just to play a bit with redis but if you are installing it the proper way for a production system we have a script doing this for ubuntu and debian systems cd utils install server sh the script will ask you a few questions and will setup everything you need to run redis properly as a background daemon that will start again on system reboots youll be able to stop and start redis using the script named etc init d redis portnumber for instance etc init d redis 6379 code contributions note by contributing code to the redis project in any form including sending a pull request via github a code fragment or patch via private email or public discussion groups you agree to release your code under the terms of the bsd license that you can find in the copying file included in the redis source distribution please see the contributing file in this source distribution for more information redis internals if you are reading this readme you are likely in front of a github page or you just untarred the redis distribution tar ball in both the cases you are basically one step away from the source code so here we explain the redis source code layout what is in each file as a general idea the most important functions and structures inside the redis server and so forth we keep all the discussion at a high level without digging into the details since this document would be huge otherwise and our code base changes continuously but a general idea should be a good starting point to understand more moreover most of the code is heavily commented and easy to follow source code layout the redis root directory just contains this readme the makefile which calls the real makefile inside the src directory and an example configuration for redis and sentinel you can find a few shell scripts that are used in order to execute the redis redis cluster and redis sentinel unit tests which are implemented inside the tests directory inside the root are the following important directories src contains the redis implementation written in c tests contains the unit tests implemented in tcl deps contains libraries redis uses everything needed to compile redis is inside this directory your system just needs to provide libc a posix compatible interface and a c compiler notably deps contains a copy of jemalloc which is the default allocator of redis under linux note that under deps there are also things which started with the redis project but for which the main repository is not anitrez redis an exception to this rule is deps geohash int which is the low level geocoding library used by redis it originated from a different project but at this point it diverged so much that it is developed as a separated entity directly inside the redis repository there are a few more directories but they are not very important for our goals here well focus mostly on src where the redis implementation is contained exploring what there is inside each file the order in which files are exposed is the logical one to follow in order to disclose different layers of complexity incrementally note lately redis was refactored quite a bit function names and file names have been changed so you may find that this documentation reflects the unstable branch more closely for instance in redis 3 0 the server c and server h files were named to redis c and redis h however the overall structure is the same keep in mind that all the new developments and pull requests should be performed against the unstable branch server h the simplest way to understand how a program works is to understand the data structures it uses so well start from the main header file of redis which is server h all the server configuration and in general all the shared state is defined in a global structure called server of type struct redisserver a few important fields in this structure are server db is an array of redis databases where data is stored server commands is the command table server clients is a linked list of clients connected to the server server master is a special client the master if the instance is a slave there are tons of other fields most fields are commented directly inside the structure definition another important redis data structure is the one defining a client in the past it was called redisclient now just client the structure has many fields here well just show the main ones struct client int fd sds querybuf int argc robj argv redisdb db int flags list reply char buf proto reply chunk bytes many other fields the client structure defines a connected client the fd field is the client socket file descriptor argc and argv are populated with the command the client is executing so that functions implementing a given redis command can read the arguments querybuf accumulates the requests from the client which are parsed by the redis server according to the redis protocol and executed by calling the implementations of the commands the client is executing reply and buf are dynamic and static buffers that accumulate the replies the server sends to the client these buffers are incrementally written to the socket as soon as the file descriptor is writable as you can see in the client structure above arguments in a command are described as robj structures the following is the full robj structure which defines a redis object typedef struct redisobject unsigned type 4 unsigned encoding 4 unsigned lru lru bits lru time relative to server lruclock int refcount void ptr robj basically this structure can represent all the basic redis data types like strings lists sets sorted sets and so forth the interesting thing is that it has a type field so that it is possible to know what type a given object has and a refcount so that the same object can be referenced in multiple places without allocating it multiple times finally the ptr field points to the actual representation of the object which might vary even for the same type depending on the encoding used redis objects are used extensively in the redis internals however in order to avoid the overhead of indirect accesses recently in many places we just use plain dynamic strings not wrapped inside a redis object server c this is the entry point of the redis server where the main function is defined the following are the most important steps in order to startup the redis server initserverconfig setups the default values of the server structure initserver allocates the data structures needed to operate setup the listening socket and so forth aemain starts the event loop which listens for new connections there are two special functions called periodically by the event loop servercron is called periodically according to server hz frequency and performs tasks that must be performed from time to time like checking for timedout clients beforesleep is called every time the event loop fired redis served a few requests and is returning back into the event loop inside server c you can find code that handles other vital things of the redis server call is used in order to call a given command in the context of a given client activeexpirecycle handles eviciton of keys with a time to live set via the expire command freememoryifneeded is called when a new write command should be performed but redis is out of memory according to the maxmemory directive the global variable rediscommandtable defines all the redis commands specifying the name of the command the function implementing the command the number of arguments required and other properties of each command networking c this file defines all the i o functions with clients masters and slaves which in redis are just special clients createclient allocates and initializes a new client the addreply family of functions are used by commands implementations in order to append data to the client structure that will be transmitted to the client as a reply for a given command executed writetoclient transmits the data pending in the output buffers to the client and is called by the writable event handler sendreplytoclient readqueryfromclient is the readable event handler and accumulates data from read from the client into the query buffer processinputbuffer is the entry point in order to parse the client query buffer according to the redis protocol once commands are ready to be processed it calls processcommand which is defined inside server c in order to actually execute the command freeclient deallocates disconnects and removes a client aof c and rdb c as you can guess from the names these files implement the rdb and aof persistence for redis redis uses a persistence model based on the fork system call in order to create a thread with the same shared memory content of the main redis thread this secondary thread dumps the content of the memory on disk this is used by rdb c to create the snapshots on disk and by aof c in order to perform the aof rewrite when the append only file gets too big the implementation inside aof c has additional functions in order to implement an api that allows commands to append new commands into the aof file as clients execute them the call function defined inside server c is responsible to call the functions that in turn will write the commands into the aof db c certain redis commands operate on specific data types others are general examples of generic commands are del and expire they operate on keys and not on their values specifically all those generic commands are defined inside db c moreover db c implements an api in order to perform certain operations on the redis dataset without directly accessing the internal data structures the most important functions inside db c which are used in many commands implementations are the following lookupkeyread and lookupkeywrite are used in order to get a pointer to the value associated to a given key or null if the key does not exist dbadd and its higher level counterpart setkey create a new key in a redis database dbdelete removes a key and its associated value emptydb removes an entire single database or all the databases defined the rest of the file implements the generic commands exposed to the client object c the robj structure defining redis objects was already described inside object c there are all the functions that operate with redis objects at a basic level like functions to allocate new objects handle the reference counting and so forth notable functions inside this file incrrefcount and decrrefcount are used in order to increment or decrement an object reference count when it drops to 0 the object is finally freed createobject allocates a new object there are also specialized functions to allocate string objects having a specific content like createstringobjectfromlonglong and similar functions this file also implements the object command replication c this is one of the most complex files inside redis it is recommended to approach it only after getting a bit familiar with the rest of the code base in this file there is the implementation of both the master and slave role of redis one of the most important functions inside this file is replicationfeedslaves that writes commands to the clients representing slave instances connected to our master so that the slaves can get the writes performed by the clients this way their data set will remain synchronized with the one in the master this file also implements both the sync and psync commands that are used in order to perform the first synchronization between masters and slaves or to continue the replication after a disconnection other c files t hash c t list c t set c t string c and t zset c contains the implementation of the redis data types they implement both an api to access a given data type and the client commands implementations for these data types ae c implements the redis event loop its a self contained library which is simple to read and understand sds c is the redis string library check http github com antirez sds for more information anet c is a library to use posix networking in a simpler way compared to the raw interface exposed by the kernel dict c is an implementation of a non blocking hash table which rehashes incrementally scripting c implements lua scripting it is completely self contained from the rest of the redis implementation and is simple enough to understand if you are familar with the lua api cluster c implements the redis cluster probably a good read only after being very familiar with the rest of the redis code base if you want to read cluster c make sure to read the redis cluster specification anatomy of a redis command all the redis commands are defined in the following way void foobarcommand client c printf s c argv 1 ptr do something with the argument addreply c shared ok reply something to the client the command is then referenced inside server c in the command table foobar foobarcommand 2 rtf 0 null 0 0 0 0 0 in the above example 2 is the number of arguments the command takes while rtf are the command flags as documented in the command table top comment inside server c after the command operates in some way it returns a reply to the client usually using addreply or a similar function defined inside networking c there are tons of commands implementations inside the redis source code that can serve as examples of actual commands implementations to write a few toy commands can be a good exercise to familiarize with the code base there are also many other files not described here but it is useless to cover everything we want to just help you with the first steps eventually youll find your way inside the redis code base enjoy