design goals integration examples json as first class data type serialization deserialization stl like access conversion from stl containers json pointer and json patch json merge patch implicit conversions conversions to from arbitrary types binary formats cbor messagepack and ubjson supported compilers license contact thanks used third party tools projects using json for modern c notes execute unit tests design goals there are myriads of json libraries out there and each may even have its reason to exist our class had these design goals intuitive syntax in languages such as python json feels like a first class data type we used all the operator magic of modern c to achieve the same feeling in your code check out the examples below and youll know what i mean trivial integration our whole code consists of a single header file json hpp thats it no library no subproject no dependencies no complex build system the class is written in vanilla c 11 all in all everything should require no adjustment of your compiler flags or project settings serious testing our class is heavily unit tested and covers 100 of the code including all exceptional behavior furthermore we checked with valgrind and the clang sanitizers that there are no memory leaks google oss fuzz additionally runs fuzz tests agains all parsers 24 7 effectively executing billions of tests so far to maintain high quality the project is following the core infrastructure initiative cii best practices other aspects were not so important to us memory efficiency each json object has an overhead of one pointer the maximal size of a union and one enumeration element 1 byte the default generalization uses the following c data types std string for strings int64 t uint64 t or double for numbers std map for objects std vector for arrays and bool for booleans however you can template the generalized class basic json to your needs speed there are certainly faster json libraries out there however if your goal is to speed up your development by adding json support with a single header then this library is the way to go if you know how to use a std vector or std map you are already set see the contribution guidelines for more information integration json hpp is the single required file in single include nlohmann or released here you need to add cpp include for convenience using json nlohmann json to the files you want to process json and set the necessary switches to enable c 11 e g std c 11 for gcc and clang you can further use file include nlohmann json fwd hpp for forward declarations the installation of json fwd hpp as part of cmakes install step can be achieved by setting djson multipleheaders on package managers beer if you are using os x and homebrew just type brew tap nlohmann json and brew install nlohmann json and youre set if you want the bleeding edge rather than the latest release use brew install nlohmann json head if you are using the meson build system then you can wrap this repository as a subproject if you are using conan to manage your dependencies merely add jsonformoderncpp x y z vthiery stable to your conanfile pys requires where x y z is the release version you want to use please file issues here if you experience problems with the packages if you are using hunter on your project for external dependencies then you can use the nlohmann json package please see the hunter project for any issues regarding the packaging if you are using buckaroo you can install this librarys module with buckaroo install nlohmann json please file issues here if you are using vcpkg on your project for external dependencies then you can use the nlohmann json package please see the vcpkg project for any issues regarding the packaging if you are using cget you can install the latest development version with cget install nlohmann json a specific version can be installed with cget install nlohmann json v3 1 0 also the multiple header version can be installed by adding the djson multipleheaders on flag i e cget install nlohmann json djson multipleheaders on examples beside the examples below you may want to check the documentation where each function contains a separate code example e g check out emplace all example files can be compiled and executed on their own e g file emplace cpp json as first class data type here are some examples to give you an idea how to use the class assume you want to create the json object json pi 3 141 happy true name niels nothing null answer everything 42 list 1 0 2 object currency usd value 42 99 with this library you could write cpp create an empty structure null json j add a number that is stored as double note the implicit conversion of j to an object j pi 3 141 add a boolean that is stored as bool j happy true add a string that is stored as std string j name niels add another null object by passing nullptr j nothing nullptr add an object inside the object j answer everything 42 add an array that is stored as std vector using an initializer list j list 1 0 2 add another object using an initializer list of pairs j object currency usd value 42 99 instead you could also write which looks very similar to the json above json j2 pi 3 141 happy true name niels nothing nullptr answer everything 42 list 1 0 2 object currency usd value 42 99 note that in all these cases you never need to tell the compiler which json value type you want to use if you want to be explicit or express some edge cases the functions json array and json object will help cpp a way to express the empty array json empty array explicit json array ways to express the empty object json empty object implicit json json empty object explicit json object a way to express an array of key value pairs currency usd value 42 99 json array not object json array currency usd value 42 99 serialization deserialization to from strings you can create a json value deserialization by appending json to a string literal cpp create object from string literal json j \ happy\ true \ pi\ 3 141 json or even nicer with a raw string literal auto j2 r happy true pi 3 141 json note that without appending the json suffix the passed string literal is not parsed but just used as json string value that is json j \ happy\ true \ pi\ 3 141 would just store the string happy true pi 3 141 rather than parsing the actual object the above example can also be expressed explicitly using json parse cpp parse explicitly auto j3 json parse \ happy\ true \ pi\ 3 141 you can also get a string representation of a json value serialize cpp explicit conversion to string std string s j dump \ happy\ true \ pi\ 3 141 serialization with pretty printing pass in the amount of spaces to indent std cout j dump 4 std endl happy true pi 3 141 note the difference between serialization and assignment cpp store a string in a json value json j string this is a string retrieve the string value implicit json to std string conversion std string cpp string j string retrieve the string value explicit json to std string conversion auto cpp string2 j string get retrieve the serialized value explicit json serialization std string serialized string j string dump output of original string std cout cpp string cpp string2 j string get \n output of serialized value std cout j string serialized string std endl dump always returns the serialized value and get std string returns the originally stored string value to from streams e g files string streams you can also use streams to serialize and deserialize cpp deserialize from standard input json j std cin j serialize to standard output std cout j the setw manipulator was overloaded to set the indentation for pretty printing std cout std setw 4 j std endl these operators work for any subclasses of std istream or std ostream here is the same example with files cpp read a json file std ifstream i file json json j i j write prettified json to another file std ofstream o pretty json o std setw 4 j std endl please note that setting the exception bit for failbit is inappropriate for this use case it will result in program termination due to the noexcept specifier in use read from iterator range you can also parse json from an iterator range that is from any container accessible by iterators whose content is stored as contiguous byte sequence for instance a std vector std uint8 t cpp std vector std uint8 t v t r u e json j json parse v begin v end you may leave the iterators for the range begin end cpp std vector std uint8 t v t r u e json j json parse v stl like access we designed the json class to behave just like an stl container in fact it satisfies the reversiblecontainer requirement cpp create an array using push back json j j push back foo j push back 1 j push back true also use emplace back j emplace back 1 78 iterate the array for json iterator it j begin it j end it std cout it \n range based for for auto element j std cout element \n getter setter const std string tmp j 0 j 1 42 bool foo j at 2 comparison j \ foo\ 1 true json true other stuff j size 3 entries j empty false j type json value t array j clear the array is empty again convenience type checkers j is null j is boolean j is number j is object j is array j is string create an object json o o foo 23 o bar false o baz 3 141 also use emplace o emplace weather sunny special iterator member functions for objects for json iterator it o begin it o end it std cout it key it value \n find an entry if o find foo o end there is an entry with key foo or simpler using count int foo present o count foo 1 int fob present o count fob 0 delete an entry o erase foo conversion from stl containers any sequence container std array std vector std deque std forward list std list whose values can be used to construct json values e g integers floating point numbers booleans string types or again stl containers described in this section can be used to create a json array the same holds for similar associative containers std set std multiset std unordered set std unordered multiset but in these cases the order of the elements of the array depends on how the elements are ordered in the respective stl container cpp std vector c vector 1 2 3 4 json j vec c vector 1 2 3 4 std deque c deque 1 2 2 3 3 4 5 6 json j deque c deque 1 2 2 3 3 4 5 6 std list c list true true false true json j list c list true true false true std forward list c flist 12345678909876 23456789098765 34567890987654 45678909876543 json j flist c flist 12345678909876 23456789098765 34567890987654 45678909876543 std array c array 1 2 3 4 json j array c array 1 2 3 4 std set c set one two three four one json j set c set only one entry for one is used four one three two std unordered set c uset one two three four one json j uset c uset only one entry for one is used maybe two three four one std multiset c mset one two one four json j mset c mset both entries for one are used maybe one two one four std unordered multiset c umset one two one four json j umset c umset both entries for one are used maybe one two one four likewise any associative key value containers std map std multimap std unordered map std unordered multimap whose keys can construct an std string and whose values can be used to construct json values see examples above can be used to create a json object note that in case of multimaps only one key is used in the json object and the value depends on the internal order of the stl container cpp std map c map one 1 two 2 three 3 json j map c map one 1 three 3 two 2 std unordered map c umap one 1 2 two 2 3 three 3 4 json j umap c umap one 1 2 two 2 3 three 3 4 std multimap c mmap one true two true three false three true json j mmap c mmap only one entry for key three is used maybe one true two true three true std unordered multimap c ummap one true two true three false three true json j ummap c ummap only one entry for key three is used maybe one true two true three true json pointer and json patch the library supports json pointer rfc 6901 as alternative means to address structured values on top of this json patch rfc 6902 allows to describe differences between two json values effectively allowing patch and diff operations known from unix cpp a json value json j original r baz one two three foo bar json access members with a json pointer rfc 6901 j original baz 1 json pointer two a json patch rfc 6902 json j patch r op replace path baz value boo op add path hello value world op remove path foo json apply the patch json j result j original patch j patch baz boo hello world calculate a json patch from two json values json diff j result j original op replace path baz value one two three op remove path hello op add path foo value bar json merge patch the library supports json merge patch rfc 7386 as a patch format instead of using json pointer see above to specify values to be manipulated it describes the changes using a syntax that closely mimics the document being modified cpp a json value json j document r a b c d e f g json a patch json j patch r a z c f null json apply the patch j original merge patch j patch a z c d e implicit conversions the type of the json object is determined automatically by the expression to store likewise the stored value is implicitly converted cpp strings std string s1 hello world json js s1 std string s2 js booleans bool b1 true json jb b1 bool b2 jb numbers int i 42 json jn i double f jn etc you can also explicitly ask for the value cpp std string vs js get bool vb jb get int vi jn get etc arbitrary types conversions every type can be serialized in json not just stl containers and scalar types usually you would do something along those lines cpp namespace ns a simple struct to model a person struct person std string name std string address int age ns person p ned flanders 744 evergreen terrace 60 convert to json copy each value into the json object json j j name p name j address p address j age p age convert from json copy each value from the json object ns person p j name get j address get j age get it works but thats quite a lot of boilerplate fortunately theres a better way cpp create a person ns person p ned flanders 744 evergreen terrace 60 conversion person json json j p std cout j std endl address 744 evergreen terrace age 60 name ned flanders conversion json person ns person p2 j thats it assert p p2 basic usage to make this work with one of your types you only need to provide two functions cpp using nlohmann json namespace ns void to json json j const person p j json name p name address p address age p age void from json const json j person p p name j at name get std string p address j at address get std string p age j at age get int namespace ns thats all when calling the json constructor with your type your custom to json method will be automatically called likewise when calling get your type the from json method will be called some important things those methods must be in your types namespace which can be the global namespace or the library will not be able to locate them in this example they are in namespace ns where person is defined when using get your type your type must be defaultconstructible there is a way to bypass this requirement described later in function from json use function at to access the object values rather than operator in case a key does not exist at throws an exception that you can handle whereas operator exhibits undefined behavior in case your type contains several operator definitions code like your variable your json may not compile you need to write your variable your json get decltype your variable instead you do not need to add serializers or deserializers for stl types like std vector the library already implements these be careful with the definition order of the from json to json functions if a type b has a member of type a you must define to json a before to json b look at issue 561 for more details how do i convert third party types this requires a bit more advanced technique but first lets see how this conversion mechanism works the library uses json serializers to convert types to json the default serializer for nlohmann json is nlohmann adl serializer adl means argument dependent lookup it is implemented like this simplified cpp template struct adl serializer static void to json json j const t value calls the to json method in ts namespace static void from json const json j t value same thing but with the from json method this serializer works fine when you have control over the types namespace however what about boost optional or std filesystem path c 17 hijacking the boost namespace is pretty bad and its illegal to add something other than template specializations to std to solve this you need to add a specialization of adl serializer to the nlohmann namespace heres an example cpp partial specialization full specialization works too namespace nlohmann template struct adl serializer static void to json json j const boost optional opt if opt boost none j nullptr else j opt this will call adl serializer to json which will find the free function to json in ts namespace static void from json const json j boost optional t opt if j is null opt boost none else opt j get t same as above but with adl serializer t from json how can i use get for non default constructible non copyable types there is a way if your type is moveconstructible you will need to specialize the adl serializer as well but with a special from json overload cpp struct move only type move only type delete move only type int ii i ii move only type const move only type delete move only type move only type default int i namespace nlohmann template struct adl serializer note the return type is no longer void and the method only takes one argument static move only type from json const json j return j get heres the catch you must provide a to json method otherwise you will not be able to convert move only type to json since you fully specialized adl serializer on that type static void to json json j move only type t j t i can i write my own serializer advanced use yes you might want to take a look at unit udt cpp in the test suite to see a few examples if you write your own serializer youll need to do a few things use a different basic json alias than nlohmann json the last template parameter of basic json is the jsonserializer use your basic json alias or a template parameter in all your to json from json methods use nlohmann to json and nlohmann from json when you need adl here is an example without simplifications that only accepts types with a size 32 and uses adl cpp you should use void as a second template argument if you dont need compile time checks on t template type struct less than 32 serializer template static void to json basicjsontype j t value we want to use adl and call the correct to json overload using nlohmann to json this method is called by adl serializer this is where the magic happens to json j value template typename basicjsontype static void from json const basicjsontype j t value same thing here using nlohmann from json from json j value be very careful when reimplementing your serializer you can stack overflow if you dont pay attention cpp template struct bad serializer template static void to json basicjsontype j const t value this calls basicjsontype json serializer to json j value if basicjsontype json serializer bad serializer oops j value template typename basicjsontype static void to json const basicjsontype j t value this calls basicjsontype json serializer t from json j value if basicjsontype json serializer bad serializer oops value j template get t oops binary formats cbor messagepack and ubjson though json is a ubiquitous data format it is not a very compact format suitable for data exchange for instance over a network hence the library supports cbor concise binary object representation messagepack and ubjson universal binary json specification to efficiently encode json values to byte vectors and to decode such vectors cpp create a json value json j r compact true schema 0 json serialize to cbor std vector v cbor json to cbor j 0xa2 0x67 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xf5 0x66 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 roundtrip json j from cbor json from cbor v cbor serialize to messagepack std vector v msgpack json to msgpack j 0x82 0xa7 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xc3 0xa6 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 roundtrip json j from msgpack json from msgpack v msgpack serialize to ubjson std vector v ubjson json to ubjson j 0x7b 0x69 0x07 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0x54 0x69 0x06 0x73 0x63 0x68 0x65 0x6d 0x61 0x69 0x00 0x7d roundtrip json j from ubjson json from ubjson v ubjson supported compilers though its 2018 already the support for c 11 is still a bit sparse currently the following compilers are known to work gcc 4 9 7 2 and possibly later clang 3 4 5 0 and possibly later intel c compiler 17 0 2 and possibly later microsoft visual c 2015 build tools 14 0 25123 0 and possibly later microsoft visual c 2017 build tools 15 5 180 51428 and possibly later i would be happy to learn about other compilers versions please note gcc 4 8 does not work because of two bugs 55817 and 57824 in the c 11 support note there is a pull request to fix some of the issues android defaults to using very old compilers and c libraries to fix this add the following to your application mk this will switch to the llvm c library the clang compiler and enable c 11 and other features disabled by default app stl c shared ndk toolchain version clang3 6 app cppflags frtti fexceptions the code compiles successfully with android ndk revision 9 11 and possibly later and crystaxs android ndk version 10 for gcc running on mingw or android sdk the error to string is not a member of std or similarly for strtod may occur note this is not an issue with the code but rather with the compiler itself on android see above to build with a newer environment for mingw please refer to this site and this discussion for information on how to fix this bug for android ndk using app stl gnustl static please refer to this discussion the following compilers are currently used in continuous integration at travis and appveyor compiler operating system version string gcc 4 9 4 ubuntu 14 04 5 lts g 4 9 ubuntu 4 9 4 2ubuntu1 14 04 1 4 9 4 gcc 5 4 1 ubuntu 14 04 5 lts g 5 ubuntu 5 4 1 2ubuntu1 14 04 5 4 1 20160904 gcc 6 3 0 ubuntu 14 04 5 lts g 6 ubuntu linaro 6 3 0 18ubuntu2 14 04 6 3 0 20170519 gcc 7 1 0 ubuntu 14 04 5 lts g 7 ubuntu 7 1 0 5ubuntu2 14 04 7 1 0 clang 3 5 0 ubuntu 14 04 5 lts clang version 3 5 0 4ubuntu2 trusty2 tags release 350 final clang 3 6 2 ubuntu 14 04 5 lts clang version 3 6 2 svn240577 1 exp1 branches release 36 clang 3 7 1 ubuntu 14 04 5 lts clang version 3 7 1 svn253571 1 exp1 branches release 37 clang 3 8 0 ubuntu 14 04 5 lts clang version 3 8 0 2ubuntu3 trusty5 tags release 380 final clang 3 9 1 ubuntu 14 04 5 lts clang version 3 9 1 4ubuntu3 14 04 2 tags release 391 rc2 clang 4 0 1 ubuntu 14 04 5 lts clang version 4 0 1 svn305264 1 exp1 branches release 40 clang 5 0 0 ubuntu 14 04 5 lts clang version 5 0 0 svn310902 1 exp1 branches release 50 clang xcode 6 4 darwin kernel version 14 3 0 osx 10 10 3 apple llvm version 6 1 0 clang 602 0 53 based on llvm 3 6 0svn clang xcode 7 3 darwin kernel version 15 0 0 osx 10 10 5 apple llvm version 7 3 0 clang 703 0 29 clang xcode 8 0 darwin kernel version 15 6 0 apple llvm version 8 0 0 clang 800 0 38 clang xcode 8 1 darwin kernel version 16 1 0 macos 10 12 1 apple llvm version 8 0 0 clang 800 0 42 1 clang xcode 8 2 darwin kernel version 16 1 0 macos 10 12 1 apple llvm version 8 0 0 clang 800 0 42 1 clang xcode 8 3 darwin kernel version 16 5 0 macos 10 12 4 apple llvm version 8 1 0 clang 802 0 38 clang xcode 9 0 darwin kernel version 16 7 0 macos 10 12 6 apple llvm version 9 0 0 clang 900 0 37 clang xcode 9 1 darwin kernel version 16 7 0 macos 10 12 6 apple llvm version 9 0 0 clang 900 0 38 clang xcode 9 2 darwin kernel version 16 7 0 macos 10 12 6 apple llvm version 8 1 0 clang 900 0 39 2 visual studio 14 2015 windows server 2012 r2 x64 microsoft r build engine version 14 0 25420 1 msvc 19 0 24215 1 visual studio 2017 windows server 2016 microsoft r build engine version 15 5 180 51428 msvc 19 12 25830 2 license the class is licensed under the mit license copyright © 2013 2018 niels lohmann permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the “software” to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software the software is provided “as is” without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall the authors or copyright holders be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software the class contains the utf 8 decoder from bjoern hoehrmann which is licensed under the mit license see above copyright © 2008 2009 björn hoehrmann bjoern hoehrmann de the class contains a slightly modified version of the grisu2 algorithm from florian loitsch which is licensed under the mit license see above copyright © 2009 florian loitsch contact if you have questions regarding the library i would like to invite you to open an issue at github please describe your request problem or question as detailed as possible and also mention the version of the library you are using as well as the version of your compiler and operating system opening an issue at github allows other users and contributors to this library to collaborate for instance i have little experience with msvc and most issues in this regard have been solved by a growing community if you have a look at the closed issues you will see that we react quite timely in most cases only if your request would contain confidential information please send me an email for encrypted messages please use this key thanks i deeply appreciate the help of the following people teemperor implemented cmake support and lcov integration realized escape and unicode handling in the string parser and fixed the json serialization elliotgoodrich fixed an issue with double deletion in the iterator classes kirkshoop made the iterators of the class composable to other libraries wancw fixed a bug that hindered the class to compile with clang tomas åblad found a bug in the iterator implementation joshua c randall fixed a bug in the floating point serialization aaron burghardt implemented code to parse streams incrementally furthermore he greatly improved the parser class by allowing the definition of a filter function to discard undesired elements while parsing daniel kopeček fixed a bug in the compilation with gcc 5 0 florian weber fixed a bug in and improved the performance of the comparison operators eric cornelius pointed out a bug in the handling with nan and infinity values he also improved the performance of the string escaping 易思龙 implemented a conversion from anonymous enums kepkin patiently pushed forward the support for microsoft visual studio gregmarr simplified the implementation of reverse iterators and helped with numerous hints and improvements in particular he pushed forward the implementation of user defined types caio luppi fixed a bug in the unicode handling dariomt fixed some typos in the examples daniel frey cleaned up some pointers and implemented exception safe memory allocation colin hirsch took care of a small namespace issue huu nguyen correct a variable name in the documentation silverweed overloaded parse to accept an rvalue reference dariomt fixed a subtlety in msvc type support and implemented the get ref function to get a reference to stored values zahlgraf added a workaround that allows compilation using android ndk whackashoe replaced a function that was marked as unsafe by visual studio 406345 fixed two small warnings glen fernandes noted a potential portability problem in the has mapped type function corbin hughes fixed some typos in the contribution guidelines twelsby fixed the array subscript operator an issue that failed the msvc build and floating point parsing dumping he further added support for unsigned integer numbers and implemented better roundtrip support for parsed numbers volker diels grabsch fixed a link in the readme file msm added support for american fuzzy lop annihil fixed an example in the readme file themercee noted a wrong url in the readme file lv zheng fixed a namespace issue with int64 t and uint64 t abc100m analyzed the issues with gcc 4 8 and proposed a partial solution zewt added useful notes to the readme file about android róbert márki added a fix to use move iterators and improved the integration via cmake chris kitching cleaned up the cmake files tom needham fixed a subtle bug with msvc 2015 which was also proposed by michael k mário feroldi fixed a small typo duncanwerner found a really embarrassing performance regression in the 2 0 0 release damien fixed one of the last conversion warnings thomas braun fixed a warning in a test case théo delrieu patiently and constructively oversaw the long way toward iterator range parsing he also implemented the magic behind the serialization deserialization of user defined types and split the single header file into smaller chunks stefan fixed a minor issue in the documentation vasil dimov fixed the documentation regarding conversions from std multiset christophjud overworked the cmake files to ease project inclusion vladimir petrigo made a sfinae hack more readable and added visual studio 17 to the build matrix denis andrejew fixed a grammar issue in the readme file pierre antoine lacaze found a subtle bug in the dump function turpentinedistillery pointed to std locale classic to avoid too much locale joggling found some nice performance improvements in the parser improved the benchmarking code and realized locale independent number parsing and printing cgzones had an idea how to fix the coverity scan jared grubb silenced a nasty documentation warning yixin zhang fixed an integer overflow check bosswestfalen merged two iterator classes into a smaller one daniel599 helped to get travis execute the tests with clangs sanitizers jonathan lee fixed an example in the readme file gnzlbg supported the implementation of user defined types alexej harm helped to get the user defined types working with visual studio jared grubb supported the implementation of user defined types enricobilla noted a typo in an example martin hořeňovský found a way for a 2x speedup for the compilation time of the test suite ukhegg found proposed an improvement for the examples section rswanson ihi noted a typo in the readme mihai stan fixed a bug in the comparison with nullptrs tushar maheshwari added cotire support to speed up the compilation tedlyngmo noted a typo in the readme removed unnecessary bit arithmetic and fixed some weffc warnings krzysztof woś made exceptions more visible ftillier fixed a compiler warning tinloaf made sure all pushed warnings are properly popped fytch found a bug in the documentation jay sistar implemented a meson build description henry lee fixed a warning in icc and improved the iterator implementation vincent thiery maintains a package for the conan package manager steffen fixed a potential issue with msvc and std min mike tzou fixed some typos amrcode noted a misleading documentation about comparison of floats oleg endo reduced the memory consumption by replacing iostream with iosfwd dan 42 cleaned up the cmake files to simplify including reusing of the library nikita ofitserov allowed for moving values from initializer lists greg hurrell fixed a typo dmitry kukovinets fixed a typo kbthomp1 fixed an issue related to the intel osx compiler markus werle fixed a typo webprodpp fixed a subtle error in a precondition check alex noted an error in a code sample tom de geus reported some warnings with icc and helped fixing them perry kundert simplified reading from input streams sonu lohani fixed a small compilation error jamie seward fixed all msvc warnings nate vargas added a doxygen tag file pvleuven helped fixing a warning in icc pavel helped fixing some warnings in msvc jamie seward avoided unnecessary string copies in find and count mitja fixed some typos jorrit wronski updated the hunter package links matthias möller added a natvis for the msvc debug view bogemic fixed some c 17 deprecation warnings eren okka fixed some msvc warnings abolz integrated the grisu2 algorithm for proper floating point formatting allowing more roundtrip checks to succeed vadim evard fixed a markdown issue in the readme zerodefect fixed a compiler warning kert allowed to template the string type in the serialization and added the possibility to override the exceptional behavior mark 99 helped fixing an icc error patrik huber fixed links in the readme file johnfb found a bug in the implementation of cbors indefinite length strings paul fultz ii added a note on the cget package manager wilson lin made the integration section of the readme more concise ralfbielig detected and fixed a memory leak in the parser callback agrianius allowed to dump json to an alternative string type thanks a lot for helping out please let me know if i forgot someone used third party tools the library itself contains of a single header file licensed under the mit license however it is built tested documented and whatnot using a lot of third party tools and services thanks a lot amalgamate py amalgamate c source and header files to create a single header file american fuzzy lop for fuzz testing appveyor for continuous integration on windows artistic style for automatic source code identation catch for the unit tests clang for compilation with code sanitizers cmake for build automation codacity for further code analysis coveralls to measure code coverage coverity scan for static analysis cppcheck for static analysis doxygen to generate documentation git update ghpages to upload the documentation to gh pages github changelog generator to generate the changelog google benchmark to implement the benchmarks libfuzzer to implement fuzz testing for oss fuzz oss fuzz for continuous fuzz testing of the library project repository probot for automating maintainer tasks such as closing stale issues requesting missing information or detecting toxic comments send to wandbox to send code examples to wandbox travis for continuous integration on linux and macos valgrind to check for correct memory management wandbox for online examples projects using json for modern c the library is currently used in apple macos sierra and ios 10 i am not sure what they are using the library for but i am happy that it runs on so many devices notes the code contains numerous debug assertions which can be switched off by defining the preprocessor macro ndebug see the documentation of assert in particular note operator implements unchecked access for const objects if the given key is not present the behavior is undefined think of a dereferenced null pointer and yields an assertion failure if assertions are switched on if you are not sure whether an element in an object exists use checked access with the at function as the exact type of a number is not defined in the json specification this library tries to choose the best fitting c number type automatically as a result the type double may be used to store numbers which may yield floating point exceptions in certain rare situations if floating point exceptions have been unmasked in the calling code these exceptions are not caused by the library and need to be fixed in the calling code such as by re masking the exceptions prior to calling library functions the library supports unicode input as follows only utf 8 encoded input is supported which is the default encoding for json according to rfc 7159 other encodings such as latin 1 utf 16 or utf 32 are not supported and will yield parse or serialization errors unicode noncharacters will not be replaced by the library invalid surrogates e g incomplete pairs such as \udead will yield parse errors the strings stored in the library are utf 8 encoded when using the default string type std string note that its length size functions return the number of stored bytes rather than the number of characters or glyphs the code can be compiled without c runtime type identification features that is you can use the fno rtti compiler flag exceptions are used widely within the library they can however be switched off with either using the compiler flag fno exceptions or by defining the symbol json noexception in this case exceptions are replaced by an abort call by default the library does not preserve the insertion order of object elements this is standards compliant as the json standard defines objects as an unordered collection of zero or more name value pairs if you do want to preserve the insertion order you can specialize the object type with containers like tsl ordered map integration or nlohmann fifo map integration execute unit tests to compile and run the tests you need to execute sh mkdir build cd build cmake cmake build ctest output on failure for more information have a look at the file travis yml