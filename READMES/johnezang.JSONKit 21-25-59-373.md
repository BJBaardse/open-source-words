jsonkit jsonkit is dual licensed under either the terms of the bsd license or alternatively under the terms of the apache license version 2 0 copyright © 2011 john engelhart a very high performance objective c json library update 2011 12 18 the benchmarks below were performed before apples nsjsonserialization was available as of mac os x 10 7 and ios 5 the obvious question is which is faster nsjsonserialization or jsonkit according to this site jsonkit is faster than nsjsonserialization some quick back of the envelope calculations using the numbers reported jsonkit appears to be approximately 25 to 40 faster than nsjsonserialization which is pretty significant parsing serializing 23 faster than binary plist 549 faster than binary plist benchmarking was performed on a macbook pro with a 2 66ghz core 2 all json libraries were compiled with gcc 4 2 dns block assertions o3 arch x86 64 timing results are the average of 1 000 iterations of the user system time reported by getrusage the json used was twitter public timeline json from samsoffes json benchmarks since the plist format does not support serializing nsnull the null values in the original json were changed to null the experimental branch contains the gzip compression changes jsonkit automagically links to libz dylib on the fly at run time– no manual linking required parsing deserializing will automagically decompress a buffer if it detects a gzip signature header you can compress gzip the serialized json by passing jkserializeoptioncompress to jsondatawithoptions error json versus plist the ultimate showdown benchmarks the common json libraries and compares them to apples plist format javascript object notation or json is a lightweight text based serialization format for structured data that is used by many web based services and apis it is defined by rfc 4627 json provides the following primitive types null boolean true and false number string array object a k a associative arrays key value hash tables maps dictionaries etc these primitive types are mapped to the following objective c foundation classes json objective c null nsnull true and false nsnumber number nsnumber string nsstring array nsarray object nsdictionary jsonkit uses core foundation internally and it is assumed that core foundation ≡ foundation for every equivalent base type i e cfstring ≡ nsstring the key words must must not required shall shall not should should not recommended may and optional in this document are to be interpreted as described in rfc 2119 json to objective c primitive mapping details the json specification is somewhat ambiguous about the details and requirements when it comes to unicode and it does not specify how unicode issues and errors should be handled most of the ambiguity stems from the interpretation and scope rfc 4627 section 3 encoding json text shall be encoded in unicode it is the authors opinion and interpretation that the language of rfc 4627 requires that a json implementation must follow the requirements specified in the unicode standard and in particular the conformance chapter of the unicode standard which specifies requirements related to handling interpreting and manipulating unicode text the default behavior for jsonkit is strict rfc 4627 conformance it is the authors opinion and interpretation that rfc 4627 requires json to be encoded in unicode and therefore json that is not legal unicode as defined by the unicode standard is invalid json therefore jsonkit will not accept json that contains ill formed unicode the default strict behavior implies that the jkparseoptionlooseunicode option is not enabled when the jkparseoptionlooseunicode option is enabled jsonkit follows the specifications and recommendations given in the unicode 6 0 standard chapter 3 conformance section 3 9 unicode encoding forms as a general rule of thumb the unicode code point u fffd is substituted for any ill formed unicode encountered jsonkit attempts to follow the recommended best practice for using u fffd replace each maximal subpart of an ill formed subsequence by a single u fffd the following unicode code points are treated as ill formed unicode and if jkparseoptionlooseunicode is enabled cause u fffd to be substituted in their place u 0000 u d800 thru u dfff inclusive u fdd0 thru u fdef inclusive u nfffe and u nffff where n is from 0x0 to 0x10 the code points u fdd0 thru u fdef u nfffe and u nffff where n is from 0x0 to 0x10 are defined as noncharacters by the unicode standard and should never be interchanged an exception is made for the code point u 0000 which is legal unicode the reason for this is that this particular code point is used by c string handling code to specify the end of the string and any such string handling code will incorrectly stop processing a string at the point where u 0000 occurs although reasonable people may have different opinions on this point it is the authors considered opinion that the risks of permitting json strings that contain u 0000 outweigh the benefits one of the risks in allowing u 0000 to appear unaltered in a string is that it has the potential to create security problems by subtly altering the semantics of the string which can then be exploited by a malicious attacker this is similar to the issue of arbitrarily deleting characters from unicode text rfc 4627 allows for these limitations under section 4 parsers an implementation may set limits on the length and character contents of strings while the unicode standard permits the mutation of the original json i e substituting u fffd for ill formed unicode rfc 4627 is silent on this issue it is the authors opinion and interpretation that rfc 4627 section 3 – encoding json text shall be encoded in unicode implies that such mutations are not only permitted but must be expected by any strictly conforming rfc 4627 json implementation the author feels obligated to note that this opinion and interpretation may not be shared by others and in fact may be a minority opinion and interpretation you should be aware that any mutation of the original json may subtly alter its semantics and as a result may have security related implications for anything that consumes the final result it is important to note that jsonkit will not delete characters from the json being parsed as this is a requirement specified by the unicode standard additional information can be found in the unicode security faq and unicode technical report 36 unicode security consideration in particular the section on non visual security the json specification does not specify the details or requirements for json string values other than such strings must consist of unicode code points nor does it specify how errors should be handled while jsonkit makes an effort subject to the reasonable caveats above regarding unicode to preserve the parsed json string exactly it can not guarantee that nsstring will preserve the exact unicode semantics of the original json string jsonkit does not perform any form of unicode normalization on the parsed json strings but can not make any guarantees that the nsstring class will not perform unicode normalization on the parsed json string used to instantiate the nsstring object the nsstring class may place additional restrictions or otherwise transform the json string in such a way so that the json string is not bijective with the instantiated nsstring object in other words jsonkit can not guarantee that when you round trip a json string to a nsstring and then back to a json string that the two json strings will be exactly the same even though in practice they are for clarity exactly in this case means bit for bit identical jsonkit can not even guarantee that the two json strings will be unicode equivalent even though in practice they will be and would be the most likely cause for the two round tripped json strings to no longer be bit for bit identical jsonkit maps true and false to the cfboolean values kcfbooleantrue and kcfbooleanfalse respectively conceptually cfboolean values can be thought of and treated as nsnumber class objects the benefit to using cfboolean is that true and false json values can be round trip deserialized and serialized without conversion or promotion to a nsnumber with a value of 0 or 1 the json specification does not specify the details or requirements for json number values nor does it specify how errors due to conversion should be handled in general jsonkit will not accept json that contains json number values that it can not convert with out error or loss of precision for non floating point numbers i e json number values that do not include a or e e jsonkit uses a 64 bit c primitive type internally regardless of whether the target architecture is 32 bit or 64 bit for unsigned values i e those that do not begin with a this allows for values up to 264 1 and up to 263 for negative values as a special case the json number 0 is treated as a floating point number since the underlying floating point primitive type is capable of representing a negative zero whereas the underlying twos complement non floating point primitive type can not json that contains number values that exceed these limits will fail to parse and optionally return a nserror object the functions strtoll and strtoull are used to perform the conversions the c double primitive type or ieee 754 double 64 bit floating point is used to represent floating point json number values json that contains floating point number values that can not be represented as a double i e due to over or underflow will fail to parse and optionally return a nserror object the function strtod is used to perform the conversion note that the json standard does not allow for infinities or nan not a number the conversion and manipulation of floating point values is non trivial unfortunately rfc 4627 is silent on how such details should be handled you should not depend on or expect that when a floating point value is round tripped that it will have the same textual representation or even compare equal this is true even when jsonkit is used as both the parser and creator of the json let alone when transferring json between different systems and implementations for json objects or nsdictionary in jsonkit nomenclature rfc 4627 says the names within an object should be unique note name is a key in jsonkit nomenclature at this time the jsonkit behavior is undefined for json that contains names within an object that are not unique however jsonkit currently tries to follow a the last key value pair parsed is the one chosen policy this behavior is not finalized and should not be depended on the previously covered limitations regarding json strings have important consequences for json objects since json strings are used as the key the json specification does not specify the details or requirements for json strings used as keys in json objects specifically what it means for two keys to compare equal unfortunately because rfc 4627 states json text shall be encoded in unicode this means that one must use the unicode standard to interpret the json and the unicode standard allows for strings that are encoded with different unicode code points to compare equal jsonkit uses nsstring exclusively to manage the parsed json strings because nsstring uses unicode as its basis there exists the possibility that nsstring may subtly and silently convert the unicode code points contained in the original json string in to a unicode equivalent string due to this the jsonkit behavior for json strings used as keys in json objects that may be unicode equivalent but not binary equivalent is undefined see also w3c requirements for string identity matching and string indexing objective c to json primitive mapping details when serializing the top level container and all of its children are required to be strictly invariant during enumeration this property is used to make certain optimizations such as if a particular object has already been serialized the result of the previous serialized utf8 string can be reused i e the utf8 string of the previous serialization can simply be copied instead of performing all the serialization work again while this is probably only of interest to those who are doing extraordinarily unusual things with the run time or custom classes inheriting from the classes that jsonkit will serialize i e a custom object whose value mutates each time it receives a message requesting its value for serialization it also covers the case where any of the objects to be serialized are mutated during enumeration i e mutated by another thread the number of times jsonkit will request an objects value is non deterministic from a minimum of once up to the number of times it appears in the serialized json– therefore an object must not depend on receiving a message requesting its value each time it appears in the serialized output the behavior is undefined if these requirements are violated the objects to be serialized must be acyclic if the objects to be serialized contain circular references the behavior is undefined for example objective c arrayone addobject arraytwo arraytwo addobject arrayone id json arrayone jsonstring … will result in undefined behavior the contents of nsstring objects are encoded as utf8 and added to the serialized json jsonkit assumes that nsstring produces well formed utf8 unicode and does no additional validation of the conversion when jkserializeoptionescapeunicode is enabled jsonkit will encode unicode code points that can be encoded as a single utf16 code unit as \uxxxx and will encode unicode code points that require utf16 surrogate pairs as \uhigh\ulow while jsonkit makes every effort to serialize the contents of a nsstring object exactly modulo any rfc 4627 requirements the nsstring class uses the unicode standard as its basis for representing strings you should be aware that the unicode standard defines string equivalence in a such a way that two strings that compare equal are not required to be bit for bit identical therefore there exists the possibility that nsstring may mutate a string in such a way that it is unicode equivalent but not bit for bit identical with the original string the nsdictionary class allows for any object which can be of any class to be used as a key json however only permits strings to be used as keys therefore jsonkit will fail with an error if it encounters a nsdictionary that contains keys that are not nsstring objects during serialization more specifically the keys must return yes when sent iskindofclass nsstring class jsonkit will fail with an error if it encounters an object that is not a nsnull nsnumber nsstring nsarray or nsdictionary class object during serialization more specifically jsonkit will fail with an error if it encounters an object where iskindofclass returns no for all of the previously mentioned classes json does not allow for numbers that are ±infinity or ±nan therefore jsonkit will fail with an error if it encounters a nsnumber that contains such a value during serialization objects created with nsnumber numberwithbool yes and nsnumber numberwithbool no will be mapped to the json values of true and false respectively more specifically an object must have pointer equality with kcfbooleantrue or kcfbooleanfalse i e if id object id kcfbooleantrue in order to be mapped to the json values true and false nsnumber objects that are not booleans as defined above are sent objctype to determine what type of c primitive type they represent those that respond with a type from the set cislq are treated as long long those that respond with a type from the set cislqb are treated as unsigned long long and those that respond with a type from the set fd are treated as double nsnumber objects that respond with a type not in the set of types mentioned will cause jsonkit to fail with an error more specifically cfnumbergetvalue object kcfnumberlonglongtype longlong is used to retrieve the value of both the signed and unsigned integer values and the type reported by objctype is used to determine whether the result is signed or unsigned for floating point values cfnumbergetvalue is used to retrieve the value using kcfnumberdoubletype for the type argument floating point numbers are converted to their decimal representation using the printf format conversion specifier 17g theoretically this allows up to a float or ieee 754 single 32 bit floating point worth of precision to be represented this means that for practical purposes double values are converted to float values with the associated loss of precision the rfc 4627 standard is silent on how floating point numbers should be dealt with and the author has found that real world json implementations vary wildly in how they handle this issue furthermore the g format conversion specifier may convert floating point values that can be exactly represented as an integer to a textual representation that does not include a or e– essentially silently promoting a floating point value to an integer value i e 5 0 becomes 5 because of these and many other issues surrounding the conversion and manipulation of floating point values you should not expect or depend on floating point values to maintain their full precision or when round tripped to compare equal reporting bugs please use the github com jsonkit issue tracker to report bugs the author requests that you do not file a bug report with jsonkit regarding problems reported by the clang static analyzer unless you first manually verify that it is an actual bona fide problem with jsonkit and if appropriate is not legal c code as defined by the c99 language specification if the clang static analyzer is reporting a problem with jsonkit that is not an actual bona fide problem and is perfectly legal code as defined by the c99 language specification then the appropriate place to file a bug report or complaint is with the developers of the clang static analyzer important details jsonkit is not designed to be used with the mac os x garbage collection the behavior of jsonkit when compiled with fobjc gc is undefined it is extremely unlikely that mac os x garbage collection will ever be supported jsonkit is not designed to be used with objective c automatic reference counting arc the behavior of jsonkit when compiled with fobjc arc is undefined the behavior of jsonkit compiled without arc mixed with code that has been compiled with arc is normatively undefined since at this time no analysis has been done to understand if this configuration is safe to use at this time there are no plans to support arc in jsonkit although tenative it is extremely unlikely that arc will ever be supported for many of the same reasons that mac os x garbage collection is not supported the json to be parsed by jsonkit must be encoded as unicode in the unlikely event you end up with json that is not encoded as unicode you must first convert the json to unicode preferably as utf8 one way to accomplish this is with the nsstring methods initwithbytes length encoding and initwithdata encoding internally the low level parsing engine uses utf8 exclusively the jsondecoder method objectwithdata takes a nsdata object as its argument and it is assumed that the raw bytes contained in the nsdata is utf8 encoded otherwise the behavior is undefined it is not safe to use the same instantiated jsondecoder object from multiple threads at the same time if you wish to share a jsondecoder between threads you are responsible for adding mutex barriers to ensure that only one thread is decoding json using the shared jsondecoder object at a time tips for speed enable the ns block assertions pre processor flag jsonkit makes heavy use of nscparameterassert internally to ensure that various arguments variables and other state contains only legal and expected values if an assertion check fails it causes a run time exception that will normally cause a program to terminate these checks and assertions come with a price they take time to execute and do not contribute to the work being performed it is perfectly safe to enable ns block assertions as jsonkit always performs checks that are required for correct operation the checks performed with nscparameterassert are completely optional and are meant to be used in debug builds where extra integrity checks are usually desired while your mileage may vary the author has found that adding dns block assertions to an o2 optimization setting can generally result in an approximate 7 12 increase in performance since the very low level parsing engine works exclusively with utf8 byte streams anything that is not already encoded as utf8 must first be converted to utf8 while jsonkit provides additions to the nsstring class which allows you to conveniently convert json contained in a nsstring this convenience does come with a price jsonkit must allocate an autoreleased nsmutabledata large enough to hold the strings utf8 conversion and then convert the string to utf8 before it can begin parsing this takes both memory and time once the parsing has finished jsonkit sets the autoreleased nsmutabledata length to 0 which allows the nsmutabledata to release the memory this helps to minimize the amount of memory that is in use but unavailable until the autorelease pool pops therefore if speed and memory usage are a priority you should avoid using the nsstring convenience methods if possible if you are receiving json data from a web server and you are able to determine that the raw bytes returned by the web server is json encoded as utf8 you should use the jsondecoder method objectwithutf8string length which immediately begins parsing the pointers bytes in practice every jsonkit method that converts json to an objective c object eventually calls this method to perform the conversion if you are using one of the various ways provided by the nsurl family of classes to receive json results from a web server which typically return the results in the form of a nsdata object and you are able to determine that the raw bytes contained in the nsdata are encoded as utf8 then you should use either the jsondecoder method objectwithdata or the nsdata method objectfromjsondata if are going to be converting a lot of json the better choice is to instantiate a jsondecoder object once and use the same instantiated object to perform all your conversions this has two benefits the nsdata method objectfromjsondata creates an autoreleased jsondecoder object to perform the one time conversion by instantiating a jsondecoder object once and using the objectwithdata method repeatedly you can avoid this overhead the instantiated object cache from the previous json conversion is reused this can result in both better performance and a reduction in memory usage if the json your are converting is very similar a typical example might be if you are converting json at periodic intervals that consists of real time status updates on average the jsondata… methods are nearly four times faster than the jsonstring… methods when serializing a nsdictionary or nsarray to json the difference in speed is due entirely to the instantiation overhead of nsstring if at all possible use nsdata instead of nsstring methods when processing json this avoids the sometimes significant conversion overhead that nsstring performs in order to provide an object oriented interface for its contents for many uses using nsstring is not needed and results in wasted effort– for example using jsonkit to serialize a nsdictionary or nsarray to a nsstring this nsstring is then passed to a method that sends the json to a web server and this invariably requires converting the nsstring to nsdata before it can be sent in this case serializing the collection object directly to nsdata would avoid the unnecessary conversions to and from a nsstring object parsing interface jsondecoder interface the objectwith… methods return immutable collection objects and their respective mutableobjectwith… methods return mutable collection objects note the bytes contained in a nsdata object must be utf8 encoded important methods will raise nsinvalidargumentexception if parseoptionflags is not valid important objectwithutf8string and mutableobjectwithutf8string will raise nsinvalidargumentexception if string is null important objectwithdata and mutableobjectwithdata will raise nsinvalidargumentexception if jsondata is null objective c id decoder id decoderwithparseoptions jkparseoptionflags parseoptionflags id initwithparseoptions jkparseoptionflags parseoptionflags void clearcache id objectwithutf8string const unsigned char string length size t length id objectwithutf8string const unsigned char string length size t length error nserror error id mutableobjectwithutf8string const unsigned char string length size t length id mutableobjectwithutf8string const unsigned char string length size t length error nserror error id objectwithdata nsdata jsondata id objectwithdata nsdata jsondata error nserror error id mutableobjectwithdata nsdata jsondata id mutableobjectwithdata nsdata jsondata error nserror error nsstring interface objective c id objectfromjsonstring id objectfromjsonstringwithparseoptions jkparseoptionflags parseoptionflags id objectfromjsonstringwithparseoptions jkparseoptionflags parseoptionflags error nserror error id mutableobjectfromjsonstring id mutableobjectfromjsonstringwithparseoptions jkparseoptionflags parseoptionflags id mutableobjectfromjsonstringwithparseoptions jkparseoptionflags parseoptionflags error nserror error nsdata interface objective c id objectfromjsondata id objectfromjsondatawithparseoptions jkparseoptionflags parseoptionflags id objectfromjsondatawithparseoptions jkparseoptionflags parseoptionflags error nserror error id mutableobjectfromjsondata id mutableobjectfromjsondatawithparseoptions jkparseoptionflags parseoptionflags id mutableobjectfromjsondatawithparseoptions jkparseoptionflags parseoptionflags error nserror error jkparseoptionflags parsing optiondescription jkparseoptionnonethis is the default if no other other parse option flags are specified and the option used when a convenience method does not provide an argument for explicitly specifying the parse options to use synonymous with jkparseoptionstrict jkparseoptionstrictthe json will be parsed in strict accordance with the rfc 4627 specification jkparseoptioncommentsallow c style and … comments in json this is a fairly common extension to json but json that contains c style comments is not strictly conforming json jkparseoptionunicodenewlinesallow unicode recommended \r\n \n\v\f\r\x85\p zl \p zp newlines in json the json specification only allows the newline characters \r and \n but this option allows json that contains the unicode recommended newline characters to be parsed json that contains these additional newline characters is not strictly conforming json jkparseoptionlooseunicodenormally the decoder will stop with an error at any malformed unicode this option allows json with malformed unicode to be parsed without reporting an error any malformed unicode is replaced with \ufffd or replacement character as specified in the unicode 6 0 standard chapter 3 section 3 9 unicode encoding forms jkparseoptionpermittextaftervalidjsonnormally non white space that follows the json is interpreted as a parsing failure this option allows for any trailing non white space to be ignored and not cause a parsing error serializing interface the serializing interface includes nsstring convenience methods for those that need to serialize a single nsstring for those that need this functionality the nsstring additions are much more convenient than having to wrap a single nsstring in a nsarray which then requires stripping the unneeded … characters from the serialized json result when serializing a single nsstring you can control whether or not the serialized json result is surrounded by quotation marks using the includequotes argument example result argument a test a \ test\ includequotes yes a test a \ test\ includequotes no note the nsstring methods that do not include a includequotes argument behave as if invoked with includequotes yes note the bytes contained in the returned nsdata object are utf8 encoded nsarray and nsdictionary interface objective c nsdata jsondata nsdata jsondatawithoptions jkserializeoptionflags serializeoptions error nserror error nsstring jsonstring nsstring jsonstringwithoptions jkserializeoptionflags serializeoptions error nserror error nsstring interface objective c nsdata jsondata nsdata jsondatawithoptions jkserializeoptionflags serializeoptions includequotes bool includequotes error nserror error nsstring jsonstring nsstring jsonstringwithoptions jkserializeoptionflags serializeoptions includequotes bool includequotes error nserror error jkserializeoptionflags serializing optiondescription jkserializeoptionnonethis is the default if no other other serialize option flags are specified and the option used when a convenience method does not provide an argument for explicitly specifying the serialize options to use jkserializeoptionprettynormally the serialized json does not include any unnecessary white space while this form is the most compact the lack of any white space means that its something only another json parser could love enabling this option causes jsonkit to add additional white space that makes it easier for people to read other than the extra white space the serialized json is identical to the json that would have been produced had this option not been enabled jkserializeoptionescapeunicodewhen jsonkit encounters unicode characters in nsstring objects the default behavior is to encode those unicode characters as utf8 this option causes jsonkit to encode those characters as \uxxxx for example w∈l⟺y ∣y∣≤∣w∣ becomes w\u2208l\u27fa\u2203y \u2223y\u2223\u2264\u2223w\u2223 jkserializeoptionescapeforwardslashesaccording to the json specification the u 002f character may be backslash escaped i e \ but it is not required the default behavior of jsonkit is to not backslash escape the character unfortunately it was found some real world implementations of the asp net date format require the date to be strictly encoded as \ date \ and the only way to achieve this is through the use of jkserializeoptionescapeforwardslashes see github issue 21 for more information