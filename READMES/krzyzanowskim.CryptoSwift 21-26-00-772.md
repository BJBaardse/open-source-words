cryptoswift crypto related functions and helpers for swift implemented in swift pureswift note the master branch follows the latest currently released version of swift if you need an version for older version of swift you can specify its version in your podfile or use the code on the branch for that version older branches are unsupported check versions for details if you find the project useful please support authors to keep it alive requirements features contribution installation swift versions how to author license changelog requirements good mood features easy to use convenient extensions for string and data support for incremental updates stream ios macos appletv watchos linux support hash digest md5 sha1 sha224 sha256 sha384 sha512 sha3 cyclic redundancy check crc crc32 crc32c crc16 cipher aes 128 aes 192 aes 256 chacha20 rabbit blowfish message authenticators poly1305 hmac md5 sha1 sha256 cmac cipher mode of operation electronic codebook ecb cipher block chaining cbc propagating cipher block chaining pcbc cipher feedback cfb output feedback ofb counter mode ctr galois counter mode gcm password based key derivation function pbkdf1 password based key derivation function 1 pbkdf2 password based key derivation function 2 hkdf hmac based extract and expand key derivation function data padding pkcs 5 pkcs 7 zero padding no padding authenticated encryption with associated data aead aead chacha20 poly1305 why why because i can how do i get involved you want to help great go ahead and fork our repo make your changes and send us a pull request contribution check out contributing md for more information on how to help with cryptoswift if you found a bug open an issue if you have a feature request open an issue installation to install cryptoswift add it as a submodule to your project on the top level project directory git submodule add https github com krzyzanowskim cryptoswift git it is recommended to enable whole module optimization to gain better performance non optimized build results in significantly worse performance embedded framework embedded frameworks require a minimum deployment target of ios 8 or os x mavericks 10 9 drag the cryptoswift xcodeproj file into your xcode project and add appropriate framework as a dependency to your target now select your app and choose the general tab for the app target find embedded binaries and press then select cryptoswift framework ios os x watchos or tvos sometimes embedded framework option is not available in that case you have to add new build phase for the target ios macos watchos tvos in the project youll find single scheme for all platforms cryptoswift swift versions support swift 1 2 branch swift12 version 0 0 13 swift 2 1 branch swift21 version 0 2 3 swift 2 2 2 3 branch swift2 version 0 5 2 swift 3 1 branch swift3 version 0 6 9 swift 3 2 branch swift32 version 0 7 0 swift 4 0 branch swift4 version 0 7 1 swift 4 1 branch master version 0 9 0 cocoapods you can use cocoapods ruby platform ios 8 0 use frameworks target myapp do pod cryptoswift end or for newest version from specified branch of code ruby pod cryptoswift git https github com krzyzanowskim cryptoswift branch master bear in mind that cocoapods will build cryptoswift without whole module optimization that may impact performance you can change it manually after installation or use cocoapods wholemodule plugin carthage you can use carthage specify in cartfile ruby github krzyzanowskim cryptoswift run carthage to build the framework and drag the built cryptoswift framework into your xcode project follow build instructions common issues swift package manager you can use swift package manager and specify dependency in package swift by adding this swift dependencies package url https github com krzyzanowskim cryptoswift git uptonextminor from 0 9 0 or more strict swift dependencies package url https github com krzyzanowskim cryptoswift git exact 0 9 0 see package swift manual how to basics data types conversion digest md5 sha message authenticators hmac cmac password based key derivation function pbkdf2 hmac based key derivation function hkdf data padding chacha20 rabbit blowfish aes advanced encryption standard aes gcm authenticated encryption with associated data aead also check playground basics swift import cryptoswift cryptoswift uses array of bytes aka array uint8 as a base type for all operations every data may be converted to a stream of bytes you will find convenience functions that accept string or data and it will be internally converted to the array of bytes data types conversion for you convenience cryptoswift provides two functions to easily convert array of bytes to data and another way around data from bytes swift let data data bytes 0x01 0x02 0x03 data to array uint8 swift let bytes data bytes 1 2 3 hexadecimal encoding swift let bytes array uint8 hex 0x010203 1 2 3 let hex bytes tohexstring 010203 build bytes out of string swift let bytes array uint8 cipherkey bytes array cipherkey utf8 also check out helpers that work with base64 encoded data swift apf i9th9ix vf49er7pyk2q7s5xmm3jkrlejgzhnjs decryptbase64tostring cipher apf i9th9ix vf49er7pyk2q7s5xmm3jkrlejgzhnjs decryptbase64 cipher bytes tobase64 calculate digest hashing a data or array of bytes aka array uint8 swift hash struct usage let bytes array uint8 0x01 0x02 0x03 let digest input md5 let digest digest md5 bytes swift let data data bytes 0x01 0x02 0x03 let hash data md5 let hash data sha1 let hash data sha224 let hash data sha256 let hash data sha384 let hash data sha512 swift do var digest md5 let partial1 try digest update withbytes 0x31 0x32 let partial2 try digest update withbytes 0x33 let result try digest finish catch hashing a string and printing result swift let hash 123 md5 123 bytes md5 calculate crc swift bytes crc16 data crc16 bytes crc32 data crc32 message authenticators swift calculate message authentication code mac for message let key array 1 2 3 4 5 6 7 8 9 10 try poly1305 key key authenticate bytes try hmac key key variant sha256 authenticate bytes try cmac key key authenticate bytes password based key derivation functions swift let password array array s33krit utf8 let salt array array nacllcan utf8 let key try pkcs5 pbkdf2 password password salt salt iterations 4096 variant sha256 calculate hmac based key derivation function swift let password array array s33krit utf8 let salt array array nacllcan utf8 let key try hkdf password password salt salt variant sha256 calculate data padding some content encryption algorithms assume the input length is a multiple of k octets where k is greater than one for such algorithms the input shall be padded swift padding pkcs7 add to bytes blocksize aes blocksize working with ciphers chacha20 swift let encrypted try chacha20 key key iv iv encrypt message let decrypted try chacha20 key key iv iv decrypt encrypted rabbit swift let encrypted try rabbit key key iv iv encrypt message let decrypted try rabbit key key iv iv decrypt encrypted blowfish swift let encrypted try blowfish key key blockmode cbc iv iv padding pkcs7 encrypt message let decrypted try blowfish key key blockmode cbc iv iv padding pkcs7 decrypt encrypted aes notice regarding padding manual padding of data is optional and cryptoswift is using pkcs7 padding by default if you need manually disable enable padding you can do this by setting parameter for aes class variant of aes encryption aes 128 aes 192 aes 256 depends on given key length aes 128 16 bytes aes 192 24 bytes aes 256 32 bytes aes 256 example swift try aes key 1 2 3 32 blockmode cbc iv 1 2 3 16 padding pkcs7 all at once swift do let aes try aes key keykeykeykeykeyk iv drowssapdrowssap aes128 let ciphertext try aes encrypt array nullam quis risus eget urna mollis ornare vel eu leo utf8 catch incremental updates incremental operations use instance of cryptor and encrypt decrypt one part at a time this way you can save on memory for large files swift do var encryptor try aes key keykeykeykeykeyk iv drowssapdrowssap makeencryptor var ciphertext array uint8 aggregate partial results ciphertext try encryptor update withbytes array nullam quis risus utf8 ciphertext try encryptor update withbytes array eget urna mollis utf8 ciphertext try encryptor update withbytes array ornare vel eu leo utf8 finish at the end ciphertext try encryptor finish print ciphertext tohexstring catch print error see playground for sample code that work with stream aes advanced usage swift let input array 0 1 2 3 4 5 6 7 8 9 let key array 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 let iv array aes randomiv aes blocksize do let encrypted try aes key key blockmode cbc iv iv padding pkcs7 encrypt input let decrypted try aes key key blockmode cbc iv iv padding pkcs7 decrypt encrypted catch print error aes without data padding swift let input array uint8 0 1 2 3 4 5 6 7 8 9 let encrypted array uint8 try aes key array secret0key000000 utf8 blockmode cbc iv array 0123456789012345 utf8 padding nopadding encrypt input using convenience extensions swift let plain data bytes 0x01 0x02 0x03 let encrypted try plain encrypt chacha20 key key iv iv let decrypted try encrypted decrypt chacha20 key key iv iv aes gcm the result of galois counter mode gcm encryption is ciphertext and authentication tag that is later used to decryption encryption swift do in combined mode the authentication tag is directly appended to the encrypted message this is usually what you want let gcm gcm iv iv mode combined let aes try aes key key blockmode gcm padding nopadding let encrypted try aes encrypt plaintext let tag gcm authenticationtag catch failed decryption swift do in combined mode the authentication tag is directly appended to the encrypted message this is usually what you want let gcm gcm iv iv mode combined let aes try aes key key blockmode gcm padding nopadding return try aes decrypt encrypted catch failed note gcm instance is not intended to be reused so you cant use the gcm from encoding do decoding aead swift let encrypt try aeadchacha20poly1305 encrypt plaintext key key iv nonce authenticationheader header let decrypt try aeadchacha20poly1305 decrypt ciphertext key key iv nonce authenticationheader header authenticationtag tagarr tag author cryptoswift is owned and maintained by marcin krzyżanowski you can follow me on twitter at krzyzanowskim for project updates and releases license copyright c 2014 2017 marcin krzyżanowski marcin krzyzanowskim com this software is provided as is without any express or implied warranty in no event will the authors be held liable for any damages arising from the use of this software permission is granted to anyone to use this software for any purpose including commercial applications and to alter it and redistribute it freely subject to the following restrictions the origin of this software must not be misrepresented you must not claim that you wrote the original software if you use this software in a product an acknowledgment in the product documentation is required altered source versions must be plainly marked as such and must not be misrepresented as being the original software this notice may not be removed or altered from any source or binary distribution redistributions of any form whatsoever must retain the following acknowledgment this product includes software developed by the marcin krzyzanowski http krzyzanowskim com changelog see changelog file