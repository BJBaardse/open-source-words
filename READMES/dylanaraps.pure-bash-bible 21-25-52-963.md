pure bash bible a collection of pure bash alternatives to external processes the goal of this book is to document known and unknown methods of doing various tasks using only built in bash features using the snippets from this bible can help remove unneeded dependencies from scripts and in most cases make them faster i came across these tips and discovered a few while developing neofetch pxltrm and other smaller projects the snippets below are linted using shellcheck and tests have been written where applicable want to contribute read the contributing md it outlines how the unit tests work and what is required when adding snippets to the bible see something incorrectly described buggy or outright wrong open an issue or send a pull request if the bible is missing something open an issue and a solution will be found this book is also available to purchase on leanpub https leanpub com bash or you can buy me a coffee table of contents vim markdown toc gfm foreword strings trim leading and trailing white space from string trim all white space from string and truncate spaces use regex on a string split a string on a delimiter change a string to lowercase change a string to uppercase trim quotes from a string strip all instances of pattern from string strip first occurrence of pattern from string strip pattern from start of string strip pattern from end of string check if string contains a sub string check if string starts with sub string check if string ends with sub string arrays reverse an array remove duplicate array elements random array element cycle through an array toggle between two values loops loop over a range of numbers loop over a variable range of numbers loop over an array loop over an array with an index loop over the contents of a file loop over files and directories file handling read a file to a string read a file to an array by line get the first n lines of a file get the last n lines of a file get the number of lines in a file count files or directories in directory create an empty file extract lines between two markers file paths get the directory name of a file path get the base name of a file path variables assign and access a variable using a variable escape sequences text colors text attributes cursor movement erasing text parameter expansion indirection replacement length expansion case modification default value brace expansion ranges string lists conditional expressions file conditionals file comparisons variable conditionals variable comparisons arithmetic operators assignment arithmetic bitwise logical miscellaneous arithmetic simpler syntax to set variables ternary tests traps do something on script exit ignore terminal interrupt ctrl c sigint react to window resize do something before every command do something when a shell function or a sourced file finishes executing performance disable unicode obsolete syntax shebang command substitution function declaration internal variables get the location to the bash binary get the version of the current running bash process open the users preferred text editor get the name of the current function get the host name of the system get the architecture of the operating system get the name of the operating system kernel get the current working directory get the number of seconds the script has been running get a pseudorandom integer information about the terminal get the terminal size in lines and columns from a script get the terminal size in pixels get the current cursor position conversion convert a hex color to rgb convert an rgb color to hex code golf shorter for loop syntax shorter infinite loops shorter function declaration shorter if syntax simpler case statement to set variable other use read as an alternative to the sleep command check if a program is in the users path get the current date using strftime generate a uuid v4 progress bars get the list of functions in a script bypass shell aliases bypass shell functions run a command in the background afterword vim markdown toc chapter start foreword a collection of pure bash alternatives to external processes and programs the bash scripting language is more powerful than people realise and most tasks can be accomplished without depending on external programs calling an external process in bash is expensive and excessive use will cause a noticeable slowdown scripts and programs written using built in methods where applicable will be faster require less dependencies and afford a better understanding of the language itself the contents of this book provide a reference for solving problems encountered when writing programs and scripts in bash examples are in function formats showcasing how to incorporate these solutions into code chapter end chapter start strings trim leading and trailing white space from string this is an alternative to sed awk perl and other tools the function below works by finding all leading and trailing white space and removing it from the start and end of the string the built in is used in place of a temporary variable example function sh trim string usage trim string example string 1 1 space space printf s\n example usage shell trim string hello world hello world name john black trim string name john black trim all white space from string and truncate spaces this is an alternative to sed awk perl and other tools the function below works by abusing word splitting to create a new string without leading trailing white space and with truncated spaces example function sh shellcheck disable sc2086 sc2048 trim all usage trim all example string set f set printf s\n set f example usage shell trim all hello world hello world name john black is my name trim all name john black is my name use regex on a string the result of bashs regex matching can be used to replace sed for a large number of use cases caveat this is one of the few platform dependant bash features bash will use whatever regex engine is installed on the users system stick to posix regex features if aiming for compatibility caveat this example only prints the first matching group when using multiple capture groups some modification is needed example function sh regex usage regex string regex 1 2 printf s\n bash rematch 1 example usage shell trim leading white space regex hello \s hello validate a hex color regex ffffff a fa f0 9 6 a fa f0 9 3 ffffff validate a hex color invalid regex red a fa f0 9 6 a fa f0 9 3 no output invalid example usage in script shell is hex color if 1 a fa f0 9 6 a fa f0 9 3 then printf s\n bash rematch 1 else printf s\n error 1 is an invalid color return 1 fi read r color is hex color color color ffffff do stuff split a string on a delimiter this is an alternative to cut awk and other tools example function sh split usage split string delimiter ifs \n read d ra arr 1 2 \n printf s\n arr example usage shell split apples oranges pears grapes apples oranges pears grapes split 1 2 3 4 5 1 2 3 4 5 multi char delimiters work too split hello world my name is john hello world my name is john change a string to lowercase caveat requires bash 4 example function sh lower usage lower string printf s\n 1 example usage shell lower hello hello lower hello hello lower hello hello change a string to uppercase caveat requires bash 4 example function sh upper usage upper string printf s\n 1 example usage shell upper hello hello upper hello hello upper hello hello trim quotes from a string example function sh trim quotes usage trim quotes string 1 \ printf s\n \ example usage shell var hello \ world\ trim quotes var hello world strip all instances of pattern from string example function sh strip all usage strip all string pattern printf s\n 1 2 example usage shell strip all the quick brown fox aeiou th qck brwn fx strip all the quick brown fox space thequickbrownfox strip all the quick brown fox quick the brown fox strip first occurrence of pattern from string example function sh strip usage strip string pattern printf s\n 1 2 example usage shell strip the quick brown fox aeiou th quick brown fox strip the quick brown fox space thequick brown fox strip pattern from start of string example function sh lstrip usage lstrip string pattern printf s\n 1 2 example usage shell lstrip the quick brown fox the quick brown fox strip pattern from end of string example function sh rstrip usage rstrip string pattern printf s\n 1 2 example usage shell rstrip the quick brown fox fox the quick brown check if string contains a sub string using a test shell if var sub string then printf s\n sub string is in var fi inverse substring not in string if var sub string then printf s\n sub string is not in var fi this works for arrays too if arr sub string then printf s\n sub string is in array fi using a case statement shell case var in sub string do stuff sub string2 do more stuff else esac check if string starts with sub string shell if var sub string then printf s\n var starts with sub string fi inverse var does not start with sub string if var sub string then printf s\n var does not start with sub string fi check if string ends with sub string shell if var sub string then printf s\n var ends with sub string fi inverse var does not end with sub string if var sub string then printf s\n var does not end with sub string fi chapter end chapter start arrays reverse an array enabling extdebug allows access to the bash argv array which stores the current functions arguments in reverse example function sh reverse array usage reverse array array shopt s extdebug f printf s\n bash argv f shopt u extdebug example usage shell reverse array 1 2 3 4 5 5 4 3 2 1 arr red blue green reverse array arr green blue red remove duplicate array elements create a temporary associative array when setting associative array values and a duplicate assignment occurs bash overwrites the key this allows us to effectively remove array duplicates caveat requires bash 4 example function sh remove array dups usage remove array dups array declare a tmp array for i in do i ifs tmp array i 1 done printf s\n tmp array example usage shell remove array dups 1 1 2 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 5 5 1 2 3 4 5 arr red red green blue blue remove array dups arr red green blue random array element example function sh random array element usage random array element array local arr printf s\n arr random example usage shell array red green blue yellow brown random array element array yellow multiple arguments can also be passed random array element 1 2 3 4 5 6 7 3 cycle through an array each time the printf is called the next array element is printed when the print hits the last array element it starts from the first element again sh arr a b c d cycle printf s arr i 0 i i arr 1 0 i toggle between two values this works the same as above this is just a different use case sh arr true false cycle printf s arr i 0 i i arr 1 0 i chapter end chapter start loops loop over a range of numbers alternative to seq shell loop from 0 100 no variable support for i in 0 100 do printf s\n i done loop over a variable range of numbers alternative to seq shell loop from 0 var var 50 for i 0 i var i do printf s\n i done loop over an array shell arr apples oranges tomatoes just elements for element in arr do printf s\n element done loop over an array with an index shell arr apples oranges tomatoes elements and index for i in arr do printf s\n arr i done alternative method for i 0 i arr i do printf s\n arr i done loop over the contents of a file shell while read r line do printf s\n line done file loop over files and directories dont use ls shell greedy example for file in do printf s\n file done png files in dir for file in pictures png do printf s\n file done iterate over directories for dir in downloads do printf s\n dir done brace expansion for file in path to parentdir file1 file2 subdir file3 do printf s\n file done iterate recursively shopt s globstar for file in pictures do printf s\n file done shopt u globstar chapter end chapter start file handling caveat bash does not handle binary data properly in versions 4 4 read a file to a string alternative to the cat command shell file data file read a file to an array by line alternative to the cat command shell bash 4 ifs \n read d ra file data file bash 4 mapfile t file data file get the first n lines of a file alternative to the head command caveat requires bash 4 example function sh head usage head n file mapfile tn 1 line 2 printf s\n line example usage shell head 2 bashrc prompt ps1 ➜ head 1 bashrc prompt get the last n lines of a file alternative to the tail command caveat requires bash 4 example function sh tail usage tail n file mapfile tn 0 line 2 printf s\n line 1 example usage shell tail 2 bashrc enable tmux z tmux exec tmux tail 1 bashrc z tmux exec tmux get the number of lines in a file alternative to wc l example function bash 4 sh lines usage lines file mapfile tn 0 lines 1 printf s\n lines example function bash 3 this method uses less memory than the mapfile method and works in bash 3 but it is slower for bigger files sh lines loop usage lines loop file count 0 while ifs read r do count done 1 printf s\n count example usage shell lines bashrc 48 lines loop bashrc 48 count files or directories in directory this works by passing the output of the glob to the function and then counting the number of arguments example function sh count usage count path to dir count path to dir printf s\n example usage shell count all files in dir count downloads 232 count all dirs in dir count downloads 45 count all jpg files in dir count pictures jpg 64 create an empty file alternative to touch shell shortest file longer alternatives file echo n file printf file extract lines between two markers example function sh extract usage extract file opening marker closing marker while ifs \n read r line do extract line 3 \ printf s\n line line 2 extract 1 line 3 extract done 1 example usage shell extract code blocks from markdown file extract projects pure bash readme md sh output here chapter end chapter start file paths get the directory name of a file path alternative to the dirname command example function sh dirname usage dirname path printf s\n 1 example usage shell dirname pictures wallpapers 1 jpg home black pictures wallpapers dirname pictures downloads home black pictures get the base name of a file path alternative to the basename command example function sh basename usage basename path 1 printf s\n example usage shell basename pictures wallpapers 1 jpg 1 jpg basename pictures downloads downloads chapter end chapter start variables assign and access a variable using a variable shell hello world test create the variable name var1 world var2 hello var1 print the value of the variable name stored in hello var1 printf s\n var2 chapter end chapter start escape sequences contrary to popular belief there is no issue in utilizing raw escape sequences using tput abstracts the same ansi sequences as if printed manually worse still tput is not actually portable there are a number of tput variants each with different commands and syntaxes try tput setaf 3 on a freebsd system raw sequences are fine text colors note sequences requiring rgb values only work in true color terminal emulators sequence what does it do value \e 38 5 num m set text foreground color 0 255 \e 48 5 num m set text background color 0 255 \e 38 2 r g b m set text foreground color to rgb color r g b \e 48 2 r g b m set text background color to rgb color r g b text attributes sequence what does it do \e m reset text formatting and colors \e 1m bold text \e 2m faint text \e 3m italic text \e 4m underline text \e 5m slow blink \e 7m swap foreground and background colors cursor movement sequence what does it do value \e line column h move cursor to absolute position line column \e h move cursor to home position 0 0 \e num a move cursor up n lines num \e num b move cursor down n lines num \e num c move cursor right n columns num \e num d move cursor left n columns num \e s save cursor position \e u restore cursor position erasing text sequence what does it do \e k erase from cursor position to end of line \e 1k erase from cursor position to start of line \e 2k erase the entire current line \e j erase from the current line to the bottom of the screen \e 1j erase from the current line to the top of the screen \e 2j clear the screen \e 2j\e h clear the screen and move cursor to 0 0 chapter end chapter start parameter expansion indirection parameter what does it do var access a variable based on the value of var var expand to ifs separated list of variable names starting with var var expand to ifs separated list of variable names starting with var replacement parameter what does it do var pattern remove shortest match of pattern from start of string var pattern remove longest match of pattern from start of string var pattern remove shortest match of pattern from end of string var pattern remove longest match of pattern from end of string var pattern replace replace first match with string var pattern replace replace all matches with string var pattern remove first match var pattern remove all matches length parameter what does it do var length of var in characters arr length of array in elements expansion parameter what does it do var offset remove first n chars from variable var offset length get substring from n character to n character var 10 10 get sub string from char 10 to char 20 var offset get first n chars from variable var offset remove last n chars from variable var offset get last n chars from variable var offset offset cut first n chars and last n chars bash 4 2 case modification parameter what does it do caveat var uppercase first character bash 4 var uppercase all characters bash 4 var lowercase first character bash 4 var lowercase all characters bash 4 default value parameter what does it do var string if var is empty or unset use string as its value var string if var is unset use string as its value var string if var is empty or unset set the value of var to string var string if var is unset set the value of var to string var string if var is not empty use string as its value var string if var is set use string as its value var string display an error if empty or unset var string display an error if unset chapter end chapter start brace expansion ranges shell syntax print numbers 1 100 echo 1 100 print range of floats echo 1 1 9 print chars a z echo a z echo a z nesting echo a z 0 9 print zero padded numbers caveat bash 4 echo 01 100 change increment amount syntax caveat bash 4 echo 1 10 2 increment by 2 string lists shell echo apples oranges pears grapes example usage remove dirs movies music and isos from downloads rm rf downloads movies music isos chapter end chapter start conditional expressions file conditionals expression value what does it do a file if file exists b file if file exists and is a block special file c file if file exists and is a character special file d file if file exists and is a directory e file if file exists f file if file exists and is a regular file g file if file exists and its set group id bit is set h file if file exists and is a symbolic link k file if file exists and its sticky bit is set p file if file exists and is a named pipe fifo r file if file exists and is readable s file if file exists and its size is greater than zero t fd if file descriptor is open and refers to a terminal u file if file exists and its set user id bit is set w file if file exists and is writable x file if file exists and is executable g file if file exists and is owned by the effective group id l file if file exists and is a symbolic link n file if file exists and has been modified since last read o file if file exists and is owned by the effective user id s file if file exists and is a socket file comparisons expression what does it do file ef file2 if both files refer to the same inode and device numbers file nt file2 if file is newer than file2 uses modification time or file exists and file2 does not file ot file2 if file is older than file2 uses modification time or file2 exists and file does not variable conditionals expression value what does it do o opt if shell option is enabled v var if variable has a value assigned r var if variable is a name reference z var if the length of string is zero n var if the length of string is non zero variable comparisons expression what does it do var var2 equal to var var2 equal to synonym for var var2 not equal to var var2 less than in ascii alphabetical order var var2 greater than in ascii alphabetical order chapter end chapter start arithmetic operators assignment operators what does it do initialize or change the value of a variable arithmetic operators what does it do addition subtraction multiplication division exponentiation modulo plus equal increment a variable minus equal decrement a variable times equal multiply a variable slash equal divide a variable mod equal remainder of dividing a variable bitwise operators what does it do bitwise left shift left shift equal bitwise right shift right shift equal bitwise and bitwise and equal \ bitwise or \ bitwise or equal bitwise not bitwise xor bitwise xor equal logical operators what does it do not and \ \ or miscellaneous operators what does it do example comma separator a 1 b 2 c 3 chapter end chapter start arithmetic simpler syntax to set variables shell simple math var 1 2 decrement increment variable var var var 1 var 1 using variables var var2 arr 2 ternary tests shell set the value of var to var2 if var2 is greater than var var variable to set var2 var condition to test var2 if the test succeeds var if the test fails var var2 var var2 var chapter end chapter start traps traps allow a script to execute code on various signals in pxltrm a pixel art editor written in bash traps are used to redraw the user interface on window resize another use case is cleaning up temporary files on script exit traps should be added near the start of scripts so any early errors are also caught note for a full list of signals see trap l do something on script exit shell clear screen on script exit trap printf \e 2j\e h\e m exit ignore terminal interrupt ctrl c sigint shell trap int react to window resize shell call a function on window resize trap code here sigwinch do something before every command shell trap code here debug do something when a shell function or a sourced file finishes executing shell trap code here return chapter end chapter start performance disable unicode if unicode is not required it can be disabled for a performance increase results may vary however there have been noticeable improvements in neofetch and other programs shell disable unicode lc all c lang c chapter end chapter start obsolete syntax shebang use usr bin env bash instead of bin bash the former searches the users path to find the bash binary the latter assumes it is always installed to bin which can cause issues shell right usr bin env bash wrong bin bash command substitution use instead of shell right var command wrong var command can easily be nested whereas cannot var command command function declaration do not use the function keyword it reduces compatibility with older versions of bash shell right do something wrong function do something chapter end chapter start internal variables get the location to the bash binary shell bash get the version of the current running bash process shell as a string bash version as an array bash versinfo open the users preferred text editor shell editor file note this variable may be empty set a fallback value editor vi file get the name of the current function shell current function funcname 0 parent function funcname 1 so on and so forth funcname 2 funcname 3 all functions including parents funcname get the host name of the system shell hostname note this variable may be empty optionally set a fallback to the hostname command hostname hostname get the architecture of the operating system shell hosttype get the name of the operating system kernel this can be used to add conditional support for different operating systems without needing to call uname shell ostype get the current working directory this is an alternative to the pwd built in shell pwd get the number of seconds the script has been running shell seconds get a pseudorandom integer each time random is used a different integer between 0 and 32767 is returned this variable should not be used for anything related to security this includes encryption keys etc shell random chapter end chapter start information about the terminal get the terminal size in lines and columns from a script this is handy when writing scripts in pure bash and stty tput cant be called example function sh get term size usage get term size is a micro sleep to ensure the variables are exported immediately shopt s checkwinsize printf s\n lines columns example usage shell output lines columns get term size 15 55 get the terminal size in pixels caveat this does not work in some terminal emulators example function sh get window size usage get window size printf b tmux \\eptmux \\e \\e 14t tmux \\e\\\\ ifs t read d t t 0 05 sra term size printf s\n term size 1 x term size 2 example usage shell output widthxheight get window size 1200x800 output fail get window size x get the current cursor position this is useful when creating a tui in pure bash example function sh get cursor pos usage get cursor pos ifs read p \e 6n d r rs y x printf s\n x y example usage shell output x y get cursor pos 1 8 chapter end chapter start conversion convert a hex color to rgb example function sh hex to rgb usage hex to rgb ffffff hex to rgb 000000 1 \ r 16 0 2 g 16 2 2 b 16 4 2 printf s\n r g b example usage shell hex to rgb ffffff 255 255 255 convert an rgb color to hex example function sh rgb to hex usage rgb to hex r g b printf 02x 02x 02x\n 1 2 3 example usage shell rgb to hex 255 255 255 ffffff code golf shorter for loop syntax shell tiny c style for i 10 echo i undocumented method for i in 1 10 echo i expansion for i in 1 10 do echo i done c style for i 0 i 10 i do echo i done shorter infinite loops shell normal method while do echo hi done shorter for echo hi shorter function declaration shell normal method f echo hi using a subshell f echo hi using arithmetic this can be used to assign integer values example f a 1 f a f 1 using tests loops etc note ‘while ‘until ‘case ‘ ‘ can also be used f if true then echo 1 fi f for i in do echo i done shorter if syntax shell one line note the 3rd statement may run when the 1st is true var hello echo hi echo bye var hello echo hi echo there echo bye multi line no else single statement note the exit status may not be the same as with an if statement var hello \ echo hi multi line no else var hello echo hi simpler case statement to set variable the built in can be used to avoid repeating variable in a case statement the variable stores the last argument of the last command always succeeds so it can be used to store the variable value shell modified snippet from neofetch case ostype in darwin macos linux linux bsd dragonfly bitrig bsd cygwin msys win32 windows printf s\n unknown os detected aborting 2 exit 1 esac finally set the variable os chapter end chapter start other use read as an alternative to the sleep command surprisingly sleep is an external command and not a bash built in caveat requires bash 4 example function sh read sleep usage sleep 1 sleep 0 2 read rst 1 1 n 999 example usage shell read sleep 1 read sleep 0 1 read sleep 30 check if a program is in the users path shell there are 3 ways to do this and either one can be used type p executable name dev null hash executable name dev null command v executable name dev null as a test if type p executable name dev null then program is in path fi inverse if type p executable name dev null then program is not in path fi example exit early if program is not installed if type p convert dev null then printf s\n error convert is not installed exiting exit 1 fi get the current date using strftime bashs printf has a built in method of getting the date which can be used in place of the date command caveat requires bash 4 example function sh date usage date format see man strftime for format printf 1 t\\n 1 example usage shell using above function date a d b l m p fri 15 jun 10 00 am using printf directly printf a d b l m p t\n 1 fri 15 jun 10 00 am assigning a variable using printf printf v date a d b l m p t\n 1 printf s\n date fri 15 jun 10 00 am generate a uuid v4 example function sh uuid usage uuid c 89ab for n 0 n 16 n do b random 256 case n in 6 printf 4 x b 16 8 printf c x c random c 1 b 16 3 5 7 9 printf 02x b printf 02x b esac done printf \n example usage shell uuid d5b6c731 1310 4c24 9fe3 55d556d44374 progress bars this is a simple way of drawing progress bars without needing a for loop in the function itself example function sh bar usage bar 1 10 elapsed percentage 0 100 total length in chars elapsed 1 2 100 create the bar with spaces printf v prog elapsed s printf v total 2 elapsed s printf s\r prog total example usage shell for i 0 i 100 i do pure bash micro sleeps for the example print the bar bar i 10 done printf \n get the list of functions in a script sh get functions usage get functions ifs \n read d ra functions declare f printf s\n functions declare f bypass shell aliases shell alias ls command shellcheck disable sc1001 \ls bypass shell functions shell function ls command command ls run a command in the background this will run the given command and keep it running even after the terminal or ssh connection is terminated all output is ignored sh bkr nohup dev null bkr some script sh some script sh is now running in the background chapter end afterword thanks for reading if this bible helped you in any way and youd like to give back consider donating donations give me the time to make this the best resource possible cant donate thats ok star the repo and share it with your friends rock on 🤘