best practices in android development avoid reinventing the wheel by following these guidelines lessons learned from android developers in futurice if you are interested in ios or windows phone development be sure to check also our ios good practices and windows app development best practices documents summary use gradle and its default project structure put passwords and sensitive data in gradle properties use the jackson library to parse json data dont write your own http client use okhttp libraries avoid guava and use only a few libraries due to the 65k method limit sail carefully when choosing between activities and fragments layout xmls are code organize them well use styles to avoid duplicate attributes in layout xmls use multiple style files to avoid a single huge one keep your colors xml short and dry just define the palette also keep dimens xml dry define generic constants do not make a deep hierarchy of viewgroups avoid client side processing for webviews and beware of leaks use junit for unit tests espresso for connected ui tests and assertj android for easier assertions in your android tests always use proguard or dexguard use sharedpreferences for simple persistence otherwise contentproviders use stetho to debug your application use leak canary to find memory leaks use continuous integration android sdk place your android sdk somewhere in your home directory or some other application independent location some distributions of ides include the sdk when installed and may place it under the same directory as the ide this can be bad when you need to upgrade or reinstall the ide as you may lose your sdk installation forcing a long and tedious redownload also avoid putting the sdk in a system level directory that might need root permissions to avoid permissions issues build system your default option should be gradle using the android gradle plugin it is important that your applications build process is defined by your gradle files rather than being reliant on ide specific configurations this allows for consistent builds between tools and better support for continuous integration systems project structure although gradle offers a large degree of flexibility in your project structure unless you have a compelling reason to do otherwise you should accept its default structure as this simplify your build scripts gradle configuration general structure follow googles guide on gradle for android minsdkversion 21 we recommend to have a look at the android version usage chart before defining the minimum api required remember that the statistics given are global statistics and may differ when targeting a specific regional demographic market it is worth mentioning that some material design features are only available on android 5 0 api level 21 and above and also from api 21 the multidex support library is not needed anymore small tasks instead of shell python perl etc scripts you can make tasks in gradle just follow gradles documentation for more details google also provides some helpful gradle recipes specific to android passwords in your apps build gradle you will need to define the signingconfigs for the release build here is what you should avoid dont do this this would appear in the version control system groovy signingconfigs release dont do this storefile file myapp keystore storepassword password123 keyalias thekey keypassword password789 instead make a gradle properties file which should not be added to the version control system keystore password password123 key password password789 that file is automatically imported by gradle so you can use it in build gradle as such groovy signingconfigs release try storefile file myapp keystore storepassword keystore password keyalias thekey keypassword key password catch ex throw new invaliduserdataexception you should define keystore password and key password in gradle properties prefer maven dependency resolution to importing jar files if you explicitly include jar files in your project they will be a specific frozen version such as 2 1 1 downloading jars and handling updates is cumbersome and is a problem that maven already solves properly where possible you should attempt to use maven to resolve your dependencies for example groovy dependencies compile com squareup okhttp okhttp3 3 8 0 avoid maven dynamic dependency resolution avoid the use of dynamic dependency versions such as 2 1 as this may result in different and unstable builds or subtle untracked differences in behavior between builds the use of static versions such as 2 1 1 helps create a more stable predictable and repeatable development environment use different package name for non release builds use applicationidsuffix for debug build type to be able to install both debug and release apk on the same device do this also for custom build types if you need any this will be especially valuable after your app has been published groovy android buildtypes debug applicationidsuffix debug versionnamesuffix debug release use different icons to distinguish the builds installed on a deviceâ€”for example with different colors or an overlaid debug label gradle makes this very easy with default project structure simply put debug icon in app src debug res and release icon in app src release res you could also change app name per build type as well as versionname as in the above example share debug app keystore file sharing the debug apk keystore file via the app repository saves time when testing on shared devices and avoids the uninstalling reinstalling of the app it also simplifies the processing of working with some android sdks such as facebook which require the registration of a single key store hash unlike the release key file the debug key file can safely be added to your repository share code style formatting defintions sharing the code style and formatting definitions via the app repository helps ensure a visually consistent code base and makes code comprehension and reviews easier android studio as your main ide the recommended ide for android development is android studio because it is developed and constantly updated by google has good support for gradle contains a range of useful monitoring and analysis tools and is fully tailored for android development avoid adding android studios specific configuration files such as iml files to the version control system as these often contain configurations specific of your local machine which wont work for your colleagues libraries jackson is a java library for json serialization and deserialization it has a wide scoped and versatile api supporting various ways of processing json streaming in memory tree model and traditional json pojo data binding gson is another popular choice and being a smaller library than jackson you might prefer it to avoid 65k methods limitation also if you are using moshi another of squares open source libraries builds upon learnings from the development of gson and also integrates well with kotlin networking caching and images there are a couple of battle proven solutions for performing requests to backend servers which you should use rather than implementing your own client we recommend basing your stack around okhttp for efficient http requests and using retrofit to provide a typesafe layer if you choose retrofit consider picasso for loading and caching images retrofit picasso and okhttp are created by the same company so they complement each other nicely and compatability issues are uncommon glide is another option for loading and caching images it has support for animated gifs circular images and claims of better performance than picasso but also a bigger method count rxjava is a library for reactive programming in other words handling asynchronous events it is a powerful paradigm but it also has a steep learning curve we recommend taking some caution before using this library to architect the entire application we have written some blog posts on it 1 2 3 4 for a reference app our open source app freesound android makes extensive use of rxjava 2 if you have no previous experience with rx start by applying it only for responses from apps backend apis alternatively start by applying it for simple ui event handling like click events or typing events on a search field if you are confident in your rx skills and want to apply it to the whole architecture then write documentation on all the tricky parts keep in mind that another programmer unfamiliar to rxjava might have a very hard time maintaining the project do your best to help them understand your code and also rx use rxandroid for android threading support and rxbinding to easily create observables from existing android components retrolambda is a java library for using lambda expression syntax in android and other pre jdk8 platforms it helps keep your code tight and readable especially if you use a functional style such as in rxjava android studio offers code assist support for java 8 lambdas if you are new to lambdas just use the following to get started any interface with just one method is lambda friendly and can be folded into the more tight syntax if in doubt about parameters and such write a normal anonymous inner class and then let android studio fold it into a lambda for you note that from android studio 3 0 retrolambda is no longer required beware of the dex method limitation and avoid using many libraries android apps when packaged as a dex file have a hard limitation of 65536 referenced methods 1 2 3 you will see a fatal error on compilation if you pass the limit for that reason use a minimal amount of libraries and use the dex method counts tool to determine which set of libraries can be used in order to stay under the limit especially avoid using the guava library since it contains over 13k methods activities and fragments there is no consensus among the community nor futurice developers how to best organize android architectures with fragments and activities square even has a library for building architectures mostly with views bypassing the need for fragments but this still is not considered a widely recommendable practice in the community because of android apis history you can loosely consider fragments as ui pieces of a screen in other words fragments are normally related to ui activities can be loosely considered to be controllers they are especially important for their lifecycle and for managing state however you are likely to see variation in these roles activities might take ui roles delivering transitions between screens and fragments might be used solely as controllers we suggest you sail carefully making informed decisions since there are drawbacks for choosing a fragments only architecture or activities only or views only here is some advice on what to be careful with but take them with a grain of salt avoid using nested fragments extensively because matryoshka bugs can occur use nested fragments only when it makes sense for instance fragments in a horizontally sliding viewpager inside a screen like fragment or if its a well informed decision avoid putting too much code in activities whenever possible keep them as lightweight containers existing in your application primarily for the lifecycle and other important android interfacing apis prefer single fragment activities instead of plain activities put ui code into the activitys fragment this makes it reusable in case you need to change it to reside in a tabbed layout or in a multi fragment tablet screen avoid having an activity without a corresponding fragment unless you are making an informed decision java packages structure we recommend using a feature based package structure for your code this has the following benefits clearer feature dependency and interface boundaries promotes encapsulation easier to understand the components that define the feature reduces risk of unknowingly modifying unrelated or shared code simpler navigation most related classes will be in the one package easier to remove a feature simplifies the transition to module based build structure better build times and instant apps support the alternative approach of defining your packages by how a feature is built by placing related activities fragments adapters etc in separate packages can lead to a fragmented code base with less implementation flexibility most importantly it hinders your ability to comprehend your code base in terms of its primary role to provide features for your app resources naming follow the convention of prefixing the type as in type foo bar xml examples fragment contact details xml view primary button xml activity main xml organizing layout xmls if youre unsure how to format a layout xml the following convention may help one attribute per line indented by 4 spaces android id as the first attribute always android layout attributes at the top style attribute at the bottom tag closer on its own line to facilitate ordering and adding attributes rather than hard coding android text consider using designtime attributes available for android studio xml xml version 1 0 encoding utf 8 textview android id id name android layout width match parent android layout height wrap content android layout alignparentright true android text string name style style fancytext include layout layout reusable part as a rule of thumb attributes android layout should be defined in the layout xml while other attributes android should stay in a style xml this rule has exceptions but in general works fine the idea is to keep only layout positioning margin sizing and content attributes in the layout files while keeping all appearance details colors padding font in styles files the exceptions are android id should obviously be in the layout files android orientation for a linearlayout normally makes more sense in layout files android text should be in layout files because it defines content sometimes it will make sense to make a generic style defining android layout width and android layout height but by default these should appear in the layout files use styles almost every project needs to properly use styles because it is very common to have a repeated appearance for a view at least you should have a common style for most text content in the application for example xml style name contenttext item name android textsize dimen font normal item item name android textcolor color basic black item style applied to textviews xml textview android layout width wrap content android layout height wrap content android text string price style style contenttext you probably will need to do the same for buttons but dont stop there yet go beyond and move a group of related and repeated android attributes to a common style split a large style file into other files you dont need to have a single styles xml file android sdk supports other files out of the box there is nothing magical about the name styles what matters are the xml tags style inside the file hence you can have files styles xml styles home xml styles item details xml styles forms xml unlike resource directory names which carry some meaning for the build system filenames in res values can be arbitrary colors xml is a color palette there should be nothing in your colors xml other than a mapping from a color name to an rgba value this helps avoid repeating rgba values and as such will make it easy to change or refactor colors and also will make it explicit how many different colors are being used normally for a aesthetic ui it is important to reduce the variety of colors being used so dont define your colors xml like this xml resources color name button foreground ffffff color color name button background 2a91bd color resources instead do this xml grayscale ffffff basic colors color name blue 2a91bd color ask the designer of the application for this palette the names do not need to be plain color names as green blue etc names such as brand primary brand secondary brand negative are totally acceptable as well by referencing the color palette from your styles allows you to abstract the underlying colors from their usage in the app as per colors xml defines only the color palette styles xml defines styles which reference the color palette and reflects the color usage e g the button foreground is white activity main xml references the appropriate style in styles xml to color the button if needed even further separation between underlying colors and style usage can be achieved by defined an additional color resource file which references the color palette as per xml color name button foreground color white color color name button background color blue color then in styles xml xml style name acceptbutton item name android foreground color button foreground item item name android background color button background item style this approach offers improved color refactoring and more stable style definitions when multiple related styles share similar color and usage properties however it comes at the cost of maintaining another set of color mappings treat dimens xml like colors xml you should also define a palette of typical spacing and font sizes for basically the same purposes as for colors a good example of a dimens file xml font sizes dimen name font larger 22sp dimen dimen name font large 18sp dimen dimen name font normal 15sp dimen dimen name font small 12sp dimen typical spacing between two views dimen name spacing huge 40dp dimen dimen name spacing large 24dp dimen dimen name spacing normal 14dp dimen dimen name spacing small 10dp dimen dimen name spacing tiny 4dp dimen typical sizes of views dimen name button height tall 60dp dimen dimen name button height normal 40dp dimen dimen name button height short 32dp dimen you should use the spacing dimensions for layouting in margins and paddings instead of hard coded values much like strings are normally treated this will give a consistent look and feel while making it easier to organize and change styles and layouts strings xml name your strings with keys that resemble namespaces and dont be afraid of repeating a value for two or more keys languages are complex so namespaces are necessary to bring context and break ambiguity bad xml string name network error network error string string name call failed call failed string string name map failed map loading failed string good xml string name error message network network error string string name error message call call failed string string name error message map map loading failed string dont write string values in all uppercase stick to normal text conventions e g capitalize first character if you need to display the string in all caps then do that using for instance the attribute textallcaps on a textview bad xml string name error message call call failed string good xml string name error message call call failed string avoid a deep hierarchy of views sometimes you might be tempted to just add yet another linearlayout to be able to accomplish an arrangement of views this kind of situation may occur xml relativelayout linearlayout linearlayout linearlayout linearlayout linearlayout linearlayout relativelayout even if you dont witness this explicitly in a layout file it might end up happening if you are inflating in java views into other views a couple of problems may occur you might experience performance problems because there is a complex ui tree that the processor needs to handle another more serious issue is a possibility of stackoverflowerror therefore try to keep your views hierarchy as flat as possible learn how to use constraintlayout how to optimize your layouts and to use the merge tag beware of problems related to webviews when you must display a web page for instance for a news article avoid doing client side processing to clean the html rather ask for a pure html from the backend programmers webviews can also leak memory when they keep a reference to their activity instead of being bound to the applicationcontext avoid using a webview for simple texts or buttons prefer the platforms widgets test frameworks use junit for unit testing plain android dependency free unit testing on the jvm is best done using junit avoid robolectric prior to the improved support for junit in the android build system robolectric was promoted as a test framework seeking to provide tests disconnected from device for the sake of development speed however testing under robolectric is inaccurate and incomplete as it works by providing mock implementations of the android platform which provides no guarantees of correctness instead use a combination of jvm based unit tests and dedicated on device integration tests espresso makes writing ui tests easy assertj android an assertj extension library making assertions easy in android tests assert j comes modules easier for you to test android specific components such as the android support google play services and appcompat libraries a test assertion will look like java example assertion using assertj android assertthat layout isvisible isvertical haschildcount 5 emulators the performance of the android sdk emulator particularly the x86 variant has improvement markedly in recent years and is now adequate for most day to day development scenarios however you should not discount the value of ensuring your application behaves correctly on real devices of course testing on all possible devices is not practical so rather focus your efforts on devices with a large market share and those most relevant to your app proguard configuration proguard is normally used on android projects to shrink and obfuscate the packaged code whether you are using proguard or not depends on your project configuration usually you would configure gradle to use proguard when building a release apk groovy buildtypes debug minifyenabled false release signingconfig signingconfigs release minifyenabled true proguardfiles getdefaultproguardfile proguard android txt proguard rules pro in order to determine which code has to be preserved and which code can be discarded or obfuscated you have to specify one or more entry points to your code these entry points are typically classes with main methods applets midlets activities etc android framework uses a default configuration which can be found from sdk home tools proguard proguard android txt using the above configuration custom project specific proguard rules as defined in my project app proguard rules pro will be appended to the default configuration a common problem related to proguard is to see the application crashing on startup with classnotfoundexception or nosuchfieldexception or similar even though the build command i e assemblerelease succeeded without warnings this means one out of two things proguard has removed the class enum method field or annotation considering its not required proguard has obfuscated renamed the class enum or field name but its being used indirectly by its original name i e through java reflection check app build outputs proguard release usage txt to see if the object in question has been removed check app build outputs proguard release mapping txt to see if the object in question has been obfuscated in order to prevent proguard from stripping away needed classes or class members add a keep options to your proguard config keep class com futurice project myclass to prevent proguard from obfuscating classes or class members add a keepnames keepnames class com futurice project myclass read more at proguard for examples early in your project make and test release build to check whether proguard rules are correctly retaining your dependencies also whenever you include new libraries or update their dependencies make a release build and test the apk on a device dont wait until your app is finally version 1 0 to make a release build you might get several unpleasant surprises and a short time to fix them tip save the mapping txt file for every release that you publish to your users by retaining a copy of the mapping txt file for each release build you ensure that you can debug a problem if a user encounters a bug and submits an obfuscated stack trace dexguard if you need hard core tools for optimizing and specially obfuscating release code consider dexguard a commercial software made by the same team that built proguard it can also easily split dex files to solve the 65k methods limitation data storage sharedpreferences if you only need to persist simple values and your application runs in a single process sharedpreferences is probably enough for you it is a good default option there are some situations where sharedpreferences are not suitable performance your data is complex or there is a lot of it multiple processes accessing the data you have widgets or remote services that run in their own processes and require synchronized data relational data distinct parts of your data are relational and you want to enforce that those relationships are maintained you can also store more complex objects by serializing them to json to store them and deserializing them when retrieving you should consider the tradeoffs when doing this as it may not be particularly performant nor maintainable contentproviders in case sharedpreferences are not enough you should use the platform standard contentproviders which are fast and process safe the single problem with contentproviders is the amount of boilerplate code that is needed to set them up as well as low quality tutorials it is possible however to generate the contentprovider by using a library such as schematic which significantly reduces the effort you still need to write some parsing code yourself to read the data objects from the sqlite columns and vice versa it is possible to serialize the data objects for instance with gson and only persist the resulting string in this way you lose in performance but on the other hand you do not need to declare a column for all the fields of the data class using an orm we generally do not recommend using an object relation mapping library unless you have unusually complex data and you have a dire need they tend to be complex and require time to learn if you decide to go with an orm you should pay attention to whether or not it is process safe if your application requires it as many of the existing orm solutions surprisingly are not use stetho stetho is a debug bridge for android applications from facebook that integrates with the chrome desktop browsers developer tools with stetho you can easily inspect your application most notably the network traffic it also allows you to easily inspect and edit sqlite databases and the shared preferences in your app you should however make sure that stetho is only enabled in the debug build and not in the release build variant another alternative is chuck which although offering slightly more simplified functionality is still useful for testers as the logs are displayed on the device rather than in the more complicated connected chrome browser setup that stetho requires use leakcanary leakcanary is a library that makes runtime detection and identification of memory leaks a more routine part of your application development process see the library wiki for details on configuration and usage just remember to configure only the no op dependency in your release build use continuous integration continuous integration systems let you automatically build and test your project every time you push updates to version control continuous integration also runs static code analysis tools generates the apk files and distributes them lint and checkstyle are tools that ensure the code quality while findbugs looks for bugs in the code there is a wide variety of continuous integration software which provide different features pricing plans might be for free if your project is open sourced jenkins is a good option if you have a local server at your disposal on the other hand travis ci is also a recommended choice if you plan to use a cloud based continuous integration service thanks to antti lammi joni karppinen peter tackage timo tuominen vera izrailit vihtori mÃ¤ntylÃ¤ mark voit andre medeiros paul houghton and other futurice developers for sharing their knowledge on android development acknowledgements this project is sponsored by spice program our open source and social impact program made with love by futurice license futurice oy creative commons attribution 4 0 international cc by 4 0