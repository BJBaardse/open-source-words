toml toms obvious minimal language by tom preston werner latest tagged version v0 5 0 note the master branch of this repository tracks the very latest development and may contain features and changes that do not exist on any released version to find the spec for a specific version look in the versions subdirectory as of version 0 5 0 toml should be considered extremely stable the goal is for version 1 0 0 to be backwards compatible as much as humanly possible with version 0 5 0 all implementations are strongly encouraged to become 0 5 0 compatible so that the transition to 1 0 0 will be simple when that happens objectives toml aims to be a minimal configuration file format thats easy to read due to obvious semantics toml is designed to map unambiguously to a hash table toml should be easy to parse into data structures in a wide variety of languages table of contents example spec comment key value pair keys string integer float boolean offset date time local date time local date local time array table inline table array of tables filename extension comparison with other formats get involved wiki example toml this is a toml document title toml example owner name tom preston werner dob 1979 05 27t07 32 00 08 00 first class dates database server 192 168 1 1 ports 8001 8001 8002 connection max 5000 enabled true servers indentation tabs and or spaces is allowed but not required servers alpha ip 10 0 0 1 dc eqdc10 servers beta ip 10 0 0 2 dc eqdc10 clients data gamma delta 1 2 line breaks are ok when inside arrays hosts alpha omega spec toml is case sensitive a toml file must be a valid utf 8 encoded unicode document whitespace means tab 0x09 or space 0x20 newline means lf 0x0a or crlf 0x0d0a comment a hash symbol marks the rest of the line as a comment toml this is a full line comment key value this is a comment at the end of a line key value pair the primary building block of a toml document is the key value pair keys are on the left of the equals sign and values are on the right whitespace is ignored around key names and values the key equals sign and value must be on the same line though some values can be broken over multiple lines toml key value values must be of the following types string integer float boolean datetime array or inline table unspecified values are invalid toml key invalid keys a key may be either bare quoted or dotted bare keys may only contain ascii letters ascii digits underscores and dashes a za z0 9 note that bare keys are allowed to be composed of only ascii digits e g 1234 but are always interpreted as strings toml key value bare key value bare key value 1234 value quoted keys follow the exact same rules as either basic strings or literal strings and allow you to use a much broader set of key names best practice is to use bare keys except when absolutely necessary toml 127 0 0 1 value character encoding value ʎǝʞ value key2 value quoted value value a bare key must be non empty but an empty quoted key is allowed though discouraged toml no key name invalid blank valid but discouraged blank valid but discouraged dotted keys are a sequence of bare or quoted keys joined with a dot this allows for grouping similar properties together toml name orange physical color orange physical shape round site google com true in json land that would give you the following structure json name orange physical color orange shape round site google com true whitespace around dot separated parts is ignored however best practice is to not use any extraneous whitespace defining a key multiple times is invalid do not do this name tom name pradyun as long as a key hasnt been directly defined you may still write to it and to names within it a b c 1 a d 2 this is invalid a b 1 a b c 2 string there are four ways to express strings basic multi line basic literal and multi line literal all strings must contain only valid utf 8 characters basic strings are surrounded by quotation marks any unicode character may be used except those that must be escaped quotation mark backslash and the control characters u 0000 to u 001f u 007f toml str im a string \ you can quote me\ name\tjos\u00e9\nlocation\tsf for convenience some popular characters have a compact escape sequence \b backspace u 0008 \t tab u 0009 \n linefeed u 000a \f form feed u 000c \r carriage return u 000d \ quote u 0022 \\ backslash u 005c \uxxxx unicode u xxxx \uxxxxxxxx unicode u xxxxxxxx any unicode character may be escaped with the \uxxxx or \uxxxxxxxx forms the escape codes must be valid unicode scalar values all other escape sequences not listed above are reserved and if used toml should produce an error sometimes you need to express passages of text e g translation files or would like to break up a very long string into multiple lines toml makes this easy multi line basic strings are surrounded by three quotation marks on each side and allow newlines a newline immediately following the opening delimiter will be trimmed all other whitespace and newline characters remain intact toml str1 roses are red violets are blue toml parsers should feel free to normalize newline to whatever makes sense for their platform toml on a unix system the above multi line string will most likely be the same as str2 roses are red\nviolets are blue on a windows system it will most likely be equivalent to str3 roses are red\r\nviolets are blue for writing long strings without introducing extraneous whitespace use a line ending backslash when the last non whitespace character on a line is a \ it will be trimmed along with all whitespace including newlines up to the next non whitespace character or closing delimiter all of the escape sequences that are valid for basic strings are also valid for multi line basic strings toml the following strings are byte for byte equivalent str1 the quick brown fox jumps over the lazy dog str2 the quick brown \ fox jumps over \ the lazy dog str3 \ the quick brown \ fox jumps over \ the lazy dog \ any unicode character may be used except those that must be escaped backslash and the control characters u 0000 to u 001f u 007f quotation marks need not be escaped unless their presence would create a premature closing delimiter if youre a frequent specifier of windows paths or regular expressions then having to escape backslashes quickly becomes tedious and error prone to help toml supports literal strings which do not allow escaping at all literal strings are surrounded by single quotes like basic strings they must appear on a single line toml what you see is what you get winpath c \users\nodejs\templates winpath2 \serverx\admin \system32\ quoted tom dubs preston werner regex \i\c\s since there is no escaping there is no way to write a single quote inside a literal string enclosed by single quotes luckily toml supports a multi line version of literal strings that solves this problem multi line literal strings are surrounded by three single quotes on each side and allow newlines like literal strings there is no escaping whatsoever a newline immediately following the opening delimiter will be trimmed all other content between the delimiters is interpreted as is without modification toml regex2 i dw ont need \d 2 apples lines the first newline is trimmed in raw strings all other whitespace is preserved control characters other than tab are not permitted in a literal string thus for binary data it is recommended that you use base64 or another suitable ascii or utf 8 encoding the handling of that encoding will be application specific integer integers are whole numbers positive numbers may be prefixed with a plus sign negative numbers are prefixed with a minus sign toml int1 99 int2 42 int3 0 int4 17 for large numbers you may use underscores between digits to enhance readability each underscore must be surrounded by at least one digit on each side toml int5 1 000 int6 5 349 221 int7 1 2 3 4 5 valid but discouraged leading zeros are not allowed integer values 0 and 0 are valid and identical to an unprefixed zero non negative integer values may also be expressed in hexadecimal octal or binary in these formats leading zeros are allowed after the prefix hex values are case insensitive underscores are allowed between digits but not between the prefix and the value toml hexadecimal with prefix 0x hex1 0xdeadbeef hex2 0xdeadbeef hex3 0xdead beef octal with prefix 0o oct1 0o01234567 oct2 0o755 useful for unix file permissions binary with prefix 0b bin1 0b11010110 64 bit signed long range expected −9 223 372 036 854 775 808 to 9 223 372 036 854 775 807 float floats should be implemented as ieee 754 binary64 values a float consists of an integer part which follows the same rules as integer values followed by a fractional part and or an exponent part if both a fractional part and exponent part are present the fractional part must precede the exponent part toml fractional flt1 1 0 flt2 3 1415 flt3 0 01 exponent flt4 5e 22 flt5 1e6 flt6 2e 2 both flt7 6 626e 34 a fractional part is a decimal point followed by one or more digits an exponent part is an e upper or lower case followed by an integer part which follows the same rules as integer values similar to integers you may use underscores to enhance readability each underscore must be surrounded by at least one digit toml flt8 9 224 617 445 991 228 313 float values 0 0 and 0 0 are valid and should map according to ieee 754 special float values can also be expressed they are always lowercase toml infinity sf1 inf positive infinity sf2 inf positive infinity sf3 inf negative infinity not a number sf4 nan actual snan qnan encoding is implementation specific sf5 nan same as nan sf6 nan valid actual encoding is implementation specific boolean booleans are just the tokens youre used to always lowercase toml bool1 true bool2 false offset date time to unambiguously represent a specific instant in time you may use an rfc 3339 formatted date time with offset toml odt1 1979 05 27t07 32 00z odt2 1979 05 27t00 32 00 07 00 odt3 1979 05 27t00 32 00 999999 07 00 for the sake of readability you may replace the t delimiter between date and time with a space as permitted by rfc 3339 section 5 6 toml odt4 1979 05 27 07 32 00z the precision of fractional seconds is implementation specific but at least millisecond precision is expected if the value contains greater precision than the implementation can support the additional precision must be truncated not rounded local date time if you omit the offset from an rfc 3339 formatted date time it will represent the given date time without any relation to an offset or timezone it cannot be converted to an instant in time without additional information conversion to an instant if required is implementation specific toml ldt1 1979 05 27t07 32 00 ldt2 1979 05 27t00 32 00 999999 the precision of fractional seconds is implementation specific but at least millisecond precision is expected if the value contains greater precision than the implementation can support the additional precision must be truncated not rounded local date if you include only the date portion of an rfc 3339 formatted date time it will represent that entire day without any relation to an offset or timezone toml ld1 1979 05 27 local time if you include only the time portion of an rfc 3339 formatted date time it will represent that time of day without any relation to a specific day or any offset or timezone toml lt1 07 32 00 lt2 00 32 00 999999 the precision of fractional seconds is implementation specific but at least millisecond precision is expected if the value contains greater precision than the implementation can support the additional precision must be truncated not rounded array arrays are square brackets with values inside whitespace is ignored elements are separated by commas data types may not be mixed different ways to define strings should be considered the same type and so should arrays with different element types toml arr1 1 2 3 arr2 red yellow green arr3 1 2 3 4 5 arr4 all strings are the same type arr5 1 2 a b c arr6 1 2 0 invalid arrays can also be multiline terminating commas also called trailing commas are ok after the last value of the array there can be an arbitrary number of newlines and comments before a value and before the closing bracket toml arr7 1 2 3 arr8 1 2 this is ok table tables also known as hash tables or dictionaries are collections of key value pairs they appear in square brackets on a line by themselves you can tell them apart from arrays because arrays are only ever values toml table under that and until the next table or eof are the key values of that table key value pairs within tables are not guaranteed to be in any specific order toml table 1 key1 some string key2 123 table 2 key1 another string key2 456 naming rules for tables are the same as for keys see definition of keys above toml dog tater man type name pug in json land that would give you the following structure json dog tater man type name pug whitespace around the key is ignored however best practice is to not use any extraneous whitespace toml a b c this is best practice d e f same as d e f g h i same as g h i j ʞ l same as j ʞ l you dont need to specify all the super tables if you dont want to toml knows how to do it for you toml x you x y dont x y z need these x y z w for this to work empty tables are allowed and simply have no key value pairs within them like keys you cannot define any table more than once doing so is invalid do not do this a b 1 a c 2 do not do this either a b 1 a b c 2 inline table inline tables provide a more compact syntax for expressing tables they are especially useful for grouped data that can otherwise quickly become verbose inline tables are enclosed in curly braces and within the braces zero or more comma separated key value pairs may appear key value pairs take the same form as key value pairs in standard tables all value types are allowed including inline tables inline tables are intended to appear on a single line no newlines are allowed between the curly braces unless they are valid within a value even so it is strongly discouraged to break an inline table onto multiples lines if you find yourself gripped with this desire it means you should be using standard tables toml name first tom last preston werner point x 1 y 2 animal type name pug the inline tables above are identical to the following standard table definitions toml name first tom last preston werner point x 1 y 2 animal type name pug array of tables the last type that has not yet been expressed is an array of tables these can be expressed by using a table name in double brackets each table with the same double bracketed name will be an element in the array the tables are inserted in the order encountered a double bracketed table without any key value pairs will be considered an empty table toml products name hammer sku 738594937 products products name nail sku 284758393 color gray in json land that would give you the following structure json products name hammer sku 738594937 name nail sku 284758393 color gray you can create nested arrays of tables as well just use the same double bracket syntax on sub tables each double bracketed sub table will belong to the most recently defined table element above it toml fruit name apple fruit physical color red shape round fruit variety name red delicious fruit variety name granny smith fruit name banana fruit variety name plantain the above toml maps to the following json json fruit name apple physical color red shape round variety name red delicious name granny smith name banana variety name plantain attempting to append to a statically defined array even if that array is empty or of compatible type must produce an error at parse time toml invalid toml doc fruit fruit not allowed attempting to define a normal table with the same name as an already established array must produce an error at parse time invalid toml doc fruit name apple fruit variety name red delicious this table conflicts with the previous table fruit variety name granny smith you may also use inline tables where appropriate toml points x 1 y 2 z 3 x 7 y 8 z 9 x 2 y 4 z 8 filename extension toml files should use the extension toml mime type when transferring toml files over the internet the appropriate mime type is application toml comparison with other formats in some ways toml is very similar to json simple well specified and maps easily to ubiquitous data types json is great for serializing data that will mostly be read and written by computer programs where toml differs from json is its emphasis on being easy for humans to read and write comments are a good example they serve no purpose when data is being sent from one program to another but are very helpful in a configuration file that may be edited by hand the yaml format is oriented towards configuration files just like toml for many purposes however yaml is an overly complex solution toml aims for simplicity a goal which is not apparent in the yaml specification http www yaml org spec 1 2 spec html the ini format is also frequently used for configuration files the format is not standardized however and usually does not handle more than one or two levels of nesting get involved documentation bug reports pull requests and all other contributions are welcome wiki we have an official toml wiki that catalogs the following projects using toml implementations validators language agnostic test suite for toml decoders and encoders editor support encoders converters please take a look if youd like to view or add to that list thanks for being a part of the toml community