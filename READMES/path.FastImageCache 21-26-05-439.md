fast image cache is an efficient persistent and—above all—fast way to store and retrieve images in your ios application part of any good ios applications user experience is fast smooth scrolling and fast image cache helps make this easier a significant burden on performance for graphics rich applications like path is image loading the traditional method of loading individual images from disk is just too slow especially while scrolling fast image cache was created specifically to solve this problem table of contents version history what fast image cache does how fast image cache works considerations requirements getting started integrating fast image cache initial configuration requesting images from the image cache providing source images to the image cache canceling source image requests working with image format families documentation demo application contributors credits license version history 1 0 10 18 2013 initial release 1 1 10 22 2013 added arc support and more robust core animation byte alignment 1 2 10 30 2013 added support for image format styles and canceling image requests 1 3 03 30 2014 significant bug fixes and performance improvements what fast image cache does stores images of similar sizes and styles together persists image data to disk returns images to the user significantly faster than traditional methods automatically manages cache expiry based on recency of usage utilizes a model based approach for storing and retrieving images allows images to be processed on a per model basis before being stored into the cache how fast image cache works in order to understand how fast image cache works its helpful to understand a typical scenario encountered by many applications that work with images the scenario ios applications especially those in the social networking space often have many images to display at once such as user photos the intuitive traditional approach is to request image data from an api process the original images to create the desired sizes and styles and store these processed images on the device later when an application needs to display these images they are loaded from disk into memory and displayed in an image view or are otherwise rendered to the screen the problem it turns out that the process of going from compressed on disk image data to a rendered core animation layer that the user can actually see is very expensive as the number of images to be displayed increases this cost easily adds up to a noticeable degradation in frame rate and scrollable views further exacerbate the situation because content can change rapidly requiring fast processing time to maintain a smooth 60fps 1 consider the workflow that occurs when loading an image from disk and displaying it on screen uiimage imagewithcontentsoffile uses image i o to create a cgimageref from memory mapped data at this point the image has not yet been decoded the returned image is assigned to a uiimageview an implicit catransaction captures these layer tree modifications on the next iteration of the main run loop core animation commits the implicit transaction which may involve creating a copy of any images which have been set as layer contents depending on the image copying it involves some or all of these steps 2 buffers are allocated to manage file io and decompression operations the file data is read from disk into memory the compressed image data is decoded into its uncompressed bitmap form which is typically a very cpu intensive operation 3 the uncompressed bitmap data is then used by core animation to render the layer these costs can easily accumulate and kill perceived application performance especially while scrolling users are presented with an unsatisfying user experience that is not in line with the the overall ios experience 1 60fps ≈ 0 01666s per frame 16 7ms per frame this means that any main thread work that takes longer than 16ms will cause your application to drop animation frames 2 the documentation for calayers contents property states that assigning a value to this property causes the layer to use your image rather than creating a separate backing store however the meaning of use your image is still vague profiling an application using instruments often reveals calls to ca render copy image even when the core animation instrument has indicated that none of the images have been copied one reason that core animation will require a copy of an image is improper byte alignment 3 as of ios 7 apple does not make their hardware jpeg decoder available for third party applications to use as a result only a slower software decoder is used for this step the solution fast image cache minimizes or avoids entirely much of the work described above using a variety of techniques mapped memory at the heart of how fast image cache works are image tables image tables are similar to sprite sheets often used in 2d gaming an image table packs together images of the same dimensions into a single file this file is opened once and is left open for reading and writing for as long as an application remains in memory image tables use the mmap system call to directly map file data into memory no memcpy occurs this system call merely creates a mapping between data on disk and a region of memory when a request is made to the image cache to return a specific image the image table finds in constant time the location of the desired image data in the file it maintains that region of file data is mapped into memory and a new cgimageref whose backing store is the mapped file data is created when the returned cgimageref wrapped into a uiimage is ready to be drawn to the screen ioss virtual memory system pages in the actual file data this is another benefit of using mapped memory the vm system will automatically handle the memory management for us in addition mapped memory doesnt count toward an applications real memory usage in like manner when image data is being stored in an image table a memory mapped bitmap context is created along with the original image this context is passed to an image tables corresponding entity object this object is responsible for drawing the image into the current context optionally further configuring the context e g clipping the context to a rounded rect or doing any additional drawing e g drawing an overlay image atop the original image mmap marshals the drawn image data to disk so no image buffer is allocated in memory uncompressed image data in order to avoid expensive image decompression operations image tables store uncompressed image data in their files if a source image is compressed it must first be decompressed for the image table to work with it this is a one time cost furthermore it is possible to utilize image format families to perform this decompression exactly once for a collection of similar image formats there are obvious consequences to this approach however uncompressed image data requires more disk space and the difference between compressed and uncompressed file sizes can be significant especially for image formats like jpeg for this reason fast image cache works best with smaller images although there is no api restriction that enforces this byte alignment for high performance scrolling it is critical that core animation is able to use an image without first having to create a copy one of the reasons core animation would create a copy of an image is improper byte alignment of the images underlying cgimageref a properly aligned bytes per row value must be a multiple of 8 pixels × bytes per pixel for a typical argb image the aligned bytes per row value is a multiple of 64 every image table is configured such that each image is always properly byte aligned for core animation from the start as a result when images are retrieved from an image table they are already in a form that core animation can work with directly without having to create a copy considerations image table size image tables are configured by image formats which specify among other things the maximum number of entries i e individual images an image table can have this is to prevent the size of an image table file from growing arbitrarily image tables allocate 4 bytes per pixel so the maximum space occupied by an image table file can be determined as follows 4 bytes per pixel × image width in pixels × image height in pixels × maximum number of entries applications using fast image cache should carefully consider how many images each image table should contain when a new image is stored in an image table that is already full it will replace the least recently accessed image image table transience image table files are stored in the users caches directory in a subdirectory called imagetables ios can remove cached files at any time to free up disk space so applications using fast image cache must be able to recreate any stored images and should not rely on image table files persisting forever note as a reminder data stored in a users caches directory is not backed up to itunes or icloud source image persistence fast image cache does not persist the original source images processed by entities to create the image data stored in its image tables for example if an original image is resized by an entity to create a thumbnail to be stored in an image table it is the applications responsibility to either persist the original image or be able to retrieve or recreate it again image format families can be specified to efficiently make use of a single source image see working with image format families for more information data protection in ios 4 apple introduced data protection when a users device is locked or turned off the disk is encrypted files written to disk are protected by default although applications can manually specify the data protection mode for each file it manages with the advent of new background modes in ios 7 applications can now execute in the background briefly even while the device is locked as a result data protection can cause issues if applications attempt to access files that are encrypted fast image cache allows each image format to specify the data protection mode used when creating its backing image table file be aware that enabling data protection for image table files means that fast image cache might not be able to read or write image data from or to these files when the disk is encrypted requirements fast image cache requires ios 6 0 or greater and relies on the following frameworks foundation core graphics uikit note as of version 1 1 fast image cache does use arc the fastimagecachedemo xcode project requires xcode 5 0 or greater and is configured to deploy against ios 6 0 getting started integrating fast image cache cocoapods for easy project integration fast image cache is available as a cocoapod manually clone this repository or download the latest archive of master from the fastimagecache root directory copy the source files from the inner fastimagecache subdirectory to your xcode project import ficimagecache h wherever you use the image cache import ficentity h for each class that conforms to ficentity initial configuration before the image cache can be used it needs to be configured this must occur each launch so the application delegate might be a good place to do this creating image formats each image format corresponds to an image table that the image cache will use image formats that can use the same source image to render the images they store in their image tables should belong to the same image format family see image table size for more information about how to determine an appropriate maximum count objective c static nsstring xximageformatnameuserthumbnailsmall com mycompany myapp xximageformatnameuserthumbnailsmall static nsstring xximageformatnameuserthumbnailmedium com mycompany myapp xximageformatnameuserthumbnailmedium static nsstring xximageformatfamilyuserthumbnails com mycompany myapp xximageformatfamilyuserthumbnails ficimageformat smalluserthumbnailimageformat ficimageformat alloc init smalluserthumbnailimageformat name xximageformatnameuserthumbnailsmall smalluserthumbnailimageformat family xximageformatfamilyuserthumbnails smalluserthumbnailimageformat style ficimageformatstyle16bitbgr smalluserthumbnailimageformat imagesize cgsizemake 50 50 smalluserthumbnailimageformat maximumcount 250 smalluserthumbnailimageformat devices ficimageformatdevicephone smalluserthumbnailimageformat protectionmode ficimageformatprotectionmodenone ficimageformat mediumuserthumbnailimageformat ficimageformat alloc init mediumuserthumbnailimageformat name xximageformatnameuserthumbnailmedium mediumuserthumbnailimageformat family xximageformatfamilyuserthumbnails mediumuserthumbnailimageformat style ficimageformatstyle32bitbgra mediumuserthumbnailimageformat imagesize cgsizemake 100 100 mediumuserthumbnailimageformat maximumcount 250 mediumuserthumbnailimageformat devices ficimageformatdevicephone mediumuserthumbnailimageformat protectionmode ficimageformatprotectionmodenone nsarray imageformats smalluserthumbnailimageformat mediumuserthumbnailimageformat an image formats style effectively determines the bit depth of the images stored in an image table the following styles are currently available 32 bit color plus an alpha component default 32 bit color no alpha component 16 bit color no alpha component 8 bit grayscale no alpha component if the source images lack transparency e g jpeg images then better core animation performance can be achieved by using 32 bit color with no alpha component if the source images have little color detail or if the image formats image size is relatively small it may be sufficient to use 16 bit color with little or no perceptible loss of quality this results in smaller image table files stored on disk configuring the image cache once one or more image formats have been defined they need to be assigned to the image cache aside from assigning the image caches delegate there is nothing further that can be configured on the image cache itself objective c ficimagecache sharedimagecache ficimagecache sharedimagecache sharedimagecache delegate self sharedimagecache formats imageformats creating entities entities are objects that conform to the ficentity protocol entities uniquely identify entries in an image table and they are also responsible for drawing the images they wish to store in the image cache applications that already have model objects defined perhaps managed by core data are usually appropriate entity candidates objective c interface xxuser nsobject property nonatomic assign getter isactive bool active property nonatomic copy nsstring userid property nonatomic copy nsurl userphotourl end here is an example implementation of the ficentity protocol objective c nsstring uuid cfuuidbytes uuidbytes ficuuidbytesfrommd5hashofstring userid nsstring uuid ficstringwithuuidbytes uuidbytes return uuid nsstring sourceimageuuid cfuuidbytes sourceimageuuidbytes ficuuidbytesfrommd5hashofstring userphotourl absolutestring nsstring sourceimageuuid ficstringwithuuidbytes sourceimageuuidbytes return sourceimageuuid nsurl sourceimageurlwithformatname nsstring formatname return sourceimageurl ficentityimagedrawingblock drawingblockforimage uiimage image withformatname nsstring formatname ficentityimagedrawingblock drawingblock cgcontextref context cgsize contextsize cgrect contextbounds cgrectzero contextbounds size contextsize cgcontextclearrect context contextbounds clip medium thumbnails so they have rounded corners if formatname isequaltostring xximageformatnameuserthumbnailmedium uibezierpath clippingpath self clippingpath clippingpath addclip uigraphicspushcontext context image drawinrect contextbounds uigraphicspopcontext return drawingblock ideally an entitys uuid should never change this is why it corresponds nicely with a model objects server generated id in the case where an application is working with resources retrieved from an api an entitys sourceimageuuid can change for example if a user updates their profile photo the url to that photo should change as well the uuid remains the same and identifies the same user but the changed profile photo url will indicate that there is a new source image note often it is best to hash whatever identifiers are being used to define uuid and sourceimageuuid fast image cache provides utility functions to do this because hashing can be expensive it is recommended that the hash be computed only once or only when the identifier changes and stored in an instance variable when the image cache is asked to provide an image for a particular entity and format name the entity is responsible for providing a url the url need not even point to an actual resource—e g the url might be constructed of a custom url scheme— but it must be a valid url the image cache uses these urls merely to keep track of which image requests are already in flight multiple requests to the image cache for the same image are handled correctly without any wasted effort the choice to use urls as a basis for keying image cache requests actually complements many real world application designs whereby urls to image resources rather than the images themselves are included with server provided model data note fast image cache does not provide any mechanism for making network requests this is the responsibility of the image caches delegate finally once the source image is available the entity is asked to provide a drawing block the image table that will store the final image sets up a file mapped bitmap context and invokes the entitys drawing block this makes it convenient for each entity to decide how to process the source image for particular image formats requesting images from the image cache fast image cache works under the on demand lazy loading design pattern common to cocoa objective c xxuser user self currentuser nsstring formatname xximageformatnameuserthumbnailsmall ficimagecachecompletionblock completionblock id entity nsstring formatname uiimage image imageview image image imageview layer addanimation catransition animation forkey kcatransition bool imageexists sharedimagecache retrieveimageforentity user withformatname formatname completionblock completionblock if imageexists no imageview image self userplaceholderimage there are a few things to note here note that it is an entity and an image format name that uniquely identifies the desired image in the image cache as a format name uniquely identifies an image table the entity alone uniquely identifies the desired image data in an image table the image cache never returns a uiimage directly the requested image is included in the completion block the return value will indicate whether or not the image already exists in the image cache retrieveimageforentity withformatname completionblock is a synchronous method if the requested image already exists in the image cache the completion block will be called immediately there is an asynchronous counterpart to this method called asynchronouslyretrieveimageforentity withformatname completionblock if a requested image does not already exist in the image cache then the image cache invokes the necessary actions to request the source image for its delegate afterwards perhaps some time later the completion block will be called note the distinction of synchronous and asynchronous only applies to the process of retrieving an image that already exists in the image cache in the case where a synchronous image request is made for an image that does not already exist in the image case the image cache does not block the calling thread until it has an image the retrieval method will immediately return no and the completion block will be called later see the ficimagecache class header for a thorough explanation of how the execution lifecycle works for image retrieval especially as it relates to the handling of the completion blocks providing source images to the image cache there are two ways to provide source images to the image cache on demand this is the preferred method the image caches delegate is responsible for supplying the image cache with source images objective c void imagecache ficimagecache imagecache wantssourceimageforentity id entity withformatname nsstring formatname completionblock ficimagerequestcompletionblock completionblock dispatch async dispatch get global queue dispatch queue priority default 0 fetch the desired source image by making a network request nsurl requesturl entity sourceimageurlwithformatname formatname uiimage sourceimage self sourceimageforurl requesturl dispatch async dispatch get main queue completionblock sourceimage this is where the url based nature of how the image cache manages image requests is convenient first an image retrieval request to the image cache for an image that is already being handled by the image caches delegate—e g waiting on a large image to be downloaded—is simply added to the first requests array of completion blocks second if source images are downloaded from the internet as is often the case the url for such a network request is readily available note the completion block must be called on the main thread fast image cache is architected such that this call will not block the main thread as processing sources image is handled in the image caches own serial dispatch queue manually it is possible to manually insert image data into the image cache objective c just finished downloading new user photo xxuser user self currentuser nsstring formatname xximageformatnameuserthumbnailsmall ficimagecachecompletionblock completionblock id entity nsstring formatname uiimage image nslog processed and stored image for entity entity sharedimagecache setimage newuserphoto forentity user withformatname formatname completionblock completionblock note fast image cache does not persist source images see source image persistence for more information canceling source image requests if an image request is already in progress it can be cancelled objective c we scrolled up far enough that the image we requested in no longer visible cancel the request xxuser user self currentuser nsstring formatname xximageformatnameuserthumbnailsmall sharedimagecache cancelimageretrievalforentity user withformatname formatname when this happens fast image cache cleans up its internal bookkeeping and any completion blocks from the corresponding image request will do nothing at this point however the image caches delegate is still responsible for ensuring that any outstanding source image requests e g network requests are cancelled objective c void imagecache ficimagecache imagecache cancelimageloadingforentity id ficentity entity withformatname nsstring formatname self cancelnetworkrequestforsourceimageforentity entity withformatname formatname working with image format families the advantage of classifying image formats into families is that the image caches delegate can tell the image cache to process entity source images for all image formats in a family when any image format in that family is processed by default all image formats are processed for a given family unless you implement this delegate and return otherwise objective c bool imagecache ficimagecache imagecache shouldprocessallformatsinfamily nsstring formatfamily forentity id entity bool shouldprocessallformats no if formatfamily isequaltostring xximageformatfamilyuserthumbnails xxuser user xxuser entity shouldprocessallformats user active return shouldprocessallformats the advantage of processing all image formats in a family at once is that the source image does not need to be repeatedly downloaded or loaded into memory if cached on disk for example if a user changes their profile photo it probably makes sense to process the new source image for every variant at the same time that the first image format is processed that is if the image cache is processing a new user profile photo for the image format named xximageformatnameuserthumbnailsmall then it makes sense to also process and store new image data for that same user for the image format named xximageformatnameuserthumbnailmedium documentation fast image caches header files are fully documented and appledoc can be used to generate documentation in various forms including html and xcode docset html documentation can be found here demo application included with this repository is a demo app xcode project it demonstrates the difference between the conventional approach for loading and displaying images and the fast image cache approach see the requirements for running the demo app xcode project note the demo application must either be supplied with jpeg images or the included fetch demo images sh script in the fastimagecachedemo directory must be run video note in this demo video the first demonstrated method is the conventional approach the second method is using image tables statistics the following statistics were measured from a run of the demo application method scrolling performance disk usage rprvt1 conventional 35fps 568kb 2 40mb 1 06mb 1 34mb fast image cache 59fps 2 2mb 1 15mb 1 06mb 0 09mb the takeaway is that fast image cache sacrifices disk usage to achieve a faster framerate and overall less memory usage 1 the first value is the the total rprvt used by a method to display a screens worth of jpeg thumbnails the second value is the baseline rprvt where all the table view cells and image views are on screen but none of the image views have images set the third value is how much additional rprvt each method used beyond the baseline contributors mallory paine — author and original api design mallorypaine michael potter — documentation and api refactoring lucastizma credits all demo application photos were taken from morguefile and are used according to the morguefile license fast image cache logo illustration by the amazing jake mix license fast image cache is made available under the mit license the mit license mit copyright c 2013 path inc permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the software to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall the authors or copyright holders be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software