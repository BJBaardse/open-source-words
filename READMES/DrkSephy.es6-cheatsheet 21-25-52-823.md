es6 cheatsheet a cheatsheet containing es2015 es6 tips tricks best practices and code snippet examples for your day to day workflow contributions are welcome table of contents var versus let const replacing iifes with blocks arrow functions strings destructuring modules parameters classes symbols maps weakmaps promises generators async await getter setter functions license var versus let const besides var we now have access to two new identifiers for storing values —let and const unlike var let and const statements are not hoisted to the top of their enclosing scope an example of using var javascript var snack meow mix function getfood food if food var snack friskies return snack return snack getfood false undefined however observe what happens when we replace var using let javascript let snack meow mix function getfood food if food let snack friskies return snack return snack getfood false meow mix this change in behavior highlights that we need to be careful when refactoring legacy code which uses var blindly replacing instances of var with let may lead to unexpected behavior note let and const are block scoped therefore referencing block scoped identifiers before they are defined will produce a referenceerror javascript console log x referenceerror x is not defined let x hi best practice leave var declarations inside of legacy code to denote that it needs to be carefully refactored when working on a new codebase use let for variables that will change their value over time and const for variables which cannot be reassigned back to table of contents replacing iifes with blocks a common use of immediately invoked function expressions is to enclose values within its scope in es6 we now have the ability to create block based scopes and therefore are not limited purely to function based scope javascript function var food meow mix console log food reference error using es6 blocks javascript let food meow mix console log food reference error back to table of contents arrow functions often times we have nested functions in which we would like to preserve the context of this from its lexical scope an example is shown below javascript function person name this name name person prototype prefixname function arr return arr map function character return this name character cannot read property name of undefined one common solution to this problem is to store the context of this using a variable javascript function person name this name name person prototype prefixname function arr var that this store the context of this return arr map function character return that name character we can also pass in the proper context of this javascript function person name this name name person prototype prefixname function arr return arr map function character return this name character this as well as bind the context javascript function person name this name name person prototype prefixname function arr return arr map function character return this name character bind this using arrow functions the lexical value of this isnt shadowed and we can re write the above as shown javascript function person name this name name person prototype prefixname function arr return arr map character this name character best practice use arrow functions whenever you need to preserve the lexical value of this arrow functions are also more concise when used in function expressions which simply return a value javascript var squares arr map function x return x x function expression javascript const arr 1 2 3 4 5 const squares arr map x x x arrow function for terser implementation best practice use arrow functions in place of function expressions when possible back to table of contents strings with es6 the standard library has grown immensely along with these changes are new methods which can be used on strings such as includes and repeat includes javascript var string food var substring foo console log string indexof substring 1 instead of checking for a return value 1 to denote string containment we can simply use includes which will return a boolean javascript const string food const substring foo console log string includes substring true repeat javascript function repeat string count var strings while strings length count strings push string return strings join in es6 we now have access to a terser implementation javascript string repeat numberofrepetitions meow repeat 3 meowmeowmeow template literals using template literals we can now construct strings that have special characters in them without needing to escape them explicitly javascript var text this string contains \ double quotes\ which are escaped javascript let text this string contains double quotes which dont need to be escaped anymore template literals also support interpolation which makes the task of concatenating strings and values javascript var name tiger var age 13 console log my cat is named name and is age years old much simpler javascript const name tiger const age 13 console log my cat is named name and is age years old in es5 we handled new lines as follows javascript var text cat\n dog\n nickelodeon or javascript var text cat dog nickelodeon join \n template literals will preserve new lines for us without having to explicitly place them in javascript let text cat dog nickelodeon template literals can accept expressions as well javascript let today new date let text the time and date is today tolocalestring back to table of contents destructuring destructuring allows us to extract values from arrays and objects even deeply nested and store them in variables with a more convenient syntax destructuring arrays javascript var arr 1 2 3 4 var a arr 0 var b arr 1 var c arr 2 var d arr 3 javascript let a b c d 1 2 3 4 console log a 1 console log b 2 destructuring objects javascript var luke occupation jedi father anakin var occupation luke occupation jedi var father luke father anakin javascript let luke occupation jedi father anakin let occupation father luke console log occupation jedi console log father anakin back to table of contents modules prior to es6 we used libraries such as browserify to create modules on the client side and require in node js with es6 we can now directly use modules of all types amd and commonjs exporting in commonjs javascript module exports 1 module exports foo bar module exports foo bar module exports function bar exporting in es6 with es6 we have various flavors of exporting we can perform named exports javascript export let name david export let age 25 ​​ as well as exporting a list of objects javascript function sumtwo a b return a b function sumthree a b c return a b c export sumtwo sumthree we can also export functions objects and values etc simply by using the export keyword javascript export function sumtwo a b return a b export function sumthree a b c return a b c and lastly we can export default bindings javascript function sumtwo a b return a b function sumthree a b c return a b c let api sumtwo sumthree export default api which is the same as export api as default best practices always use the export default method at the end of the module it makes it clear what is being exported and saves time by having to figure out what name a value was exported as more so the common practice in commonjs modules is to export a single value or object by sticking to this paradigm we make our code easily readable and allow ourselves to interpolate between commonjs and es6 modules importing in es6 es6 provides us with various flavors of importing we can import an entire file javascript import underscore it is important to note that simply importing an entire file will execute all code at the top level of that file similar to python we have named imports javascript import sumtwo sumthree from math addition we can also rename the named imports javascript import sumtwo as addtwonumbers sumthree as sumthreenumbers from math addition in addition we can import all the things also called namespace import javascript import as util from math addition lastly we can import a list of values from a module javascript import as additionutil from math addition const sumtwo sumthree additionutil importing from the default binding like this javascript import api from math addition same as import default as api from math addition while it is better to keep the exports simple but we can sometimes mix default import and mixed import if needed when we are exporting like this javascript foos js export foo as default foo1 foo2 we can import them like the following javascript import foo foo1 foo2 from foos when importing a module exported using commonjs syntax such as react we can do javascript import react from react const component proptypes react this can also be simplified further using javascript import react component proptypes from react note values that are exported are bindings not references therefore changing the binding of a variable in one module will affect the value within the exported module avoid changing the public interface of these exported values back to table of contents parameters in es5 we had varying ways to handle functions which needed default values indefinite arguments and named parameters with es6 we can accomplish all of this and more using more concise syntax default parameters javascript function addtwonumbers x y x x 0 y y 0 return x y in es6 we can simply supply default values for parameters in a function javascript function addtwonumbers x 0 y 0 return x y javascript addtwonumbers 2 4 6 addtwonumbers 2 2 addtwonumbers 0 rest parameters in es5 we handled an indefinite number of arguments like so javascript function logarguments for var i 0 i arguments length i console log arguments i using the rest operator we can pass in an indefinite amount of arguments javascript function logarguments args for let arg of args console log arg named parameters one of the patterns in es5 to handle named parameters was to use the options object pattern adopted from jquery javascript function initializecanvas options var height options height 600 var width options width 400 var linestroke options linestroke black we can achieve the same functionality using destructuring as a formal parameter to a function javascript function initializecanvas height 600 width 400 linestroke black use variables height width linestroke here if we want to make the entire value optional we can do so by destructuring an empty object javascript function initializecanvas height 600 width 400 linestroke black spread operator in es5 we could find the max of values in an array by using the apply method on math max like this javascript math max apply null 1 100 9001 32 9001 in es6 we can now use the spread operator to pass an array of values to be used as parameters to a function javascript math max 1 100 9001 32 9001 we can concat array literals easily with this intuitive syntax javascript let cities san francisco los angeles let places miami cities chicago miami san francisco los angeles chicago back to table of contents classes prior to es6 we implemented classes by creating a constructor function and adding properties by extending the prototype javascript function person name age gender this name name this age age this gender gender person prototype incrementage function return this age 1 and created extended classes by the following javascript function personal name age gender occupation hobby person call this name age gender this occupation occupation this hobby hobby personal prototype object create person prototype personal prototype constructor personal personal prototype incrementage function person prototype incrementage call this this age 20 console log this age es6 provides much needed syntactic sugar for doing this under the hood we can create classes directly javascript class person constructor name age gender this name name this age age this gender gender incrementage this age 1 and extend them using the extends keyword javascript class personal extends person constructor name age gender occupation hobby super name age gender this occupation occupation this hobby hobby incrementage super incrementage this age 20 console log this age best practice while the syntax for creating classes in es6 obscures how implementation and prototypes work under the hood it is a good feature for beginners and allows us to write cleaner code back to table of contents symbols symbols have existed prior to es6 but now we have a public interface to using them directly symbols are immutable and unique and can be used as keys in any hash symbol calling symbol or symbol description will create a unique symbol that cannot be looked up globally a use case for symbol is to patch objects or namespaces from third parties with your own logic but be confident that you wont collide with updates to that library for example if you wanted to add a method refreshcomponent to the react component class and be certain that you didnt trample a method they add in a later update javascript const refreshcomponent symbol react component prototype refreshcomponent do something symbol for key symbol for key will create a symbol that is still immutable and unique but can be looked up globally two identical calls to symbol for key will return the same symbol instance note this is not true for symbol description javascript symbol foo symbol foo false symbol for foo symbol foo false symbol for foo symbol for foo true a common use case for symbols and in particular with symbol for key is for interoperability this can be achieved by having your code look for a symbol member on object arguments from third parties that contain some known interface for example javascript function reader obj const specialread symbol for specialread if obj specialread const reader obj specialread do something with reader else throw new typeerror object cannot be read and then in another library javascript const specialread symbol for specialread class somereadabletype specialread const reader createsomereaderfrom this return reader a notable example of symbol use for interoperability is symbol iterator which exists on all iterable types in es6 arrays strings generators etc when called as a method it returns an object with an iterator interface back to table of contents maps maps is a much needed data structure in javascript prior to es6 we created hash maps through objects javascript var map new object map key1 value1 map key2 value2 however this does not protect us from accidentally overriding functions with specific property names javascript getownproperty hasownproperty hah overwritten pwned typeerror property hasownproperty is not a function actual maps allow us to set get and search for values and much more javascript let map new map map set name david map get name david map has name true the most amazing part of maps is that we are no longer limited to just using strings we can now use any type as a key and it will not be type cast to a string javascript let map new map name david true false 1 one object function function for let key of map keys console log typeof key string boolean number object function note using non primitive values such as functions or objects wont work when testing equality using methods such as map get as such stick to primitive values such as strings booleans and numbers we can also iterate over maps using entries javascript for let key value of map entries console log key value back to table of contents weakmaps in order to store private data versions es6 we had various ways of doing this one such method was using naming conventions javascript class person constructor age this age age incrementage this age 1 but naming conventions can cause confusion in a codebase and are not always going to be upheld instead we can use weakmaps to store our values javascript let age new weakmap class person constructor age age set this age incrementage let age age get this 1 age set this age if age 50 console log midlife crisis the cool thing about using weakmaps to store our private data is that their keys do not give away the property names which can be seen by using reflect ownkeys javascript const person new person 50 person incrementage midlife crisis reflect ownkeys person a more practical example of using weakmaps is to store data which is associated to a dom element without having to pollute the dom itself javascript let map new weakmap let el document getelementbyid someelement store a weak reference to the element with a key map set el reference access the value of the element let value map get el reference remove the reference el parentnode removechild el el null map is empty since the element is destroyed as shown above once the object is destroyed by the garbage collector the weakmap will automatically remove the key value pair which was identified by that object note to further illustrate the usefulness of this example consider how jquery stores a cache of objects corresponding to dom elements which have references using weakmaps jquery can automatically free up any memory that was associated with a particular dom element once it has been removed from the document in general weakmaps are very useful for any library that wraps dom elements back to table of contents promises promises allow us to turn our horizontal code callback hell javascript func1 function value1 func2 value1 function value2 func3 value2 function value3 func4 value3 function value4 func5 value4 function value5 do something with value 5 into vertical code javascript func1 value1 then func2 then func3 then func4 then func5 value5 do something with value 5 prior to es6 we used bluebird or q now we have promises natively javascript new promise resolve reject reject new error failed to fulfill promise catch reason console log reason where we have two handlers resolve a function called when the promise is fulfilled and reject a function called when the promise is rejected benefits of promises error handling using a bunch of nested callbacks can get chaotic using promises we have a clear path to bubbling errors up and handling them appropriately moreover the value of a promise after it has been resolved rejected is immutable it will never change here is a practical example of using promises javascript var request require request return new promise resolve reject request get url error response body if body resolve json parse body else resolve we can also parallelize promises to handle an array of asynchronous operations by using promise all javascript let urls api commits api issues opened api issues assigned api issues completed api issues comments api pullrequests let promises urls map url return new promise resolve reject ajax url url done data resolve data promise all promises then results do something with results of all our promises back to table of contents generators similar to how promises allow us to avoid callback hell generators allow us to flatten our code giving our asynchronous code a synchronous feel generators are essentially functions which we can pause their execution and subsequently return the value of an expression a simple example of using generators is shown below javascript function sillygenerator yield 1 yield 2 yield 3 yield 4 var generator sillygenerator console log generator next value 1 done false console log generator next value 2 done false console log generator next value 3 done false console log generator next value 4 done false where next will allow us to push our generator forward and evaluate a new expression while the above example is extremely contrived we can utilize generators to write asynchronous code in a synchronous manner javascript hiding asynchronousity with generators function request url getjson url function response generator next response and here we write a generator function that will return our data javascript function getdata var entry1 yield request http some api item1 var data1 json parse entry1 var entry2 yield request http some api item2 var data2 json parse entry2 by the power of yield we are guaranteed that entry1 will have the data needed to be parsed and stored in data1 while generators allow us to write asynchronous code in a synchronous manner there is no clear and easy path for error propagation as such as we can augment our generator with promises javascript function request url return new promise resolve reject getjson url resolve and we write a function which will step through our generator using next which in turn will utilize our request method above to yield a promise javascript function iterategenerator gen var generator gen function iterate val var ret generator next if ret done ret value then iterate by augmenting our generator with promises we have a clear way of propagating errors through the use of our promise catch and reject to use our newly augmented generator it is as simple as before javascript iterategenerator function getdata var entry1 yield request http some api item1 var data1 json parse entry1 var entry2 yield request http some api item2 var data2 json parse entry2 we were able to reuse our implementation to use our generator as before which shows their power while generators and promises allow us to write asynchronous code in a synchronous manner while retaining the ability to propagate errors in a nice way we can actually begin to utilize a simpler construction that provides the same benefits async await back to table of contents async await while this is actually an upcoming es2016 feature async await allows us to perform the same thing we accomplished using generators and promises with less effort javascript var request require request function getjson url return new promise function resolve reject request url function error response body resolve body async function main var data await getjson console log data not undefined main under the hood it performs similarly to generators i highly recommend using them over generators promises a great resource for getting up and running with es7 and babel can be found here back to table of contents getter and setter functions es6 has started supporting getter and setter functions within classes using the following example javascript class employee constructor name this name name get name if this name return mr this name touppercase else return undefined set name newname if newname this name console log i already have this name else if newname this name newname else return false var emp new employee james bond uses the get method in the background if emp name console log emp name mr james bond uses the setter in the background emp name bond 007 console log emp name mr bond 007 latest browsers are also supporting getter setter functions in objects and we can use them for computed properties adding listeners and preprocessing before setting getting javascript var person firstname james lastname bond get fullname console log getting fullname return this firstname this lastname set fullname name console log setting fullname var words name tostring split this firstname words 0 this lastname words 1 person fullname james bond person fullname bond 007 person fullname bond 007 back to table of contents license the mit license mit copyright c 2015 david leonard permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the software to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall the authors or copyright holders be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software back to table of contents