ios good practices just like software this document will rot unless we take care of it we encourage everyone to help us on that – just open an issue or send a pull request interested in other mobile platforms our best practices in android development and windows app development best practices documents have got you covered why getting on board with ios can be intimidating neither swift nor objective c are widely used elsewhere the platform has its own names for almost everything and its a bumpy road for your code to actually make it onto a physical device this living document is here to help you whether youre taking your first steps in cocoaland or youre curious about doing things the right way everything below is just suggestions so if you have a good reason to do something differently by all means go for it contents if you are looking for something specific you can jump right into the relevant section from here getting started common libraries architecture stores assets coding style security diagnostics analytics building deployment in app purchases iap license getting started human interface guidelines if youre coming from another platform do take some time to familiarize yourself with apples human interface guidelines for the platform there is a strong emphasis on good design in the ios world and your app should be no exception the guidelines also provide a handy overview of native ui elements technologies such as 3d touch or wallet and icon dimensions for designers xcode xcode is the ide of choice for most ios developers and the only one officially supported by apple there are some alternatives of which appcode is arguably the most famous but unless youre already a seasoned ios person go with xcode despite its shortcomings its actually quite usable nowadays to install simply download xcode on the mac app store it comes with the newest sdk and simulators and you can install more stuff under preferences downloads project setup a common question when beginning an ios project is whether to write all views in code or use interface builder with storyboards or xib files both are known to occasionally result in working software however there are a few considerations why code storyboards are more prone to version conflicts due to their complex xml structure this makes merging much harder than with code its easier to structure and reuse views in code thereby keeping your codebase dry all information is in one place in interface builder you have to click through all the inspectors to find what youre looking for storyboards introduce coupling between your code and ui which can lead to crashes e g when an outlet or action is not set up correctly these issues are not detected by the compiler why storyboards for the less technically inclined storyboards can be a great way to contribute to the project directly e g by tweaking colors or layout constraints however this requires a working project setup and some time to learn the basics iteration is often faster since you can preview certain changes without building the project custom fonts and ui elements are represented visually in storyboards giving you a much better idea of the final appearance while designing for size classes interface builder gives you a live layout preview for the devices of your choice including ipad split screen multitasking why not both to get the best of both worlds you can also take a hybrid approach start off by sketching the initial design with storyboards which are great for tinkering and quick changes you can even invite designers to participate in this process as the ui matures and reliability becomes more important you then transition into a code based setup thats easier to maintain and collaborate on ignores a good first step when putting a project under version control is to have a decent gitignore file that way unwanted files user settings temporary files etc will never even make it into your repository luckily github has us covered for both swift and objective c dependency management cocoapods if youre planning on including external dependencies e g third party libraries in your project cocoapods offers easy and fast integration install it like so sudo gem install cocoapods to get started move inside your ios project folder and run pod init this creates a podfile which will hold all your dependencies in one place after adding your dependencies to the podfile you run pod install to install the libraries and include them as part of a workspace which also holds your own project it is generally recommended to commit the installed dependencies to your own repo instead of relying on having each developer running pod install after a fresh checkout note that from now on youll need to open the xcworkspace file instead of xcproject or your code will not compile the command pod update will update all pods to the newest versions permitted by the podfile you can use a wealth of operators to specify your exact version requirements carthage carthage takes the simple not easy approach by building your dependencies into binary frameworks without magically integrating them with your project in any way this also greatly reduces build times because your dependencies have already been compiled by the time you start building there is no centralized repository of projects which means any library that can be compiled into a framework supports carthage out of the box to get started follow the instructions in carthages documentation project structure to keep all those hundreds of source files from ending up in the same directory its a good idea to set up some folder structure depending on your architecture for instance you can use the following ├─ models ├─ views ├─ controllers or viewmodels if your architecture is mvvm ├─ stores ├─ helpers first create them as groups little yellow folders within the group with your projects name in xcodes project navigator then for each of the groups link them to an actual directory in your project path by opening their file inspector on the right hitting the little gray folder icon and creating a new subfolder with the name of the group in your project directory localization keep all user strings in localization files right from the beginning this is good not only for translations but also for finding user facing text quickly you can add a launch argument to your build scheme to launch the app in a certain language e g applelanguages finnish for more complex translations such as plural forms that depending on a number of items e g 1 person vs 3 people you should use the stringsdict format instead of a regular localizable strings file as soon as youve wrapped your head around the crazy syntax you have a powerful tool that knows how to make plurals for one some few and many items as needed e g in russian or arabic find more information about localization in these presentation slides from the february 2012 helsinkios meetup most of the talk is still relevant constants keep your constants scope as small as possible for instance when you only need it inside a class it should live in that class those constants that need to be truly app wide should be kept in one place in swift you can use enums defined in a constants swift file to group store and access your app wide constants in a clean way swift enum config static let baseurl nsurl string http www example org static let splinereticulatorname foobar enum color static let primarycolor uicolor red 0 22 green 0 58 blue 0 29 alpha 1 0 static let secondarycolor uicolor lightgray a visual way to define colours within code files is to use colorliteral this syntax will present you with colour picker component right on the code line static let tertiarycolor colorliteral red 0 22 green 0 58 blue 0 29 alpha 1 0 when using objective c keep app wide constants in a constants h file that is included in the prefix header instead of preprocessor macro definitions via define use actual constants static cgfloat const xyzbrandingfontsizesmall 12 0f static nsstring const xyzawesomenessdeliverednotificationname foo actual constants are type safe have more explicit scope theyre not available in all imported included files until undefined cannot be redefined or undefined in later parts of the code and are available in the debugger branching model especially when distributing an app to the public e g through the app store its a good idea to isolate releases to their own branch with proper tags also feature work that involves a lot of commits should be done on its own branch git flow is a tool that helps you follow these conventions it is simply a convenience wrapper around gits branching and tagging commands but can help maintain a proper branching structure especially for teams do all development on feature branches or on develop for smaller work tag releases with the app version and commit to master only via git flow release finish version minimum ios version requirement its useful to make an early decision on the minimum ios version you want to support in your project knowing which os versions you need to develop and test against and which system apis you can rely on helps you estimate your workload and enables you to determine whats possible and whats not use these resources to gather the data necessary for making this choice official “first party” resources apples world wide ios version penetration statistics the primary public source for version penetration stats prefer more localized and domain specific statistics if available third party resources ios support matrix useful for determining which specific device models are ruled out by a given minimum os version requirement davidsmith ios version stats version penetration stats for david smiths audiobooks apps mixpanel trends ios versions version penetration stats from mixpanel common libraries generally speaking make it a conscious decision to add an external dependency to your project sure this one neat library solves your problem now but maybe later gets stuck in maintenance limbo with the next os version that breaks everything being just around the corner another scenario is that a feature only achievable with external libraries suddenly becomes part of the official apis in a well designed codebase switching out the implementation is a small effort that pays off quickly always consider solving the problem using apples extensive and mostly excellent frameworks first therefore this section has been deliberately kept rather short the libraries featured here tend to reduce boilerplate code e g auto layout or solve complex problems that require extensive testing such as date calculations as you become more proficient with ios be sure to dive into the source here and there and acquaint yourself with their underlying apple frameworks youll find that those alone can do a lot of the heavy lifting afnetworking alamofire the majority of ios developers use one of these network libraries while nsurlsession is surprisingly powerful by itself afnetworking and alamofire remain unbeaten when it comes to actually managing queues of requests which is pretty much a requirement of any modern app we recommend afnetworking for objective c projects and alamofire for swift projects while the two frameworks have subtle differences they share the same ideology and are published by the same foundation datetools as a general rule dont write your date calculations yourself luckily in datetools you get an mit licensed thoroughly tested library that covers pretty much all your calendar needs auto layout libraries if you prefer to write your views in code chances are youve heard of either apples awkward syntaxes – the regular nslayoutconstraint factory or the so called visual format language the former is extremely verbose and the latter based on strings which effectively prevents compile time checking fortunately theyve addressed the issue in ios 9 allowing a more concise specification of constraints if youre stuck with an earlier ios version masonry snapkit remedies the problem by introducing its own dsl to make update and replace constraints purelayout solves the same problem using cocoa api style for swift there is also cartography which builds on the languages powerful operator overloading features for the more conservative flkautolayout offers a clean but rather non magical wrapper around the native apis architecture model view controller store mvcs this is the default apple architecture mvc extended by a store layer that vends model instances and handles the networking caching etc every store exposes to the view controllers either signals or void methods with custom completion blocks model view viewmodel mvvm motivated by massive view controllers mvvm considers uiviewcontroller subclasses part of the view and keeps them slim by maintaining all state in the viewmodel to learn more about it check out bob spryns fantastic introduction view interactor presenter entity routing viper rather exotic architecture that might be worth looking into in larger projects where even mvvm feels too cluttered and testability is a major concern “event” patterns these are the idiomatic ways for components to notify others about things delegation one to one apple uses this a lot some would say too much use when you want to communicate stuff back e g from a modal view callback blocks one to one allow for a more loose coupling while keeping related code sections close to each other also scales better than delegation when there are many senders notification center one to many possibly the most common way for objects to emit “events” to multiple observers very loose coupling — notifications can even be observed globally without reference to the dispatching object key value observing kvo one to many does not require the observed object to explicitly “emit events” as long as it is key value coding kvc compliant for the observed keys properties usually not recommended due to its implicit nature and the cumbersome standard library api signals one to many the centerpiece of reactivecocoa they allow chaining and combining to your hearts content thereby offering a way out of callback hell models keep your models immutable and use them to translate the remote apis semantics and types to your app for objective c projects githubs mantle is a good choice in swift you can use structs instead of classes to ensure immutability and use a parsing library such as swiftyjson or argo to do the json to model mapping views with todays wealth of screen sizes in the apple ecosystem and the advent of split screen multitasking on ipad the boundaries between devices and form factors become increasingly blurred much like todays websites are expected to adapt to different browser window sizes your app should handle changes in available screen real estate in a graceful way this can happen e g if the user rotates the device or swipes in a secondary ipad app next to your own instead of manipulating view frames directly you should use size classes and auto layout to declare constraints on your views the system will then calculate the appropriate frames based on these rules and re evaluate them when the environment changes apples recommended approach for setting up your layout constraints is to create and activate them once during initialization if you need to change your constraints dynamically hold references to them and then deactivate activate them as required the main use case for uiviews updateconstraints or its uiviewcontroller counterpart updateviewconstraints is when you want the system to perform batch updates for better performance however this comes at the cost of having to call setneedsupdateconstraints elsewhere in your code increasing its complexity if you override updateconstraints in a custom view you should explicitly state that your view requires a constraint based layout swift swift override class var requiresconstraintbasedlayout bool return true objective c objective c bool requiresconstraintbasedlayout return yes otherwise you may encounter strange bugs when the system doesnt call updateconstraints as you would expect it to this blog post by edward huynh offers a more detailed explanation controllers use dependency injection i e pass any required objects in as parameters instead of keeping all state around in singletons the latter is okay only if the state really is global swift swift let fooviewcontroller fooviewcontroller withviewmodel fooviewmodel objective c objective c fooviewcontroller fooviewcontroller fooviewcontroller alloc initwithviewmodel fooviewmodel try to avoid bloating your view controllers with logic that can safely reside in other places soroush khanlou has a good writeup of how to achieve this and architectures like mvvm treat view controllers as views thereby greatly reducing their complexity stores at the ground level of a mobile app is usually some kind of model storage that keeps its data in places such as on disk in a local database or on a remote server this layer is also useful to abstract away any activities related to the vending of model objects such as caching whether it means kicking off a backend request or deserializing a large file from disk fetching data is often asynchronous in nature your stores api should reflect this by offering some kind of deferral mechanism as synchronously returning the data would cause the rest of your app to stall if youre using reactivecocoa signalproducer is a natural choice for the return type for instance fetching gigs for a given artist would yield the following signature swift reactiveswift swift func fetchgigs for artist artist signalproducer gig error objectivec reactiveobjc objective c racsignal nsarray gig fetchgigsforartist artist artist here the returned signalproducer is merely a recipe for getting a list of gigs only when started by the subscriber e g a view model will it perform the actual work of fetching the gigs unsubscribing before the data has arrived would then cancel the network request if you dont want to use signals futures or similar mechanisms to represent your future data you can also use a regular callback block keep in mind that chaining or nesting such blocks e g in the case where one network request depends on the outcome of another can quickly become very unwieldy – a condition generally known as callback hell assets asset catalogs are the best way to manage all your projects visual assets they can hold both universal and device specific iphone 4 inch iphone retina ipad etc assets and will automatically serve the correct ones for a given name teaching your designer s how to add and commit things there xcode has its own built in git client can save a lot of time that would otherwise be spent copying stuff from emails or other channels to the codebase it also allows them to instantly try out their changes and iterate if needed using bitmap images asset catalogs expose only the names of image sets abstracting away the actual file names within the set this nicely prevents asset name conflicts as files such as button large 2x png are now namespaced inside their image sets appending the modifiers 568h 2x iphone and ipad are not required per se but having them in the file name when dragging the file to an image set will automatically place them in the right slot thereby preventing assignment mistakes that can be hard to hunt down using vector images you can include the original vector graphics pdfs produced by designers into the asset catalogs and have xcode automatically generate the bitmaps from that this reduces the complexity of your project the number of files to manage image optimisation xcode automatically tries to optimise resources living in asset catalogs yet another reason to use them developers can choose from lossless and lossy compression algorithms app icons are an exception apps with large or unoptimised app icons are known to be rejected by apple for app icons and more advanced optimisation of png files we recommend using pngcrush or imageoptim its gui counterpart coding style naming apple pays great attention to keeping naming consistent adhering to their coding guidelines for objective c and api design guidelines for swift makes it much easier for new people to join the project here are some basic takeaways you can start using right away a method beginning with a verb indicates that it performs some side effects but wont return anything void loadview void startanimating any method starting with a noun however returns that object and should do so without side effects uinavigationitem navigationitem uilabel labelwithtext nsstring text it pays off to keep these two as separated as possible i e not perform side effects when you transform data and vice versa that will keep your side effects contained to smaller sections of the code which makes it more understandable and facilitates debugging structure mark comments swift and pragma marks objective c are a great way to group your methods especially in view controllers here is a swift example for a common structure that works with almost any view controller swift import someexternalframework class fooviewcontroller uiviewcontroller foobardelegate let foo foo private let foostringconstant fooconstant private let floatconstant 1234 5 mark lifecycle custom initializers go here mark view lifecycle override func viewdidload super viewdidload mark layout private func makeviewconstraints mark user interaction func foobarbuttontapped mark foobardelegate func foobar foobar foobar didsomethingwithfoo foo foo mark additional helpers private func displaynameforfoo foo foo the most important point is to keep these consistent across your projects classes external style guides futurice does not have company level guidelines for coding style it can however be useful to peruse the style guides of other software companies even if some bits can be quite company specific or opinionated github swift and objective c ray wenderlich swift and objective c google objective c the new york times objective c sam soffes objective c luke redpath objective c security even in an age where we trust our portable devices with the most private data app security remains an often overlooked subject try to find a good trade off given the nature of your data following just a few simple rules can go a long way here a good resource to get started is apples own ios security guide data storage if your app needs to store sensitive data such as a username and password an authentication token or some personal user details you need to keep these in a location where they cannot be accessed from outside the app never use nsuserdefaults other plist files on disk or core data for this as they are not encrypted in most such cases the ios keychain is your friend if youre uncomfortable working with the c apis directly you can use a wrapper library such as sskeychain or uickeychainstore when storing files and passwords be sure to set the correct protection level and choose it conservatively if you need access while the device is locked e g for background tasks use the accessible after first unlock variety in other cases you should probably require that the device is unlocked to access the data only keep sensitive data around while you need it networking keep any http traffic to remote servers encrypted with tls at all times to avoid man in the middle attacks that intercept your encrypted traffic you can set up certificate pinning popular networking libraries such as afnetworking and alamofire support this out of the box logging take extra care to set up proper log levels before releasing your app production builds should never log passwords api tokens and the like as this can easily cause them to leak to the public on the other hand logging the basic control flow can help you pinpoint issues that your users are experiencing user interface when using uitextfields for password entry remember to set their securetextentry property to true to avoid showing the password in cleartext you should also disable auto correction for the password field and clear the field whenever appropriate such as when your app enters the background when this happens its also good practice to clear the pasteboard to avoid passwords and other sensitive data from leaking as ios may take screenshots of your app for display in the app switcher make sure to clear any sensitive data from the ui before returning from applicationdidenterbackground diagnostics compiler warnings enable as many compiler warnings as possible and treat those warnings as errors it will be worth it in the long run for objective c code add these values to the “other warning flags” build setting wall enables lots of additional warnings wextra enables more additional warnings and then enable the “treat warnings as errors” build setting to treat warnings as errors for swift code add warnings as errors to the other swift flags build setting clang static analyzer the clang compiler which xcode uses has a static analyzer that performs control and data flow analysis on your code and checks for lots of errors that the compiler cannot you can manually run the analyzer from the product → analyze menu item in xcode the analyzer can work in either “shallow” or “deep” mode the latter is much slower but may find more issues due to cross function control and data flow analysis recommendations enable all of the checks in the analyzer by enabling all of the options in the “static analyzer” build setting sections enable the “analyze during ‘build” build setting for your release build configuration to have the analyzer run automatically during release builds seriously do this — youre not going to remember to run it manually set the “mode of analysis for ‘analyze” build setting to shallow faster set the “mode of analysis for ‘build” build setting to deep faux pas created by our very own ali rantakari faux pas is a fabulous static error detection tool it analyzes your codebase and finds issues you had no idea even existed there is no swift support yet but the tool also offers plenty of language agnostic rules be sure to run it before shipping any ios or mac app note all futurice employees get a free license to this — just ask ali debugging when your app crashes xcode does not break into the debugger by default to achieve this add an exception breakpoint click the at the bottom of xcodes breakpoint navigator to halt execution whenever an exception is raised in many cases you will then see the line of code responsible for the exception this catches any exception even handled ones if xcode keeps breaking on benign exceptions in third party libraries e g you might be able to mitigate this by choosing edit breakpoint and setting the exception drop down to objective c for view debugging reveal and spark inspector are two powerful visual inspectors that can save you hours of time especially if youre using auto layout and want to locate views that are collapsed or off screen xcode also has integrated view debugger which is good enough and free to use profiling xcode comes with a profiling suite called instruments it contains a myriad of tools for profiling memory usage cpu network communications graphics and much more its a complex beast but one of its more straight forward use cases is tracking down memory leaks with the allocations instrument simply choose product profile in xcode select the allocations instrument hit the record button and filter the allocation summary on some useful string like the prefix of your own apps class names the count in the persistent column then tells you how many instances of each object you have any class for which the instance count increases indiscriminately indicates a memory leak pay extra attention to how and where you create expensive classes nsdateformatter for instance is very expensive to create and doing so in rapid succession e g inside a tableview cellforrowatindexpath method can really slow down your app instead keep a static instance of it around for each date format that you need analytics including some analytics framework in your app is strongly recommended as it allows you to gain insights on how people actually use it does feature x add value is button y too hard to find to answer these you can send events timings and other measurable information to a service that aggregates and visualizes them – for instance google tag manager the latter is more versatile than google analytics in that it inserts a data layer between app and analytics so that the data logic can be modified through a web service without having to update the app a good practice is to create a slim helper class e g analyticshelper that handles the translation from app internal models and data formats foomodel nstimeinterval … to the mostly string based data layer swift func pushadditemevent with item item editmode editmode let editmodestring name for editmode pushtodatalayer event additem itemidentifier item identifier editmode editmodestring this has the additional advantage of allowing you to swap out the entire analytics framework behind the scenes if needed without the rest of the app noticing crash logs first you should make your app send crash logs onto a server somewhere so that you can access them you can implement this manually using plcrashreporter and your own backend but its recommended that you use an existing service instead — for example one of the following fabric hockeyapp crittercism splunk mintexpress instabug once you have this set up ensure that you save the xcode archive xcarchive of every build you release the archive contains the built app binary and the debug symbols dsym which you will need to symbolicate crash reports from that particular version of your app building this section contains an overview of this topic — please refer here for more comprehensive information ios developer library xcode concepts samantha marshall managing xcode build configurations even simple apps can be built in different ways the most basic separation that xcode gives you is that between debug and release builds for the latter there is a lot more optimization going on at compile time at the expense of debugging possibilities apple suggests that you use the debug build configuration for development and create your app store packages using the release build configuration this is codified in the default scheme the dropdown next to the play and stop buttons in xcode which commands that debug be used for run and release for archive however this is a bit too simple for real world applications you might – no should – have different environments for testing staging and other activities related to your service each might have its own base url log level bundle identifier so you can install them side by side provisioning profile and so on therefore a simple debug release distinction wont cut it you can add more build configurations on the info tab of your project settings in xcode xcconfig files for build settings typically build settings are specified in the xcode gui but you can also use configuration settings files “ xcconfig files” for them the benefits of using these are you can add comments to explain things you can include other build settings files which helps you avoid repeating yourself if you have some settings that apply to all build configurations add a common xcconfig and include it in all the other files if you e g want to have a “debug” build configuration that enables compiler optimizations you can just include myapp debug xcconfig and override one of the settings conflict resolution and merging becomes easier find more information about this topic in these presentation slides targets a target resides conceptually below the project level i e a project can have several targets that may override its project settings roughly each target corresponds to an app within the context of your codebase for instance you could have country specific apps built from the same codebase for different countries app stores each of these will need development staging release builds so its better to handle those through build configurations not targets its not uncommon at all for an app to only have a single target schemes schemes tell xcode what should happen when you hit the run test profile analyze or archive action basically they map each of these actions to a target and a build configuration you can also pass launch arguments such as the language the app should run in handy for testing your localizations or set some diagnostic flags for debugging a suggested naming convention for schemes is myapp language environment myapp english development myapp german development myapp testing myapp staging myapp app store for most environments the language is not needed as the app will probably be installed through other means than xcode e g testflight and the launch argument thus be ignored anyway in that case the device language should be set manually to test localization deployment deploying software on ios devices isnt exactly straightforward that being said here are some central concepts that once understood will help you tremendously with it signing whenever you want to run software on an actual device as opposed to the simulator you will need to sign your build with a certificate issued by apple each certificate is linked to a private public keypair the private half of which resides in your macs keychain there are two types of certificates development certificate every developer on a team has their own and it is generated upon request xcode might do this for you but its better not to press the magic fix issue button and understand what is actually going on this certificate is needed to deploy development builds to devices distribution certificate there can be several but its best to keep it to one per organization and share its associated key through some internal channel this certificate is needed to ship to the app store or your organizations internal enterprise app store provisioning besides certificates there are also provisioning profiles which are basically the missing link between devices and certificates again there are two types to distinguish between development and distribution purposes development provisioning profile it contains a list of all devices that are authorized to install and run the software it is also linked to one or more development certificates one for each developer that is allowed to use the profile the profile can be tied to a specific app or use a wildcard app id the latter is discouraged because xcode is notoriously bad at picking the correct files for signing unless guided in the right direction also certain capabilities like push notifications or app groups require an explicit app id distribution provisioning profile there are three different ways of distribution each for a different use case each distribution profile is linked to a distribution certificate and will be invalid when the certificate expires ad hoc just like development profiles it contains a whitelist of devices the app can be installed to this type of profile can be used for beta testing on 100 devices per year for a smoother experience and up to 1000 distinct users you can use apples newly acquired testflight service supertop offers a good summary of its advantages and issues app store this profile has no list of allowed devices as anyone can install it through apples official distribution channel this profile is required for all app store releases enterprise just like app store there is no device whitelist and the app can be installed by anyone with access to the enterprises internal app store which can be just a website with links this profile is available only on enterprise accounts to sync all certificates and profiles to your machine go to accounts in xcodes preferences add your apple id if needed and double click your team name there is a refresh button at the bottom but sometimes you just need to restart xcode to make everything show up debugging provisioning sometimes you need to debug a provisioning issue for instance xcode may refuse to install the build to an attached device because the latter is not on the development or ad hoc profiles device list in those cases you can use craig hockenberrys excellent provisioning plugin by browsing to library mobiledevice provisioning profiles selecting a mobileprovision file and hitting space to launch finders quick look feature it will show you a wealth of information such as devices entitlements certificates and the app id when dealing with an existing app archive ipa you can inspect its provisioning profile in a similar fashion simply rename the ipa to zip unpack it and find the app package within from its finder context menu choose show package contents to see a file called embedded mobileprovision that you can examine with the above method uploading itunes connect is apples portal for managing your apps on the app store to upload a build xcode 6 requires an apple id that is part of the developer account used for signing this can make things tricky when you are part of several developer accounts and want to upload their apps as for mysterious reasons any given apple id can only be associated with a single itunes connect account one workaround is to create a new apple id for each itunes connect account you need to be part of and use application loader instead of xcode to upload the builds that effectively decouples the building and signing process from the upload of the resulting app file after uploading the build be patient as it can take up to an hour for it to show up under the builds section of your app version when it appears you can link it to the app version and submit your app for review in app purchases iap when validating in app purchase receipts remember to perform the following checks authenticity that the receipt comes from apple integrity that the receipt has not been tampered with app match that the app bundle id in the receipt matches your apps bundle identifier product match that the product id in the receipt matches your expected product identifier freshness that you havent seen the same receipt id before whenever possible design your iap system to store the content for sale server side and provide it to the client only in exchange for a valid receipt that passes all of the above checks this kind of a design thwarts common piracy mechanisms and — since the validation is performed on the server — allows you to use apples http receipt validation service instead of interpreting the receipt pkcs 7 asn 1 format yourself for more information on this topic check out the futurice blog validating in app purchases in your ios app license futurice • creative commons attribution 4 0 international cc by 4 0 more ideas add list of suggested compiler warnings ask it about automated jenkins build machine add section on testing add proven donts