nginx proxy sets up a container running nginx and docker gen docker gen generates reverse proxy configs for nginx and reloads nginx when containers are started and stopped see automated nginx reverse proxy for docker for why you might want to use this usage to run it docker run d p 80 80 v var run docker sock tmp docker sock ro jwilder nginx proxy then start any containers you want proxied with an env var virtual host subdomain youdomain com docker run e virtual host foo bar com the containers being proxied must expose the port to be proxied either by using the expose directive in their dockerfile or by using the expose flag to docker run or docker create provided your dns is setup to forward foo bar com to the host running nginx proxy the request will be routed to a container with the virtual host env var set image variants the nginx proxy images are available in two flavors jwilder nginx proxy latest this image uses the debian jessie based nginx image docker pull jwilder nginx proxy latest jwilder nginx proxy alpine this image is based on the nginx alpine image use this image to fully support http 2 including alpn required by recent chrome versions a valid certificate is required as well see eg below ssl support using letsencrypt for more info docker pull jwilder nginx proxy alpine docker compose yaml version 2 services nginx proxy image jwilder nginx proxy ports 80 80 volumes var run docker sock tmp docker sock ro whoami image jwilder whoami environment virtual host whoami local shell docker compose up curl h host whoami local localhost im 5b129ab83266 ipv6 support you can activate the ipv6 support for the nginx proxy container by passing the value true to the enable ipv6 environment variable docker run d p 80 80 e enable ipv6 true v var run docker sock tmp docker sock ro jwilder nginx proxy multiple ports if your container exposes multiple ports nginx proxy will default to the service running on port 80 if you need to specify a different port you can set a virtual port env var to select a different one if your container only exposes one port and it has a virtual host env var set that port will be selected multiple hosts if you need to support multiple virtual hosts for a container you can separate each entry with commas for example foo bar com baz bar com bar com and each host will be setup the same wildcard hosts you can also use wildcards at the beginning and the end of host name like bar com or foo bar or even a regular expression which can be very useful in conjunction with a wildcard dns service like xip io using foo\ bar\ \ xip\ io will match foo bar 127 0 0 1 xip io foo bar 10 0 2 2 xip io and all other given ips more information about this topic can be found in the nginx documentation about server names multiple networks with the addition of overlay networking in docker 1 9 your nginx proxy container may need to connect to backend containers on multiple networks by default if you dont pass the net flag when your nginx proxy container is created it will only be attached to the default bridge network this means that it will not be able to connect to containers on networks other than bridge if you want your nginx proxy container to be attached to a different network you must pass the net my network option in your docker create or docker run command at the time of this writing only a single network can be specified at container creation time to attach to other networks you can use the docker network connect command after your container is created console docker run d p 80 80 v var run docker sock tmp docker sock ro \ name my nginx proxy net my network jwilder nginx proxy docker network connect my other network my nginx proxy in this example the my nginx proxy container will be connected to my network and my other network and will be able to proxy to other containers attached to those networks internet vs local network access if you allow traffic from the public internet to access your nginx proxy container you may want to restrict some containers to the internal network only so they cannot be accessed from the public internet on containers that should be restricted to the internal network you should set the environment variable network access internal by default the internal network is defined as 127 0 0 0 8 10 0 0 0 8 172 16 0 0 12 192 168 0 0 16 to change the list of networks considered internal mount a file on the nginx proxy at etc nginx network internal conf with these contents edited to suit your needs these networks are considered internal allow 127 0 0 0 8 allow 10 0 0 0 8 allow 192 168 0 0 16 allow 172 16 0 0 12 traffic from all other networks will be rejected deny all when internal only access is enabled external clients with be denied with an http 403 forbidden if there is a load balancer reverse proxy in front of nginx proxy that hides the client ip example aws application elastic load balancer you will need to use the nginx realip module already installed to extract the clients ip from the http request headers please see the nginx realip module configuration for more details this configuration can be added to a new config file and mounted in etc nginx conf d ssl backends if you would like the reverse proxy to connect to your backend using https instead of http set virtual proto https on the backend container note if you use virtual proto https and your backend container exposes port 80 and 443 nginx proxy will use https on port 80 this is almost certainly not what you want so you should also include virtual port 443 uwsgi backends if you would like to connect to uwsgi backend set virtual proto uwsgi on the backend container your backend container should then listen on a port rather than a socket and expose that port fastcgi backends if you would like to connect to fastcgi backend set virtual proto fastcgi on the backend container your backend container should then listen on a port rather than a socket and expose that port fastcgi filr root directory if you use fastcgi you can set virtual root xxx for your root directory default host to set the default host for nginx use the env var default host foo bar com for example docker run d p 80 80 e default host foo bar com v var run docker sock tmp docker sock ro jwilder nginx proxy separate containers nginx proxy can also be run as two separate containers using the jwilder docker gen image and the official nginx image you may want to do this to prevent having the docker socket bound to a publicly exposed container service you can demo this pattern with docker compose console docker compose file docker compose separate containers yml up curl h host whoami local localhost im 5b129ab83266 to run nginx proxy as a separate container youll need to have nginx tmpl on your host system first start nginx with a volume docker run d p 80 80 name nginx v tmp nginx etc nginx conf d t nginx then start the docker gen container with the shared volume and template docker run volumes from nginx \ v var run docker sock tmp docker sock ro \ v pwd etc docker gen templates \ t jwilder docker gen notify sighup nginx watch etc docker gen templates nginx tmpl etc nginx conf d default conf finally start your containers with virtual host environment variables docker run e virtual host foo bar com ssl support using letsencrypt letsencrypt nginx proxy companion is a lightweight companion container for the nginx proxy it allow the creation renewal of lets encrypt certificates automatically ssl support ssl is supported using single host wildcard and sni certificates using naming conventions for certificates or optionally specifying a cert name for sni as an environment variable to enable ssl docker run d p 80 80 p 443 443 v path to certs etc nginx certs v var run docker sock tmp docker sock ro jwilder nginx proxy the contents of path to certs should contain the certificates and private keys for any virtual hosts in use the certificate and keys should be named after the virtual host with a crt and key extension for example a container with virtual host foo bar com should have a foo bar com crt and foo bar com key file in the certs directory if you are running the container in a virtualized environment hyper v virtualbox etc path to certs must exist in that environment or be made accessible to that environment by default docker is not able to mount directories on the host machine to containers running in a virtual machine diffie hellman groups diffie hellman groups are enabled by default with a pregenerated key in etc nginx dhparam dhparam pem you can mount a different dhparam pem file at that location to override the default cert to use custom dhparam pem files per virtual host the files should be named after the virtual host with a dhparam suffix and pem extension for example a container with virtual host foo bar com should have a foo bar com dhparam pem file in the etc nginx certs directory note if you dont mount a dhparam pem file at etc nginx dhparam dhparam pem one will be generated at startup since it can take minutes to generate a new dhparam pem it is done at low priority in the background once generation is complete the dhparam pem is saved on a persistent volume and nginx is reloaded this generation process only occurs the first time you start nginx proxy compatibility warning the default generated dhparam pem key is 2048 bits for a security some older clients like java 6 and 7 do not support dh keys with over 1024 bits in order to support these clients you must either provide your own dhparam pem or tell nginx proxy to generate a 1024 bit key on startup by passing e dhparam bits 1024 in the separate container setup no pregenerated key will be available and neither the jwilder docker gen image nor the offical nginx image will generate one if you still want a security in a separate container setup youll have to generate a 2048 bits dh key file manually and mount it on the nginx container at etc nginx dhparam dhparam pem wildcard certificates wildcard certificates and keys should be named after the domain name with a crt and key extension for example virtual host foo bar com would use cert name bar com crt and bar com key sni if your certificate s supports multiple domain names you can start a container with cert name name to identify the certificate to be used for example a certificate for foo com and bar com could be named shared crt and shared key a container running with virtual host foo bar com and cert name shared will then use this shared cert ocsp stapling to enable ocsp stapling for a domain nginx proxy looks for a pem certificate containing the trusted ca certificate chain at etc nginx certs domain chain pem where domain is the domain name in the virtual host directive the format of this file is a concatenation of the public pem ca certificates starting with the intermediate ca most near the ssl certificate down to the root ca this is often referred to as the ssl certificate chain if found this filename is passed to the nginx ssl trusted certificate directive and ocsp stapling is enabled how ssl support works the default ssl cipher configuration is based on the mozilla intermediate profile which should provide compatibility with clients back to firefox 1 chrome 1 ie 7 opera 5 safari 1 windows xp ie8 android 2 3 java 7 note that the des based tls ciphers were removed for security the configuration also enables hsts pfs ocsp stapling and ssl session caches currently tls 1 0 1 1 and 1 2 are supported tls 1 0 is deprecated but its end of life is not until june 30 2018 it is being included because the following browsers will stop working when it is removed chrome 22 firefox 27 ie 11 safari 7 ios 5 android browser 5 if you dont require backward compatibility you can use the mozilla modern profile profile instead by including the environment variable ssl policy mozilla modern to your container this profile is compatible with clients back to firefox 27 chrome 30 ie 11 on windows 7 edge opera 17 safari 9 android 5 0 and java 8 other policies available through the ssl policy environment variable are mozilla old and the aws elb security policies aws tls 1 2 2017 01 aws tls 1 1 2017 01 aws 2016 08 aws 2015 05 aws 2015 03 and aws 2015 02 note that the mozilla old policy should use a 1024 bits dh key for compatibility but this container generates a 2048 bits key the diffie hellman groups section details different methods of bypassing this either globally or per virtual host the default behavior for the proxy when port 80 and 443 are exposed is as follows if a container has a usable cert port 80 will redirect to 443 for that container so that https is always preferred when available if the container does not have a usable cert a 503 will be returned note that in the latter case a browser may get an connection error as no certificate is available to establish a connection a self signed or generic cert named default crt and default key will allow a client browser to make a ssl connection likely w a warning and subsequently receive a 500 to serve traffic in both ssl and non ssl modes without redirecting to ssl you can include the environment variable https method noredirect the default is https method redirect you can also disable the non ssl site entirely with https method nohttp or disable the https site with https method nohttps https method must be specified on each container for which you want to override the default behavior if https method noredirect is used strict transport security hsts is disabled to prevent https users from being redirected by the client if you cannot get to the http site after changing this setting your browser has probably cached the hsts policy and is automatically redirecting you back to https you will need to clear your browsers hsts cache or use an incognito window different browser by default http strict transport security hsts is enabled with max age 31536000 for https sites you can disable hsts with the environment variable hsts off or use a custom hsts configuration like hsts max age 31536000 includesubdomains preload warning hsts will force your users to visit the https version of your site for the max age time even if they type in http manually the only way to get to an http site after receiving an hsts response is to clear your browsers hsts cache basic authentication support in order to be able to secure your virtual host you have to create a file named as its equivalent virtual host variable on directory etc nginx htpasswd virtual host docker run d p 80 80 p 443 443 \ v path to htpasswd etc nginx htpasswd \ v path to certs etc nginx certs \ v var run docker sock tmp docker sock ro \ jwilder nginx proxy youll need apache2 utils on the machine where you plan to create the htpasswd file follow these instructions custom nginx configuration if you need to configure nginx beyond what is possible using environment variables you can provide custom configuration files on either a proxy wide or per virtual host basis replacing default proxy settings if you want to replace the default proxy settings for the nginx container add a configuration file at etc nginx proxy conf a file with the default settings would look like this nginx http 1 1 support proxy http version 1 1 proxy buffering off proxy set header host http host proxy set header upgrade http upgrade proxy set header connection proxy connection proxy set header x real ip remote addr proxy set header x forwarded for proxy add x forwarded for proxy set header x forwarded proto proxy x forwarded proto proxy set header x forwarded ssl proxy x forwarded ssl proxy set header x forwarded port proxy x forwarded port mitigate httpoxy attack see readme for details proxy set header proxy note if you provide this file it will replace the defaults you may want to check the tmpl file to make sure you have all of the needed options note the default configuration blocks the proxy http request header from being sent to downstream servers this prevents attackers from using the so called httpoxy attack there is no legitimate reason for a client to send this header and there are many vulnerable languages platforms cve 2016 5385 cve 2016 5386 cve 2016 5387 cve 2016 5388 cve 2016 1000109 cve 2016 1000110 cert vu 797896 proxy wide to add settings on a proxy wide basis add your configuration file under etc nginx conf d using a name ending in conf this can be done in a derived image by creating the file in a run command or by copying the file into conf d dockerfile from jwilder nginx proxy run \ echo server tokens off \ echo client max body size 100m \ etc nginx conf d my proxy conf or it can be done by mounting in your custom configuration in your docker run command docker run d p 80 80 p 443 443 v path to my proxy conf etc nginx conf d my proxy conf ro v var run docker sock tmp docker sock ro jwilder nginx proxy per virtual host to add settings on a per virtual host basis add your configuration file under etc nginx vhost d unlike in the proxy wide case which allows multiple config files with any name ending in conf the per virtual host file must be named exactly after the virtual host in order to allow virtual hosts to be dynamically configured as backends are added and removed it makes the most sense to mount an external directory as etc nginx vhost d as opposed to using derived images or mounting individual configuration files for example if you have a virtual host named app example com you could provide a custom configuration for that host as follows docker run d p 80 80 p 443 443 v path to vhost d etc nginx vhost d ro v var run docker sock tmp docker sock ro jwilder nginx proxy echo server tokens off echo client max body size 100m path to vhost d app example com if you are using multiple hostnames for a single container e g virtual host example com www example com the virtual host configuration file must exist for each hostname if you would like to use the same configuration for multiple virtual host names you can use a symlink echo server tokens off echo client max body size 100m path to vhost d www example com ln s path to vhost d www example com path to vhost d example com per virtual host default configuration if you want most of your virtual hosts to use a default single configuration and then override on a few specific ones add those settings to the etc nginx vhost d default file this file will be used on any virtual host which does not have a etc nginx vhost d virtual host file associated with it per virtual host location configuration to add settings to the location block on a per virtual host basis add your configuration file under etc nginx vhost d just like the previous section except with the suffix location for example if you have a virtual host named app example com and you have configured a proxy cache my cache in another custom file you could tell it to use a proxy cache as follows docker run d p 80 80 p 443 443 v path to vhost d etc nginx vhost d ro v var run docker sock tmp docker sock ro jwilder nginx proxy echo proxy cache my cache echo proxy cache valid 200 302 60m echo proxy cache valid 404 1m path to vhost d app example com location if you are using multiple hostnames for a single container e g virtual host example com www example com the virtual host configuration file must exist for each hostname if you would like to use the same configuration for multiple virtual host names you can use a symlink echo proxy cache my cache echo proxy cache valid 200 302 60m echo proxy cache valid 404 1m path to vhost d app example com location ln s path to vhost d www example com path to vhost d example com per virtual host location default configuration if you want most of your virtual hosts to use a default single location block configuration and then override on a few specific ones add those settings to the etc nginx vhost d default location file this file will be used on any virtual host which does not have a etc nginx vhost d virtual host location file associated with it contributing before submitting pull requests or issues please check github to make sure an existing issue or pull request is not already open running tests locally to run tests you need to prepare the docker image to test which must be tagged jwilder nginx proxy test docker build t jwilder nginx proxy test build the debian variant image and call the test pytest sh script then build the alpine variant of the image docker build f dockerfile alpine t jwilder nginx proxy test build the alpline variant image and call the test pytest sh script again if your system has the make command you can automate those tasks by calling make test you can learn more about how the test suite works and how to write new tests in the test readme md file need help if you have questions on how to use the image please ask them on the q a group