rxjava reactive extensions for the jvm rxjava is a java vm implementation of reactive extensions a library for composing asynchronous and event based programs by using observable sequences it extends the observer pattern to support sequences of data events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low level threading synchronization thread safety and concurrent data structures version 2 x javadoc single dependency reactive streams continued support for java 6 android 2 3 performance gains through design changes learned through the 1 x cycle and through reactive streams commons research project java 8 lambda friendly api non opinionated about source of concurrency threads pools event loops fibers actors etc async or synchronous execution virtual time and schedulers for parameterized concurrency version 2 x and 1 x will live side by side for several years they will have different group ids io reactivex rxjava2 vs io reactivex and namespaces io reactivex vs rx see the differences between version 1 x and 2 x in the wiki article whats different in 2 0 learn more about rxjava in general on the wiki home version 1 x the 1 x version is end of life as of march 31 2018 no further development support maintenance prs and updates will happen the javadoc of the very last version 1 3 8 will remain accessible getting started setting up the dependency the first step is to include rxjava 2 into your project for example as a gradle compile dependency groovy compile io reactivex rxjava2 rxjava 2 x y please replace x and y with the latest version numbers hello world the second is to write the hello world program java package rxjava examples import io reactivex public class helloworld public static void main string args flowable just hello world subscribe system out println if your platform doesnt support java 8 lambdas yet you have to create an inner class of consumer manually java import io reactivex functions consumer flowable just hello world subscribe new consumer override public void accept string s system out println s base classes rxjava 2 features several base classes you can discover operators on io reactivex flowable 0 n flows supporting reactive streams and backpressure io reactivex observable 0 n flows no backpressure io reactivex single a flow of exactly 1 item or an error io reactivex completable a flow without items but only a completion or error signal io reactivex maybe a flow with no items exactly one item or an error some terminology upstream downstream the dataflows in rxjava consist of a source zero or more intermediate steps followed by a data consumer or combinator step where the step is responsible to consume the dataflow by some means java source operator1 operator2 operator3 subscribe consumer source flatmap value source operator1 operator2 operator3 here if we imagine ourselves on operator2 looking to the left towards the source is called the upstream looking to the right towards the subscriber consumer is called the downstream this is often more apparent when each element is written on a separate line java source operator1 operator2 operator3 subscribe consumer objects in motion in rxjavas documentation emission emits item event signal data and message are considered synonyms and represent the object traveling along the dataflow backpressure when the dataflow runs through asynchronous steps each step may perform different things with different speed to avoid overwhelming such steps which usually would manifest itself as increased memory usage due to temporary buffering or the need for skipping dropping data a so called backpressure is applied which is a form of flow control where the steps can express how many items are they ready to process this allows constraining the memory usage of the dataflows in situations where there is generally no way for a step to know how many items the upstream will send to it in rxjava the dedicated flowable class is designated to support backpressure and observable is dedicated for the non backpressured operations short sequences gui interactions etc the other types single maybe and completable dont support backpressure nor should they there is always room to store one item temporarily assembly time the preparation of dataflows by applying various intermediate operators happens in the so called assembly time java flowable integer flow flowable range 1 5 map v v v filter v v 3 0 at this point the data is not flowing yet and no side effects are happening subscription time this is a temporary state when subscribe is called on a flow that establishes the chain of processing steps internally java flow subscribe system out println this is when the subscription side effects are triggered see doonsubscribe some sources block or start emitting items right away in this state runtime this is the state when the flows are actively emitting items errors or completion signals java observable create emitter while emitter isdisposed long time system currenttimemillis emitter onnext time if time 2 0 emitter onerror new illegalstateexception odd millisecond break subscribe system out println throwable printstacktrace practically this is when the body of the given example above executes simple background computation one of the common use cases for rxjava is to run some computation network request on a background thread and show the results or error on the ui thread java import io reactivex schedulers schedulers flowable fromcallable thread sleep 1000 imitate expensive computation return done subscribeon schedulers io observeon schedulers single subscribe system out println throwable printstacktrace thread sleep 2000 wait for the flow to finish this style of chaining methods is called a fluent api which resembles the builder pattern however rxjavas reactive types are immutable each of the method calls returns a new flowable with added behavior to illustrate the example can be rewritten as follows java flowable source flowable fromcallable thread sleep 1000 imitate expensive computation return done flowable runbackground source subscribeon schedulers io flowable showforeground runbackground observeon schedulers single showforeground subscribe system out println throwable printstacktrace thread sleep 2000 typically you can move computations or blocking io to some other thread via subscribeon once the data is ready you can make sure they get processed on the foreground or gui thread via observeon schedulers rxjava operators dont work with threads or executorservices directly but with so called schedulers that abstract away sources of concurrency behind an uniform api rxjava 2 features several standard schedulers accessible via schedulers utility class schedulers computation run computation intensive work on a fixed number of dedicated threads in the background most asynchronous operator use this as their default scheduler schedulers io run i o like or blocking operations on a dynamically changing set of threads schedulers single run work on a single thread in a sequential and fifo manner schedulers trampoline run work in a sequential and fifo manner in one of the participating threads usually for testing purposes these are available on all jvm platforms but some specific platforms such as android have their own typical schedulers defined androidschedulers mainthread swingscheduler instance or javafxschedulers gui in addition there is option to wrap an existing executor and its subtypes such as executorservice into a scheduler via schedulers from executor this can be used for example to have a larger but still fixed pool of threads unlike computation and io respectively the thread sleep 2000 at the end is no accident in rxjava the default schedulers run on daemon threads which means once the java main thread exits they all get stopped and background computations may never happen sleeping for some time in this example situations lets you see the output of the flow on the console with time to spare concurrency within a flow flows in rxjava are sequential in nature split into processing stages that may run concurrently with each other java flowable range 1 10 observeon schedulers computation map v v v blockingsubscribe system out println this example flow squares the numbers from 1 to 10 on the computation scheduler and consumes the results on the main thread more precisely the caller thread of blockingsubscribe however the lambda v v v doesnt run in parallel for this flow it receives the values 1 to 10 on the same computation thread one after the other parallel processing processing the numbers 1 to 10 in parallel is a bit more involved java flowable range 1 10 flatmap v flowable just v subscribeon schedulers computation map w w w blockingsubscribe system out println practically parallelism in rxjava means running independent flows and merging their results back into a single flow the operator flatmap does this by first mapping each number from 1 to 10 into its own individual flowable runs them and merges the computed squares note however that flatmap doesnt guarantee any order and the end result from the inner flows may end up interleaved there are alternative operators concatmap that maps and runs one inner flow at a time and concatmapeager which runs all inner flows at once but the output flow will be in the order those inner flows were created alternatively there is a beta operator flowable parallel and type parallelflowable that helps achieve the same parallel processing pattern java flowable range 1 10 parallel runon schedulers computation map v v v sequential blockingsubscribe system out println dependent sub flows flatmap is a powerful operator and helps in a lot of situations for example given a service that returns a flowable wed like to call another service with values emitted by the first service java flowable inventorysource warehouse getinventoryasync inventorysource flatmap inventoryitem erp getdemandasync inventoryitem getid map demand system out println item inventoryitem getname has demand demand subscribe continuations sometimes when an item has become available one would like to perform some dependent computations on it this is sometimes called continuations and depending on what should happen and what types are involved may involve various operators to accomplish dependent the most typical scenario is to given a value invoke another service await and continue with its result java service apicall flatmap value service anotherapicall value flatmap next service finalcall next it is often the case also that later sequences would require values from earlier mappings this can be achieved by moving the outer flatmap into the inner parts of the previous flatmap for example java service apicall flatmap value service anotherapicall value flatmap next service finalcallboth value next here the original value will be available inside the inner flatmap courtesy of lambda variable capture non dependent in other scenarios the result s of the first source dataflow is irrelevant and one would like to continue with a quasi independent another source here flatmap works as well java observable continued sourceobservable flatmapsingle ignored somesinglesource continued map v v tostring subscribe system out println throwable printstacktrace however the continuation in this case stays observable instead of the likely more appropriate single this is understandable because from the perspective of flatmapsingle sourceobservable is a multi valued source and thus the mapping may result in multiple values as well often though there is a way that is somewhat more expressive and also lower overhead by using completable as the mediator and its operator andthen to resume with something else java sourceobservable ignoreelements returns completable andthen somesinglesource map v v tostring the only dependency between the sourceobservable and the somesinglesource is that the former should complete normally in order for the latter to be consumed deferred dependent sometimes there is an implicit data dependency between the previous sequence and the new sequence that for some reason was not flowing through the regular channels one would be inclined to write such continuations as follows java atomicinteger count new atomicinteger observable range 1 10 doonnext ignored count incrementandget ignoreelements andthen single just count get subscribe system out println unfortunately this prints 0 because single just count get is evaluated at assembly time when the dataflow hasnt even run yet we need something that defers the evaluation of this single source until runtime when the main source completes java atomicinteger count new atomicinteger observable range 1 10 doonnext ignored count incrementandget ignoreelements andthen single defer single just count get subscribe system out println or java atomicinteger count new atomicinteger observable range 1 10 doonnext ignored count incrementandget ignoreelements andthen single fromcallable count get subscribe system out println type conversions sometimes a source or service returns a different type than the flow that is supposed to work with it for example in the inventory example above getdemandasync could return a single demandrecord if the code example is left unchanged this will result in a compile time error however often with misleading error message about lack of overload in such situations there are usually two options to fix the transformation 1 convert to the desired type or 2 find and use an overload of the specific operator supporting the different type converting to the desired type each reactive base class features operators that can perform such conversions including the protocol conversions to match some other type the following matrix shows the available conversion options flowable observable single maybe completable flowable toobservable first firstorerror single singleorerror last lastorerror1 firstelement singleelement lastelement ignoreelements observable toflowable2 first firstorerror single singleorerror last lastorerror1 firstelement singleelement lastelement ignoreelements single toflowable3 toobservable tomaybe tocompletable maybe toflowable3 toobservable tosingle ignoreelement completable toflowable toobservable tosingle tomaybe 1 when turning a multi valued source into a single valued source one should decide which of the many source values should be considered as the result 2 turning an observable into flowable requires an additional decision what to do with the potential unconstrained flow of the source observable there are several strategies available such as buffering dropping keeping the latest via the backpressurestrategy parameter or via standard flowable operators such as onbackpressurebuffer onbackpressuredrop onbackpressurelatest which also allow further customization of the backpressure behavior 3 when there is only at most one source item there is no problem with backpressure as it can be always stored until the downstream is ready to consume using an overload with the desired type many frequently used operator has overloads that can deal with the other types these are usually named with the suffix of the target type operator overloads flatmap flatmapsingle flatmapmaybe flatmapcompletable flatmapiterable concatmap concatmapsingle concatmapmaybe concatmapcompletable concatmapiterable switchmap switchmapsingle switchmapmaybe switchmapcompletable the reason these operators have a suffix instead of simply having the same name with different signature is type erasure java doesnt consider signatures such as operator function t single r and operator function t maybe r different unlike c and due to erasure the two operators would end up as duplicate methods with the same signature operator naming conventions naming in programming is one of the hardest things as names are expected to be not long expressive capturing and easily memorable unfortunately the target language and pre existing conventions may not give too much help in this regard unusable keywords type erasure type ambiguities etc unusable keywords in the original rx net the operator that emits a single item and then completes is called return t since the java convention is to have a lowercase letter start a method name this would have been return t which is a keyword in java and thus not available therefore rxjava chose to name this operator just t the same limitation exists for the operator switch which had to be named switchonnext yet another example is catch which was named onerrorresumenext type erasure many operators that expect the user to provide some function returning a reactive type cant be overloaded because the type erasure around a function t x turns such method signatures into duplicates rxjava chose to name such operators by appending the type as suffix as well java flowable flatmap function super t extends publisher extends r mapper flowable flatmapmaybe function super t extends maybesource extends r mapper type ambiguities even though certain operators have no problems from type erasure their signature may turn up being ambiguous especially if one uses java 8 and lambdas for example there are several overloads of concatwith taking the various other reactive base types as arguments for providing convenience and performance benefits in the underlying implementation java flowable concatwith publisher extends t other flowable concatwith singlesource extends t other both publisher and singlesource appear as functional interfaces types with one abstract method and may encourage users to try to provide a lambda expression java somesource concatwith s single just 2 subscribe system out println throwable printstacktrace unfortunately this approach doesnt work and the example does not print 2 at all in fact since version 2 1 10 it doesnt even compile because at least 4 concatwith overloads exist and the compiler finds the code above ambiguous the user in such situations probably wanted to defer some computation until the somesource has completed thus the correct unambiguous operator should have been defer java somesource concatwith single defer single just 2 subscribe system out println throwable printstacktrace sometimes a suffix is added to avoid logical ambiguities that may compile but produce the wrong type in a flow java flowable merge publisher extends publisher extends t sources flowable mergearray publisher extends t sources this can get also ambiguous when functional interface types get involved as the type argument t error handling dataflows can fail at which point the error is emitted to the consumer s sometimes though multiple sources may fail at which point there is a choice whether or not wait for all of them to complete or fail to indicate this opportunity many operator names are suffixed with the delayerror words while others feature a delayerror or delayerrors boolean flag in one of their overloads java flowable concat publisher extends publisher extends t sources flowable concatdelayerror publisher extends publisher extends t sources of course suffixes of various kinds may appear together java flowable t concatarrayeagerdelayerror publisher extends t sources base class vs base type the base classes can be considered heavy due to the sheer number of static and instance methods on them rxjava 2s design was heavily influenced by the reactive streams specification therefore the library features a class and an interface per each reactive type type class interface consumer 0 n backpressured flowable publisher1 subscriber 0 n unbounded observable observablesource2 observer 1 element or error single singlesource singleobserver 0 1 element or error maybe maybesource maybeobserver 0 element or error completable completablesource completableobserver 1the org reactivestreams publisher is part of the external reactive streams library it is the main type to interact with other reactive libraries through a standardized mechanism governed by the reactive streams specification 2the naming convention of the interface was to append source to the semi traditional class name there is no flowablesource since publisher is provided by the reactive streams library and subtyping it wouldnt have helped with interoperation either these interfaces are however not standard in the sense of the reactive streams specification and are currently rxjava specific only further reading for further details consult the wiki communication google group rxjava twitter rxjava github issues stackoverflow rx java and rx java2 gitter im versioning version 2 x is now considered stable and final version 1 x will be supported for several years along with 2 x enhancements and bugfixes will be synchronized between the two in a timely manner minor 2 x increments such as 2 1 2 2 etc will occur when non trivial new functionality is added or significant enhancements or bug fixes occur that may have behavioral changes that may affect some edge cases such as dependence on behavior resulting from a bug an example of an enhancement that would classify as this is adding reactive pull backpressure support to an operator that previously did not support it this should be backwards compatible but does behave differently patch 2 x y increments such as 2 0 0 2 0 1 2 3 1 2 3 2 etc will occur for bug fixes and trivial functionality like adding a method overload new functionality marked with an beta or experimental annotation can also be added in patch releases to allow rapid exploration and iteration of unstable new functionality beta apis marked with the beta annotation at the class or method level are subject to change they can be modified in any way or even removed at any time if your code is a library itself i e it is used on the classpath of users outside your own control you should not use beta apis unless you repackage them e g using proguard shading etc experimental apis marked with the experimental annotation at the class or method level will almost certainly change they can be modified in any way or even removed at any time you should not use or rely on them in any production code they are purely to allow broad testing and feedback deprecated apis marked with the deprecated annotation at the class or method level will remain supported until the next major release but it is recommended to stop using them io reactivex internal all code inside the io reactivex internal packages is considered private api and should not be relied upon at all it can change at any time full documentation wiki javadoc latest snaphot javadoc javadoc of a specific release version http reactivex io rxjava 2 x javadoc 2 x y binaries binaries and dependency information for maven ivy gradle and others can be found at http search maven org example for gradle groovy compile io reactivex rxjava2 rxjava x y z and for maven xml dependency groupid io reactivex rxjava2 groupid artifactid rxjava artifactid version x y z version dependency and for ivy xml dependency org io reactivex rxjava2 name rxjava rev x y z snapshots are available via https oss jfrog org libs snapshot io reactivex rxjava2 rxjava groovy repositories maven url https oss jfrog org libs snapshot dependencies compile io reactivex rxjava2 rxjava 2 2 0 snapshot build to build git clone git github com reactivex rxjava git cd rxjava gradlew build further details on building can be found on the getting started page of the wiki bugs and feedback for bugs questions and discussions please use the github issues license copyright c 2016 present rxjava contributors licensed under the apache license version 2 0 the license you may not use this file except in compliance with the license you may obtain a copy of the license at http www apache org licenses license 2 0 unless required by applicable law or agreed to in writing software distributed under the license is distributed on an as is basis without warranties or conditions of any kind either express or implied see the license for the specific language governing permissions and limitations under the license