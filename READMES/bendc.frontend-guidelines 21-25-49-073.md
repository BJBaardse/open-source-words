frontend guidelines html semantics html5 provides us with lots of semantic elements aimed to describe precisely the content make sure you benefit from its rich vocabulary html bad blog post published 21st feb 2015 … good blog post published 21st feb 2015 … make sure you understand the semantics of the elements youre using its worse to use a semantic element in a wrong way than staying neutral html bad good brevity keep your code terse forget about your old xhtml habits html bad doctype html contact contact me email address good doctype html contact contact me email address accessibility accessibility shouldnt be an afterthought you dont have to be a wcag expert to improve your website you can start immediately by fixing the little things that make a huge difference such as learning to use the alt attribute properly making sure your links and buttons are marked as such no div class button atrocities not relying exclusively on colors to communicate information explicitly labelling form controls html bad good language while defining the language and character encoding is optional its recommended to always declare both at document level even if theyre specified in your http headers favor utf 8 over any other character encoding html bad doctype html hello world good doctype html hello world performance unless theres a valid reason for loading your scripts before your content dont block the rendering of your page if your style sheet is heavy isolate the styles that are absolutely required initially and defer the loading of the secondary declarations in a separate style sheet two http requests is significantly slower than one but the perception of speed is the most important factor html bad doctype html hello world good doctype html hello world css semicolons while the semicolon is technically a separator in css always treat it as a terminator css bad div color red good div color red box model the box model should ideally be the same for the entire document a global box sizing border box is fine but dont change the default box model on specific elements if you can avoid it css bad div width 100 padding 10px box sizing border box good div padding 10px flow dont change the default behavior of an element if you can avoid it keep elements in the natural document flow as much as you can for example removing the white space below an image shouldnt make you change its default display css bad img display block good img vertical align middle similarly dont take an element off the flow if you can avoid it css bad div width 100px position absolute right 0 good div width 100px margin left auto positioning there are many ways to position elements in css favor modern layout specifications such as flexbox and grid and avoid removing elements from the normal document flow for example example with position absolute selectors minimize selectors tightly coupled to the dom consider adding a class to the elements you want to match when your selector exceeds 3 structural pseudo classes descendant or sibling combinators css bad div first of type last child p good div first of type info avoid overloading your selectors when you dont need to css bad img src svg ul li first child opacity 0 good src svg ul first child opacity 0 specificity dont make values and selectors hard to override minimize the use of ids and avoid important css bad bar color green important foo color red good foo bar color green foo color red overriding overriding styles makes selectors and debugging harder avoid it when possible css bad li visibility hidden li first child visibility visible good li li visibility hidden inheritance dont duplicate style declarations that can be inherited css bad div h1 div p text shadow 0 1px 0 fff good div text shadow 0 1px 0 fff brevity keep your code terse use shorthand properties and avoid using multiple properties when its not needed css bad div transition all 1s top 50 margin top 10px padding top 5px padding right 10px padding bottom 20px padding left 10px good div transition 1s top calc 50 10px padding 5px 10px 20px language prefer english over math css bad nth child 2n 1 transform rotate 360deg good nth child odd transform rotate 1turn vendor prefixes kill obsolete vendor prefixes aggressively if you need to use them insert them before the standard property css bad div transform scale 2 webkit transform scale 2 moz transform scale 2 ms transform scale 2 transition 1s webkit transition 1s moz transition 1s ms transition 1s good div webkit transform scale 2 transform scale 2 transition 1s animations favor transitions over animations avoid animating other properties than opacity and transform css bad div hover animation move 1s forwards keyframes move 100 margin left 100px good div hover transition 1s transform translatex 100px units use unitless values when you can favor rem if you use relative units prefer seconds over milliseconds css bad div margin 0px font size 9em line height 22px transition 500ms good div margin 0 font size 9rem line height 1 5 transition 5s colors if you need transparency use rgba otherwise always use the hexadecimal format css bad div color hsl 103 54 43 good div color 5a3 drawing avoid http requests when the resources are easily replicable with css css bad div before content url white circle svg good div before content display block width 20px height 20px border radius 50 background fff hacks dont use them css bad div position relative transform translatez 0 good div position relative will change transform javascript performance favor readability correctness and expressiveness over performance javascript will basically never be your performance bottleneck optimize things like image compression network access and dom reflows instead if you remember just one guideline from this document choose this one javascript bad albeit way faster const arr 1 2 3 4 const len arr length var i 1 var result while i len var n arr i if n 2 0 continue result push n n good const arr 1 2 3 4 const iseven n n 2 0 const square n n n const result arr filter iseven map square statelessness try to keep your functions pure all functions should ideally produce no side effects use no outside data and return new objects instead of mutating existing ones javascript bad const merge target sources object assign target sources merge foo foo bar bar foo foo bar bar good const merge sources object assign sources merge foo foo bar bar foo foo bar bar natives rely on native methods as much as possible javascript bad const toarray obj slice call obj good const toarray array from array from obj slice call obj coercion embrace implicit coercion when it makes sense avoid it otherwise dont cargo cult javascript bad if x undefined x null good if x undefined loops dont use loops as they force you to use mutable objects rely on array prototype methods javascript bad const sum arr var sum 0 var i 1 for arr i sum arr i return sum sum 1 2 3 6 good const sum arr arr reduce x y x y sum 1 2 3 6 if you cant or if usingarray prototype methods is arguably abusive use recursion javascript bad const createdivs howmany while howmany document body insertadjacenthtml beforeend createdivs 5 bad const createdivs howmany array howmany foreach document body insertadjacenthtml beforeend createdivs 5 good const createdivs howmany if howmany return document body insertadjacenthtml beforeend return createdivs howmany 1 createdivs 5 heres a generic loop function making recursion easier to use arguments forget about the arguments object the rest parameter is always a better option because its named so it gives you a better idea of the arguments the function is expecting its a real array which makes it easier to use javascript bad const sortnumbers array prototype slice call arguments sort good const sortnumbers numbers numbers sort apply forget about apply use the spread operator instead javascript const greet first last hi first last const person john doe bad greet apply null person good greet person bind dont bind when theres a more idiomatic approach javascript bad foo bar foreach func bind this good foo bar foreach func this javascript bad const person first john last doe greet const full function return this first this last bind this return hello full good const person first john last doe greet const full this first this last return hello full higher order functions avoid nesting functions when you dont have to javascript bad 1 2 3 map num string num good 1 2 3 map string composition avoid multiple nested function calls use composition instead javascript const plus1 a a 1 const mult2 a a 2 bad mult2 plus1 5 12 good const pipeline funcs val funcs reduce a b b a val const addthenmult pipeline plus1 mult2 addthenmult 5 12 caching cache feature tests large data structures and any expensive operation javascript bad const contains arr value array prototype includes arr includes value arr some el el value contains foo bar baz false good const contains array prototype includes arr value arr includes value arr value arr some el el value contains foo bar baz false variables favor const over let and let over var javascript bad var me new map me set name ben set country belgium good const me new map me set name ben set country belgium conditions favor iifes and return statements over if else if else and switch statements javascript bad var grade if result 50 grade bad else if result 90 grade good else grade excellent good const grade if result 50 return bad if result 90 return good return excellent object iteration avoid for in when you can javascript const shared foo foo const obj object create shared bar value bar enumerable true bad for var prop in obj if obj hasownproperty prop console log prop good object keys obj foreach prop console log prop objects as maps while objects have legitimate use cases maps are usually a better more powerful choice when in doubt use a map javascript bad const me name ben age 30 var mesize object keys me length mesize 2 me country belgium mesize mesize 3 good const me new map me set name ben me set age 30 me size 2 me set country belgium me size 3 curry currying is a powerful but foreign paradigm for many developers dont abuse it as its appropriate use cases are fairly unusual javascript bad const sum a b a b sum 5 3 8 good const sum a b a b sum 5 3 8 readability dont obfuscate the intent of your code by using seemingly smart tricks javascript bad foo dosomething good if foo dosomething javascript bad void function iife good function iife javascript bad const n 3 14 good const n math floor 3 14 code reuse dont be afraid of creating lots of small highly composable and reusable functions javascript bad arr arr length 1 good const first arr arr 0 const last arr first arr slice 1 last arr javascript bad const product a b a b const triple n n 3 good const product a b a b const triple product bind null 3 dependencies minimize dependencies third party is code you dont know dont load an entire library for just a couple of methods easily replicable javascript bad var require underscore compact foo 0 unique foo foo union foo bar foo good const compact arr arr filter el el const unique arr new set arr const union arr unique concat arr compact foo 0 unique foo foo union foo bar foo