a higher order component for loading components with dynamic imports install sh yarn add react loadable example js import loadable from react loadable import loading from my loading component const loadablecomponent loadable loader import my component loading loading export default class app extends react component render return happy customers im obsessed with this right now cra with react router v4 and react loadable free code splitting this is so easy webpack 2 upgrade react loadable initial load from 1 1mb to 529kb in under 2 hours immense oh hey using loadable component i knocked 13k off my initial load easy win had a look and its awesome shaved like 50kb off our main bundle ive got that server side rendering code splitting pwa serviceworker caching setup done ðŸ˜Ž thanks to react loadable now our frontend is super fast using react loadable went from 221 28 kb â†’ 115 76 kb main bundle fucking awesome and very simple api users analog cafe appbase io atlassian cloudflare curio dresez flyhomes gogo mediatek mcs lite snipit spectrum chat talentpair tinder unsplash wave if your company or project is using react loadable please open a pr and add yourself to this list in alphabetical order please also see react loadable visibility building on top of and keeping the same api as react loadable this library enables you to load content that is visible on the screen guide so youve got your react app youre bundling it with webpack and things are going smooth but then one day you notice your apps bundle is getting so big that its slowing things down its time to start code splitting your app code splitting is the process of taking one large bundle containing your entire app and splitting them up into multiple smaller bundles which contain separate parts of your app this might seem difficult to do but tools like webpack have this built in and react loadable is designed to make it super simple route based splitting vs component based splitting a common piece of advice you will see is to break your app into separate routes and load each one asynchronously this seems to work well enough for many appsâ€“ as a user clicking a link and waiting for a page to load is a familiar experience on the web but we can do better than that using most routing tools for react a route is simply a component theres nothing particularly special about them sorry ryan and michaelâ€“ youre whats special so what if we optimized for splitting around components instead of routes what would that get us as it turns out quite a lot there are many more places than just routes where you can pretty easily split apart your app modals tabs and many more ui components hide content until the user has done something to reveal it example maybe your app has a map buried inside of a tab component why would you load a massive mapping library for the parent route every time when the user may never go to that tab not to mention all the places where you can defer loading content until higher priority content is finished loading that component at the bottom of your page which loads a bunch of libraries why should that be loaded at the same time as the content at the top and because routes are just components we can still easily code split at the route level introducing new code splitting points in your app should be so easy that you dont think twice about it it should be a matter of changing a few lines of code and everything else should be automated introducing react loadable react loadable is a small library that makes component centric code splitting incredibly easy in react loadable is a higher order component a function that creates a component which lets you dynamically load any module before rendering it into your app lets imagine two components one that imports and renders another js import bar from components bar class foo extends react component render return right now were depending on bar being imported synchronously via import but we dont need it until we go to render it so why dont we just defer that using a dynamic import a tc39 proposal currently at stage 3 we can modify our component to load bar asynchronously js class mycomponent extends react component state bar null componentwillmount import components bar then bar this setstate bar render let bar this state if bar return loading else return but thats a whole bunch of work and it doesnt even handle a bunch of cases what about when import fails what about server side rendering instead you can use loadable to abstract away the problem js import loadable from react loadable const loadablebar loadable loader import components bar loading return loading class mycomponent extends react component render return automatic code splitting on import when you use import with webpack 2 it will automatically code split for you with no additional configuration this means that you can easily experiment with new code splitting points just by switching to import and using react loadable figure out what performs best for your app creating a great loading component rendering a static loading doesnt communicate enough to the user you also need to think about error states timeouts and making it a nice experience js function loading return loading loadable loader import willfailtoload oh no loading loading to make this all nice your loading component receives a couple different props loading error states when your loader fails your loading component will receive an error prop which will be an error object otherwise it will be null js function loading props if props error return div error button onclick props retry retry button div else return div loading div avoiding flash of loading component sometimes components load really quickly 200ms and the loading screen only quickly flashes on the screen a number of user studies have proven that this causes users to perceive things taking longer than they really have if you dont show anything users perceive it as being faster so your loading component will also get a pastdelay prop which will only be true once the component has taken longer to load than a set delay js function loading props if props error return div error button onclick props retry retry button div else if props pastdelay return div loading div else return null this delay defaults to 200ms but you can also customize the delay in loadable js loadable loader import components bar loading loading delay 300 0 3 seconds timing out when the loader is taking too long sometimes network connections suck and never resolve or fail they just hang there forever this sucks for the user because they wont know if it should always take this long or if they should try refreshing the loading component will receive a timedout prop which will be set to true when the loader has timed out js function loading props if props error return div error button onclick props retry retry button div else if props timedout return div taking a long time button onclick props retry retry button div else if props pastdelay return div loading div else return null however this feature is disabled by default to turn it on you can pass a timeout option to loadable js loadable loader import components bar loading loading timeout 10000 10 seconds customizing rendering by default loadable will render the default export of the returned module if you want to customize this behavior you can use the render option js loadable loader import my component render loaded props let component loaded namedexport return component props loading multiple resources technically you can do whatever you want within loader as long as it returns a promise and youre able to render something but writing it out can be a bit annoying to make it easier to load multiple resources in parallel you can use loadable map js loadable map loader bar import bar i18n fetch i18n bar json then res res json render loaded props let bar loaded bar default let i18n loaded i18n return bar props i18n i18n when using loadable map the render method is required it will be passed a loaded param which will be an object matching the shape of your loader preloading as an optimization you can also decide to preload a component before it gets rendered for example if you need to load a new component when a button gets pressed you could start preloading the component when the user hovers over the button the component created by loadable exposes a static preload method which does exactly this js const loadablebar loadable loader import bar loading loading class mycomponent extends react component state showbar false onclick this setstate showbar true onmouseover loadablebar preload render return show bar this state showbar server side rendering when you go to render all these dynamically loaded components what youll get is a whole bunch of loading screens this really sucks but the good news is that react loadable is designed to make server side rendering work as if nothing is being loaded dynamically heres our starting server using express js import express from express import react from react import reactdomserver from react dom server import app from components app const app express app get req res res send doctype html html lang en head head body div id app reactdomserver rendertostring app div script src dist main js script body html app listen 3000 console log running on http localhost 3000 preloading all your loadable components on the server the first step to rendering the correct content from the server is to make sure that all of your loadable components are already loaded when you go to render them to do this you can use the loadable preloadall method it returns a promise that will resolve when all your loadable components are ready js loadable preloadall then app listen 3000 console log running on http localhost 3000 picking up a server side rendered app on the client this is where things get a little bit tricky so lets prepare ourselves little bit in order for us to pick up what was rendered from the server we need to have all the same code that was used to render on the server to do this we first need our loadable components telling us which modules they are rendering declaring which modules are being loaded there are two options in loadable and loadable map which are used to tell us which modules our component is trying to load opts modules and opts webpack js loadable loader import bar modules bar webpack require resolveweak bar but dont worry too much about these options react loadable includes a babel plugin to add them for you just add the react loadable babel plugin to your babel config json plugins react loadable babel now these options will automatically be provided finding out which dynamic modules were rendered next we need to find out which modules were actually rendered when a request comes in for this there is loadable capture component which can be used to collect all the modules that were rendered js import loadable from react loadable app get req res let modules let html reactdomserver rendertostring modules push modulename console log modules res send html mapping loaded modules to bundles in order to make sure that the client loads all the modules that were rendered server side well need to map them to the bundles that webpack created this comes in two parts first we need webpack to tell us which bundles each module lives inside for this there is the react loadable webpack plugin import the reactloadableplugin from react loadable webpack and include it in your webpack config pass it a filename for where to store the json data about our bundles js webpack config js import reactloadableplugin from react loadable webpack export default plugins new reactloadableplugin filename dist react loadable json then well go back to our server and use this data to convert our modules to bundles to convert from modules to bundles import the getbundles method from react loadable webpack and the data from webpack js import loadable from react loadable import getbundles from react loadable webpack import stats from dist react loadable json app get req res let modules let html reactdomserver rendertostring modules push modulename let bundles getbundles stats modules we can then render these bundles into script tags in our html it is important that the bundles are included before the main bundle so that they can be loaded by the browser prior to the app rendering however as the webpack manifest including the logic for parsing bundles lives in the main bundle it will need to be extracted into its own chunk this is easy to do with the commonschunkplugin js webpack config js export default plugins new webpack optimize commonschunkplugin name manifest minchunks infinity notice as of webpack 4 the commonschunkplugin has been removed and the manifest doesnt need to be extracted anymore js let bundles getbundles stats modules res send doctype html html lang en head head body div id app html div script src dist manifest js script bundles map bundle return alternatively if you are using publicpath option in webpack config you can use the publicpath value from bundle e g return join \n script src dist main js script body html preloading ready loadable components on the client we can use the loadable preloadready method on the client to preload the loadable components that were included on the page like loadable preloadall it returns a promise which on resolution means that we can hydrate our app js src entry js import react from react import reactdom from react dom import loadable from react loadable import app from components app loadable preloadready then reactdom hydrate document getelementbyid app now server side rendering should work perfectly api docs loadable a higher order component for dynamically loading a module before rendering it a loading component is rendered while the module is unavailable js const loadablecomponent loadable loader import bar loading loading delay 200 timeout 10000 this returns a loadablecomponent loadable map a higher order component that allows you to load multiple resources in parallel loadable maps opts loader accepts an object of functions and needs a opts render method js loadable map loader bar import bar i18n fetch i18n bar json then res res json render loaded props let bar loaded bar default let i18n loaded i18n return bar props i18n i18n when using loadable map the render methods loaded param will be an object with the same shape as your loader loadable and loadable map options opts loader a function returning a promise that loads your module js loadable loader import bar when using with loadable map this accepts an object of these types of functions js loadable map loader bar import bar i18n fetch i18n bar json then res res json when using with loadable map youll also need to pass a opts render function opts loading a loadingcomponent that renders while a module is loading or when it errors js loadable loading loadingcomponent this option is required if you dont want to render anything return null js loadable loading null opts delay time to wait in milliseconds before passing props pastdelay to your loading component this defaults to 200 js loadable delay 200 read more about delays opts timeout time to wait in milliseconds before passing props timedout to your loading component this is turned off by default js loadable timeout 10000 read more about timeouts opts render a function to customize the rendering of loaded modules receives loaded which is the resolved value of opts loader and props which are the props passed to the loadablecomponent js loadable render loaded props let component loaded default return component props opts webpack an optional function which returns an array of webpack module ids which you can get with require resolveweak js loadable loader import foo webpack require resolveweak foo this option can be automated with the babel plugin opts modules an optional array with module paths for your imports js loadable loader import my component modules my component this option can be automated with the babel plugin loadablecomponent this is the component returned by loadable and loadable map js const loadablecomponent loadable props passed to this component will be passed straight through to the dynamically loaded component via opts render loadablecomponent preload this is a static method on loadablecomponent which can be used to load the component ahead of time js const loadablecomponent loadable loadablecomponent preload this returns a promise but you should avoid waiting for that promise to resolve to update your ui in most cases it creates a bad user experience read more about preloading loadingcomponent this is the component you pass to opts loading js function loadingcomponent props if props error when the loader has errored return error retry else if props timedout when the loader has taken longer than the timeout return taking a long time retry else if props pastdelay when the loader has taken longer than the delay return loading else when the loader has just started return null loading loading loadingcomponent read more about loading components props error an error object passed to loadingcomponent when the loader has failed when there is no error null is passed js function loadingcomponent props if props error return div error div else return div loading div read more about errors props retry a function prop passed to loadingcomponent when the loader has failed used to retry loading the component js function loadingcomponent props if props error return div error button onclick props retry retry button div else return div loading div read more about errors props timedout a boolean prop passed to loadingcomponent after a set timeout js function loadingcomponent props if props timedout return div taking a long time div else return div loading div read more about timeouts props pastdelay a boolean prop passed to loadingcomponent after a set delay js function loadingcomponent props if props pastdelay return div loading div else return null read more about delays loadable preloadall this will call all of the loadablecomponent preload methods recursively until they are all resolved allowing you to preload all of your dynamic modules in environments like the server js loadable preloadall then app listen 3000 console log running on http localhost 3000 its important to note that this requires that you declare all of your loadable components when modules are initialized rather than when your app is being rendered good js during module initialization const loadablecomponent loadable class mycomponent extends react component componentdidmount bad js class mycomponent extends react component componentdidmount during app render const loadablecomponent loadable note loadable preloadall will not work if you have more than one copy of react loadable in your app read more about preloading on the server loadable preloadready check for modules that are already loaded in the browser and call the matching loadablecomponent preload methods js loadable preloadready then reactdom hydrate app document getelementbyid app read more about preloading on the client loadable capture a component for reporting which modules were rendered accepts a report prop which is called for every modulename that is rendered via react loadable js let modules let html reactdomserver rendertostring modules push modulename console log modules read more about capturing rendered modules babel plugin providing opts webpack and opts modules for every loadable component is a lot of manual work to remember to do instead you can add the babel plugin to your config and it will automate it for you json plugins react loadable babel input js import loadable from react loadable const loadablemycomponent loadable loader import mycomponent const loadablecomponents loadable map loader one import one two import two output js import loadable from react loadable import path from path const loadablemycomponent loadable loader import mycomponent webpack require resolveweak mycomponent modules path join dirname mycomponent const loadablecomponents loadable map loader one import one two import two webpack require resolveweak one require resolveweak two modules path join dirname one path join dirname two read more about declaring modules webpack plugin in order to send the right bundles down when rendering server side youll need the react loadable webpack plugin to provide you with a mapping of modules to bundles js webpack config js import reactloadableplugin from react loadable webpack export default plugins new reactloadableplugin filename dist react loadable json this will create a file opts filename which you can import to map modules to bundles read more about mapping modules to bundles getbundles a method exported by react loadable webpack for converting modules to bundles js import getbundles from react loadable webpack let bundles getbundles stats modules read more about mapping modules to bundles faq how do i avoid repetition specifying the same loading component or delay every time you use loadable gets repetitive fast instead you can wrap loadable with your own higher order component hoc to set default options js import loadable from react loadable import loading from my loading component export default function myloadable opts return loadable object assign loading loading delay 200 timeout 10 opts then you can just specify a loader when you go to use it js import myloadable from myloadable const loadablemycomponent myloadable loader import mycomponent export default class app extends react component render return unfortunately at the moment using wrapped loadable breaks react loadable babel so in such case you have to add required properties modules webpack manually js import myloadable from myloadable const loadablemycomponent myloadable loader import mycomponent modules mycomponent webpack require resolveweak mycomponent export default class app extends react component render return how do i handle other styles css or sourcemaps map with server side rendering when you call getbundles it may return file types other than javascript depending on your webpack configuration to handle this you should manually filter down to the file extensions that you care about js let bundles getbundles stats modules let styles bundles filter bundle bundle file endswith css let scripts bundles filter bundle bundle file endswith js res send doctype html html lang en head styles map style return join \n head body div id app html div script src dist main js script scripts map script return join \n body html