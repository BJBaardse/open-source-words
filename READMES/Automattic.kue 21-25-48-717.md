kue kue is a priority job queue backed by redis built for node js protip this is the latest kue documentation make sure to also read the changelist upgrade notes please read 0 9 0 10 0 8 0 9 installation latest release npm install kue master branch npm install http github com automattic kue tarball master features delayed jobs distribution of parallel work load job event and progress pubsub job ttl optional retries with backoff graceful workers shutdown full text search capabilities restful json api rich integrated ui infinite scrolling ui progress indication job specific logging powered by redis overview creating jobs jobs priority failure attempts failure backoff job ttl job logs job progress job events queue events delayed jobs processing jobs processing concurrency pause processing updating progress graceful shutdown error handling queue maintenance redis connection settings user interface json api parallel processing with cluster securing kue testing screencasts license creating jobs first create a job queue with kue createqueue js var kue require kue queue kue createqueue calling queue create with the type of job email and arbitrary job data will return a job which can then be save ed adding it to redis with a default priority level of normal the save method optionally accepts a callback responding with an error if something goes wrong the title key is special cased and will display in the job listings within the ui making it easier to find a specific job js var job queue create email title welcome email for tj to tj learnboost com template welcome email save function err if err console log job id job priority to specify the priority of a job simply invoke the priority method with a number or priority name which is mapped to a number js queue create email title welcome email for tj to tj learnboost com template welcome email priority high save the default priority map is as follows js low 10 normal 0 medium 5 high 10 critical 15 failure attempts by default jobs only have one attempt that is when they fail they are marked as a failure and remain that way until you intervene however kue allows you to specify this which is important for jobs such as transferring an email which upon failure may usually retry without issue to do this invoke the attempts method with a number js queue create email title welcome email for tj to tj learnboost com template welcome email priority high attempts 5 save failure backoff job retry attempts are done as soon as they fail with no delay even if your job had a delay set via job delay if you want to delay job re attempts upon failures known as backoff you can use job backoff method in different ways js honor jobs original delay if set at each attempt defaults to fixed backoff job attempts 3 backoff true override delay value fixed backoff job attempts 3 backoff delay 60 1000 type fixed enable exponential backoff using original delay if set job attempts 3 backoff type exponential use a function to get a customized next attempt delay value job attempts 3 backoff function attempts delay attempts will correspond to the nth attempt failure so it will start with 0 delay will be the amount of the last delay not the initial delay unless attempts 0 return my customized calculated delay in the last scenario provided function will be executed via eval on each re attempt to get next attempt delay value meaning that you cant reference external context variables within it job ttl job producers can set an expiry value for the time their job can live in active state so that if workers didnt reply in timely fashion kue will fail it with ttl exceeded error message preventing that job from being stuck in active state and spoiling concurrency js queue create email title email job with ttl ttl milliseconds save job logs job specific logs enable you to expose information to the ui at any point in the jobs life time to do so simply invoke job log which accepts a message string as well as variable arguments for sprintf like support js job log d sent to s amount user name or anything else uses util inspect internally js job log key some key value 10 job log 1 2 3 5 8 job log 10 1 job progress job progress is extremely useful for long running jobs such as video conversion to update the jobs progress simply invoke job progress completed total data js job progress frames totalframes data can be used to pass extra information about the job for example a message or an object with some extra contextual data to the current status job events job specific events are fired on the job instances via redis pubsub the following events are currently supported enqueue the job is now queued start the job is now running promotion the job is promoted from delayed state to queued progress the jobs progress ranging from 0 100 failed attempt the job has failed but has remaining attempts yet failed the job has failed and has no remaining attempts complete the job has completed remove the job has been removed for example this may look something like the following js var job queue create video conversion title converting loki\s to avi user 1 frames 200 job on complete function result console log job completed with data result on failed attempt function errormessage doneattempts console log job failed on failed function errormessage console log job failed on progress function progress data console log \r job job id progress complete with data data note that job level events are not guaranteed to be received upon process restarts since restarted node js process will lose the reference to the specific job object if you want a more reliable event handler look for queue events note kue stores job objects in memory until they are complete failed to be able to emit events on them if you have a huge concurrency in uncompleted jobs turn this feature off and use queue level events for better memory scaling js kue createqueue jobevents false alternatively you can use the job level function events to control whether events are fired for a job at the job level js var job queue create test events false save queue events queue level events provide access to the job level events previously mentioned however scoped to the queue instance to apply logic at a global level an example of this is removing completed jobs js queue on job enqueue function id type console log job s got queued of type s id type on job complete function id result kue job get id function err job if err return job remove function err if err throw err console log removed completed job d job id the events available are the same as mentioned in job events however prefixed with job delayed jobs delayed jobs may be scheduled to be queued for an arbitrary distance in time by invoking the delay ms method passing the number of milliseconds relative to now alternatively you can pass a javascript date object with a specific time in the future this automatically flags the job as delayed js var email queue create email title account renewal required to tj learnboost com template renewal email delay milliseconds priority high save kue will check the delayed jobs with a timer promoting them if the scheduled delay has been exceeded defaulting to a check of top 1000 jobs every second processing jobs processing jobs is simple with kue first create a queue instance much like we do for creating jobs providing us access to redis etc then invoke queue process with the associated type note that unlike what the name createqueue suggests it currently returns a singleton queue instance so you can configure and use only a single queue object within your node js process in the following example we pass the callback done to email when an error occurs we invoke done err to tell kue something happened otherwise we invoke done only when the job is complete if this function responds with an error it will be displayed in the ui and the job will be marked as a failure the error object passed to done should be of standard type error js var kue require kue queue kue createqueue queue process email function job done email job data to done function email address done if isvalidemail address done invalid to address is possible but discouraged return done new error invalid to address email send stuff done workers can also pass job result as the second parameter to done done null result to store that in job result key result is also passed through complete event handlers so that job producers can receive it if they like to processing concurrency by default a call to queue process will only accept one job at a time for processing for small tasks like sending emails this is not ideal so we may specify the maximum active jobs for this type by passing a number js queue process email 20 function job done pause processing workers can temporarily pause and resume their activity that is after calling pause they will receive no jobs in their process callback until resume is called the pause function gracefully shutdowns this worker and uses the same internal functionality as the shutdown method in graceful shutdown js queue process email function job ctx done ctx pause 5000 function err console log worker is paused settimeout function ctx resume 10000 note the ctx parameter from kue 0 9 0 is the second argument of the process callback function and done is idiomatically always the last note the pause method signature is changed from kue 0 9 0 to move the callback function to the last updating progress for a real example lets say we need to compile a pdf from numerous slides with node canvas our job may consist of the following data note that in general you should not store large data in the job it self its better to store references like ids pulling them in while processing js queue create slideshow pdf title user name s slideshow slides keys to data stored in redis mongodb or some other store we can access this same arbitrary data within a separate process while processing via the job data property in the example we render each slide one by one updating the jobs log and progress js queue process slideshow pdf 5 function job done var slides job data slides len slides length function next i var slide slides i pretend we did a query on this slide id job log rendering dx d slide slide width slide height renderslide slide function err if err return done err job progress i len nextslide i len itsdone i 1 if i len done else next i 1 next 0 graceful shutdown queue shutdown timeout fn signals all workers to stop processing after their current active job is done workers will wait timeout milliseconds for their active jobs done to be called or mark the active job failed with shutdown error reason when all workers tell kue they are stopped fn is called javascript var queue require kue createqueue process once sigterm function sig queue shutdown 5000 function err console log kue shutdown err process exit 0 note that shutdown method signature is changed from kue 0 9 0 to move the callback function to the last error handling all errors either in redis client library or queue are emitted to the queue object you should bind to error events to prevent uncaught exceptions or debug kue errors javascript var queue require kue createqueue queue on error function err console log oops err prevent from stuck active jobs kue marks a job complete failed when done is called by your worker so you should use proper error handling to prevent uncaught exceptions in your workers code and node js process exiting before in handle jobs get done this can be achieved in two ways wrapping your workers process function in domains js queue process my error prone task function job done var domain require domain create domain on error function err done err domain run function your process function throw new error bad things happen done notice domains are deprecated from nodejs with stability 0 and its not recommended to use this is the softest and best solution however is not built in with kue please refer to this discussion you can comment on this feature in the related open kue issue you can also use promises to do something like js queue process my error prone task function job done promise method function your process function throw new error bad things happen nodeify done but this wont catch exceptions in your async call stack as domains do binding to uncaughtexception and gracefully shutting down the kue however this is not a recommended error handling idiom in javascript since you are losing the error context js process once uncaughtexception function err console error something bad happened err queue shutdown 1000 function err2 console error kue shutdown result err2 ok process exit 0 unstable redis connections kue currently uses client side job state management and when redis crashes in the middle of that operations some stuck jobs or index inconsistencies will happen the consequence is that certain number of jobs will be stuck and be pulled out by worker only when new jobs are created if no more new jobs are created they stuck forever so we strongly suggest that you run watchdog to fix this issue by calling js queue watchstuckjobs interval interval is in milliseconds and defaults to 1000ms kue will be refactored to fully atomic job state management from version 1 0 and this will happen by lua scripts and or brpoplpush combination you can read more here and here queue maintenance queue object has two type of methods to tell you about the number of jobs in each state js queue inactivecount function err total others are activecount completecount failedcount delayedcount if total 100000 console log we need some back pressure here you can also query on an specific job type js queue failedcount my critical job function err total if total 10000 console log this is toooo bad and iterating over job ids js queue inactive function err ids others are active complete failed delayed you may want to fetch each id to get the job object out of it however the second one doesnt scale to large deployments there you can use more specific job static methods js kue job rangebystate failed 0 n asc function err jobs you have an array of maximum n job objects here or js kue job rangebytype my job type failed 0 n asc function err jobs you have an array of maximum n job objects here note that the last two methods are subject to change in later kue versions programmatic job management if you did none of above in error handling section or your process lost active jobs in any way you can recover from them when your process is restarted a blind logic would be to re queue all stuck jobs js queue active function err ids ids foreach function id kue job get id function err job your application should check if job is a stuck one job inactive note in a clustered deployment your application should be aware not to involve a job that is valid currently inprocess by other workers job cleanup jobs data and search indexes eat up redis memory space so you will need some job keeping process in real world deployments your first chance is using automatic job removal on completion javascript queue create removeoncomplete true save but if you eventually temporally need completed job data you can setup an on demand job removal script like below to remove top n completed jobs js kue job rangebystate complete 0 n asc function err jobs jobs foreach function job job remove function console log removed job id note that you should provide enough time for remove calls on each job object to complete before your process exits or job indexes will leak redis connection settings by default kue will connect to redis using the client default settings port defaults to 6379 host defaults to 127 0 0 1 prefix defaults to q queue createqueue options accepts redis connection options in options redis key javascript var kue require kue var q kue createqueue prefix q redis port 1234 host 10 0 50 20 auth password db 3 if provided select a non default redis db options see https github com mranney node redis rediscreateclient prefix controls the key names used in redis by default this is simply q prefix generally shouldnt be changed unless you need to use one redis instance for multiple apps it can also be useful for providing an isolated testbed across your main application you can also specify the connection information as a url string js var q kue createqueue redis redis example com 1234 redis option value redis option value connecting using unix domain sockets since node redis supports unix domain sockets you can also tell kue to do so see unix domain socket for your redis server configuration javascript var kue require kue var q kue createqueue prefix q redis socket data sockets redis sock auth password options see https github com mranney node redis rediscreateclient replacing redis client module any node js redis client library that conforms or when adapted to node redis api can be injected into kue you should only provide a createclientfactory function as a redis connection factory instead of providing node redis connection options below is a sample code to enable redis sentinel to connect to redis sentinel for automatic master slave failover javascript var kue require kue var sentinel require redis sentinel var endpoints host 192 168 1 10 port 6379 host 192 168 1 11 port 6379 var opts options standard node redis client options var mastername mymaster var sentinel sentinel sentinel endpoints var q kue createqueue redis createclientfactory function return sentinel createclient mastername opts note that all 0 8 x client codes should be refactored to pass redis options to queue createqueue instead of monkey patched style overriding of redis createclient or they will be broken from kue 0 8 x using ioredis client with cluster support javascript var redis require ioredis var kue require kue using https github com 72squared vagrant redis cluster var queue kue createqueue redis createclientfactory function return new redis cluster port 7000 port 7001 user interface the ui is a small express application a script is provided in bin for running the interface as a standalone application with default settings you may pass in options for the port redis url and prefix for example node modules kue bin kue dashboard p 3050 r redis 127 0 0 1 3000 q prefix you can fire it up from within another application too js var kue require kue kue createqueue kue app listen 3000 the title defaults to kue to alter this invoke js kue app set title my application note that if you are using non default kue options kue createqueue must be called before accessing kue app third party interfaces you can also use kue ui web interface contributed by arnaud bénard json api along with the ui kue also exposes a json api which is utilized by the ui get job search q query jobs for example get job search q avi video js 5 7 10 by default kue indexes the whole job data object for searching but this can be customized via calling job searchkeys to tell kue which keys on job data to create index for javascript var kue require kue queue kue createqueue queue create email title welcome email for tj to tj learnboost com template welcome email searchkeys to title save search feature is turned off by default from kue 0 9 0 read more about this here you should enable search indexes and add reds in your dependencies if you need to javascript var kue require kue q kue createqueue disablesearch false npm install reds save get stats currently responds with state counts and worker activity time in milliseconds js inactivecount 4 completecount 69 activecount 2 failedcount 0 worktime 20892 get job id get a job by id js id 3 type email data title welcome email for tj to tj learnboost com template welcome email priority 10 progress 100 state complete attempts null created at 1309973155248 updated at 1309973155248 duration 15002 get job id log get job ids log js foo bar baz get jobs from to order get jobs with the specified range from to to for example jobs 0 2 where order may be asc or desc js id 12 type email data title welcome email for tj to tj learnboost com template welcome email priority 10 progress 0 state active attempts null created at 1309973299293 updated at 1309973299293 id 130 type email data title welcome email for tj to tj learnboost com template welcome email priority 10 progress 0 state active attempts null created at 1309975157291 updated at 1309975157291 get jobs state from to order same as above restricting by state which is one of active inactive failed complete get jobs type state from to order same as above however restricted to type and state delete job id delete job id curl x delete http local 3000 job 2 message job 2 removed post job create a job curl h content type application json x post d \ type email data title welcome email for tj to tj learnboost com template welcome email options attempts 5 priority high http localhost 3000 job message job created id 3 you can create multiple jobs at once by passing an array in this case the response will be an array too preserving the order curl h content type application json x post d \ type email data title welcome email for tj to tj learnboost com template welcome email options attempts 5 priority high type email data title followup email for tj to tj learnboost com template followup email options delay 86400 attempts 5 priority high http localhost 3000 job message job created id 4 message job created id 5 note when inserting multiple jobs in bulk if one insertion fails kue will keep processing the remaining jobs in order the response array will contain the ids of the jobs added successfully and any failed element will be an object describing the error error error reason parallel processing with cluster the example below shows how you may use cluster to spread the job processing load across cpus please see cluster modules documentation for more detailed examples on using it when cluster ismaster the file is being executed in context of the master process in which case you may perform tasks that you only want once such as starting the web app bundled with kue the logic in the else block is executed per worker js var kue require kue cluster require cluster queue kue createqueue var clusterworkersize require os cpus length if cluster ismaster kue app listen 3000 for var i 0 i clusterworkersize i cluster fork else queue process email 10 function job done var pending 5 total pending var interval setinterval function job log sending job progress total pending total pending done pending clearinterval interval 1000 this will create an email job processor worker per each of your machine cpu cores with each you can handle 10 concurrent email jobs leading to total 10 n concurrent email jobs processed in your n core machine now when you visit kues ui in the browser youll see that jobs are being processed roughly n times faster if you have n cores securing kue through the use of app mounting you may customize the web application enabling tls or adding additional middleware like basic auth connect bash npm install save basic auth connect js var basicauth require basic auth connect var app express createserver tls options app use basicauth foo bar app use kue app app listen 3000 testing enable test mode to push all jobs into a jobs array make assertions against the jobs in that array to ensure code under test is correctly enqueuing jobs js queue require kue createqueue before function queue testmode enter aftereach function queue testmode clear after function queue testmode exit it does something cool function queue createjob myjob foo bar save queue createjob anotherjob baz bip save expect queue testmode jobs length to equal 2 expect queue testmode jobs 0 type to equal myjob expect queue testmode jobs 0 data to eql foo bar important by default jobs arent processed when created during test mode you can enable job processing by passing true to testmode enter js before function queue testmode enter true screencasts introduction to kue api walkthrough to kue contributing we love contributions when contributing follow the simple rules dont violate dry principles boy scout rule needs to have been applied your code should look like all the other code – this project should look like it was written by one person always if you want to propose something – just create an issue and describe your question with as much description as you can if you think you have some general improvement consider creating a pull request with it if you add new code it should be covered by tests no tests – no code if you add a new feature dont forget to update the documentation for it if you find a bug or at least you think it is a bug create an issue with the library version and test case that we can run and see what are you talking about or at least full steps by which we can reproduce it license the mit license copyright c 2011 learnboost tj learnboost com permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the software to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall the authors or copyright holders be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software