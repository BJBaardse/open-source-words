xray xray is an experimental electron based text editor informed by what weve learned in the four years since the launch of atom in the short term this project is a testbed for rapidly iterating on several radical ideas without risking the stability of atom the longer term future of the code in this repository will become clearer after a few months of progress for now our primary goal is to iterate rapidly and learn as much as possible active development is on the eon branch were actively developing a subcomponent of xray called eon which is a real time fine grained version control system were keeping that work on a branch since its still in a pretty messy state but xray will eventually pull in eon as a library and build directly on its data structures check out the readme on that branch for more details updates july 10 2018 may 28 2018 may 14 2018 may 7 2018 april 30 2018 archives foundational priorities our goal is to build a cross platform text editor that is designed from the beginning around the following foundational priorities high performance xray feels lightweight and responsive we design our features to be responsive from the beginning we reliably provide visual feedback within the latency windows suggested by the rail performance model for all interactions we shoot for the following targets on the hardware of our median user duration action 8ms scrolling animations and fine grained interactions such as typing or cursor movement 50ms coarse grained interactions such as opening a file or initiating a search if we cant complete the action within this window we should show a progress bar 150ms opening an application window we are careful to maximize throughput of batch operations such as project wide search memory consumption is kept within a low constant factor of the size of the project and open buffer set but we trade memory for speed and extensibility so long as memory requirements are reasonable collaboration xray makes it as easy to code together as it is to code alone we design features for collaborative use from the beginning editors and other relevant ui elements are designed to be occupied by multiple users interactions with the file system and other resources such as subprocesses are abstracted to work over network connections extensibility xray gives developers control over their own tools we expose convenient and powerful apis to enable users to add non trivial functionality to the application we balance the power of our apis with the ability to ensure the responsiveness stability and security of the application as a whole we avoid leaking implementation details and use versioning where possible to enable a sustained rapid development without destabilizing the package ecosystem web compatibility editing on github feels like editing in xray we want to provide a full featured editor experience that can be used from within a browser this will ultimately help us provide a more unified experience between github com and xray and give us a stronger base of stakeholders in the core editing technology architecture martin fowler defines software architecture as those decisions which are both important and hard to change since these decisions are hard to change we need to be sure that our foundational priorities are well served by these decisions the ui is built with web technology web tech adds a lot of overhead which detracts from our top priority of high performance however web standards are also the best approach that we know of to deliver a cross platform extensible user interface atom proved that developers want to add non trivial ui elements to their editor and we still see web technologies as the most viable way to offer them that ability the fundamental question is whether we can gain the webs benefits for extensibility while still meeting our desired performance goals our hypothesis is that its possibleâ€“with the right architecture core application logic is written in rust while the ui will be web based the core of the application is implemented in a server process written in rust we place as much logic as possible in a library crate located in xray core then expose this logic as a server when running xray on the desktop xray server and a web assembly library running on a worker thread when running xray in the browser xray wasm we communicate between the ui and the back end process via json rpc all of the core application code other than the view logic should be written in rust this will ensure that it has a minimal footprint to load and execute and rusts robust type system will help us maintain it more efficiently than dynamically typed code a language that is fundamentally designed for multi threading will also make it easier to exploit parallelism whenever the need arises whereas javascripts single threaded nature makes parallelism awkward and challenging fundamentally we want to spend our time writing in a language that is fast by default its true that its possible to write slow rust and also possible to write fast javascript its also true that its much harder to write slow rust than it is to write slow javascript by spending fewer resources on the implementation of the platform itself well make more resources available to run package code i o will be centralized in the server the server will serialize buffer loads and saves on a per path basis and maintains a persistent database of crdt operations for each file as edits are performed in windows they will be streamed to the host process to be stored and echoed out to any other windows with the same open buffer this will enable unsaved changes to always be incrementally preserved in case of a crash or power failure and preserves the history associated with a file indefinitely early on we should design the application process to be capable of connecting to multiple workspace servers to facilitate real time collaboration or editing files on a remote server by running a headless host process to support these use cases all code paths that touch the file system or spawn subprocesses will occur in the server process the ui will not make use of the i o facilities provided by electron and instead interact with the server via rpc packages will run in a javascript vm in the server process a misbehaving package should not be able to impact the responsiveness of the application the best way to guarantee this while preserving ease of development is to activate packages on their own threads we can run a worker thread per package or run packages in their own contexts across a pool of threads packages can run code on the render thread by specifying versioned components in their package json json components todolist components todo list js if a package called my todos had the above entry in its package json it could request that the workspace attach that component by referring to mytodos todolist when adding an item during package installation on the desktop we can automatically update the v8 snapshot of the ui to include the components of every installed package components will only be dynamically loaded from the provided paths in development mode custom views will only have access to the dom and an asynchronous channel to communicate with the packages back end running on the server apis for interacting with the core application state and the underlying operating system will only be available within the server process discouraging package authors from putting too much logic into their views well use a combination of asynchronous channels and crdts to present convenient apis to package authors within worker threads text is stored in a copy on write crdt to fully exploit rusts unique advantage of parallelism we need to store text in a concurrency friendly way we use a variant of rga called rgasplit which is described in this research paper in rga split the document is stored as a sequence of insertion fragments in the example above the document starts as just a single insertion containing hello world we then introduce there and as additional insertions splitting the original insertion into two fragments to delete the ld at the end of world in the third step we create another fragment containing just the ld and mark it as deleted with a tombstone structuring the document in this way has a number of advantages real time collaboration works out of the box concurrent edits any thread can read or write its own replica of the document without diverging in the presence of concurrent edits integrated non linear history to undo any group of operations we increment an undo counter associated with any insertions and deletions that controls their visibility this means we only need to store operation ids in the history rather than operations themselves and we can undo any operation at any time rather than adhering to historical order stable logical positions instead of tracking the location of markers on every edit we can refer to stable positions that are guaranteed to be valid for any future buffer state for example we can mark the positions of all search results in a background thread and continue to interpret them in a foreground thread if edits are performed in the meantime our use of a crdt is similar to the xi editor but the approach were exploring is somewhat different our current understanding is that in xi the buffer is stored in a rope data structure then a secondary layer is used to incorporate edits in xray the fundamental storage structure of all text is itself a crdt its similar to xis rope in that it uses a copy on write b tree to index all inserted fragments but it does not require any secondary system for incorporating edits derived state will be computed asynchronously we should avoid implementing synchronous apis that depend on open ended computations of derived state for example when soft wrapping is enabled in atom we synchronously update a display index that maps display coordinates to buffer coordinates which can block the ui in xray we want to avoid making these kinds of promises in our api for example we will allow the display index to be accessed synchronously after a buffer edit but only provide an interpolated version of its state that can be produced in logarithmic time this means it will be spatially consistent with the underlying buffer but may contain lines that have not yet been soft wrapped we can expose an asynchronous api that allows a package author to wait until the display layer is up to date with a specific version of the buffer in the user interface we can display a progress bar for any derived state updates that exceed 50ms which may occur when the user pastes multiple megabytes of text into the editor react will be used for presentation by using react we completely eliminate the view framework as a concern that we need to deal with and give package authors access to a tool theyre likely to be familiar with we also raise the level of abstraction above basic dom apis the risk of using react is of course that it is not standardized and could have breaking api changes to mitigate this risk we will require packages to declare which version of react they depend on we will attempt using this version information to provide shims to older versions of react when we upgrade the bundled version when its not possible to shim breaking changes well use the version information to present a warning styling will be specified in js css is a widely known and well supported tool for styling user interfaces which is why we embraced it in atom unfortunately the performance and maintainability of css degrade as the number of selectors increases css also lacks good tools for exposing a versioned theming api and applying programmatic logic such as altering colors finally the browser does not expose apis for being notified when computed styles change making it difficult to use css as a source of truth for complex components for a theming system that performs well and scales we need more direct control we plan to use a css in js approach that automatically generates atomic selectors so as to keep our total number of selectors minimal text is rendered via webgl in atom the vast majority of computation of any given frame is spent manipulating the dom recalculating styles and performing layout to achieve good text rendering performance it is critical that we bypass this overhead and take direct control over rendering like alacritty and xi we plan to employ opengl to position quads that are mapped to glyph bitmaps in a texture atlas there isnt always a 1 1 relationship between code units inside a javascript string and glyphs on screen characters code points can be expressed as two 16 bit units but this situation is simple to detect by examining the numeric ranges of the code units in other cases the correspondence between code units and glyphs is less straightforward to determine if the current font and or locale depends on ligatures or contextual alternates to render correctly determining the correspondence between code points and glyphs requires support for complex text shaping that references metadata embedded in the font bi directional text complicates the situation further for now our plan is to detect the presence of characters that may require such complex text shaping and fall back to rendering with html on the specific lines that require these features this will enable us to support scripts such as arabic and devanagari for fonts like firacode which include ligatures for common character sequences used in programming well need a different approach one idea would be to perform a limited subset of text shaping that just handles ligatures so as to keep performance high another approach that would only work on the desktop would be to use the platform text shaping and rasterization apis in this environment bypassing the dom means that well need to implement styling and text layout ourselves that is a high price to pay but we think it will be worth it to bypass the performance overhead imposed by the dom development process experiment at this phase this code is focused on learning whatever code we write should be production quality but we dont need to support everything at this phase we can defer features that dont contribute substantially to learning documentation driven development before coding we ask ourselves whether the code were writing can be motivated by something thats written in the guide the right approach here will always be a judgment call but lets err on the side of transparency and see what happens disciplined monorepo all code related to xray should live in this repository but intra repository dependencies should be expressed in a disciplined way to ensure that a one line docs change doesnt require us to rebuild the world builds should be finger printed on a per component basis and we should aim to keep components granular community sla well formulated prs and issues will receive some form of response by the end of the next business day if this interferes with our ability to learn well revisit contributing interested in helping out welcome check out the contributing guide to get started q1 2018 roadmap by may 1 wed like it to be possible for multiple xray clients to connect to a headless remote workspace clients should be able to open files from the remote project via the file finder and collaboratively edit shared buffers we also would like to enable collaborators to follow each other around and have a text based conversation in the workspace were going to focus on the bare minimum of editor features needed to reach this goal if were collaboratively editing text that isnt syntax highlighted thats ok for now x high performance text rendering x cursors selections and editing x client server architecture x file finder x load and save buffers x remote headless workspace x file finder x loading a buffer x editing can be shared between multiple participants x saving x discussions x flesh out basic editor experience x autoscroll x easy movement and editing operations q2 2018 once we get the basic collaboration experience down well be looking to expand on it by adding the basic features that developers expect from a text editor this list is incomplete and will likely evolve as this time approaches x key bindings system x horizontal scrolling x word and line based cursor movements x gutter with line numbers x basic mouse interaction workspace tabs split panes undo history syntax highlighting diagnostics autocomplete symbolic navigation find and replace in a buffer local project wide search remote project wide search project browser code folding soft wrapping clarify theming following js extensions further optimize multi cursor editing