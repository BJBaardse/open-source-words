gorilla mux http www gorillatoolkit org pkg mux package gorilla mux implements a request router and dispatcher for matching incoming requests to their respective handler the name mux stands for http request multiplexer like the standard http servemux mux router matches incoming requests against a list of registered routes and calls a handler for the route that matches the url or other conditions the main features are it implements the http handler interface so it is compatible with the standard http servemux requests can be matched based on url host path path prefix schemes header and query values http methods or using custom matchers url hosts paths and query values can have variables with an optional regular expression registered urls can be built or reversed which helps maintaining references to resources routes can be used as subrouters nested routes are only tested if the parent route matches this is useful to define groups of routes that share common conditions like a host a path prefix or other repeated attributes as a bonus this optimizes request matching install examples matching routes static files registered urls walking routes graceful shutdown middleware testing handlers full example install with a correctly configured go toolchain sh go get u github com gorilla mux examples lets start registering a couple of url paths and handlers go func main r mux newrouter r handlefunc homehandler r handlefunc products productshandler r handlefunc articles articleshandler http handle r here we register three routes mapping url paths to handlers this is equivalent to how http handlefunc works if an incoming request url matches one of the paths the corresponding handler is called passing http responsewriter http request as parameters paths can have variables they are defined using the format name or name pattern if a regular expression pattern is not defined the matched variable will be anything until the next slash for example go r mux newrouter r handlefunc products key producthandler r handlefunc articles category articlescategoryhandler r handlefunc articles category id 0 9 articlehandler the names are used to create a map of route variables which can be retrieved calling mux vars go func articlescategoryhandler w http responsewriter r http request vars mux vars r w writeheader http statusok fmt fprintf w category v\n vars category and this is all you need to know about the basic usage more advanced options are explained below matching routes routes can also be restricted to a domain or subdomain just define a host pattern to be matched they can also have variables go r mux newrouter only matches if domain is www example com r host www example com matches a dynamic subdomain r host subdomain a z domain com there are several other matchers that can be added to match path prefixes go r pathprefix products or http methods go r methods get post or url schemes go r schemes https or header values go r headers x requested with xmlhttprequest or query values go r queries key value or to use a custom matcher function go r matcherfunc func r http request rm routematch bool return r protomajor 0 and finally it is possible to combine several matchers in a single route go r handlefunc products productshandler host www example com methods get schemes http routes are tested in the order they were added to the router if two routes match the first one wins go r mux newrouter r handlefunc specific specifichandler r pathprefix handler catchallhandler setting the same matching conditions again and again can be boring so we have a way to group several routes that share the same requirements we call it subrouting for example lets say we have several urls that should only match when the host is www example com create a route for that host and get a subrouter from it go r mux newrouter s r host www example com subrouter then register routes in the subrouter go s handlefunc products productshandler s handlefunc products key producthandler s handlefunc articles category id 0 9 articlehandler the three url paths we registered above will only be tested if the domain is www example com because the subrouter is tested first this is not only convenient but also optimizes request matching you can create subrouters combining any attribute matchers accepted by a route subrouters can be used to create domain or path namespaces you define subrouters in a central place and then parts of the app can register its paths relatively to a given subrouter theres one more thing about subroutes when a subrouter has a path prefix the inner routes use it as base for their paths go r mux newrouter s r pathprefix products subrouter products s handlefunc productshandler products key s handlefunc key producthandler products key details s handlefunc key details productdetailshandler static files note that the path provided to pathprefix represents a wildcard calling pathprefix static handler means that the handler will be passed any request that matches static this makes it easy to serve static files with mux go func main var dir string flag stringvar dir dir the directory to serve files from defaults to the current dir flag parse r mux newrouter this will serve files under http localhost 8000 static filename r pathprefix static handler http stripprefix static http fileserver http dir dir srv http server handler r addr 127 0 0 1 8000 good practice enforce timeouts for servers you create writetimeout 15 time second readtimeout 15 time second log fatal srv listenandserve registered urls now lets see how to build registered urls routes can be named all routes that define a name can have their urls built or reversed we define a name calling name on a route for example go r mux newrouter r handlefunc articles category id 0 9 articlehandler name article to build a url get the route and call the url method passing a sequence of key value pairs for the route variables for the previous route we would do go url err r get article url category technology id 42 and the result will be a url url with the following path articles technology 42 this also works for host and query value variables go r mux newrouter r host subdomain domain com path articles category id 0 9 queries filter filter handlerfunc articlehandler name article url string will be http news domain com articles technology 42 filter gorilla url err r get article url subdomain news category technology id 42 filter gorilla all variables defined in the route are required and their values must conform to the corresponding patterns these requirements guarantee that a generated url will always match a registered route the only exception is for explicitly defined build only routes which never match regex support also exists for matching headers within a route for example we could do go r headersregexp content type application text json and the route will match both requests with a content type of application json as well as application text theres also a way to build only the url host or path for a route use the methods urlhost or urlpath instead for the previous route we would do go http news domain com host err r get article urlhost subdomain news articles technology 42 path err r get article urlpath category technology id 42 and if you use subrouters host and path defined separately can be built as well go r mux newrouter s r host subdomain domain com subrouter s path articles category id 0 9 handlerfunc articlehandler name article http news domain com articles technology 42 url err r get article url subdomain news category technology id 42 walking routes the walk function on mux router can be used to visit all of the routes that are registered on a router for example the following prints all of the registered routes go package main import fmt net http strings github com gorilla mux func handler w http responsewriter r http request return func main r mux newrouter r handlefunc handler r handlefunc products handler methods post r handlefunc articles handler methods get r handlefunc articles id handler methods get put r handlefunc authors handler queries surname surname err r walk func route mux route router mux router ancestors mux route error pathtemplate err route getpathtemplate if err nil fmt println route pathtemplate pathregexp err route getpathregexp if err nil fmt println path regexp pathregexp queriestemplates err route getqueriestemplates if err nil fmt println queries templates strings join queriestemplates queriesregexps err route getqueriesregexp if err nil fmt println queries regexps strings join queriesregexps methods err route getmethods if err nil fmt println methods strings join methods fmt println return nil if err nil fmt println err http handle r graceful shutdown go 1 8 introduced the ability to gracefully shutdown a http server heres how to do that alongside mux go package main import context flag log net http os os signal time github com gorilla mux func main var wait time duration flag durationvar wait graceful timeout time second 15 the duration for which the server gracefully wait for existing connections to finish e g 15s or 1m flag parse r mux newrouter add your routes as needed srv http server addr 0 0 0 0 8080 good practice to set timeouts to avoid slowloris attacks writetimeout time second 15 readtimeout time second 15 idletimeout time second 60 handler r pass our instance of gorilla mux in run our server in a goroutine so that it doesnt block go func if err srv listenandserve err nil log println err c make chan os signal 1 well accept graceful shutdowns when quit via sigint ctrl c sigkill sigquit or sigterm ctrl will not be caught signal notify c os interrupt block until we receive our signal c create a deadline to wait for ctx cancel context withtimeout context background wait defer cancel doesnt block if no connections but will otherwise wait until the timeout deadline srv shutdown ctx optionally you could run srv shutdown in a goroutine and block on ctx done if your application should wait for other services to finalize based on context cancellation log println shutting down os exit 0 middleware mux supports the addition of middlewares to a router which are executed in the order they are added if a match is found including its subrouters middlewares are typically small pieces of code which take one request do something with it and pass it down to another middleware or the final handler some common use cases for middleware are request logging header manipulation or responsewriter hijacking mux middlewares are defined using the de facto standard type go type middlewarefunc func http handler http handler typically the returned handler is a closure which does something with the http responsewriter and http request passed to it and then calls the handler passed as parameter to the middlewarefunc this takes advantage of closures being able access variables from the context where they are created while retaining the signature enforced by the receivers a very basic middleware which logs the uri of the request being handled could be written as go func loggingmiddleware next http handler http handler return http handlerfunc func w http responsewriter r http request do stuff here log println r requesturi call the next handler which can be another middleware in the chain or the final handler next servehttp w r middlewares can be added to a router using router use go r mux newrouter r handlefunc handler r use loggingmiddleware a more complex authentication middleware which maps session token to users could be written as go define our struct type authenticationmiddleware struct tokenusers map string string initialize it somewhere func amw authenticationmiddleware populate amw tokenusers 00000000 user0 amw tokenusers aaaaaaaa usera amw tokenusers 05f717e5 randomuser amw tokenusers deadbeef user0 middleware function which will be called for each request func amw authenticationmiddleware middleware next http handler http handler return http handlerfunc func w http responsewriter r http request token r header get x session token if user found amw tokenusers token found we found the token in our map log printf authenticated user s\n user pass down the request to the next middleware or final handler next servehttp w r else write an error and stop the handler chain http error w forbidden http statusforbidden go r mux newrouter r handlefunc handler amw authenticationmiddleware amw populate r use amw middleware note the handler chain will be stopped if your middleware doesnt call next servehttp with the corresponding parameters this can be used to abort a request if the middleware writer wants to middlewares should write to responsewriter if they are going to terminate the request and they should not write to responsewriter if they are not going to terminate it testing handlers testing handlers in a go web application is straightforward and mux doesnt complicate this any further given two files endpoints go and endpoints test go heres how wed test an application using mux first our simple http handler go endpoints go package main func healthcheckhandler w http responsewriter r http request a very simple health check w writeheader http statusok w header set content type application json in the future we could report back on the status of our db or our cache e g redis by performing a simple ping and include them in the response io writestring w alive true func main r mux newrouter r handlefunc health healthcheckhandler log fatal http listenandserve localhost 8080 r our test code go endpoints test go package main import net http net http httptest testing func testhealthcheckhandler t testing t create a request to pass to our handler we dont have any query parameters for now so well pass nil as the third parameter req err http newrequest get health nil if err nil t fatal err we create a responserecorder which satisfies http responsewriter to record the response rr httptest newrecorder handler http handlerfunc healthcheckhandler our handlers satisfy http handler so we can call their servehttp method directly and pass in our request and responserecorder handler servehttp rr req check the status code is what we expect if status rr code status http statusok t errorf handler returned wrong status code got v want v status http statusok check the response body is what we expect expected alive true if rr body string expected t errorf handler returned unexpected body got v want v rr body string expected in the case that our routes have variables we can pass those in the request we could write table driven tests to test multiple possible route variables as needed go endpoints go func main r mux newrouter a route with a route variable r handlefunc metrics type metricshandler log fatal http listenandserve localhost 8080 r our test file with a table driven test of routevariables go endpoints test go func testmetricshandler t testing t tt struct routevariable string shouldpass bool goroutines true heap true counters true queries true adhadaeqm3k false for tc range tt path fmt sprintf metrics s tc routevariable req err http newrequest get path nil if err nil t fatal err rr httptest newrecorder need to create a router that we can pass the request through so that the vars will be added to the context router mux newrouter router handlefunc metrics type metricshandler router servehttp rr req in this case our metricshandler returns a non 200 response for a route variable it doesnt know about if rr code http statusok tc shouldpass t errorf handler should have failed on routevariable s got v want v tc routevariable rr code http statusok full example heres a complete runnable example of a small mux based server go package main import net http log github com gorilla mux func yourhandler w http responsewriter r http request w write byte gorilla \n func main r mux newrouter routes consist of a path and a handler function r handlefunc yourhandler bind to a port and pass our router in log fatal http listenandserve 8000 r license bsd licensed see the license file for details