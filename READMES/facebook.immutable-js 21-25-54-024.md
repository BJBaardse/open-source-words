immutable collections for javascript immutable data cannot be changed once created leading to much simpler application development no defensive copying and enabling advanced memoization and change detection techniques with simple logic persistent data presents a mutative api which does not update the data in place but instead always yields new updated data immutable js provides many persistent immutable data structures including list stack map orderedmap set orderedset and record these data structures are highly efficient on modern javascript vms by using structural sharing via hash maps tries and vector tries as popularized by clojure and scala minimizing the need to copy or cache data immutable js also provides a lazy seq allowing efficient chaining of collection methods like map and filter without creating intermediate representations create some seq with range and repeat want to hear more watch the presentation about immutable js getting started install immutable using npm shell npm install immutable then require it into any module runkit activate js const map require immutable const map1 map a 1 b 2 c 3 const map2 map1 set b 50 map1 get b vs map2 get b 2 vs 50 browser immutable js has no dependencies which makes it predictable to include in a browser its highly recommended to use a module bundler like webpack rollup or browserify the immutable npm module works without any additional consideration all examples throughout the documentation will assume use of this kind of tool alternatively immutable js may be directly included as a script tag download or link to a cdn such as cdnjs or jsdelivr use a script tag to directly add immutable to the global scope html script src immutable min js script script var map1 immutable map a 1 b 2 c 3 var map2 map1 set b 50 map1 get b 2 map2 get b 50 script or use an amd style loader such as requirejs js require immutable min js function immutable var map1 immutable map a 1 b 2 c 3 var map2 map1 set b 50 map1 get b 2 map2 get b 50 flow typescript use these immutable collections and sequences as you would use native collections in your flowtype or typescript programs while still taking advantage of type generics error detection and auto complete in your ide installing immutable via npm brings with it type definitions for flow v0 55 0 or higher and typescript v2 1 0 or higher so you shouldnt need to do anything at all using typescript with immutable js v4 immutable js type definitions embrace es2015 while immutable js itself supports legacy browsers and environments its type definitions require typescripts 2015 lib include either target es2015 or lib es2015 in your tsconfig json or provide target es2015 or lib es2015 to the tsc command runkit activate js const map require immutable const map1 map a 1 b 2 c 3 const map2 map1 set b 50 map1 get b vs map2 get b 2 vs 50 using typescript with immutable js v3 and earlier previous versions of immutable js include a reference file which you can include via relative path to the type definitions at the top of your file js reference path node modules immutable dist immutable d ts import immutable from require immutable var map1 immutable map string number map1 immutable map a 1 b 2 c 3 var map2 map1 set b 50 map1 get b 2 map2 get b 50 the case for immutability much of what makes application development difficult is tracking mutation and maintaining state developing with immutable data encourages you to think differently about how data flows through your application subscribing to data events throughout your application creates a huge overhead of book keeping which can hurt performance sometimes dramatically and creates opportunities for areas of your application to get out of sync with each other due to easy to make programmer error since immutable data never changes subscribing to changes throughout the model is a dead end and new data can only ever be passed from above this model of data flow aligns well with the architecture of react and especially well with an application designed using the ideas of flux when data is passed from above rather than being subscribed to and youre only interested in doing work when something has changed you can use equality immutable collections should be treated as values rather than objects while objects represent some thing which could change over time a value represents the state of that thing at a particular instance of time this principle is most important to understanding the appropriate use of immutable data in order to treat immutable js collections as values its important to use the immutable is function or equals method to determine value equality instead of the operator which determines object reference identity runkit activate js const map require immutable const map1 map a 1 b 2 c 3 const map2 map a 1 b 2 c 3 map1 equals map2 true map1 map2 false note as a performance optimization immutable js attempts to return the existing collection when an operation would result in an identical collection allowing for using reference equality to determine if something definitely has not changed this can be extremely useful when used within a memoization function which would prefer to re run the function if a deeper equality check could potentially be more costly the equality check is also used internally by immutable is and equals as a performance optimization runkit activate js const map require immutable const map1 map a 1 b 2 c 3 const map2 map1 set b 2 set to same value map1 map2 true if an object is immutable it can be copied simply by making another reference to it instead of copying the entire object because a reference is much smaller than the object itself this results in memory savings and a potential boost in execution speed for programs which rely on copies such as an undo stack runkit activate js const map require immutable const map map a 1 b 2 c 3 const mapcopy map look copies are free javascript first api while immutable js is inspired by clojure scala haskell and other functional programming environments its designed to bring these powerful concepts to javascript and therefore has an object oriented api that closely mirrors that of es2015 array map and set the difference for the immutable collections is that methods which would mutate the collection like push set unshift or splice instead return a new immutable collection methods which return new arrays like slice or concat instead return new immutable collections runkit activate js const list require immutable const list1 list 1 2 const list2 list1 push 3 4 5 const list3 list2 unshift 0 const list4 list1 concat list2 list3 assert equal list1 size 2 assert equal list2 size 5 assert equal list3 size 6 assert equal list4 size 13 assert equal list4 get 0 1 almost all of the methods on array will be found in similar form on immutable list those of map found on immutable map and those of set found on immutable set including collection operations like foreach and map runkit activate js const map require immutable const alpha map a 1 b 2 c 3 d 4 alpha map v k k touppercase join a b c d convert from raw javascript objects and arrays designed to inter operate with your existing javascript immutable js accepts plain javascript arrays and objects anywhere a method expects a collection runkit activate js const map list require immutable const map1 map a 1 b 2 c 3 d 4 const map2 map c 10 a 20 t 30 const obj d 100 o 200 g 300 const map3 map1 merge map2 obj map a 20 b 2 c 10 d 100 t 30 o 200 g 300 const list1 list 1 2 3 const list2 list 4 5 6 const array 7 8 9 const list3 list1 concat list2 array list 1 2 3 4 5 6 7 8 9 this is possible because immutable js can treat any javascript array or object as a collection you can take advantage of this in order to get sophisticated collection methods on javascript objects which otherwise have a very sparse native api because seq evaluates lazily and does not cache intermediate results these operations can be extremely efficient runkit activate js const seq require immutable const myobject a 1 b 2 c 3 seq myobject map x x x toobject a 1 b 4 c 9 keep in mind when using js objects to construct immutable maps that javascript object properties are always strings even if written in a quote less shorthand while immutable maps accept keys of any type runkit activate js const fromjs require immutable const obj 1 one console log object keys obj 1 console log obj 1 obj 1 one one const map fromjs obj console log map get 1 map get 1 one undefined property access for javascript objects first converts the key to a string but since immutable map keys can be of any type the argument to get is not altered converts back to raw javascript objects all immutable js collections can be converted to plain javascript arrays and objects shallowly with toarray and toobject or deeply with tojs all immutable collections also implement tojson allowing them to be passed to json stringify directly they also respect the custom tojson methods of nested objects runkit activate js const map list require immutable const deep map a 1 b 2 c list 3 4 5 console log deep toobject a 1 b 2 c list 3 4 5 console log deep toarray 1 2 list 3 4 5 console log deep tojs a 1 b 2 c 3 4 5 json stringify deep a 1 b 2 c 3 4 5 embraces es2015 immutable js supports all javascript environments including legacy browsers even ie8 however it also takes advantage of features added to javascript in es2015 the latest standard version of javascript including iterators arrow functions classes and modules its inspired by the native map and set collections added to es2015 all examples in the documentation are presented in es2015 to run in all browsers they need to be translated to es5 js es2015 const mapped foo map x x x es5 var mapped foo map function x return x x all immutable js collections are iterable which allows them to be used anywhere an iterable is expected such as when spreading into an array runkit activate js const list require immutable const alist list 1 2 3 const anarray 0 alist 4 5 0 1 2 3 4 5 note a collection is always iterated in the same order however that order may not always be well defined as is the case for the map and set nested structures the collections in immutable js are intended to be nested allowing for deep trees of data similar to json runkit activate js const fromjs require immutable const nested fromjs a b c 3 4 5 map a map b map c list 3 4 5 a few power tools allow for reading and operating on nested data the most useful are mergedeep getin setin and updatein found on list map and orderedmap runkit activate js const fromjs require immutable const nested fromjs a b c 3 4 5 const nested2 nested mergedeep a b d 6 map a map b map c list 3 4 5 d 6 console log nested2 getin a b d 6 const nested3 nested2 updatein a b d value value 1 console log nested3 map a map b map c list 3 4 5 d 7 const nested4 nested3 updatein a b c list list push 6 map a map b map c list 3 4 5 6 d 7 equality treats collections as values immutable js collections are treated as pure data values two immutable collections are considered value equal via equals or is if they represent the same collection of values this differs from javascripts typical reference equal via or for objects and arrays which only determines if two variables represent references to the same object instance consider the example below where two identical map instances are not reference equal but are value equal runkit activate js first consider const obj1 a 1 b 2 c 3 const obj2 a 1 b 2 c 3 obj1 obj2 two different instances are always not equal with const map is require immutable const map1 map a 1 b 2 c 3 const map2 map a 1 b 2 c 3 map1 map2 two different instances are not reference equal map1 equals map2 but are value equal if they have the same values is map1 map2 alternatively can use the is function value equality allows immutable js collections to be used as keys in maps or values in sets and retrieved with different but equivalent collections runkit activate js const map set require immutable const map1 map a 1 b 2 c 3 const map2 map a 1 b 2 c 3 const set set add map1 set has map2 true because these are value equal note is uses the same measure of equality as object is for scalar strings and numbers but uses value equality for immutable collections determining if both are immutable and all keys and values are equal using the same measure of equality performance tradeoffs while value equality is useful in many circumstances it has different performance characteristics than reference equality understanding these tradeoffs may help you decide which to use in each case especially when used to memoize some operation when comparing two collections value equality may require considering every item in each collection on an o n time complexity for large collections of values this could become a costly operation though if the two are not equal and hardly similar the inequality is determined very quickly in contrast when comparing two collections with reference equality only the initial references to memory need to be compared which is not based on the size of the collections which has an o 1 time complexity checking reference equality is always very fast however just because two collections are not reference equal does not rule out the possibility that they may be value equal return self on no op optimization when possible immutable js avoids creating new objects for updates where no change in value occurred to allow for efficient reference equality checking to quickly determine if no change occurred runkit activate js const map require immutable const originalmap map a 1 b 2 c 3 const updatedmap originalmap set b 2 updatedmap originalmap no op set returned the original reference however updates which do result in a change will return a new reference each of these operations occur independently so two similar updates will not return the same reference runkit activate js const map require immutable const originalmap map a 1 b 2 c 3 const updatedmap originalmap set b 1000 new instance leaving the original immutable updatedmap originalmap const anotherupdatedmap originalmap set b 1000 despite both the results of the same operation each created a new reference anotherupdatedmap updatedmap however the two are value equal anotherupdatedmap equals updatedmap batching mutations if a tree falls in the woods does it make a sound if a pure function mutates some local data in order to produce an immutable return value is that ok — rich hickey clojure applying a mutation to create a new immutable object results in some overhead which can add up to a minor performance penalty if you need to apply a series of mutations locally before returning immutable js gives you the ability to create a temporary mutable transient copy of a collection and apply a batch of mutations in a performant manner by using withmutations in fact this is exactly how immutable js applies complex mutations itself as an example building list2 results in the creation of 1 not 3 new immutable lists runkit activate js const list require immutable const list1 list 1 2 3 const list2 list1 withmutations function list list push 4 push 5 push 6 assert equal list1 size 3 assert equal list2 size 6 note immutable js also provides asmutable and asimmutable but only encourages their use when withmutations will not suffice use caution to not return a mutable copy which could result in undesired behavior important only a select few methods can be used in withmutations including set push and pop these methods can be applied directly against a persistent data structure where other methods like map filter sort and splice will always return new immutable data structures and never mutate a mutable collection lazy seq seq describes a lazy operation allowing them to efficiently chain use of all the higher order collection methods such as map and filter by not creating intermediate collections seq is immutable — once a seq is created it cannot be changed appended to rearranged or otherwise modified instead any mutative method called on a seq will return a new seq seq is lazy — seq does as little work as necessary to respond to any method call values are often created during iteration including implicit iteration when reducing or converting to a concrete data structure such as a list or javascript array for example the following performs no work because the resulting seqs values are never iterated js const seq require immutable const oddsquares seq 1 2 3 4 5 6 7 8 filter x x 2 0 map x x x once the seq is used it performs only the work necessary in this example no intermediate arrays are ever created filter is called three times and map is only called once js oddsquares get 1 9 any collection can be converted to a lazy seq with seq runkit activate js const map seq require immutable const map map a 1 b 2 c 3 const lazyseq seq map seq allows for the efficient chaining of operations allowing for the expression of logic that can otherwise be very tedious js lazyseq flip map key key touppercase flip seq a 1 b 1 c 1 as well as expressing logic that would otherwise seem memory or time limited for example range is a special kind of lazy sequence runkit activate js const range require immutable range 1 infinity skip 1000 map n n filter n n 2 0 take 2 reduce r n r n 1 1006008 documentation read the docs and eat your vegetables docs are automatically generated from immutable d ts please contribute also dont miss the wiki which contains articles on specific topics cant find something open an issue testing if you are using the chai assertion library chai immutable provides a set of assertions to use against immutable js collections contribution use github issues for requests we actively welcome pull requests learn how to contribute changelog changes are tracked as github releases thanks phil bagwell for his inspiration and research in persistent data structures hugh jackson for providing the npm package name if youre looking for his unsupported package see this repository license immutable js is mit licensed