principles of writing consistent idiomatic javascript this is a living document and new ideas for improving the code around us are always welcome contribute fork clone branch commit push pull request rick waldron rwaldron github mathias bynens mathias github schalk neethling ossreleasefeed github kit cambridge kitcambridge github raynos github matias arriola matiasarriola github john fischer jfroffice github idan gazit idangazit github leo balter leobalter github breno oliveira garu rj github leo beto souza leobetosouza github ryuichi okumura okuryu github pascal precht pascalprecht github engfordev engfordev hwan min hong mintaek kwon leoinsight tw shim marocchino github nassol kim nassol99 github juntai park rkjun github minkyu shim gangmin won justin yoo justinchronicle daeyup lee marco trulla marcotrulla github alex navasardyan alexnavasardyan github mihai paun mihaipaun github evgeny mandrikov godin github sofish lin sofish github дејан димић dejan dimic github miloš gavrilović gavrisimo github firede firede github monkadd github stephan lindauer stephanlindauer github thomas p dragon5689 github yotam ofek yotamofek github aleksandr filatov greybax github duc nguyen ducntq github james young jamsyoung github hao wei jeng l0ckys github richard gibson gibson042 github fesuy github stephane moreau github all code in any code base should look like a single person typed it no matter how many people contributed the following list outlines the practices that i use in all code that i am the original author of contributions to projects that i have created should follow these guidelines i do not intend to impose my style preferences on other peoples code or projects if an existing common style exists it should be respected arguments over style are pointless there should be a style guide and you should follow it rebecca murphey part of being a good steward to a successful project is realizing that writing code for yourself is a bad idea™ if thousands of people are using your code then write your code for maximum clarity not your personal preference of how to get clever within the spec idan gazit translations german french spanish portuguese brazil korean 日本語 italian russian romanian 简体中文 serbian cyrilic alphabet serbian latin alphabet 繁體中文 indonesian greek important non idiomatic stuff code quality tools resources references javascript plugin for sonar plato jsperf jsfiddle codepen jsbin javascript lint jsl jshint jslint eslint jscs jscodesniffer editorconfig hound get smart annotated ecmascript 5 1 ecmascript language specification 5 1 edition the following should be considered 1 incomplete and 2 required reading i dont always agree with the style written by the authors below but one thing is certain they are consistent furthermore these are authorities on the language baseline for front end developers 2015 eloquent javascript javascript javascript adventures in javascript development perfection kills douglas crockfords wrrrld wide web js assessment build deployment process projects should always attempt to include some generic means by which source can be linted tested and compressed in preparation for production use for this task grunt by ben alman is second to none and has officially replaced the kits directory of this repo test facility projects must include some form of unit reference implementation or functional testing use case demos do not qualify as tests the following is a list of test frameworks none of which are endorsed more than the other qunit jasmine vows mocha hiro jstestdriver buster js sinon js tape table of contents whitespace beautiful syntax type checking courtesy jquery core style guidelines conditional evaluation practical style naming misc native host objects comments one language code preface the following sections outline a reasonable style guide for modern javascript development and are not meant to be prescriptive the most important take away is the law of code style consistency whatever you choose as the style for your project should be considered law link to this document as a statement of your projects commitment to code style consistency readability and maintainability idiomatic style manifesto whitespace never mix spaces and tabs when beginning a project before you write any code choose between soft indents spaces or real tabs consider this law for readability i always recommend setting your editors indent size to two characters — this means two spaces or two spaces representing a real tab if your editor supports it always work with the show invisibles setting turned on the benefits of this practice are enforced consistency eliminating end of line whitespace eliminating blank line whitespace commits and diffs that are easier to read use editorconfig when possible it supports most ides and handles most whitespace settings beautiful syntax a parens braces linebreaks javascript if else for while try always have spaces braces and span multiple lines this encourages readability 2 a 1 1 examples of really cramped syntax if condition dosomething while condition iterating for var i 0 i 100 i someiterativefn 2 a 1 1 use whitespace to promote readability if condition statements while condition statements for var i 0 i 100 i statements even better var i length 100 for i 0 i length i statements or var i 0 length 100 for i length i statements var prop for prop in object statements if true statements else statements b assignments declarations functions named expression constructor javascript 2 b 1 1 variables var foo bar num 1 undef literal notations var array object 2 b 1 2 using only one var per scope function or one var for each variable promotes readability and keeps your declaration list free of clutter using one var per variable you can take more control of your versions and makes it easier to reorder the lines one var per scope makes it easier to detect undeclared variables that may become implied globals choose better for your project and never mix them bad var foo bar var qux good var foo var bar var qux or var foo bar qux or var comment on these foo bar quux 2 b 1 3 var statements should always be in the beginning of their respective scope function bad function foo some statements here var bar qux good function foo var bar qux all statements after the variables declarations 2 b 1 4 const and let from ecmascript 6 should likewise be at the top of their scope block bad function foo let foo bar if condition bar statements good function foo let foo if condition let bar statements javascript 2 b 2 1 named function declaration function foo arg1 argn usage foo arg1 argn 2 b 2 2 named function declaration function square number return number number usage square 10 really contrived continuation passing style function square number callback callback number number square 10 function square callback statements 2 b 2 3 function expression var square function number return something valuable and relevant return number number function expression with identifier this preferred form has the added value of being able to call itself and have an identity in stack traces var factorial function factorial number if number 2 return 1 return number factorial number 1 2 b 2 4 constructor declaration function foobar options this options options usage var foobar new foobar a alpha foobar options a alpha c exceptions slight deviations javascript 2 c 1 1 functions with callbacks foo function note there is no extra space between the first paren of the executing function call and the word function function accepting an array no space foo alpha beta 2 c 1 2 function accepting an object no space foo a alpha b beta single argument string literal no space foo bar expression parens no space if foo in obj obj obj bar defaults baz d consistency always wins in sections 2 a 2 c the whitespace rules are set forth as a recommendation with a simpler higher purpose consistency its important to note that formatting preferences such as inner whitespace should be considered optional but only one style should exist across the entire source of your project javascript 2 d 1 1 if condition statements while condition statements for var i 0 i 100 i statements if true statements else statements e quotes whether you prefer single or double shouldnt matter there is no difference in how javascript parses them what absolutely must be enforced is consistency never mix quotes in the same project pick one style and stick with it f end of lines and empty lines whitespace can ruin diffs and make changesets impossible to read consider incorporating a pre commit hook that removes end of line whitespace and blanks spaces on empty lines automatically type checking courtesy jquery core style guidelines a actual types string typeof variable string number typeof variable number boolean typeof variable boolean object typeof variable object array array isarray arraylikeobject wherever possible node elem nodetype 1 null variable null null or undefined variable null undefined global variables typeof variable undefined local variables variable undefined properties object prop undefined object hasownproperty prop prop in object b coerced types consider the implications of the following given this html html javascript 3 b 1 1 foo has been declared with the value 0 and its type is number var foo 0 typeof foo number somewhere later in your code you need to update foo with a new value derived from an input element foo document getelementbyid foo input value if you were to test typeof foo now the result would be string this means that if you had logic that tested foo like if foo 1 importanttask importanttask would never be evaluated even though foo has a value of 1 3 b 1 2 you can preempt issues by using smart coercion with unary or operators foo document getelementbyid foo input value unary operator will convert its right side operand to a number typeof foo number if foo 1 importanttask importanttask will be called here are some common cases along with coercions javascript 3 b 2 1 var number 1 string 1 bool false number 1 number 1 string 1 string 1 string 1 string 2 bool false bool 0 bool false javascript 3 b 2 2 var number 1 string 1 bool true string number false string number true string number true bool number false bool number true bool string false bool string true javascript 3 b 2 3 var array a b c array indexof a true array indexof b true array indexof c true array indexof d false note that the above should be considered unnecessarily clever prefer the obvious approach of comparing the returned value of indexof like if array indexof a 0 javascript 3 b 2 4 var num 2 5 parseint num 10 is the same as num num 0 num 0 all result in 2 keep in mind however that negative numbers will be treated differently var neg 2 5 parseint neg 10 is the same as neg neg 0 all result in 2 however neg 0 will result in 4294967294 conditional evaluation javascript 4 1 1 when only evaluating that an array has length instead of this if array length 0 evaluate truthiness like this if array length 4 1 2 when only evaluating that an array is empty instead of this if array length 0 evaluate truthiness like this if array length 4 1 3 when only evaluating that a string is not empty instead of this if string evaluate truthiness like this if string 4 1 4 when only evaluating that a string is empty instead of this if string evaluate falsy ness like this if string 4 1 5 when only evaluating that a reference is true instead of this if foo true evaluate like you mean it take advantage of built in capabilities if foo 4 1 6 when evaluating that a reference is false instead of this if foo false use negation to coerce a true evaluation if foo be careful this will also match 0 null undefined nan if you must test for a boolean false then use if foo false 4 1 7 when only evaluating a ref that might be null or undefined but not false or 0 instead of this if foo null foo undefined take advantage of type coercion like this if foo null remember using will match a null to both null and undefined but not false or 0 null undefined always evaluate for the best most accurate result the above is a guideline not a dogma javascript 4 2 1 type coercion and evaluation notes prefer over unless the case requires loose type evaluation does not coerce type which means that 1 1 false does coerce type which means that 1 1 true 4 2 2 booleans truthies falsies booleans true false truthy foo 1 falsy 0 null undefined nan void 0 practical style javascript 5 1 1 a practical module function global var module function var data secret return this is some boolean property bool true some string value string a string an array property array 1 2 3 4 an object property object lang en us getdata function get the current value of data return data setdata function value set the value of data and return it return data value other things might happen here expose our module to the global object global module module this javascript 5 2 1 a practical constructor function global function ctor foo this foo foo return this ctor prototype getfoo function return this foo ctor prototype setfoo function val return this foo val to call constructors without new you might do this var ctor function foo return new ctor foo expose our constructor to the global object global ctor ctor this naming a you are not a human code compiler compressor so dont try to be one the following code is an example of egregious naming javascript 6 a 1 1 example of code with poor names function q s return document queryselectorall s var i a els q foo for i 0 i els length i a push els i without a doubt youve written code like this hopefully that ends today heres the same piece of logic but with kinder more thoughtful naming and a readable structure javascript 6 a 2 1 example of code with improved names function query selector return document queryselectorall selector var idx 0 elements matches query foo length matches length for idx length idx elements push matches idx a few additional naming pointers javascript 6 a 3 1 naming strings dog is a string 6 a 3 2 naming arrays dogs is an array of dog strings 6 a 3 3 naming functions objects instances etc camelcase function and var declarations 6 a 3 4 naming constructors prototypes etc pascalcase constructor function 6 a 3 5 naming regular expressions rdesc 6 a 3 6 from the google closure library style guide functionnameslikethis variablenameslikethis constructornameslikethis enumnameslikethis methodnameslikethis symbolic constants like this b faces of this beyond the generally well known use cases of call and apply always prefer bind this or a functional equivalent for creating boundfunction definitions for later invocation only resort to aliasing when no preferable option is available javascript 6 b 1 function device opts this value null open an async stream this will be called continuously stream read opts path function data update this instances current value with the most recent value from the data stream this value data bind this throttle the frequency of events emitted from this device instance setinterval function emit a throttled event this emit event bind this opts freq 100 just pretend weve inherited eventemitter when unavailable functional equivalents to bind exist in many modern javascript libraries javascript 6 b 2 eg lodash underscore bind function device opts this value null stream read opts path bind function data this value data this setinterval bind function this emit event this opts freq 100 eg jquery proxy function device opts this value null stream read opts path jquery proxy function data this value data this setinterval jquery proxy function this emit event this opts freq 100 eg dojo hitch function device opts this value null stream read opts path dojo hitch this function data this value data setinterval dojo hitch this function this emit event opts freq 100 as a last resort create an alias to this using self as an identifier this is extremely bug prone and should be avoided whenever possible javascript 6 b 3 function device opts var self this this value null stream read opts path function data self value data setinterval function self emit event opts freq 100 c use thisarg several prototype methods of es 5 1 built ins come with a special thisarg signature which should be used whenever possible javascript 6 c 1 var obj obj f foo b bar q qux object keys obj foreach function key this now refers to obj console log this key obj the last arg is thisarg prints foo bar qux thisarg can be used with array prototype every array prototype foreach array prototype some array prototype map array prototype filter misc this section will serve to illustrate ideas and concepts that should not be considered dogma but instead exists to encourage questioning practices in an attempt to find better ways to do common javascript programming tasks a using switch should be avoided modern method tracing will blacklist functions with switch statements there seems to be drastic improvements to the execution of switch statements in latest releases of firefox and chrome http jsperf com switch vs object literal vs module notable improvements can be witnessed here as well https github com rwldrn idiomatic js issues 13 javascript 7 a 1 1 an example switch statement switch foo case alpha alpha break case beta beta break default something to default to break 7 a 1 2 a alternate approach that supports composability and reusability is to use an object to store cases and a function to delegate var cases delegator example returns for illustration only cases alpha function statements a return return alpha arguments length beta function statements a return return beta arguments length default function statements a return return default arguments length delegator function var args key delegate transform arguments list into an array args slice call arguments shift the case key from the arguments key args shift assign the default case handler delegate cases default derive the method to delegate operation to if cases hasownproperty key delegate cases key the scope arg could be set to something specific in this case null will suffice return delegate apply null args 7 a 1 3 put the api in 7 a 1 2 to work delegator alpha 1 2 3 4 5 alpha 5 of course the case key argument could easily be based on some other arbitrary condition var casekey someuserinput possibly some kind of form input someuserinput 9 if someuserinput 10 casekey alpha else casekey beta or casekey someuserinput 10 alpha beta and then delegator casekey someuserinput beta 1 and of course delegator default 0 b early returns promote code readability with negligible performance difference javascript 7 b 1 1 bad function returnlate foo var ret if foo ret foo else ret quux return ret good function returnearly foo if foo return foo return quux native host objects the basic principle here is dont do stupid shit and everything will be ok to reinforce this concept please watch the following presentation “everything is permitted extending built ins” by andrew dupont jsconf2011 portland oregon http www everytalk tv talks 441 jsconf everything is permitted extending built ins comments single line above the code that is subject multiline is good end of line comments are prohibited jsdoc style is good but requires a significant time investment one language code programs should be written in one language whatever that language may be as dictated by the maintainer or maintainers appendix comma first any project that cites this document as its base style guide will not accept comma first code formatting unless explicitly specified otherwise by that projects author principles of writing consistent idiomatic javascript by rick waldron and contributors is licensed under a creative commons attribution 3 0 unported license based on a work at github com rwldrn idiomatic js