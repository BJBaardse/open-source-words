httprouter httprouter is a lightweight high performance http request router also called multiplexer or just mux for short for go in contrast to the default mux of gos net http package this router supports variables in the routing pattern and matches against the request method it also scales better the router is optimized for high performance and a small memory footprint it scales well even with very long paths and a large number of routes a compressing dynamic trie radix tree structure is used for efficient matching features only explicit matches with other routers like http servemux a requested url path could match multiple patterns therefore they have some awkward pattern priority rules like longest match or first registered first matched by design of this router a request can only match exactly one or no route as a result there are also no unintended matches which makes it great for seo and improves the user experience stop caring about trailing slashes choose the url style you like the router automatically redirects the client if a trailing slash is missing or if there is one extra of course it only does so if the new path has a handler if you dont like it you can turn off this behavior path auto correction besides detecting the missing or additional trailing slash at no extra cost the router can also fix wrong cases and remove superfluous path elements like or is captain caps lock one of your users httprouter can help him by making a case insensitive look up and redirecting him to the correct url parameters in your routing pattern stop parsing the requested url path just give the path segment a name and the router delivers the dynamic value to you because of the design of the router path parameters are very cheap zero garbage the matching and dispatching process generates zero bytes of garbage the only heap allocations that are made are building the slice of the key value pairs for path parameters and building new context and request objects the latter only in the standard handler handlerfunc api in the 3 argument api if the request path contains no parameters not a single heap allocation is necessary best performance benchmarks speak for themselves see below for technical details of the implementation no more server crashes you can set a panic handler to deal with panics occurring during handling a http request the router then recovers and lets the panichandler log what happened and deliver a nice error page perfect for apis the router design encourages to build sensible hierarchical restful apis moreover it has builtin native support for options requests and 405 method not allowed replies of course you can also set custom notfound and methodnotallowed handlers and serve static files usage this is just a quick introduction view the godoc for details lets start with a trivial example go package main import fmt github com julienschmidt httprouter net http log func index w http responsewriter r http request httprouter params fmt fprint w welcome \n func hello w http responsewriter r http request ps httprouter params fmt fprintf w hello s \n ps byname name func main router httprouter new router get index router get hello name hello log fatal http listenandserve 8080 router named parameters as you can see name is a named parameter the values are accessible via httprouter params which is just a slice of httprouter params you can get the value of a parameter either by its index in the slice or by using the byname name method name can be retrived by byname name named parameters only match a single path segment pattern user user user gordon match user you match user gordon profile no match user no match note since this router has only explicit matches you can not register static routes and parameters for the same path segment for example you can not register the patterns user new and user user for the same request method at the same time the routing of different request methods is independent from each other catch all parameters the second type are catch all parameters and have the form name like the name suggests they match everything therefore they must always be at the end of the pattern pattern src filepath src match src somefile go match src subdir somefile go match how does it work the router relies on a tree structure which makes heavy use of common prefixes it is basically a compact prefix tree or just radix tree nodes with a common prefix also share a common parent here is a short example what the routing tree for the get request method could look like priority path handle 9 \ 1 3 ├s nil 2 ├earch\ 2 1 └upport\ 3 2 ├blog\ 4 1 └ post nil 1 └\ 5 2 ├about us\ 6 1 └team\ 7 1 └contact\ 8 every num represents the memory address of a handler function a pointer if you follow a path trough the tree from the root to the leaf you get the complete route path e g \blog\ post\ where post is just a placeholder parameter for an actual post name unlike hash maps a tree structure also allows us to use dynamic parts like the post parameter since we actually match against the routing patterns instead of just comparing hashes as benchmarks show this works very well and efficient since url paths have a hierarchical structure and make use only of a limited set of characters byte values it is very likely that there are a lot of common prefixes this allows us to easily reduce the routing into ever smaller problems moreover the router manages a separate tree for every request method for one thing it is more space efficient than holding a method handle map in every single node it also allows us to greatly reduce the routing problem before even starting the look up in the prefix tree for even better scalability the child nodes on each tree level are ordered by priority where the priority is just the number of handles registered in sub nodes children grandchildren and so on this helps in two ways nodes which are part of the most routing paths are evaluated first this helps to make as much routes as possible to be reachable as fast as possible it is some sort of cost compensation the longest reachable path highest cost can always be evaluated first the following scheme visualizes the tree structure nodes are evaluated from top to bottom and from left to right ├ ├ ├ ├ ├ ├ └ why doesnt this work with http handler it does the router itself implements the http handler interface moreover the router provides convenient adapters for http handlers and http handlerfuncs which allows them to be used as a httprouter handle when registering a route the only disadvantage is that no parameter values can be retrieved when a http handler or http handlerfunc is used since there is no efficient way to pass the values with the existing function parameters therefore httprouter handle has a third function parameter just try it out for yourself the usage of httprouter is very straightforward the package is compact and minimalistic but also probably one of the easiest routers to set up where can i find middleware x this package just provides a very efficient request router with a few extra features the router is just a http handler you can chain any http handler compatible middleware before the router for example the gorilla handlers or you could just write your own its very easy alternatively you could try a web framework based on httprouter multi domain sub domains here is a quick example does your server serve multiple domains hosts you want to use sub domains define a router per host go we need an object that implements the http handler interface therefore we need a type for which we implement the servehttp method we just use a map here in which we map host names with port to http handlers type hostswitch map string http handler implement the servehttp method on our new type func hs hostswitch servehttp w http responsewriter r http request check if a http handler is registered for the given host if yes use it to handle the request if handler hs r host handler nil handler servehttp w r else handle host names for which no handler is registered http error w forbidden 403 or redirect func main initialize a router as usual router httprouter new router get index router get hello name hello make a new hostswitch and insert the router our http handler for example com and port 12345 hs make hostswitch hs example com 12345 router use the hostswitch to listen and serve on port 12345 log fatal http listenandserve 12345 hs basic authentication another quick example basic authentication rfc 2617 for handles go package main import fmt log net http github com julienschmidt httprouter func basicauth h httprouter handle requireduser requiredpassword string httprouter handle return func w http responsewriter r http request ps httprouter params get the basic authentication credentials user password hasauth r basicauth if hasauth user requireduser password requiredpassword delegate request to the given handle h w r ps else request basic authentication otherwise w header set www authenticate basic realm restricted http error w http statustext http statusunauthorized http statusunauthorized func index w http responsewriter r http request httprouter params fmt fprint w not protected \n func protected w http responsewriter r http request httprouter params fmt fprint w protected \n func main user gordon pass secret router httprouter new router get index router get protected basicauth protected user pass log fatal http listenandserve 8080 router chaining with the notfound handler note it might be required to set router handlemethodnotallowed to false to avoid problems you can use another http handler for example another router to handle requests which could not be matched by this router by using the router notfound handler this allows chaining static files the notfound handler can for example be used to serve static files from the root path like an index html file along with other assets go serve static files from the public directory router notfound http fileserver http dir public but this approach sidesteps the strict core rules of this router to avoid routing problems a cleaner approach is to use a distinct sub path for serving files like static filepath or files filepath web frameworks based on httprouter if the httprouter is a bit too minimalistic for you you might try one of the following more high level 3rd party web frameworks building upon the httprouter package ace blazing fast go web framework api2go a json api implementation for go gin features a martini like api with much better performance goat a minimalistic rest api server in go gomiddlewarechain an express js like middleware chain hikaru supports standalone and google appengine hitch hitch ties httprouter httpcontext and middleware up in a bow httpway simple middleware extension with context for httprouter and a server with gracefully shutdown support kami a tiny web framework using x net context medeina inspired by rubys roda and cuba neko a lightweight web application framework for golang river river is a simple and lightweight rest server roxanna an amalgamation of httprouter better logging and hot reload siesta composable http handlers with contexts xmux xmux is a httprouter fork on top of xhandler net context aware