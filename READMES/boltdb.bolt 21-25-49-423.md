bolt bolt is a pure go key value store inspired by howard chus lmdb project the goal of the project is to provide a simple fast and reliable database for projects that dont require a full database server such as postgres or mysql since bolt is meant to be used as such a low level piece of functionality simplicity is key the api will be small and only focus on getting values and setting values thats it project status bolt is stable the api is fixed and the file format is fixed full unit test coverage and randomized black box testing are used to ensure database consistency and thread safety bolt is currently used in high load production environments serving databases as large as 1tb many companies such as shopify and heroku use bolt backed services every day a message from the author the original goal of bolt was to provide a simple pure go key value store and to not bloat the code with extraneous features to that end the project has been a success however this limited scope also means that the project is complete maintaining an open source database requires an immense amount of time and energy changes to the code can have unintended and sometimes catastrophic effects so even simple changes require hours and hours of careful testing and validation unfortunately i no longer have the time or energy to continue this work bolt is in a stable state and has years of successful production use as such i feel that leaving it in its current state is the most prudent course of action if you are interested in using a more featureful version of bolt i suggest that you look at the coreos fork called bbolt ben johnson benbjohnson table of contents getting started installing opening a database transactions read write transactions read only transactions batch read write transactions managing transactions manually using buckets using key value pairs autoincrementing integer for the bucket iterating over keys prefix scans range scans foreach nested buckets database backups statistics read only mode mobile use ios android resources comparison with other databases postgres mysql other relational databases leveldb rocksdb lmdb caveats limitations reading the source other projects using bolt getting started installing to start using bolt install go and run go get sh go get github com boltdb bolt this will retrieve the library and install the bolt command line utility into your gobin path opening a database the top level object in bolt is a db it is represented as a single file on your disk and represents a consistent snapshot of your data to open your database simply use the bolt open function go package main import log github com boltdb bolt func main open the my db data file in your current directory it will be created if it doesnt exist db err bolt open my db 0600 nil if err nil log fatal err defer db close please note that bolt obtains a file lock on the data file so multiple processes cannot open the same database at the same time opening an already open bolt database will cause it to hang until the other process closes it to prevent an indefinite wait you can pass a timeout option to the open function go db err bolt open my db 0600 bolt options timeout 1 time second transactions bolt allows only one read write transaction at a time but allows as many read only transactions as you want at a time each transaction has a consistent view of the data as it existed when the transaction started individual transactions and all objects created from them e g buckets keys are not thread safe to work with data in multiple goroutines you must start a transaction for each one or use locking to ensure only one goroutine accesses a transaction at a time creating transaction from the db is thread safe read only transactions and read write transactions should not depend on one another and generally shouldnt be opened simultaneously in the same goroutine this can cause a deadlock as the read write transaction needs to periodically re map the data file but it cannot do so while a read only transaction is open read write transactions to start a read write transaction you can use the db update function go err db update func tx bolt tx error return nil inside the closure you have a consistent view of the database you commit the transaction by returning nil at the end you can also rollback the transaction at any point by returning an error all database operations are allowed inside a read write transaction always check the return error as it will report any disk failures that can cause your transaction to not complete if you return an error within your closure it will be passed through read only transactions to start a read only transaction you can use the db view function go err db view func tx bolt tx error return nil you also get a consistent view of the database within this closure however no mutating operations are allowed within a read only transaction you can only retrieve buckets retrieve values and copy the database within a read only transaction batch read write transactions each db update waits for disk to commit the writes this overhead can be minimized by combining multiple updates with the db batch function go err db batch func tx bolt tx error return nil concurrent batch calls are opportunistically combined into larger transactions batch is only useful when there are multiple goroutines calling it the trade off is that batch can call the given function multiple times if parts of the transaction fail the function must be idempotent and side effects must take effect only after a successful return from db batch for example dont display messages from inside the function instead set variables in the enclosing scope go var id uint64 err db batch func tx bolt tx error find last key in bucket decode as bigendian uint64 increment by one encode back to byte and add new key id newvalue return nil if err nil return fmt println allocated id d id managing transactions manually the db view and db update functions are wrappers around the db begin function these helper functions will start the transaction execute a function and then safely close your transaction if an error is returned this is the recommended way to use bolt transactions however sometimes you may want to manually start and end your transactions you can use the db begin function directly but please be sure to close the transaction go start a writable transaction tx err db begin true if err nil return err defer tx rollback use the transaction err tx createbucket byte mybucket if err nil return err commit the transaction and check for error if err tx commit err nil return err the first argument to db begin is a boolean stating if the transaction should be writable using buckets buckets are collections of key value pairs within the database all keys in a bucket must be unique you can create a bucket using the db createbucket function go db update func tx bolt tx error b err tx createbucket byte mybucket if err nil return fmt errorf create bucket s err return nil you can also create a bucket only if it doesnt exist by using the tx createbucketifnotexists function its a common pattern to call this function for all your top level buckets after you open your database so you can guarantee that they exist for future transactions to delete a bucket simply call the tx deletebucket function using key value pairs to save a key value pair to a bucket use the bucket put function go db update func tx bolt tx error b tx bucket byte mybucket err b put byte answer byte 42 return err this will set the value of the answer key to 42 in the mybucket bucket to retrieve this value we can use the bucket get function go db view func tx bolt tx error b tx bucket byte mybucket v b get byte answer fmt printf the answer is s\n v return nil the get function does not return an error because its operation is guaranteed to work unless there is some kind of system failure if the key exists then it will return its byte slice value if it doesnt exist then it will return nil its important to note that you can have a zero length value set to a key which is different than the key not existing use the bucket delete function to delete a key from the bucket please note that values returned from get are only valid while the transaction is open if you need to use a value outside of the transaction then you must use copy to copy it to another byte slice autoincrementing integer for the bucket by using the nextsequence function you can let bolt determine a sequence which can be used as the unique identifier for your key value pairs see the example below go createuser saves u to the store the new user id is set on u once the data is persisted func s store createuser u user error return s db update func tx bolt tx error retrieve the users bucket this should be created when the db is first opened b tx bucket byte users generate id for the user this returns an error only if the tx is closed or not writeable that cant happen in an update call so i ignore the error check id b nextsequence u id int id marshal user data into bytes buf err json marshal u if err nil return err persist bytes to users bucket return b put itob u id buf itob returns an 8 byte big endian representation of v func itob v int byte b make byte 8 binary bigendian putuint64 b uint64 v return b type user struct id int iterating over keys bolt stores its keys in byte sorted order within a bucket this makes sequential iteration over these keys extremely fast to iterate over keys well use a cursor go db view func tx bolt tx error assume bucket exists and has keys b tx bucket byte mybucket c b cursor for k v c first k nil k v c next fmt printf key s value s\n k v return nil the cursor allows you to move to a specific point in the list of keys and move forward or backward through the keys one at a time the following functions are available on the cursor first move to the first key last move to the last key seek move to a specific key next move to the next key prev move to the previous key each of those functions has a return signature of key byte value byte when you have iterated to the end of the cursor then next will return a nil key you must seek to a position using first last or seek before calling next or prev if you do not seek to a position then these functions will return a nil key during iteration if the key is non nil but the value is nil that means the key refers to a bucket rather than a value use bucket bucket to access the sub bucket prefix scans to iterate over a key prefix you can combine seek and bytes hasprefix go db view func tx bolt tx error assume bucket exists and has keys c tx bucket byte mybucket cursor prefix byte 1234 for k v c seek prefix k nil bytes hasprefix k prefix k v c next fmt printf key s value s\n k v return nil range scans another common use case is scanning over a range such as a time range if you use a sortable time encoding such as rfc3339 then you can query a specific date range like this go db view func tx bolt tx error assume our events bucket exists and has rfc3339 encoded time keys c tx bucket byte events cursor our time range spans the 90s decade min byte 1990 01 01t00 00 00z max byte 2000 01 01t00 00 00z iterate over the 90s for k v c seek min k nil bytes compare k max 0 k v c next fmt printf s s\n k v return nil note that while rfc3339 is sortable the golang implementation of rfc3339nano does not use a fixed number of digits after the decimal point and is therefore not sortable foreach you can also use the function foreach if you know youll be iterating over all the keys in a bucket go db view func tx bolt tx error assume bucket exists and has keys b tx bucket byte mybucket b foreach func k v byte error fmt printf key s value s\n k v return nil return nil please note that keys and values in foreach are only valid while the transaction is open if you need to use a key or value outside of the transaction you must use copy to copy it to another byte slice nested buckets you can also store a bucket in a key to create nested buckets the api is the same as the bucket management api on the db object go func bucket createbucket key byte bucket error func bucket createbucketifnotexists key byte bucket error func bucket deletebucket key byte error say you had a multi tenant application where the root level bucket was the account bucket inside of this bucket was a sequence of accounts which themselves are buckets and inside the sequence bucket you could have many buckets pertaining to the account itself users notes etc isolating the information into logical groupings go createuser creates a new user in the given account func createuser accountid int u user error start the transaction tx err db begin true if err nil return err defer tx rollback retrieve the root bucket for the account assume this has already been created when the account was set up root tx bucket byte strconv formatuint accountid 10 setup the users bucket bkt err root createbucketifnotexists byte users if err nil return err generate an id for the new user userid err bkt nextsequence if err nil return err u id userid marshal and save the encoded user if buf err json marshal u err nil return err else if err bkt put byte strconv formatuint u id 10 buf err nil return err commit the transaction if err tx commit err nil return err return nil database backups bolt is a single file so its easy to backup you can use the tx writeto function to write a consistent view of the database to a writer if you call this from a read only transaction it will perform a hot backup and not block your other database reads and writes by default it will use a regular file handle which will utilize the operating systems page cache see the tx documentation for information about optimizing for larger than ram datasets one common use case is to backup over http so you can use tools like curl to do database backups go func backuphandlefunc w http responsewriter req http request err db view func tx bolt tx error w header set content type application octet stream w header set content disposition attachment filename my db w header set content length strconv itoa int tx size err tx writeto w return err if err nil http error w err error http statusinternalservererror then you can backup using this command sh curl http localhost backup my db or you can open your browser to http localhost backup and it will download automatically if you want to backup to another file you can use the tx copyfile helper function statistics the database keeps a running count of many of the internal operations it performs so you can better understand whats going on by grabbing a snapshot of these stats at two points in time we can see what operations were performed in that time range for example we could start a goroutine to log stats every 10 seconds go go func grab the initial stats prev db stats for wait for 10s time sleep 10 time second grab the current stats and diff them stats db stats diff stats sub prev encode stats to json and print to stderr json newencoder os stderr encode diff save stats for the next loop prev stats its also useful to pipe these stats to a service such as statsd for monitoring or to provide an http endpoint that will perform a fixed length sample read only mode sometimes it is useful to create a shared read only bolt database to this set the options readonly flag when opening your database read only mode uses a shared lock to allow multiple processes to read from the database but it will block any processes from opening the database in read write mode go db err bolt open my db 0666 bolt options readonly true if err nil log fatal err mobile use ios android bolt is able to run on mobile devices by leveraging the binding feature of the gomobile tool create a struct that will contain your database logic and a reference to a bolt db with a initializing constructor that takes in a filepath where the database file will be stored neither android nor ios require extra permissions or cleanup from using this method go func newboltdb filepath string boltdb db err bolt open filepath demo db 0600 nil if err nil log fatal err return boltdb db type boltdb struct db bolt db func b boltdb path string return b db path func b boltdb close b db close database logic should be defined as methods on this wrapper struct to initialize this struct from the native language both platforms now sync their local storage to the cloud these snippets disable that functionality for the database file android java string path if android os build version sdk int android os build version codes lollipop path getnobackupfilesdir getabsolutepath else path getfilesdir getabsolutepath boltmobiledemo boltdb boltdb boltmobiledemo newboltdb path ios objc void demo nsstring path nssearchpathfordirectoriesindomains nslibrarydirectory nsuserdomainmask yes objectatindex 0 goboltmobiledemoboltdb demo goboltmobiledemonewboltdb path self addskipbackupattributetoitematpath demo path some db logic would go here demo close bool addskipbackupattributetoitematpath nsstring filepathstring nsurl url nsurl fileurlwithpath filepathstring assert nsfilemanager defaultmanager fileexistsatpath url path nserror error nil bool success url setresourcevalue nsnumber numberwithbool yes forkey nsurlisexcludedfrombackupkey error error if success nslog error excluding from backup url lastpathcomponent error return success resources for more information on getting started with bolt check out the following articles intro to boltdb painless performant persistence by nate finch bolt an embedded key value database for go by progville comparison with other databases postgres mysql other relational databases relational databases structure data into rows and are only accessible through the use of sql this approach provides flexibility in how you store and query your data but also incurs overhead in parsing and planning sql statements bolt accesses all data by a byte slice key this makes bolt fast to read and write data by key but provides no built in support for joining values together most relational databases with the exception of sqlite are standalone servers that run separately from your application this gives your systems flexibility to connect multiple application servers to a single database server but also adds overhead in serializing and transporting data over the network bolt runs as a library included in your application so all data access has to go through your applications process this brings data closer to your application but limits multi process access to the data leveldb rocksdb leveldb and its derivatives rocksdb hyperleveldb are similar to bolt in that they are libraries bundled into the application however their underlying structure is a log structured merge tree lsm tree an lsm tree optimizes random writes by using a write ahead log and multi tiered sorted files called sstables bolt uses a b tree internally and only a single file both approaches have trade offs if you require a high random write throughput 10 000 w sec or you need to use spinning disks then leveldb could be a good choice if your application is read heavy or does a lot of range scans then bolt could be a good choice one other important consideration is that leveldb does not have transactions it supports batch writing of key values pairs and it supports read snapshots but it will not give you the ability to do a compare and swap operation safely bolt supports fully serializable acid transactions lmdb bolt was originally a port of lmdb so it is architecturally similar both use a b tree have acid semantics with fully serializable transactions and support lock free mvcc using a single writer and multiple readers the two projects have somewhat diverged lmdb heavily focuses on raw performance while bolt has focused on simplicity and ease of use for example lmdb allows several unsafe actions such as direct writes for the sake of performance bolt opts to disallow actions which can leave the database in a corrupted state the only exception to this in bolt is db nosync there are also a few differences in api lmdb requires a maximum mmap size when opening an mdb env whereas bolt will handle incremental mmap resizing automatically lmdb overloads the getter and setter functions with multiple flags whereas bolt splits these specialized cases into their own functions caveats limitations its important to pick the right tool for the job and bolt is no exception here are a few things to note when evaluating and using bolt bolt is good for read intensive workloads sequential write performance is also fast but random writes can be slow you can use db batch or add a write ahead log to help mitigate this issue bolt uses a b tree internally so there can be a lot of random page access ssds provide a significant performance boost over spinning disks try to avoid long running read transactions bolt uses copy on write so old pages cannot be reclaimed while an old transaction is using them byte slices returned from bolt are only valid during a transaction once the transaction has been committed or rolled back then the memory they point to can be reused by a new page or can be unmapped from virtual memory and youll see an unexpected fault address panic when accessing it bolt uses an exclusive write lock on the database file so it cannot be shared by multiple processes be careful when using bucket fillpercent setting a high fill percent for buckets that have random inserts will cause your database to have very poor page utilization use larger buckets in general smaller buckets causes poor page utilization once they become larger than the page size typically 4kb bulk loading a lot of random writes into a new bucket can be slow as the page will not split until the transaction is committed randomly inserting more than 100 000 key value pairs into a single new bucket in a single transaction is not advised bolt uses a memory mapped file so the underlying operating system handles the caching of the data typically the os will cache as much of the file as it can in memory and will release memory as needed to other processes this means that bolt can show very high memory usage when working with large databases however this is expected and the os will release memory as needed bolt can handle databases much larger than the available physical ram provided its memory map fits in the process virtual address space it may be problematic on 32 bits systems the data structures in the bolt database are memory mapped so the data file will be endian specific this means that you cannot copy a bolt file from a little endian machine to a big endian machine and have it work for most users this is not a concern since most modern cpus are little endian because of the way pages are laid out on disk bolt cannot truncate data files and return free pages back to the disk instead bolt maintains a free list of unused pages within its data file these free pages can be reused by later transactions this works well for many use cases as databases generally tend to grow however its important to note that deleting large chunks of data will not allow you to reclaim that space on disk for more information on page allocation see this comment reading the source bolt is a relatively small code base 3kloc for an embedded serializable transactional key value database so it can be a good starting point for people interested in how databases work the best places to start are the main entry points into bolt open initializes the reference to the database its responsible for creating the database if it doesnt exist obtaining an exclusive lock on the file reading the meta pages memory mapping the file db begin starts a read only or read write transaction depending on the value of the writable argument this requires briefly obtaining the meta lock to keep track of open transactions only one read write transaction can exist at a time so the rwlock is acquired during the life of a read write transaction bucket put writes a key value pair into a bucket after validating the arguments a cursor is used to traverse the b tree to the page and position where they key value will be written once the position is found the bucket materializes the underlying page and the pages parent pages into memory as nodes these nodes are where mutations occur during read write transactions these changes get flushed to disk during commit bucket get retrieves a key value pair from a bucket this uses a cursor to move to the page position of a key value pair during a read only transaction the key and value data is returned as a direct reference to the underlying mmap file so theres no allocation overhead for read write transactions this data may reference the mmap file or one of the in memory node values cursor this object is simply for traversing the b tree of on disk pages or in memory nodes it can seek to a specific key move to the first or last value or it can move forward or backward the cursor handles the movement up and down the b tree transparently to the end user tx commit converts the in memory dirty nodes and the list of free pages into pages to be written to disk writing to disk then occurs in two phases first the dirty pages are written to disk and an fsync occurs second a new meta page with an incremented transaction id is written and another fsync occurs this two phase write ensures that partially written data pages are ignored in the event of a crash since the meta page pointing to them is never written partially written meta pages are invalidated because they are written with a checksum if you have additional notes that could be helpful for others please submit them via pull request other projects using bolt below is a list of public open source projects that use bolt boltdbweb a web based gui for boltdb files operation go a routine mission an online programming game for golang using bolt for user accounts and a leaderboard bazil a file system that lets your data reside where it is most convenient for it to reside dvid added bolt as optional storage engine and testing it against basho tuned leveldb skybox analytics a standalone funnel analysis tool for web analytics scuttlebutt uses bolt to store and process all twitter mentions of github projects wiki a tiny wiki using goji boltdb and blackfriday chainstore simple key value interface to a variety of storage engines organized as a chain of operations metricbase single binary version of graphite gitchain decentralized peer to peer git repositories aka git meets bitcoin event shuttle a unix system service to collect and reliably deliver messages to kafka ipxed web interface and api for ipxed boltstore session store using bolt photosite session sessions for a photo viewing site ledisdb a high performance nosql using bolt as optional storage iplocator a fast ip geo location server using bolt with bloom filters cayley cayley is an open source graph database using bolt as optional backend bleve a pure go search engine similar to elasticsearch that uses bolt as the default storage backend tentacool rest api server to manage system stuff ip dns gateway on a linux server seaweed file system highly scalable distributed key file system with o 1 disk read influxdb scalable datastore for metrics events and real time analytics freehold an open secure and lightweight platform for your files and data prometheus annotation server annotation server for promdash prometheus service monitoring system consul consul is service discovery and configuration made easy distributed highly available and datacenter aware kala kala is a modern job scheduler optimized to run on a single node it is persistent json over http api iso 8601 duration notation and dependent jobs drive drive is an unofficial google drive command line client for nix operating systems stow a persistence manager for objects backed by boltdb buckets a bolt wrapper streamlining simple tx and key scans mbuckets a bolt wrapper that allows easy operations on multi level nested buckets request baskets a web service to collect arbitrary http requests and inspect them via rest api or simple web ui similar to requestbin service go report card go code quality report cards as a free and open source service boltdb boilerplate boilerplate wrapper around bolt aiming to make simple calls one liners lru easy to use bolt backed least recently used lru read through cache with chainable remote stores storm simple and powerful orm for boltdb gowebapp a basic mvc web application in go using boltdb simplebolt a simple way to use boltdb deals mainly with strings algernon a http 2 web server with built in support for lua uses boltdb as the default database backend mulifs music library filesystem creates a filesystem to organise your music files goshort goshort is a url shortener written in golang and boltdb for persistent key value storage and for routing its using high performent httprouter torrent full featured bittorrent client package and utilities in go boltdb is a storage backend in development gopherpit a web service to manage go remote import paths with custom domains bolter command line app for viewing boltdb file in your terminal btcwallet a bitcoin wallet dcrwallet a wallet for the decred cryptocurrency ironsmith a simple script driven continuous integration build test release tool with no external dependencies bolthold an embeddable nosql store for go types built on boltdb ponzu cms headless cms automatic json api with auto https http 2 server push and flexible server framework if you are using bolt in a project please send a pull request to add it to the list