airbnb javascript style guide a mostly reasonable approach to javascript note this guide assumes you are using babel and requires that you use babel preset airbnb or the equivalent it also assumes you are installing shims polyfills in your app with airbnb browser shims or the equivalent this guide is available in other languages too see translation other style guides es5 deprecated react css in javascript css sass ruby table of contents types references objects arrays destructuring strings functions arrow functions classes constructors modules iterators and generators properties variables hoisting comparison operators equality blocks control statements comments whitespace commas semicolons type casting coercion naming conventions accessors events jquery ecmascript 5 compatibility ecmascript 6 es 2015 styles standard library testing performance resources in the wild translation the javascript style guide guide chat with us about javascript contributors license amendments types 1 1 primitives when you access a primitive type you work directly on its value string number boolean null undefined symbol javascript const foo 1 let bar foo bar 9 console log foo bar 1 9 symbols cannot be faithfully polyfilled so they should not be used when targeting browsers environments that dont support them natively 1 2 complex when you access a complex type you work on a reference to its value object array function javascript const foo 1 2 const bar foo bar 0 9 console log foo 0 bar 0 9 9 ⬆ back to top references 2 1 use const for all of your references avoid using var eslint prefer const no const assign why this ensures that you cant reassign your references which can lead to bugs and difficult to comprehend code javascript bad var a 1 var b 2 good const a 1 const b 2 2 2 if you must reassign references use let instead of var eslint no var why let is block scoped rather than function scoped like var javascript bad var count 1 if true count 1 good use the let let count 1 if true count 1 2 3 note that both let and const are block scoped javascript const and let only exist in the blocks they are defined in let a 1 const b 1 console log a referenceerror console log b referenceerror ⬆ back to top objects 3 1 use the literal syntax for object creation eslint no new object javascript bad const item new object good const item 3 2 use computed property names when creating objects with dynamic property names why they allow you to define all the properties of an object in one place javascript function getkey k return a key named k bad const obj id 5 name san francisco obj getkey enabled true good const obj id 5 name san francisco getkey enabled true 3 3 use object method shorthand eslint object shorthand javascript bad const atom value 1 addvalue function value return atom value value good const atom value 1 addvalue value return atom value value 3 4 use property value shorthand eslint object shorthand why it is shorter to write and descriptive javascript const lukeskywalker luke skywalker bad const obj lukeskywalker lukeskywalker good const obj lukeskywalker 3 5 group your shorthand properties at the beginning of your object declaration why its easier to tell which properties are using the shorthand javascript const anakinskywalker anakin skywalker const lukeskywalker luke skywalker bad const obj episodeone 1 twojediwalkintoacantina 2 lukeskywalker episodethree 3 maythefourth 4 anakinskywalker good const obj lukeskywalker anakinskywalker episodeone 1 twojediwalkintoacantina 2 episodethree 3 maythefourth 4 3 6 only quote properties that are invalid identifiers eslint quote props why in general we consider it subjectively easier to read it improves syntax highlighting and is also more easily optimized by many js engines javascript bad const bad foo 3 bar 4 data blah 5 good const good foo 3 bar 4 data blah 5 3 7 do not call object prototype methods directly such as hasownproperty propertyisenumerable and isprototypeof why these methods may be shadowed by properties on the object in question consider hasownproperty false or the object may be a null object object create null javascript bad console log object hasownproperty key good console log object prototype hasownproperty call object key best const has object prototype hasownproperty cache the lookup once in module scope or import has from has https www npmjs com package has console log has call object key 3 8 prefer the object spread operator over object assign to shallow copy objects use the object rest operator to get a new object with certain properties omitted javascript very bad const original a 1 b 2 const copy object assign original c 3 this mutates original ಠ ಠ delete copy a so does this bad const original a 1 b 2 const copy object assign original c 3 copy a 1 b 2 c 3 good const original a 1 b 2 const copy original c 3 copy a 1 b 2 c 3 const a noa copy noa b 2 c 3 ⬆ back to top arrays 4 1 use the literal syntax for array creation eslint no array constructor javascript bad const items new array good const items 4 2 use array push instead of direct assignment to add items to an array javascript const somestack bad somestack somestack length abracadabra good somestack push abracadabra 4 3 use array spreads to copy arrays javascript bad const len items length const itemscopy let i for i 0 i len i 1 itemscopy i items i good const itemscopy items 4 4 to convert an iterable object to an array use spreads instead of array from javascript const foo document queryselectorall foo good const nodes array from foo best const nodes foo 4 5 use array from for converting an array like object to an array javascript const arrlike 0 foo 1 bar 2 baz length 3 bad const arr array prototype slice call arrlike good const arr array from arrlike 4 6 use array from instead of spread for mapping over iterables because it avoids creating an intermediate array javascript bad const baz foo map bar good const baz array from foo bar 4 7 use return statements in array method callbacks its ok to omit the return if the function body consists of a single statement returning an expression without side effects following 8 2 eslint array callback return javascript good 1 2 3 map x const y x 1 return x y good 1 2 3 map x x 1 bad no returned value means acc becomes undefined after the first iteration 0 1 2 3 4 5 reduce acc item index const flatten acc concat item acc index flatten good 0 1 2 3 4 5 reduce acc item index const flatten acc concat item acc index flatten return flatten bad inbox filter msg const subject author msg if subject mockingbird return author harper lee else return false good inbox filter msg const subject author msg if subject mockingbird return author harper lee return false 4 8 use line breaks after open and before close array brackets if an array has multiple lines javascript bad const arr 0 1 2 3 4 5 const objectinarray id 1 id 2 const numberinarray 1 2 good const arr 0 1 2 3 4 5 const objectinarray id 1 id 2 const numberinarray 1 2 ⬆ back to top destructuring 5 1 use object destructuring when accessing and using multiple properties of an object eslint prefer destructuring why destructuring saves you from creating temporary references for those properties javascript bad function getfullname user const firstname user firstname const lastname user lastname return firstname lastname good function getfullname user const firstname lastname user return firstname lastname best function getfullname firstname lastname return firstname lastname 5 2 use array destructuring eslint prefer destructuring javascript const arr 1 2 3 4 bad const first arr 0 const second arr 1 good const first second arr 5 3 use object destructuring for multiple return values not array destructuring why you can add new properties over time or change the order of things without breaking call sites javascript bad function processinput input then a miracle occurs return left right top bottom the caller needs to think about the order of return data const left top processinput input good function processinput input then a miracle occurs return left right top bottom the caller selects only the data they need const left top processinput input ⬆ back to top strings 6 1 use single quotes for strings eslint quotes https eslint org docs rules quotes html javascript bad const name capt janeway bad template literals should contain interpolation or newlines const name capt janeway good const name capt janeway 6 2 strings that cause the line to go over 100 characters should not be written across multiple lines using string concatenation why broken strings are painful to work with and make code less searchable javascript bad const errormessage this is a super long error that was thrown because \ of batman when you stop to think about how batman had anything to do \ with this you would get nowhere \ fast bad const errormessage this is a super long error that was thrown because of batman when you stop to think about how batman had anything to do with this you would get nowhere fast good const errormessage this is a super long error that was thrown because of batman when you stop to think about how batman had anything to do with this you would get nowhere fast 6 3 when programmatically building up strings use template strings instead of concatenation eslint prefer template template curly spacing why template strings give you a readable concise syntax with proper newlines and string interpolation features javascript bad function sayhi name return how are you name bad function sayhi name return how are you name join bad function sayhi name return how are you name good function sayhi name return how are you name 6 4 never use eval on a string it opens too many vulnerabilities eslint no eval 6 5 do not unnecessarily escape characters in strings eslint no useless escape why backslashes harm readability thus they should only be present when necessary javascript bad const foo \this\ \i\s \ quoted\ good const foo \this\ is quoted const foo my name is name ⬆ back to top functions 7 1 use named function expressions instead of function declarations eslint func style why function declarations are hoisted which means that its easy too easy to reference the function before it is defined in the file this harms readability and maintainability if you find that a functions definition is large or complex enough that it is interfering with understanding the rest of the file then perhaps its time to extract it to its own module dont forget to explicitly name the expression regardless of whether or not the name is inferred from the containing variable which is often the case in modern browsers or when using compilers such as babel this eliminates any assumptions made about the errors call stack discussion https github com airbnb javascript issues 794 javascript bad function foo bad const foo function good lexical name distinguished from the variable referenced invocation s const short function longuniquemoredescriptivelexicalfoo 7 2 wrap immediately invoked function expressions in parentheses eslint wrap iife why an immediately invoked function expression is a single unit wrapping both it and its invocation parens in parens cleanly expresses this note that in a world with modules everywhere you almost never need an iife javascript immediately invoked function expression iife function console log welcome to the internet please follow me 7 3 never declare a function in a non function block if while etc assign the function to a variable instead browsers will allow you to do it but they all interpret it differently which is bad news bears eslint no loop func 7 4 note ecma 262 defines a block as a list of statements a function declaration is not a statement javascript bad if currentuser function test console log nope good let test if currentuser test console log yup 7 5 never name a parameter arguments this will take precedence over the arguments object that is given to every function scope javascript bad function foo name options arguments good function foo name options args 7 6 never use arguments opt to use rest syntax instead eslint prefer rest params why is explicit about which arguments you want pulled plus rest arguments are a real array and not merely array like like arguments javascript bad function concatenateall const args array prototype slice call arguments return args join good function concatenateall args return args join 7 7 use default parameter syntax rather than mutating function arguments javascript really bad function handlethings opts no we shouldnt mutate function arguments double bad if opts is falsy itll be set to an object which may be what you want but it can introduce subtle bugs opts opts still bad function handlethings opts if opts void 0 opts good function handlethings opts 7 8 avoid side effects with default parameters why they are confusing to reason about javascript var b 1 bad function count a b console log a count 1 count 2 count 3 3 count 3 7 9 always put default parameters last javascript bad function handlethings opts name good function handlethings name opts 7 10 never use the function constructor to create a new function eslint no new func why creating a function in this way evaluates a string similarly to eval which opens vulnerabilities javascript bad var add new function a b return a b still bad var subtract function a b return a b 7 11 spacing in a function signature eslint space before function paren space before blocks why consistency is good and you shouldnt have to add or remove a space when adding or removing a name javascript bad const f function const g function const h function good const x function const y function a 7 12 never mutate parameters eslint no param reassign why manipulating objects passed in as parameters can cause unwanted variable side effects in the original caller javascript bad function f1 obj obj key 1 good function f2 obj const key object prototype hasownproperty call obj key obj key 1 7 13 never reassign parameters eslint no param reassign why reassigning parameters can lead to unexpected behavior especially when accessing the arguments object it can also cause optimization issues especially in v8 javascript bad function f1 a a 1 function f2 a if a a 1 good function f3 a const b a 1 function f4 a 1 7 14 prefer the use of the spread operator to call variadic functions eslint prefer spread why its cleaner you dont need to supply a context and you can not easily compose new with apply javascript bad const x 1 2 3 4 5 console log apply console x good const x 1 2 3 4 5 console log x bad new function prototype bind apply date null 2016 8 5 good new date 2016 8 5 7 15 functions with multiline signatures or invocations should be indented just like every other multiline list in this guide with each item on a line by itself with a trailing comma on the last item eslint function paren newline javascript bad function foo bar baz quux good function foo bar baz quux bad console log foo bar baz good console log foo bar baz ⬆ back to top arrow functions 8 1 when you must use an anonymous function as when passing an inline callback use arrow function notation eslint prefer arrow callback arrow spacing why it creates a version of the function that executes in the context of this which is usually what you want and is a more concise syntax why not if you have a fairly complicated function you might move that logic out into its own named function expression javascript bad 1 2 3 map function x const y x 1 return x y good 1 2 3 map x const y x 1 return x y 8 2 if the function body consists of a single statement returning an expression without side effects omit the braces and use the implicit return otherwise keep the braces and use a return statement eslint arrow parens arrow body style why syntactic sugar it reads well when multiple functions are chained together javascript bad 1 2 3 map number const nextnumber number 1 a string containing the nextnumber good 1 2 3 map number a string containing the number good 1 2 3 map number const nextnumber number 1 return a string containing the nextnumber good 1 2 3 map number index index number no implicit return with side effects function foo callback const val callback if val true do something if callback returns true let bool false bad foo bool true good foo bool true 8 3 in case the expression spans over multiple lines wrap it in parentheses for better readability why it shows clearly where the function starts and ends javascript bad get post put map httpmethod object prototype hasownproperty call httpmagicobjectwithaverylongname httpmethod good get post put map httpmethod object prototype hasownproperty call httpmagicobjectwithaverylongname httpmethod 8 4 if your function takes a single argument and doesnt use braces omit the parentheses otherwise always include parentheses around arguments for clarity and consistency note it is also acceptable to always use parentheses in which case use the “always” option for eslint eslint arrow parens why less visual clutter javascript bad 1 2 3 map x x x good 1 2 3 map x x x good 1 2 3 map number a long string with the number its so long that we dont want it to take up space on the map line bad 1 2 3 map x const y x 1 return x y good 1 2 3 map x const y x 1 return x y 8 5 avoid confusing arrow function syntax with comparison operators eslint no confusing arrow javascript bad const itemheight item item height 256 item largesize item smallsize bad const itemheight item item height 256 item largesize item smallsize good const itemheight item item height 256 item largesize item smallsize good const itemheight item const height largesize smallsize item return height 256 largesize smallsize 8 6 enforce the location of arrow function bodies with implicit returns eslint implicit arrow linebreak javascript bad foo bar foo bar good foo bar foo bar foo bar ⬆ back to top classes constructors 9 1 always use class avoid manipulating prototype directly why class syntax is more concise and easier to reason about javascript bad function queue contents this queue contents queue prototype pop function const value this queue 0 this queue splice 0 1 return value good class queue constructor contents this queue contents pop const value this queue 0 this queue splice 0 1 return value 9 2 use extends for inheritance why it is a built in way to inherit prototype functionality without breaking instanceof javascript bad const inherits require inherits function peekablequeue contents queue apply this contents inherits peekablequeue queue peekablequeue prototype peek function return this queue 0 good class peekablequeue extends queue peek return this queue 0 9 3 methods can return this to help with method chaining javascript bad jedi prototype jump function this jumping true return true jedi prototype setheight function height this height height const luke new jedi luke jump true luke setheight 20 undefined good class jedi jump this jumping true return this setheight height this height height return this const luke new jedi luke jump setheight 20 9 4 its okay to write a custom tostring method just make sure it works successfully and causes no side effects javascript class jedi constructor options this name options name no name getname return this name tostring return jedi this getname 9 5 classes have a default constructor if one is not specified an empty constructor function or one that just delegates to a parent class is unnecessary eslint no useless constructor javascript bad class jedi constructor getname return this name bad class rey extends jedi constructor args super args good class rey extends jedi constructor args super args this name rey 9 6 avoid duplicate class members eslint no dupe class members why duplicate class member declarations will silently prefer the last one having duplicates is almost certainly a bug javascript bad class foo bar return 1 bar return 2 good class foo bar return 1 good class foo bar return 2 ⬆ back to top modules 10 1 always use modules import export over a non standard module system you can always transpile to your preferred module system why modules are the future lets start using the future now javascript bad const airbnbstyleguide require airbnbstyleguide module exports airbnbstyleguide es6 ok import airbnbstyleguide from airbnbstyleguide export default airbnbstyleguide es6 best import es6 from airbnbstyleguide export default es6 10 2 do not use wildcard imports why this makes sure you have a single default export javascript bad import as airbnbstyleguide from airbnbstyleguide good import airbnbstyleguide from airbnbstyleguide 10 3 and do not export directly from an import why although the one liner is concise having one clear way to import and one clear way to export makes things consistent javascript bad filename es6 js export es6 as default from airbnbstyleguide good filename es6 js import es6 from airbnbstyleguide export default es6 10 4 only import from a path in one place eslint no duplicate imports why having multiple lines that import from the same path can make code harder to maintain javascript bad import foo from foo … some other imports … import named1 named2 from foo good import foo named1 named2 from foo good import foo named1 named2 from foo 10 5 do not export mutable bindings eslint import no mutable exports why mutation should be avoided in general but in particular when exporting mutable bindings while this technique may be needed for some special cases in general only constant references should be exported javascript bad let foo 3 export foo good const foo 3 export foo 10 6 in modules with a single export prefer default export over named export eslint import prefer default export why to encourage more files that only ever export one thing which is better for readability and maintainability javascript bad export function foo good export default function foo 10 7 put all imports above non import statements eslint import first why since imports are hoisted keeping them all at the top prevents surprising behavior javascript bad import foo from foo foo init import bar from bar good import foo from foo import bar from bar foo init 10 8 multiline imports should be indented just like multiline array and object literals why the curly braces follow the same indentation rules as every other curly brace block in the style guide as do the trailing commas javascript bad import longnamea longnameb longnamec longnamed longnamee from path good import longnamea longnameb longnamec longnamed longnamee from path 10 9 disallow webpack loader syntax in module import statements eslint import no webpack loader syntax why since using webpack syntax in the imports couples the code to a module bundler prefer using the loader syntax in webpack config js javascript bad import foosass from css sass foo scss import barcss from style css bar css good import foosass from foo scss import barcss from bar css ⬆ back to top iterators and generators 11 1 dont use iterators prefer javascripts higher order functions instead of loops like for in or for of eslint no iterator no restricted syntax why this enforces our immutable rule dealing with pure functions that return values is easier to reason about than side effects use map every filter find findindex reduce some to iterate over arrays and object keys object values object entries to produce arrays so you can iterate over objects javascript const numbers 1 2 3 4 5 bad let sum 0 for let num of numbers sum num sum 15 good let sum 0 numbers foreach num sum num sum 15 best use the functional force const sum numbers reduce total num total num 0 sum 15 bad const increasedbyone for let i 0 i numbers length i increasedbyone push numbers i 1 good const increasedbyone numbers foreach num increasedbyone push num 1 best keeping it functional const increasedbyone numbers map num num 1 11 2 dont use generators for now why they dont transpile well to es5 11 3 if you must use generators or if you disregard our advice make sure their function signature is spaced properly eslint generator star spacing why function and are part of the same conceptual keyword is not a modifier for function function is a unique construct different from function javascript bad function foo bad const bar function bad const baz function bad const quux function bad function foo bad function foo very bad function foo very bad const wat function good function foo good const foo function ⬆ back to top properties 12 1 use dot notation when accessing properties eslint dot notation javascript const luke jedi true age 28 bad const isjedi luke jedi good const isjedi luke jedi 12 2 use bracket notation when accessing properties with a variable javascript const luke jedi true age 28 function getprop prop return luke prop const isjedi getprop jedi 12 3 use exponentiation operator when calculating exponentiations eslint no restricted properties javascript bad const binary math pow 2 10 good const binary 2 10 ⬆ back to top variables 13 1 always use const or let to declare variables not doing so will result in global variables we want to avoid polluting the global namespace captain planet warned us of that eslint no undef prefer const javascript bad superpower new superpower good const superpower new superpower 13 2 use one const or let declaration per variable eslint one var why its easier to add new variable declarations this way and you never have to worry about swapping out a for a or introducing punctuation only diffs you can also step through each declaration with the debugger instead of jumping through all of them at once javascript bad const items getitems gosportsteam true dragonball z bad compare to above and try to spot the mistake const items getitems gosportsteam true dragonball z good const items getitems const gosportsteam true const dragonball z 13 3 group all your consts and then group all your lets why this is helpful when later on you might need to assign a variable depending on one of the previous assigned variables javascript bad let i len dragonball items getitems gosportsteam true bad let i const items getitems let dragonball const gosportsteam true let len good const gosportsteam true const items getitems let dragonball let i let length 13 4 assign variables where you need them but place them in a reasonable place why let and const are block scoped and not function scoped javascript bad unnecessary function call function checkname hasname const name getname if hasname test return false if name test this setname return false return name good function checkname hasname if hasname test return false const name getname if name test this setname return false return name 13 5 dont chain variable assignments eslint no multi assign why chaining variable assignments creates implicit global variables javascript bad function example javascript interprets this as let a b c 1 the let keyword only applies to variable a variables b and c become global variables let a b c 1 console log a throws referenceerror console log b 1 console log c 1 good function example let a 1 let b a let c a console log a throws referenceerror console log b throws referenceerror console log c throws referenceerror the same applies for const 13 6 avoid using unary increments and decrements eslint no plusplus why per the eslint documentation unary increment and decrement statements are subject to automatic semicolon insertion and can cause silent errors with incrementing or decrementing values within an application it is also more expressive to mutate your values with statements like num 1 instead of num or num disallowing unary increment and decrement statements also prevents you from pre incrementing pre decrementing values unintentionally which can also cause unexpected behavior in your programs javascript bad const array 1 2 3 let num 1 num num let sum 0 let truthycount 0 for let i 0 i array length i let value array i sum value if value truthycount good const array 1 2 3 let num 1 num 1 num 1 const sum array reduce a b a b 0 const truthycount array filter boolean length 13 7 avoid linebreaks before or after in an assignment if your assignment violates max len surround the value in parens eslint operator linebreak why linebreaks surrounding can obfuscate the value of an assignment javascript bad const foo superlonglonglonglonglonglonglonglongfunctionname bad const foo superlonglonglonglonglonglonglonglongstring good const foo superlonglonglonglonglonglonglonglongfunctionname good const foo superlonglonglonglonglonglonglonglongstring 13 8 disallow unused variables eslint no unused vars why variables that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring such variables take up space in the code and can lead to confusion by readers javascript bad var some unused var 42 write only variables are not considered as used var y 10 y 5 a read for a modification of itself is not considered as used var z 0 z z 1 unused function arguments function getx x y return x good function getxplusy x y return x y var x 1 var y a 2 alert getxplusy x y type is ignored even if unused because it has a rest property sibling this is a form of extracting an object that omits the specified keys var type coords data coords is now the data object without its type property ⬆ back to top hoisting 14 1 var declarations get hoisted to the top of their closest enclosing function scope their assignment does not const and let declarations are blessed with a new concept called temporal dead zones tdz its important to know why typeof is no longer safe javascript we know this wouldnt work assuming there is no notdefined global variable function example console log notdefined throws a referenceerror creating a variable declaration after you reference the variable will work due to variable hoisting note the assignment value of true is not hoisted function example console log declaredbutnotassigned undefined var declaredbutnotassigned true the interpreter is hoisting the variable declaration to the top of the scope which means our example could be rewritten as function example let declaredbutnotassigned console log declaredbutnotassigned undefined declaredbutnotassigned true using const and let function example console log declaredbutnotassigned throws a referenceerror console log typeof declaredbutnotassigned throws a referenceerror const declaredbutnotassigned true 14 2 anonymous function expressions hoist their variable name but not the function assignment javascript function example console log anonymous undefined anonymous typeerror anonymous is not a function var anonymous function console log anonymous function expression 14 3 named function expressions hoist the variable name not the function name or the function body javascript function example console log named undefined named typeerror named is not a function superpower referenceerror superpower is not defined var named function superpower console log flying the same is true when the function name is the same as the variable name function example console log named undefined named typeerror named is not a function var named function named console log named 14 4 function declarations hoist their name and the function body javascript function example superpower flying function superpower console log flying for more information refer to javascript scoping hoisting by ben cherry ⬆ back to top comparison operators equality 15 1 use and over and eslint eqeqeq 15 2 conditional statements such as the if statement evaluate their expression using coercion with the toboolean abstract method and always follow these simple rules objects evaluate to true undefined evaluates to false null evaluates to false booleans evaluate to the value of the boolean numbers evaluate to false if 0 0 or nan otherwise true strings evaluate to false if an empty string otherwise true javascript if 0 true an array even an empty one is an object objects will evaluate to true 15 3 use shortcuts for booleans but explicit comparisons for strings and numbers javascript bad if isvalid true good if isvalid bad if name good if name bad if collection length good if collection length 0 15 4 for more information see truth equality and javascript by angus croll 15 5 use braces to create blocks in case and default clauses that contain lexical declarations e g let const function and class eslint no case declarations why lexical declarations are visible in the entire switch block but only get initialized when assigned which only happens when its case is reached this causes problems when multiple case clauses attempt to define the same thing javascript bad switch foo case 1 let x 1 break case 2 const y 2 break case 3 function f break default class c good switch foo case 1 let x 1 break case 2 const y 2 break case 3 function f break case 4 bar break default class c 15 6 ternaries should not be nested and generally be single line expressions eslint no nested ternary javascript bad const foo maybe1 maybe2 bar value1 value2 baz null split into 2 separated ternary expressions const maybenull value1 value2 baz null better const foo maybe1 maybe2 bar maybenull best const foo maybe1 maybe2 bar maybenull 15 7 avoid unneeded ternary statements eslint no unneeded ternary javascript bad const foo a a b const bar c true false const baz c false true good const foo a b const bar c const baz c 15 8 when mixing operators enclose them in parentheses the only exception is the standard arithmetic operators since their precedence is broadly understood eslint no mixed operators why this improves readability and clarifies the developers intention javascript bad const foo a b 0 c 0 d 1 0 bad const bar a b 5 d bad one may be confused into thinking a b c if a b c return d good const foo a b 0 c 0 d 1 0 good const bar a b 5 d good if a b c return d good const bar a b c d ⬆ back to top blocks 16 1 use braces with all multi line blocks eslint nonblock statement body position javascript bad if test return false good if test return false good if test return false bad function foo return false good function bar return false 16 2 if youre using multi line blocks with if and else put else on the same line as your if blocks closing brace eslint brace style javascript bad if test thing1 thing2 else thing3 good if test thing1 thing2 else thing3 16 3 if an if block always executes a return statement the subsequent else block is unnecessary a return in an else if block following an if block that contains a return can be separated into multiple if blocks eslint no else return javascript bad function foo if x return x else return y bad function cats if x return x else if y return y bad function dogs if x return x else if y return y good function foo if x return x return y good function cats if x return x if y return y good function dogs x if x if z return y else return z ⬆ back to top control statements 17 1 in case your control statement if while etc gets too long or exceeds the maximum line length each grouped condition could be put into a new line the logical operator should begin the line why requiring operators at the beginning of the line keeps the operators aligned and follows a pattern similar to method chaining this also improves readability by making it easier to visually follow complex logic javascript bad if foo 123 bar abc doesitlookgoodwhenitbecomesthatlong isthisreallyhappening thing1 bad if foo 123 bar abc thing1 bad if foo 123 bar abc thing1 bad if foo 123 bar abc thing1 good if foo 123 bar abc thing1 good if foo 123 bar abc doesitlookgoodwhenitbecomesthatlong isthisreallyhappening thing1 good if foo 123 bar abc thing1 17 2 dont use selection operators in place of control statements javascript bad isrunning startrunning good if isrunning startrunning ⬆ back to top comments 18 1 use for multi line comments javascript bad make returns a new element based on the passed in tag name param string tag return element element function make tag return element good make returns a new element based on the passed in tag name function make tag return element 18 2 use for single line comments place single line comments on a newline above the subject of the comment put an empty line before the comment unless its on the first line of a block javascript bad const active true is current tab good is current tab const active true bad function gettype console log fetching type set the default type to no type const type this type no type return type good function gettype console log fetching type set the default type to no type const type this type no type return type also good function gettype set the default type to no type const type this type no type return type 18 3 start all comments with a space to make it easier to read eslint spaced comment javascript bad is current tab const active true good is current tab const active true bad make returns a new element based on the passed in tag name function make tag return element good make returns a new element based on the passed in tag name function make tag return element 18 4 prefixing your comments with fixme or todo helps other developers quickly understand if youre pointing out a problem that needs to be revisited or if youre suggesting a solution to the problem that needs to be implemented these are different than regular comments because they are actionable the actions are fixme need to figure this out or todo need to implement 18 5 use fixme to annotate problems javascript class calculator extends abacus constructor super fixme shouldnt use a global here total 0 18 6 use todo to annotate solutions to problems javascript class calculator extends abacus constructor super todo total should be configurable by an options param this total 0 ⬆ back to top whitespace 19 1 use soft tabs space character set to 2 spaces eslint indent javascript bad function foo ∙∙∙∙let name bad function bar ∙let name good function baz ∙∙let name 19 2 place 1 space before the leading brace eslint space before blocks javascript bad function test console log test good function test console log test bad dog set attr age 1 year breed bernese mountain dog good dog set attr age 1 year breed bernese mountain dog 19 3 place 1 space before the opening parenthesis in control statements if while etc place no space between the argument list and the function name in function calls and declarations eslint keyword spacing javascript bad if isjedi fight good if isjedi fight bad function fight console log swooosh good function fight console log swooosh 19 4 set off operators with spaces eslint space infix ops javascript bad const x y 5 good const x y 5 19 5 end files with a single newline character eslint eol last javascript bad import es6 from airbnbstyleguide export default es6 javascript bad import es6 from airbnbstyleguide export default es6 ↵ ↵ javascript good import es6 from airbnbstyleguide export default es6 ↵ 19 6 use indentation when making long method chains more than 2 method chains use a leading dot which emphasizes that the line is a method call not a new statement eslint newline per chained call no whitespace before property javascript bad items find selected highlight end find open updatecount bad items find selected highlight end find open updatecount good items find selected highlight end find open updatecount bad const leds stage selectall led data data enter append svg svg classed led true attr width radius margin 2 append svg g attr transform translate radius margin radius margin call tron led good const leds stage selectall led data data enter append svg svg classed led true attr width radius margin 2 append svg g attr transform translate radius margin radius margin call tron led good const leds stage selectall led data data 19 7 leave a blank line after blocks and before the next statement javascript bad if foo return bar return baz good if foo return bar return baz bad const obj foo bar return obj good const obj foo bar return obj bad const arr function foo function bar return arr good const arr function foo function bar return arr 19 8 do not pad your blocks with blank lines eslint padded blocks javascript bad function bar console log foo bad if baz console log qux else console log foo bad class foo constructor bar this bar bar good function bar console log foo good if baz console log qux else console log foo 19 9 do not add spaces inside parentheses eslint space in parens javascript bad function bar foo return foo good function bar foo return foo bad if foo console log foo good if foo console log foo 19 10 do not add spaces inside brackets eslint array bracket spacing javascript bad const foo 1 2 3 console log foo 0 good const foo 1 2 3 console log foo 0 19 11 add spaces inside curly braces eslint object curly spacing javascript bad const foo clark kent good const foo clark kent 19 12 avoid having lines of code that are longer than 100 characters including whitespace note per above long strings are exempt from this rule and should not be broken up eslint max len why this ensures readability and maintainability javascript bad const foo jsondata jsondata foo jsondata foo bar jsondata foo bar baz jsondata foo bar baz quux jsondata foo bar baz quux xyzzy bad ajax method post url https airbnb com data name john done console log congratulations fail console log you have failed this city good const foo jsondata jsondata foo jsondata foo bar jsondata foo bar baz jsondata foo bar baz quux jsondata foo bar baz quux xyzzy good ajax method post url https airbnb com data name john done console log congratulations fail console log you have failed this city 19 13 require consistent spacing inside an open block token and the next token on the same line this rule also enforces consistent spacing inside a close block token and previous token on the same line eslint block spacing javascript bad function foo return true if foo bar 0 good function foo return true if foo bar 0 19 14 avoid spaces before commas and require a space after commas eslint comma spacing javascript bad var foo 1 bar 2 var arr 1 2 good var foo 1 bar 2 var arr 1 2 19 15 enforce spacing inside of computed properties eslint computed property spacing javascript bad obj foo obj foo var x b a obj foo bar good obj foo obj foo var x b a obj foo bar 19 16 enforce spacing between functions and their invocations eslint func call spacing javascript bad func func good func 19 17 enforce spacing between keys and values in object literal properties eslint key spacing javascript bad var obj foo 42 var obj2 foo 42 good var obj foo 42 19 18 avoid trailing spaces at the end of lines eslint no trailing spaces 19 19 avoid multiple empty lines and only allow one newline at the end of files eslint no multiple empty lines markdownlint disable md012 javascript bad var x 1 var y 2 good var x 1 var y 2 markdownlint enable md012 ⬆ back to top commas 20 1 leading commas nope eslint comma style javascript bad const story once upon atime good const story once upon atime bad const hero firstname ada lastname lovelace birthyear 1815 superpower computers good const hero firstname ada lastname lovelace birthyear 1815 superpower computers 20 2 additional trailing comma yup eslint comma dangle why this leads to cleaner git diffs also transpilers like babel will remove the additional trailing comma in the transpiled code which means you dont have to worry about the trailing comma problem https github com airbnb javascript blob es5 deprecated es5 readme md commas in legacy browsers diff bad git diff without trailing comma const hero firstname florence lastname nightingale lastname nightingale inventorof coxcomb chart modern nursing good git diff with trailing comma const hero firstname florence lastname nightingale inventorof coxcomb chart modern nursing javascript bad const hero firstname dana lastname scully const heroes batman superman good const hero firstname dana lastname scully const heroes batman superman bad function createhero firstname lastname inventorof does nothing good function createhero firstname lastname inventorof does nothing good note that a comma must not appear after a rest element function createhero firstname lastname inventorof heroargs does nothing bad createhero firstname lastname inventorof good createhero firstname lastname inventorof good note that a comma must not appear after a rest element createhero firstname lastname inventorof heroargs ⬆ back to top semicolons 21 1 yup eslint semi why when javascript encounters a line break without a semicolon it uses a set of rules called automatic semicolon insertion https tc39 github io ecma262 sec automatic semicolon insertion to determine whether or not it should regard that line break as the end of a statement and as the name implies place a semicolon into your code before the line break if it thinks so asi contains a few eccentric behaviors though and your code will break if javascript misinterprets your line break these rules will become more complicated as new features become a part of javascript explicitly terminating your statements and configuring your linter to catch missing semicolons will help prevent you from encountering issues javascript bad raises exception const luke const leia luke leia foreach jedi jedi father vader bad raises exception const reaction no thats impossible async function meanwhileonthefalcon handle leia lando chewie r2 c3p0 bad returns undefined instead of the value on the next line always happens when return is on a line by itself because of asi function foo return search your feelings you know it to be foo good const luke const leia luke leia foreach jedi jedi father vader good const reaction no thats impossible async function meanwhileonthefalcon handle leia lando chewie r2 c3p0 good function foo return search your feelings you know it to be foo read more https stackoverflow com questions 7365172 semicolon before self invoking function 7365214 7365214 ⬆ back to top type casting coercion 22 1 perform type coercion at the beginning of the statement 22 2 strings eslint no new wrappers javascript this reviewscore 9 bad const totalscore new string this reviewscore typeof totalscore is object not string bad const totalscore this reviewscore invokes this reviewscore valueof bad const totalscore this reviewscore tostring isnt guaranteed to return a string good const totalscore string this reviewscore 22 3 numbers use number for type casting and parseint always with a radix for parsing strings eslint radix no new wrappers javascript const inputvalue 4 bad const val new number inputvalue bad const val inputvalue bad const val inputvalue 0 bad const val parseint inputvalue good const val number inputvalue good const val parseint inputvalue 10 22 4 if for whatever reason you are doing something wild and parseint is your bottleneck and need to use bitshift for performance reasons leave a comment explaining why and what youre doing javascript good parseint was the reason my code was slow bitshifting the string to coerce it to a number made it a lot faster const val inputvalue 0 22 5 note be careful when using bitshift operations numbers are represented as 64 bit values but bitshift operations always return a 32 bit integer source bitshift can lead to unexpected behavior for integer values larger than 32 bits discussion largest signed 32 bit int is 2 147 483 647 javascript 2147483647 0 2147483647 2147483648 0 2147483648 2147483649 0 2147483647 22 6 booleans eslint no new wrappers javascript const age 0 bad const hasage new boolean age good const hasage boolean age best const hasage age ⬆ back to top naming conventions 23 1 avoid single letter names be descriptive with your naming eslint id length javascript bad function q good function query 23 2 use camelcase when naming objects functions and instances eslint camelcase javascript bad const objecttsssss const this is my object function c good const thisismyobject function thisismyfunction 23 3 use pascalcase only when naming constructors or classes eslint new cap javascript bad function user options this name options name const bad new user name nope good class user constructor options this name options name const good new user name yup 23 4 do not use trailing or leading underscores eslint no underscore dangle why javascript does not have the concept of privacy in terms of properties or methods although a leading underscore is a common convention to mean “private” in fact these properties are fully public and as such are part of your public api contract this convention might lead developers to wrongly think that a change wont count as breaking or that tests arent needed tl dr if you want something to be “private” it must not be observably present javascript bad this firstname panda this firstname panda this firstname panda good this firstname panda good in environments where weakmaps are available see https kangax github io compat table es6 test weakmap const firstnames new weakmap firstnames set this panda 23 5 dont save references to this use arrow functions or function bind javascript bad function foo const self this return function console log self bad function foo const that this return function console log that good function foo return console log this 23 6 a base filename should exactly match the name of its default export javascript file 1 contents class checkbox export default checkbox file 2 contents export default function fortytwo return 42 file 3 contents export default function insidedirectory in some other file bad import checkbox from checkbox pascalcase import export camelcase filename import fortytwo from fortytwo pascalcase import filename camelcase export import insidedirectory from insidedirectory pascalcase import filename camelcase export bad import checkbox from check box pascalcase import export snake case filename import forty two from forty two snake case import filename camelcase export import inside directory from inside directory snake case import camelcase export import index from inside directory index requiring the index file explicitly import insidedirectory from insidedirectory index requiring the index file explicitly good import checkbox from checkbox pascalcase export import filename import fortytwo from fortytwo camelcase export import filename import insidedirectory from insidedirectory camelcase export import directory name implicit index supports both insidedirectory js and insidedirectory index js 23 7 use camelcase when you export default a function your filename should be identical to your functions name javascript function makestyleguide export default makestyleguide 23 8 use pascalcase when you export a constructor class singleton function library bare object javascript const airbnbstyleguide es6 export default airbnbstyleguide 23 9 acronyms and initialisms should always be all capitalized or all lowercased why names are for readability not to appease a computer algorithm javascript bad import smscontainer from containers smscontainer bad const httprequests good import smscontainer from containers smscontainer good const httprequests also good const httprequests best import textmessagecontainer from containers textmessagecontainer best const requests 23 10 you may optionally uppercase a constant only if it 1 is exported 2 is a const it can not be reassigned and 3 the programmer can trust it and its nested properties to never change why this is an additional tool to assist in situations where the programmer would be unsure if a variable might ever change uppercase variables are letting the programmer know that they can trust the variable and its properties not to change what about all const variables this is unnecessary so uppercasing should not be used for constants within a file it should be used for exported constants however what about exported objects uppercase at the top level of export e g exported object key and maintain that all nested properties do not change javascript bad const private variable should not be unnecessarily uppercased within a file bad export const thing to be changed should obviously not be uppercased bad export let reassignable variable do not use let with uppercase variables allowed but does not supply semantic value export const apikey somekey better in most cases export const api key somekey bad unnecessarily uppercases key while adding no semantic value export const mapping key value good export const mapping key value ⬆ back to top accessors 24 1 accessor functions for properties are not required 24 2 do not use javascript getters setters as they cause unexpected side effects and are harder to test maintain and reason about instead if you do make accessor functions use getval and setval hello javascript bad class dragon get age set age value good class dragon getage setage value 24 3 if the property method is a boolean use isval or hasval javascript bad if dragon age return false good if dragon hasage return false 24 4 its okay to create get and set functions but be consistent javascript class jedi constructor options const lightsaber options lightsaber blue this set lightsaber lightsaber set key val this key val get key return this key ⬆ back to top events 25 1 when attaching data payloads to events whether dom events or something more proprietary like backbone events pass an object literal also known as a hash instead of a raw value this allows a subsequent contributor to add more data to the event payload without finding and updating every handler for the event for example instead of javascript bad this trigger listingupdated listing id this on listingupdated e listingid do something with listingid prefer javascript good this trigger listingupdated listingid listing id this on listingupdated e data do something with data listingid ⬆ back to top jquery 26 1 prefix jquery object variables with a javascript bad const sidebar sidebar good const sidebar sidebar good const sidebarbtn sidebar btn 26 2 cache jquery lookups javascript bad function setsidebar sidebar hide sidebar css background color pink good function setsidebar const sidebar sidebar sidebar hide sidebar css background color pink 26 3 for dom queries use cascading sidebar ul or parent child sidebar ul jsperf 26 4 use find with scoped jquery object queries javascript bad ul sidebar hide bad sidebar find ul hide good sidebar ul hide good sidebar ul hide good sidebar find ul hide ⬆ back to top ecmascript 5 compatibility 27 1 refer to kangaxs es5 compatibility table ⬆ back to top ecmascript 6 es 2015 styles 28 1 this is a collection of links to the various es6 features arrow functions classes object shorthand object concise object computed properties template strings destructuring default parameters rest array spreads let and const exponentiation operator iterators and generators modules 28 2 do not use tc39 proposals that have not reached stage 3 why they are not finalized https tc39 github io process document and they are subject to change or to be withdrawn entirely we want to use javascript and proposals are not javascript yet ⬆ back to top standard library the standard library contains utilities that are functionally broken but remain for legacy reasons 29 1 use number isnan instead of global isnan eslint no restricted globals why the global isnan coerces non numbers to numbers returning true for anything that coerces to nan if this behavior is desired make it explicit javascript bad isnan 1 2 false isnan 1 2 3 true good number isnan 1 2 3 false number isnan number 1 2 3 true 29 2 use number isfinite instead of global isfinite eslint no restricted globals why the global isfinite coerces non numbers to numbers returning true for anything that coerces to a finite number if this behavior is desired make it explicit javascript bad isfinite 2e3 true good number isfinite 2e3 false number isfinite parseint 2e3 10 true ⬆ back to top testing 30 1 yup javascript function foo return true 30 2 no but seriously whichever testing framework you use you should be writing tests strive to write many small pure functions and minimize where mutations occur be cautious about stubs and mocks they can make your tests more brittle we primarily use mocha and jest at airbnb tape is also used occasionally for small separate modules 100 test coverage is a good goal to strive for even if its not always practical to reach it whenever you fix a bug write a regression test a bug fixed without a regression test is almost certainly going to break again in the future ⬆ back to top performance on layout web performance string vs array concat try catch cost in a loop bang function jquery find vs context selector innerhtml vs textcontent for script text long string concatenation are javascript functions like map reduce and filter optimized for traversing arrays loading ⬆ back to top resources learning es6 latest ecma spec exploringjs es6 compatibility table comprehensive overview of es6 features read this standard ecma 262 tools code style linters eslint airbnb style eslintrc jshint airbnb style jshintrc neutrino preset neutrino preset airbnb base other style guides google javascript style guide jquery core style guidelines principles of writing consistent idiomatic javascript standardjs other styles naming this in nested functions christian johansen conditional callbacks ross allen popular javascript coding conventions on github jeonghoon byun multiple var statements in javascript not superfluous ben alman further reading understanding javascript closures angus croll basic javascript for the impatient programmer dr axel rauschmayer you might not need jquery zack bloom adam schwartz es6 features luke hoban frontend guidelines benjamin de cock books javascript the good parts douglas crockford javascript patterns stoyan stefanov pro javascript design patterns ross harmes and dustin diaz high performance web sites essential knowledge for front end engineers steve souders maintainable javascript nicholas c zakas javascript web applications alex maccaw pro javascript techniques john resig smashing node js javascript everywhere guillermo rauch secrets of the javascript ninja john resig and bear bibeault human javascript henrik joreteg superhero js kim joar bekkelund mads mobæk olav bjorkoy jsbooks julien bouquillon third party javascript ben vinegar and anton kovalyov effective javascript 68 specific ways to harness the power of javascript david herman eloquent javascript marijn haverbeke you dont know js es6 beyond kyle simpson blogs javascript weekly javascript javascript bocoup weblog adequately good nczonline perfection kills ben alman dmitry baranovskiy nettuts podcasts javascript air javascript jabber ⬆ back to top in the wild this is a list of organizations that are using this style guide send us a pull request and well add you to the list 123erfasst 123erfasst javascript 3blades 3blades 4catalyzer 4catalyzer javascript aan zee aanzee javascript adult swim adult swim javascript airbnb airbnb javascript altschool altschool javascript apartmint apartmint javascript ascribe ascribe javascript avalara avalara javascript avant avantcredit javascript axept axept javascript bashpros bashpros javascript billabong billabong javascript bisk bisk bonhomme bonhommeparis javascript brainshark brainshark javascript casenine casenine javascript cerner cerner chartboost chartboost javascript style guide comparaonline comparaonline javascript compass learning compasslearning javascript style guide dailymotion dailymotion javascript dosomething dosomething eslint config digitpaint digitpaint javascript drupal www drupal org ecosia ecosia javascript evernote evernote javascript style guide evolution gaming evolution gaming javascript evozonjs evozonjs javascript exacttarget exacttarget javascript expensify expensify style guide flexberry flexberry javascript style guide gawker media gawkermedia general electric generalelectric javascript generation tux generationtux javascript gooddata gooddata gdc js style greenchef greenchef javascript grooveshark grooveshark javascript grupo abraxas grupo abraxas javascript honey honeyscience javascript how about we howaboutwe javascript huballin huballin hubspot hubspot javascript hyper hyperoslo javascript playbook intercity group intercitygroup javascript style guide jam3 jam3 javascript code conventions jeopardybot kesne jeopardy bot jssolutions jssolutions javascript kaplan komputing kaplankomputing javascript kickorstick kickorstick kinetica solutions kinetica javascript leinwand leinwand javascript lonely planet lonelyplanet javascript m2gen m2gen javascript mighty spring mightyspring javascript minnpost minnpost javascript mitocgroup mitocgroup javascript modcloth modcloth javascript money advice service moneyadviceservice javascript muber muber national geographic natgeo nimbl3 nimbl3 javascript nulogy nulogy javascript orange hill development orangehill javascript orion health orionhealth javascript outboxsoft outboxsoft javascript peerby peerby javascript qotto qotto javascript style guide razorfish razorfish javascript style guide reddit reddit styleguide javascript react facebook github io react contributing how to contribute html style guide rei reidev js style guide ripple ripple javascript style guide sainsburys supermarkets jsainsburyplc seekingalpha seekingalpha javascript style guide shutterfly shutterfly javascript sourcetoad sourcetoad javascript springload springload stratodem analytics stratodem javascript steelkiwi development steelkiwi javascript studentsphere studentsphere javascript swoopapp swoopapp javascript sysgarage sysgarage javascript style guide syzygy warsaw syzygypl javascript target target javascript theladders theladders javascript the nerdery thenerdery javascript standards t4r technology t4r technology javascript voxfeed voxfeed javascript style guide webox studio weboxstudio javascript weggo weggo javascript zillow zillow javascript zocdoc zocdoc javascript ⬆ back to top translation this style guide is also available in other languages brazilian portuguese armoucar javascript style guide bulgarian borislavvv javascript catalan fpmweb javascript style guide chinese simplified yuche javascript chinese traditional jigsawye javascript french nmussy javascript style guide german timofurrer javascript style guide italian sinkswim javascript style guide japanese mitsuruog javascript style guide korean parksb javascript style guide russian leonidlebedev javascript airbnb spanish paolocarrasco javascript style guide thai lvarayut javascript style guide turkish eraycetinay javascript ukrainian ivanzusko javascript vietnam hngiang javascript style guide the javascript style guide guide reference chat with us about javascript find us on gitter contributors view contributors license the mit license copyright c 2012 airbnb permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the software to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall the authors or copyright holders be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software ⬆ back to top amendments we encourage you to fork this guide and change the rules to fit your teams style guide below you may list some amendments to the style guide this allows you to periodically update your style guide without having to deal with merge conflicts