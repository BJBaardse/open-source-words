what the f ck python üêç an interesting collection of surprising snippets and lesser known python features python being a beautifully designed high level and interpreter based programming language provides us with many features for the programmers comfort but sometimes the outcomes of a python snippet may not seem obvious to a regular user at first sight here is a fun project to collect such tricky counter intuitive examples and lesser known features in python attempting to discuss what exactly is happening under the hood while some of the examples you see below may not be wtfs in the truest sense but theyll reveal some of the interesting parts of python that you might be unaware of i find it a nice way to learn the internals of a programming language and i think youll find them interesting as well if youre an experienced python programmer you can take it as a challenge to get most of them right in first attempt you may be already familiar with some of these examples and i might be able to revive sweet old memories of yours being bitten by these gotchas sweat smile if youre a returning reader you can learn about the new modifications here so here we go table of contents start doctoc generated toc please keep comment here to allow auto update dont edit this section instead re run doctoc to update structure of the examples usage üëÄ examples section strain your brain ‚ñ∂ strings can be tricky sometimes ‚ñ∂ time for some hash brownies ‚ñ∂ return return everywhere ‚ñ∂ deep down were all the same ‚ñ∂ for what ‚ñ∂ evaluation time discrepancy ‚ñ∂ is is not what it is ‚ñ∂ a tic tac toe where x wins in the first attempt ‚ñ∂ the sticky output function ‚ñ∂ is not is not is not ‚ñ∂ the surprising comma ‚ñ∂ backslashes at the end of string ‚ñ∂ not knot ‚ñ∂ half triple quoted strings ‚ñ∂ midnight time doesnt exist ‚ñ∂ whats wrong with booleans ‚ñ∂ class attributes and instance attributes ‚ñ∂ yielding none ‚ñ∂ mutating the immutable ‚ñ∂ the disappearing variable from outer scope ‚ñ∂ when true is actually false ‚ñ∂ from filled to none in one instruction ‚ñ∂ subclass relationships ‚ñ∂ the mysterious key type conversion ‚ñ∂ lets see if you can guess this section appearances are deceptive ‚ñ∂ skipping lines ‚ñ∂ teleportation ‚ñ∂ well something is fishy section watch out for the landmines ‚ñ∂ modifying a dictionary while iterating over it ‚ñ∂ stubborn del operator ‚ñ∂ deleting a list item while iterating ‚ñ∂ loop variables leaking out ‚ñ∂ beware of default mutable arguments ‚ñ∂ catching the exceptions ‚ñ∂ same operands different story ‚ñ∂ the out of scope variable ‚ñ∂ be careful with chained operations ‚ñ∂ name resolution ignoring class scope ‚ñ∂ needle in a haystack section the hidden treasures ‚ñ∂ okay python can you make me fly ‚ñ∂ goto but why ‚ñ∂ brace yourself ‚ñ∂ lets meet friendly language uncle for life ‚ñ∂ even python understands that love is complicated ‚ñ∂ yes it exists ‚ñ∂ inpinity ‚ñ∂ mangling time section miscellaneous ‚ñ∂ is faster ‚ñ∂ lets make a giant string ‚ñ∂ explicit typecast of strings ‚ñ∂ minor ones contributing acknowledgements üéì license help want to share wtfpython with friends need a pdf version end doctoc generated toc please keep comment here to allow auto update structure of the examples all the examples are structured like below ‚ñ∂ some fancy title the asterisk at the end of the title indicates the example was not present in the first release and has been recently added py setting up the code preparation for the magic output python version py triggering statement probably unexpected output optional one line describing the unexpected output üí° explanation brief explanation of whats happening and why is it happening py setting up examples for clarification if necessary output py trigger some example that makes it easy to unveil the magic some justified output note all the examples are tested on python 3 5 2 interactive interpreter and they should work for all the python versions unless explicitly specified in the description usage a nice way to get the most out of these examples in my opinion will be just to read the examples chronologically and for every example carefully read the initial code for setting up the example if youre an experienced python programmer most of the times you will successfully anticipate whats going to happen next read the output snippets and check if the outputs are the same as youd expect make sure if you know the exact reason behind the output being the way it is if no take a deep breath and read the explanation and if you still dont understand shout out and create an issue here if yes give a gentle pat on your back and you may skip to the next example ps you can also read wtfpython at the command line theres a pypi package and an npm package supports colored formatting for the same to install the npm package wtfpython sh npm install g wtfpython alternatively to install the pypi package wtfpython sh pip install wtfpython u now just run wtfpython at the command line which will open this collection in your selected pager üëÄ examples section strain your brain ‚ñ∂ strings can be tricky sometimes 1 py a some string id a 140420665652016 id some string notice that both the ids are same 140420665652016 2 py a wtf b wtf a is b true a wtf b wtf a is b false a b wtf wtf a is b true 3 py a 20 is aaaaaaaaaaaaaaaaaaaa true a 21 is aaaaaaaaaaaaaaaaaaaaa false makes sense right üí° explanation such behavior is due to cpython optimization called string interning that tries to use existing immutable objects in some cases rather than creating a new object every time after being interned many variables may point to the same string object in memory thereby saving memory in the snippets above strings are implicitly interned the decision of when to implicitly intern a string is implementation dependent there are some facts that can be used to guess if a string will be interned or not all length 0 and length 1 strings are interned strings are interned at compile time wtf will be interned but join w t f will not be interned strings that are not composed of ascii letters digits or underscores are not interned this explains why wtf was not interned due to cpython implementation of this rule can be found here when a and b are set to wtf in the same line the python interpreter creates a new object then references the second variable at the same time if you do it on separate lines it doesnt know that theres already wtf as an object because wtf is not implicitly interned as per the facts mentioned above its a compiler optimization and specifically applies to the interactive environment constant folding is a technique for peephole optimization in python this means the expression a 20 is replaced by aaaaaaaaaaaaaaaaaaaa during compilation to reduce few clock cycles during runtime constant folding only occurs for strings having length less than 20 why imagine the size of pyc file generated as a result of the expression a 10 10 heres the implementation source for the same ‚ñ∂ time for some hash brownies 1 py some dict some dict 5 5 ruby some dict 5 0 javascript some dict 5 python output py some dict 5 5 ruby some dict 5 0 python some dict 5 python python destroyed the existence of javascript üí° explanation python dictionaries check for equality and compare the hash value to determine if two keys are the same immutable objects with same value always have the same hash in python py 5 5 0 true hash 5 hash 5 0 true note objects with different values may also have same hash known as hash collision when the statement some dict 5 python is executed the existing value javascript is overwritten with python because python recognizes 5 and 5 0 as the same keys of the dictionary some dict this stackoverflow answer explains beautifully the rationale behind it ‚ñ∂ return return everywhere py def some func try return from try finally return from finally output py some func from finally üí° explanation when a return break or continue statement is executed in the try suite of a try‚Ä¶finally statement the finally clause is also executed ‚Äòon the way out the return value of a function is determined by the last return statement executed since the finally clause always executes a return statement executed in the finally clause will always be the last one executed ‚ñ∂ deep down were all the same py class wtf pass output py wtf wtf two different instances cant be equal false wtf is wtf identities are also different false hash wtf hash wtf hashes should be different as well true id wtf id wtf true üí° explanation when id was called python created a wtf class object and passed it to the id function the id function takes its id its memory location and throws away the object the object is destroyed when we do this twice in succession python allocates the same memory location to this second object as well since in cpython id uses the memory location as the object id the id of the two objects is the same so objects id is unique only for the lifetime of the object after the object is destroyed or before it is created something else can have the same id but why did the is operator evaluated to false lets see with this snippet py class wtf object def init self print i def del self print d output py wtf is wtf i i d d id wtf id wtf i d i d as you may observe the order in which the objects are destroyed is what made all the difference here ‚ñ∂ for what py some string wtf some dict for i some dict i in enumerate some string pass output py some dict an indexed dict is created 0 w 1 t 2 f üí° explanation a for statement is defined in the python grammar as for stmt for exprlist in testlist suite else suite where exprlist is the assignment target this means that the equivalent of exprlist next value is executed for each item in the iterable an interesting example that illustrates this py for i in range 4 print i i 10 output 0 1 2 3 did you expect the loop to run just once üí° explanation the assignment statement i 10 never affects the iterations of the loop because of the way for loops work in python before the beginning of every iteration the next item provided by the iterator range 4 this case is unpacked and assigned the target list variables i in this case the enumerate some string function yields a new value i a counter going up and a character from the some string in each iteration it then sets the just assigned i key of the dictionary some dict to that character the unrolling of the loop can be simplified as py i some dict i 0 w i some dict i 1 t i some dict i 2 f some dict ‚ñ∂ evaluation time discrepancy 1 py array 1 8 15 g x for x in array if array count x 0 array 2 8 22 output py print list g 8 2 py array 1 1 2 3 4 g1 x for x in array 1 array 1 1 2 3 4 5 array 2 1 2 3 4 g2 x for x in array 2 array 2 1 2 3 4 5 output py print list g1 1 2 3 4 print list g2 1 2 3 4 5 üí° explanation in a generator expression the in clause is evaluated at declaration time but the conditional clause is evaluated at runtime so before runtime array is re assigned to the list 2 8 22 and since out of 1 8 and 15 only the count of 8 is greater than 0 the generator only yields 8 the differences in the output of g1 and g2 in the second part is due the way variables array 1 and array 2 are re assigned values in the first case array 1 is binded to the new object 1 2 3 4 5 and since the in clause is evaluated at the declaration time it still refers to the old object 1 2 3 4 which is not destroyed in the second case the slice assignment to array 2 updates the same old object 1 2 3 4 to 1 2 3 4 5 hence both the g2 and array 2 still have reference to the same object which has now been updated to 1 2 3 4 5 ‚ñ∂ is is not what it is the following is a very famous example present all over the internet py a 256 b 256 a is b true a 257 b 257 a is b false a 257 b 257 a is b true üí° explanation the difference between is and is operator checks if both the operands refer to the same object i e it checks if the identity of the operands matches or not operator compares the values of both the operands and checks if they are the same so is is for reference equality and is for value equality an example to clear things up py true is these are two empty lists at two different memory locations false 256 is an existing object but 257 isnt when you start up python the numbers from 5 to 256 will be allocated these numbers are used a lot so it makes sense just to have them ready quoting from https docs python org 3 c api long html the current implementation keeps an array of integer objects for all integers between 5 and 256 when you create an int in that range you just get back a reference to the existing object so it should be possible to change the value of 1 i suspect the behavior of python in this case is undefined py id 256 10922528 a 256 b 256 id a 10922528 id b 10922528 id 257 140084850247312 x 257 y 257 id x 140084850247440 id y 140084850247344 here the interpreter isnt smart enough while executing y 257 to recognize that weve already created an integer of the value 257 and so it goes on to create another object in the memory both a and b refer to the same object when initialized with same value in the same line py a b 257 257 id a 140640774013296 id b 140640774013296 a 257 b 257 id a 140640774013392 id b 140640774013488 when a and b are set to 257 in the same line the python interpreter creates a new object then references the second variable at the same time if you do it on separate lines it doesnt know that theres already 257 as an object its a compiler optimization and specifically applies to the interactive environment when you enter two lines in a live interpreter theyre compiled separately therefore optimized separately if you were to try this example in a py file you would not see the same behavior because the file is compiled all at once ‚ñ∂ a tic tac toe where x wins in the first attempt py lets initialize a row row 3 row i lets make a board board row 3 output py board board 0 board 0 0 board 0 0 x board x x x we didnt assign 3 x s or did we üí° explanation when we initialize row variable this visualization explains what happens in the memory and when the board is initialized by multiplying the row this is what happens inside the memory each of the elements board 0 board 1 and board 2 is a reference to the same list referred by row we can avoid this scenario here by not using row variable to generate board asked in this issue py board 3 for in range 3 board 0 0 x board x ‚ñ∂ the sticky output function py funcs results for x in range 7 def some func return x funcs append some func results append some func funcs results func for func in funcs output py results 0 1 2 3 4 5 6 funcs results 6 6 6 6 6 6 6 even when the values ofxwere different in every iteration prior to appendingsome functofuncs all the functions return 6 or py powers of x lambda x x i for i in range 10 f 2 for f in powers of x 512 512 512 512 512 512 512 512 512 512 üí° explanation when defining a function inside a loop that uses the loop variable in its body the loop functions closure is bound to the variable not its value so all of the functions use the latest value assigned to the variable for computation to get the desired behavior you can pass in the loop variable as a named variable to the function why this works because this will define the variable again within the functions scope py funcs for x in range 7 def some func x x return x funcs append some func output py funcs results func for func in funcs funcs results 0 1 2 3 4 5 6 ‚ñ∂ is not is not is not py something is not none true something is not none false üí° explanation is not is a single binary operator and has behavior different than using is and not separated is not evaluates to false if the variables on either side of the operator point to the same object and true otherwise ‚ñ∂ the surprising comma output py def f x y print x y def g x 4 y 5 print x y def h x kwargs file line 1 def h x kwargs syntaxerror invalid syntax def h args file line 1 def h args syntaxerror invalid syntax üí° explanation trailing comma is not always legal in formal parameters list of a python function in python the argument list is defined partially with leading commas and partially with trailing commas this conflict causes situations where a comma is trapped in the middle and no rule accepts it note the trailing comma problem is fixed in python 3 6 the remarks in this post discuss in brief different usages of trailing commas in python ‚ñ∂ backslashes at the end of string output print \ c \ \ c \ print r \ c \ c print r \ c \ file stdin line 1 print r \ c \ syntaxerror eol while scanning string literal üí° explanation in a raw string literal as indicated by the prefix r the backslash doesnt have the special meaning py print repr r wt\ f wt\ f what the interpreter actually does though is simply change the behavior of backslashes so they pass themselves and the following character through thats why backslashes dont work at the end of a raw string ‚ñ∂ not knot py x true y false output py not x y true x not y file line 1 x not y syntaxerror invalid syntax üí° explanation operator precedence affects how an expression is evaluated and operator has higher precedence than not operator in python so not x y is equivalent to not x y which is equivalent to not true false finally evaluating to true but x not y raises a syntaxerror because it can be thought of being equivalent to x not y and not x not y which you might have expected at first sight the parser expected the not token to be a part of the not in operator because both and not in operators have the same precedence but after not being able to find an in token following the not token it raises a syntaxerror ‚ñ∂ half triple quoted strings output py print wtfpython wtfpython print wtfpython wtfpython the following statements raise syntaxerror print wtfpython print wtfpython üí° explanation python supports implicit string literal concatenation example print wtf python wtfpython print wtf or wtf wtf and are also string delimiters in python which causes a syntaxerror because the python interpreter was expecting a terminating triple quote as delimiter while scanning the currently encountered triple quoted string literal ‚ñ∂ midnight time doesnt exist py from datetime import datetime midnight datetime 2018 1 1 0 0 midnight time midnight time noon datetime 2018 1 1 12 0 noon time noon time if midnight time print time at midnight is midnight time if noon time print time at noon is noon time output sh time at noon is datetime time 12 0 the midnight time is not printed üí° explanation before python 3 5 the boolean value for datetime time object was considered to be false if it represented midnight in utc it is error prone when using the if obj syntax to check if the obj is null or some equivalent of empty ‚ñ∂ whats wrong with booleans 1 py a simple example to count the number of boolean and integers in an iterable of mixed data types mixed list false 1 0 some string 3 true false integers found so far 0 booleans found so far 0 for item in mixed list if isinstance item int integers found so far 1 elif isinstance item bool booleans found so far 1 output py booleans found so far 0 integers found so far 4 2 py another dict another dict true javascript another dict 1 ruby another dict 1 0 python output py another dict true python 3 py some bool true wtf some bool wtf some bool false wtf some bool üí° explanation booleans are a subclass of int py isinstance true int true isinstance false int true the integer value of true is 1 and that of false is 0 py true 1 1 0 and false 0 0 0 true see this stackoverflow answer for the rationale behind it ‚ñ∂ class attributes and instance attributes 1 py class a x 1 class b a pass class c a pass ouptut py a x b x c x 1 1 1 b x 2 a x b x c x 1 2 1 a x 3 a x b x c x 3 2 3 a a a x a x 3 3 a x 1 a x a x 4 3 2 py class someclass some var 15 some list 5 another list 5 def init self x self some var x 1 self some list self some list x self another list x output py some obj someclass 420 some obj some list 5 420 some obj another list 5 420 another obj someclass 111 another obj some list 5 111 another obj another list 5 420 111 another obj another list is someclass another list true another obj another list is some obj another list true üí° explanation class variables and variables in class instances are internally handled as dictionaries of a class object if a variable name is not found in the dictionary of the current class the parent classes are searched for it the operator modifies the mutable object in place without creating a new object so changing the attribute of one instance affects the other instances and the class attribute as well ‚ñ∂ yielding none py some iterable a b def some func val return something output py x for x in some iterable a b yield x for x in some iterable at 0x7f70b0a4ad58 list yield x for x in some iterable a b list yield x for x in some iterable a none b none list some func yield x for x in some iterable a something b something üí° explanation source and explanation can be found here https stackoverflow com questions 32139885 yield in list comprehensions and generator expressions related bug report http bugs python org issue10544 ‚ñ∂ mutating the immutable py some tuple a tuple with values another tuple 1 2 3 4 5 6 output py some tuple 2 change this typeerror tuple object does not support item assignment another tuple 2 append 1000 this throws no error another tuple 1 2 3 4 5 6 1000 another tuple 2 99 999 typeerror tuple object does not support item assignment another tuple 1 2 3 4 5 6 1000 99 999 but i thought tuples were immutable üí° explanation quoting from https docs python org 2 reference datamodel html immutable sequences an object of an immutable sequence type cannot change once it is created if the object contains references to other objects these other objects may be mutable and may be modified however the collection of objects directly referenced by an immutable object cannot change operator changes the list in place the item assignment doesnt work but when the exception occurs the item has already been changed in place ‚ñ∂ the disappearing variable from outer scope py e 7 try raise exception except exception as e pass output python 2 x py print e prints nothing output python 3 x py print e nameerror name e is not defined üí° explanation source https docs python org 3 reference compound stmts html except when an exception has been assigned using as target it is cleared at the end of the except clause this is as if py except e as n foo was translated into py except e as n try foo finally del n this means the exception must be assigned to a different name to be able to refer to it after the except clause exceptions are cleared because with the traceback attached to them they form a reference cycle with the stack frame keeping all locals in that frame alive until the next garbage collection occurs the clauses are not scoped in python everything in the example is present in the same scope and the variable e got removed due to the execution of the except clause the same is not the case with functions which have their separate inner scopes the example below illustrates this py def f x del x print x x 5 y 5 4 3 output py f x unboundlocalerror local variable x referenced before assignment f y unboundlocalerror local variable x referenced before assignment x 5 y 5 4 3 in python 2 x the variable name e gets assigned to exception instance so when you try to print it prints nothing output python 2 x py e exception print e nothing is printed ‚ñ∂ when true is actually false py true false if true false print ive lost faith in truth output ive lost faith in truth üí° explanation initially python used to have no bool type people used 0 for false and non zero value like 1 for true then they added true false and a bool type but for backward compatibility they couldnt make true and false constants they just were built in variables python 3 was backward incompatible so it was now finally possible to fix that and so this example wont work with python 3 x ‚ñ∂ from filled to none in one instruction py some list 1 2 3 some dict key 1 1 key 2 2 key 3 3 some list some list append 4 some dict some dict update key 4 4 output py print some list none print some dict none üí° explanation most methods that modify the items of sequence mapping objects like list append dict update list sort etc modify the objects in place and return none the rationale behind this is to improve performance by avoiding making a copy of the object if the operation can be done in place referred from here ‚ñ∂ subclass relationships output py from collections import hashable issubclass list object true issubclass object hashable true issubclass list hashable false the subclass relationships were expected to be transitive right i e if a is a subclass of b and b is a subclass of c the a should a subclass of c üí° explanation subclass relationships are not necessarily transitive in python anyone is allowed to define their own arbitrary subclasscheck in a metaclass when issubclass cls hashable is called it simply looks for non falsey hash method in cls or anything it inherits from since object is hashable but list is non hashable it breaks the transitivity relation more detailed explanation can be found here ‚ñ∂ the mysterious key type conversion py class someclass str pass some dict s 42 output py type list some dict keys 0 str s someclass s some dict s 40 some dict expected two different keys value pairs s 40 type list some dict keys 0 str üí° explanation both the object s and the string s hash to the same value because someclass inherits the hash method of str class someclass s s evaluates to true because someclass also inherits eq method from str class since both the objects hash to the same value and are equal they are represented by the same key in the dictionary for the desired behavior we can redefine the eq method in someclass py class someclass str def eq self other return type self is someclass and type other is someclass and super eq other when we define a custom eq python stops automatically inheriting the hash method so we need to define it as well hash str hash some dict s 42 output py s someclass s some dict s 40 some dict s 40 s 42 keys list some dict keys type keys 0 type keys 1 main someclass str ‚ñ∂ lets see if you can guess this py a b a b 5 output py a 5 5 üí° explanation according to python language reference assignment statements have the form target list expression list yield expression and an assignment statement evaluates the expression list remember that this can be a single expression or a comma separated list the latter yielding a tuple and assigns the single resulting object to each of the target lists from left to right the in target list means there can be one or more target lists in this case target lists are a b and a b note the expression list is exactly one which in our case is 5 after the expression list is evaluated its value is unpacked to the target lists from left to right so in our case first the 5 tuple is unpacked to a b and we now have a and b 5 a is now assigned to which is a mutable object the second target list is a b you may expect this to throw an error because both a and b have not been defined in the statements before but remember we just assigned a to and b to 5 now we are setting the key 5 in the dictionary to the tuple 5 creating a circular reference the in the output refers to the same object that a is already referencing another simpler example of circular reference could be py some list some list 0 0 some list some list 0 some list is some list 0 true some list 0 0 0 0 0 0 some list true similar is the case in our example a b 0 is the same object asa so to sum it up you can break the example down to py a b 5 a b a b and the circular reference can be justified by the fact that a b 0 is the same object as a py a b 0 is a true section appearances are deceptive ‚ñ∂ skipping lines output py value 11 valu–µ 32 value 11 wut note the easiest way to reproduce this is to simply copy the statements from the above snippet and paste them into your file shell üí° explanation some non western characters look identical to letters in the english alphabet but are considered distinct by the interpreter py ord –µ cyrillic e ye 1077 ord e latin e as used in english and typed using standard keyboard 101 –µ e false value 42 latin e valu–µ 23 cyrillic e python 2 x interpreter would raise a syntaxerror here value 42 the built in ord function returns a characters unicode code point and different code positions of cyrillic e and latin e justify the behavior of the above example ‚ñ∂ teleportation py import numpy as np def energy send x initializing a numpy array np array float x def energy receive return an empty numpy array return np empty dtype np float tolist output py energy send 123 456 energy receive 123 456 wheres the nobel prize üí° explanation notice that the numpy array created in the energy send function is not returned so that memory space is free to reallocate numpy empty returns the next free memory slot without reinitializing it this memory spot just happens to be the same one that was just freed usually but not always ‚ñ∂ well something is fishy py def square x a simple function to calculate the square of a number by addition sum so far 0 for counter in range x sum so far sum so far x return sum so far output python 2 x py square 10 10 shouldnt that be 100 note if youre not able to reproduce this try running the file mixed tabs and spaces py via the shell üí° explanation dont mix tabs and spaces the character just preceding return is a tab and the code is indented by multiple of 4 spaces elsewhere in the example this is how python handles tabs first tabs are replaced from left to right by one to eight spaces such that the total number of characters up to and including the replacement is a multiple of eight so the tab at the last line of square function is replaced with eight spaces and it gets into the loop python 3 is kind enough to throw an error for such cases automatically output python 3 x py taberror inconsistent use of tabs and spaces in indentation section watch out for the landmines ‚ñ∂ modifying a dictionary while iterating over it py x 0 none for i in x del x i x i 1 none print i output python 2 7 python 3 5 0 1 2 3 4 5 6 7 yes it runs for exactly eight times and stops üí° explanation iteration over a dictionary that you edit at the same time is not supported it runs eight times because thats the point at which the dictionary resizes to hold more keys we have eight deletion entries so a resize is needed this is actually an implementation detail how deleted keys are handled and when the resize occurs might be different for different python implementations for more information you may refer to this stackoverflow thread explaining a similar example in detail ‚ñ∂ stubborn del operator py class someclass def del self print deleted output 1 py x someclass y x del x this should print deleted del y deleted phew deleted at last you might have guessed what saved from del being called in our first attempt to delete x lets add more twist to the example 2 py x someclass y x del x y check if y exists main someclass instance at 0x7f98a1a67fc8 del y like previously this should print deleted globals oh it didnt lets check all our global variables and confirm deleted builtins someclass package none name main doc none okay now its deleted confused üí° explanation del x doesnt directly call x del whenever del x is encountered python decrements the reference count for x by one and x del when xs reference count reaches zero in the second output snippet y del was not called because the previous statement y in the interactive interpreter created another reference to the same object thus preventing the reference count to reach zero when del y was encountered calling globals caused the existing reference to be destroyed and hence we can see deleted being printed finally ‚ñ∂ deleting a list item while iterating py list 1 1 2 3 4 list 2 1 2 3 4 list 3 1 2 3 4 list 4 1 2 3 4 for idx item in enumerate list 1 del item for idx item in enumerate list 2 list 2 remove item for idx item in enumerate list 3 list 3 remove item for idx item in enumerate list 4 list 4 pop idx output py list 1 1 2 3 4 list 2 2 4 list 3 list 4 2 4 can you guess why the output is 2 4 üí° explanation its never a good idea to change the object youre iterating over the correct way to do so is to iterate over a copy of the object instead and list 3 does just that py some list 1 2 3 4 id some list 139798789457608 id some list notice that python creates new object for sliced list 139798779601192 difference between del remove and pop del var name just removes the binding of the var name from the local or global namespace thats why the list 1 is unaffected remove removes the first matching value not a specific index raises valueerror if the value is not found pop removes the element at a specific index and returns it raises indexerror if an invalid index is specified why the output is 2 4 the list iteration is done index by index and when we remove 1 from list 2 or list 4 the contents of the lists are now 2 3 4 the remaining elements are shifted down i e 2 is at index 0 and 3 is at index 1 since the next iteration is going to look at index 1 which is the 3 the 2 gets skipped entirely a similar thing will happen with every alternate element in the list sequence refer to this stackoverflow thread explaining the example see also this nice stackoverflow thread for a similar example related to dictionaries in python ‚ñ∂ loop variables leaking out 1 py for x in range 7 if x 6 print x for x inside loop print x x in global output py 6 for x inside loop 6 x in global but x was never defined outside the scope of for loop 2 py this time lets initialize x first x 1 for x in range 7 if x 6 print x for x inside loop print x x in global output py 6 for x inside loop 6 x in global 3 x 1 print x for x in range 5 print x x in global output on python 2 x 0 1 2 3 4 4 x in global output on python 3 x 0 1 2 3 4 1 x in global üí° explanation in python for loops use the scope they exist in and leave their defined loop variable behind this also applies if we explicitly defined the for loop variable in the global namespace before in this case it will rebind the existing variable the differences in the output of python 2 x and python 3 x interpreters for list comprehension example can be explained by following change documented in whats new in python 3 0 documentation list comprehensions no longer support the syntactic form for var in item1 item2 use for var in item1 item2 instead also note that list comprehensions have different semantics they are closer to syntactic sugar for a generator expression inside a list constructor and in particular the loop control variables are no longer leaked into the surrounding scope ‚ñ∂ beware of default mutable arguments py def some func default arg default arg append some string return default arg output py some func some string some func some string some string some func some string some func some string some string some string üí° explanation the default mutable arguments of functions in python arent really initialized every time you call the function instead the recently assigned value to them is used as the default value when we explicitly passed to some func as the argument the default value of the default arg variable was not used so the function returned as expected py def some func default arg default arg append some string return default arg output py some func defaults this will show the default argument values for the function some func some func defaults some string some func some func defaults some string some string some func some func defaults some string some string a common practice to avoid bugs due to mutable arguments is to assign none as the default value and later check if any value is passed to the function corresponding to that argument example py def some func default arg none if not default arg default arg default arg append some string return default arg ‚ñ∂ catching the exceptions py some list 1 2 3 try this should raise anindexerror print some list 4 except indexerror valueerror print caught try this should raise a valueerror some list remove 4 except indexerror valueerror print caught again output python 2 x py caught valueerror list remove x x not in list output python 3 x py file input line 3 except indexerror valueerror syntaxerror invalid syntax üí° explanation to add multiple exceptions to the except clause you need to pass them as parenthesized tuple as the first argument the second argument is an optional name which when supplied will bind the exception instance that has been raised example py some list 1 2 3 try this should raise a valueerror some list remove 4 except indexerror valueerror e print caught again print e output python 2 x caught again list remove x x not in list output python 3 x py file input line 4 except indexerror valueerror e indentationerror unindent does not match any outer indentation level separating the exception from the variable with a comma is deprecated and does not work in python 3 the correct way is to use as example py some list 1 2 3 try some list remove 4 except indexerror valueerror as e print caught again print e output caught again list remove x x not in list ‚ñ∂ same operands different story 1 py a 1 2 3 4 b a a a 5 6 7 8 output py a 1 2 3 4 5 6 7 8 b 1 2 3 4 2 py a 1 2 3 4 b a a 5 6 7 8 output py a 1 2 3 4 5 6 7 8 b 1 2 3 4 5 6 7 8 üí° explanation a b doesnt always behave the same way as a a b classes may implement the op operators differently and lists do this the expression a a 5 6 7 8 generates a new list and sets as reference to that new list leaving b unchanged the expression a 5 6 7 8 is actually mapped to an extend function that operates on the list such that a and b still point to the same list that has been modified in place ‚ñ∂ the out of scope variable py a 1 def some func return a def another func a 1 return a output py some func 1 another func unboundlocalerror local variable a referenced before assignment üí° explanation when you make an assignment to a variable in scope it becomes local to that scope so a becomes local to the scope of another func but it has not been initialized previously in the same scope which throws an error read this short but an awesome guide to learn more about how namespaces and scope resolution works in python to modify the outer scope variable a in another func use global keyword py def another func global a a 1 return a output py another func 2 ‚ñ∂ be careful with chained operations py false false in false makes sense false false false in false makes sense false false false in false now what true true is false false false false is false is false true 1 0 1 true 1 0 1 false 1 0 1 false üí° explanation as per https docs python org 2 reference expressions html not in formally if a b c y z are expressions and op1 op2 opn are comparison operators then a op1 b op2 c y opn z is equivalent to a op1 b and b op2 c and y opn z except that each expression is evaluated at most once while such behavior might seem silly to you in the above examples its fantastic with stuff like a b c and 0 x 100 false is false is false is equivalent to false is false and false is false true is false false is equivalent to true is false and false false and since the first part of the statement true is false evaluates to false the overall expression evaluates to false 1 0 1 is equivalent to 1 0 and 0 1 which evaluates to true the expression 1 0 1 is equivalent to true 1 and py int true 1 true 1 not relevant for this example but just for fun 2 so 1 1evaluates tofalse ‚ñ∂ name resolution ignoring class scope 1 py x 5 class someclass x 17 y x for i in range 10 output py list someclass y 0 5 2 py x 5 class someclass x 17 y x for i in range 10 output python 2 x py someclass y 0 17 output python 3 x py someclass y 0 5 üí° explanation scopes nested inside class definition ignore names bound at the class level a generator expression has its own scope starting from python 3 x list comprehensions also have their own scope ‚ñ∂ needle in a haystack 1 py x y 0 1 if true else none none output x y expected 0 1 0 1 none almost every python programmer has faced a similar situation 2 py t one two for i in t print i t one for i in t print i t print t output py one two o n e tuple üí° explanation for 1 the correct statement for expected behavior is x y 0 1 if true else none none for 2 the correct statement for expected behavior is t one or t one missing comma otherwise the interpreter considers t to be a str and iterates over it character by character is a special token and denotes empty tuple section the hidden treasures this section contains few of the lesser known interesting things about python that most beginners like me are unaware of well not anymore ‚ñ∂ okay python can you make me fly well here you go py import antigravity output sshh its a super secret üí° explanation antigravity module is one of the few easter eggs released by python developers import antigravity opens up a web browser pointing to the classic xkcd comic about python well theres more to it theres another easter egg inside the easter egg if look at the code theres a function defined that purports to implement the xkcds geohashing algorithm ‚ñ∂ goto but why py from goto import goto label for i in range 9 for j in range 9 for k in range 9 print im trapped please rescue if k 2 goto breakout breaking out from a deeply nested loop label breakout print freedom output python 2 3 py im trapped please rescue im trapped please rescue freedom üí° explanation a working version of goto in python was announced as an april fools joke on 1st april 2004 current versions of python do not have this module although it works but please dont use it heres the reason to why goto is not present in python ‚ñ∂ brace yourself if you are one of the people who doesnt like using whitespace in python to denote scopes you can use the c style by importing py from future import braces output py file some file py line 1 from future import braces syntaxerror not a chance braces no way if you think thats disappointing use java üí° explanation the future module is normally used to provide features from future versions of python the future here is however ironic this is an easter egg concerned with the communitys feelings on this issue ‚ñ∂ lets meet friendly language uncle for life output python 3 x py from future import barry as flufl ruby python theres no doubt about it file some file py line 1 ruby python syntaxerror invalid syntax ruby python true there we go üí° explanation this is relevant to pep 401 released on april 1 2009 now you know what it means quoting from the pep 401 recognized that the inequality operator in python 3 0 was a horrible finger pain inducing mistake the flufl reinstates the diamond operator as the sole spelling there were more things that uncle barry had to share in the pep you can read them here ‚ñ∂ even python understands that love is complicated py import this wait whats this this is love heart output the zen of python by tim peters beautiful is better than ugly explicit is better than implicit simple is better than complex complex is better than complicated flat is better than nested sparse is better than dense readability counts special cases arent special enough to break the rules although practicality beats purity errors should never pass silently unless explicitly silenced in the face of ambiguity refuse the temptation to guess there should be one and preferably only one obvious way to do it although that way may not be obvious at first unless youre dutch now is better than never although never is often better than right now if the implementation is hard to explain its a bad idea if the implementation is easy to explain it may be a good idea namespaces are one honking great idea lets do more of those its the zen of python py love this this is love true love is true false love is false false love is not true or false true love is not true or false love is love love is complicated true üí° explanation this module in python is an easter egg for the zen of python pep 20 and if you think thats already interesting enough check out the implementation of this py interestingly the code for the zen violates itself and thats probably the only place where this happens regarding the statement love is not true or false love is love ironic but its self explanatory ‚ñ∂ yes it exists the else clause for loops one typical example might be py def does exists num l to find for num in l if num to find print exists break else print does not exist output py some list 1 2 3 4 5 does exists num some list 4 exists does exists num some list 1 does not exist the else clause in exception handling an example py try pass except print exception occurred else print try block executed successfully output py try block executed successfully üí° explanation the else clause after a loop is executed only when theres no explicit break after all the iterations else clause after try block is also called completion clause as reaching the else clause in a try statement means that the try block actually completed successfully ‚ñ∂ inpinity the spelling is intended please dont submit a patch for this output python 3 x py infinity float infinity hash infinity 314159 hash float inf 314159 üí° explanation hash of infinity is 10‚Åµ x œÄ interestingly the hash of float inf is 10‚Åµ x œÄ in python 3 whereas 10‚Åµ x e in python 2 ‚ñ∂ mangling time py class yo object def init self self honey true self bitch true output py yo bitch true yo honey attributeerror yo object has no attribute honey yo yo honey true why did yo yo honey work only indian readers would understand üí° explanation name mangling is used to avoid naming collisions between different namespaces in python the interpreter modifies mangles the class member names starting with double underscore and not ending with more than one trailing underscore by adding nameoftheclass in front so to access honey attribute we are required to append yo to the front which would prevent conflicts with the same name attribute defined in any other class section miscellaneous ‚ñ∂ is faster py using three strings timeit timeit s1 s1 s2 s3 setup s1 100000 s2 100000 s3 100000 number 100 0 25748300552368164 using three strings timeit timeit s1 s2 s3 setup s1 100000 s2 100000 s3 100000 number 100 0 012188911437988281 üí° explanation is faster than for concatenating more than two strings because the first string example s1 for s1 s2 s3 is not destroyed while calculating the complete string ‚ñ∂ lets make a giant string py def add string with plus iters s for i in range iters s xyz assert len s 3 iters def add bytes with plus iters s b for i in range iters s b xyz assert len s 3 iters def add string with format iters fs iters s fs format xyz iters assert len s 3iters def add string with join iters l for i in range iters l append xyz s join l assert len s 3 iters def convert list to string l iters s join l assert len s 3 iters output py timeit add string with plus 10000 1000 loops best of 3 972 ¬µs per loop timeit add bytes with plus 10000 1000 loops best of 3 815 ¬µs per loop timeit add string with format 10000 1000 loops best of 3 508 ¬µs per loop timeit add string with join 10000 1000 loops best of 3 878 ¬µs per loop l xyz 10000 timeit convert list to string l 10000 10000 loops best of 3 80 ¬µs per loop lets increase the number of iterations by a factor of 10 py timeit add string with plus 100000 linear increase in execution time 100 loops best of 3 9 75 ms per loop timeit add bytes with plus 100000 quadratic increase 1000 loops best of 3 974 ms per loop timeit add string with format 100000 linear increase 100 loops best of 3 5 25 ms per loop timeit add string with join 100000 linear increase 100 loops best of 3 9 85 ms per loop l xyz 100000 timeit convert list to string l 100000 linear increase 1000 loops best of 3 723 ¬µs per loop üí° explanation you can read more about timeit from here it is generally used to measure the execution time of snippets dont use for generating long strings ‚Äî in python str is immutable so the left and right strings have to be copied into the new string for every pair of concatenations if you concatenate four strings of length 10 youll be copying 10 10 10 10 10 10 10 10 10 90 characters instead of just 40 characters things get quadratically worse as the number and size of the string increases justified with the execution times of add bytes with plus function therefore its advised to use format or syntax however they are slightly slower than for short strings or better if already youve contents available in the form of an iterable object then use join iterable object which is much faster add string with plus didnt show a quadratic increase in execution time unlike add bytes with plus because of the optimizations discussed in the previous example had the statement been s s x y z instead of s xyz the increase would have been quadratic py def add string with plus iters s for i in range iters s s x y z assert len s 3 iters timeit add string with plus 10000 100 loops best of 3 9 87 ms per loop timeit add string with plus 100000 quadratic increase in execution time 1 loops best of 3 1 09 s per loop ‚ñ∂ explicit typecast of strings py a float inf b float nan c float inf these strings are case insensitive d float nan output py a inf b nan c inf float some other string valueerror could not convert string to float some other string a c inf inf true none none none none true b d but nan nan false 50 a 0 0 a a nan 23 b nan üí° explanation inf and nan are special strings case insensitive which when explicitly typecasted to float type are used to represent mathematical infinity and not a number respectively ‚ñ∂ minor ones join is a string operation instead of list operation sort of counter intuitive at first usage üí° explanation if join is a method on a string then it can operate on any iterable list tuple iterators if it were a method on a list itd have to be implemented separately by every type also it doesnt make much sense to put a string specific method on a generic list object api few weird looking but semantically correct statements is a semantically correct statement unpacking an empty tuple into an empty list a 0 0 0 0 0 is also a semantically correct statement as strings are sequences iterables supporting element access using integer indices in python 3 0 5 8 and 5 5 are both semantically correct statements and evaluate to true given that a is a number a and a are both valid python statements but dont behave the same way as compared with similar statements in languages like c c or java py a 5 a 5 a 5 a 5 üí° explanation there is no operator in python grammar it is actually two operators a parses as a which translates to a similarly the output of the statement a can be justified this stackoverflow thread discusses the rationale behind the absence of increment and decrement operators in python python uses 2 bytes for local variable storage in functions in theory this means that only 65536 variables can be defined in a function however python has a handy solution built in that can be used to store more than 2 16 variable names the following code demonstrates what happens in the stack when more than 65536 local variables are defined warning this code prints around 2 18 lines of text so be prepared py import dis exec def f join x str x str x for x in range 65539 f print dis dis f multiple python threads wont run your python code concurrently yes you heard it right it may seem intuitive to spawn several threads and let them execute your python code concurrently but because of the global interpreter lock in python all youre doing is making your threads execute on the same core turn by turn python threads are good for io bound tasks but to achieve actual parallelization in python for cpu bound tasks you might want to use the python multiprocessing module list slicing with out of the bounds indices throws no errors py some list 1 2 3 4 5 some list 111 int Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ© returns 123456789 in python 3 in python decimal characters include digit characters and all characters that can be used to form decimal radix numbers e g u 0660 arabic indic digit zero heres an interesting story related to this behavior of python abc count 4 heres an approximate implementation of count method which would make the things more clear py def count s sub result 0 for i in range len s 1 len sub result s i i len sub sub return result the behavior is due to the matching of empty substring with slices of length 0 in the original string contributing all patches are welcome please see contributing md for further details for discussions you can either create a new issue or ping on the gitter channel acknowledgements the idea and design for this collection were initially inspired by denys dovhans awesome project wtfjs the overwhelming support by the community gave it the shape it is in right now some nice links https www youtube com watch v sh4xf6pkkmk https www reddit com r python comments 3cu6ej what are some wtf things about python https sopython com wiki common gotchas in python https stackoverflow com questions 530530 python 2 x gotchas and landmines https stackoverflow com questions 1011431 common pitfalls in python https www python org doc humor https www satwikkansal xyz archives posts python my python archives üéì license ¬© satwik kansal help if you have any wtfs ideas or suggestions please share want to surprise your geeky pythonist friends you can recommend wtfpython to your friends on twitter and linkedin by using these quick links twitter linkedin need a pdf version ive received a few requests for the pdf version of wtfpython you can add your details here to get the pdf as soon as it is finished