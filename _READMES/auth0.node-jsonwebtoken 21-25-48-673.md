jsonwebtoken an implementation of json web tokens this was developed against draft ietf oauth json web token 08 it makes use of node jws install bash npm install jsonwebtoken migration notes from v7 to v8 usage jwt sign payload secretorprivatekey options callback asynchronous if a callback is supplied the callback is called with the err or the jwt synchronous returns the jsonwebtoken as string payload could be an object literal buffer or string representing valid json please note that exp or any other claim is only set if the payload is an object literal buffer or string payloads are not checked for json validity secretorprivatekey is a string buffer or object containing either the secret for hmac algorithms or the pem encoded private key for rsa and ecdsa in case of a private key with passphrase an object key passphrase can be used based on crypto documentation in this case be sure you pass the algorithm option options algorithm default hs256 expiresin expressed in seconds or a string describing a time span zeit ms eg 60 2 days 10h 7d a numeric value is interpreted as a seconds count if you use a string be sure you provide the time units days hours etc otherwise milliseconds unit is used by default 120 is equal to 120ms notbefore expressed in seconds or a string describing a time span zeit ms eg 60 2 days 10h 7d a numeric value is interpreted as a seconds count if you use a string be sure you provide the time units days hours etc otherwise milliseconds unit is used by default 120 is equal to 120ms audience issuer jwtid subject notimestamp header keyid mutatepayload if true the sign function will modify the payload object directly this is useful if you need a raw reference to the payload after claims have been applied to it but before it has been encoded into a token if payload is not a buffer or a string it will be coerced into a string using json stringify there are no default values for expiresin notbefore audience subject issuer these claims can also be provided in the payload directly with exp nbf aud sub and iss respectively but you cant include in both places remember that exp nbf and iat are numericdate see related token expiration exp claim the header can be customized via the options header object generated jwts will include an iat issued at claim by default unless notimestamp is specified if iat is inserted in the payload it will be used instead of the real timestamp for calculating other things like exp given a timespan in options expiresin sign with default hmac sha256 js var jwt require jsonwebtoken var token jwt sign foo bar shhhhh sign with rsa sha256 js sign with rsa sha256 var cert fs readfilesync private key var token jwt sign foo bar cert algorithm rs256 sign asynchronously js jwt sign foo bar cert algorithm rs256 function err token console log token backdate a jwt 30 seconds js var older token jwt sign foo bar iat math floor date now 1000 30 shhhhh token expiration exp claim the standard for jwt defines an exp claim for expiration the expiration is represented as a numericdate a json numeric value representing the number of seconds from 1970 01 01t00 00 00z utc until the specified utc date time ignoring leap seconds this is equivalent to the ieee std 1003 1 2013 edition posix 1 definition seconds since the epoch in which each day is accounted for by exactly 86400 seconds other than that non integer values can be represented see rfc 3339 rfc3339 for details regarding date times in general and utc in particular this means that the exp field should contain the number of seconds since the epoch signing a token with 1 hour of expiration javascript jwt sign exp math floor date now 1000 60 60 data foobar secret another way to generate a token like this with this library is javascript jwt sign data foobar secret expiresin 60 60 or even better jwt sign data foobar secret expiresin 1h jwt verify token secretorpublickey options callback asynchronous if a callback is supplied function acts asynchronously the callback is called with the decoded payload if the signature is valid and optional expiration audience or issuer are valid if not it will be called with the error synchronous if a callback is not supplied function acts synchronously returns the payload decoded if the signature is valid and optional expiration audience or issuer are valid if not it will throw the error token is the jsonwebtoken string secretorpublickey is a string or buffer containing either the secret for hmac algorithms or the pem encoded public key for rsa and ecdsa if jwt verify is called asynchronous secretorpublickey can be a function that should fetch the secret or public key see below for a detailed example as mentioned in this comment there are other libraries that expect base64 encoded secrets random bytes encoded using base64 if that is your case you can pass buffer from secret base64 by doing this the secret will be decoded using base64 and the token verification will use the original random bytes options algorithms list of strings with the names of the allowed algorithms for instance hs256 hs384 audience if you want to check audience aud provide a value here the audience can be checked against a string a regular expression or a list of strings and or regular expressions eg urn foo urn f o 2 urn f o 2 urn bar issuer optional string or array of strings of valid values for the iss field ignoreexpiration if true do not validate the expiration of the token ignorenotbefore subject if you want to check subject sub provide a value here clocktolerance number of seconds to tolerate when checking the nbf and exp claims to deal with small clock differences among different servers maxage the maximum allowed age for tokens to still be valid it is expressed in seconds or a string describing a time span zeit ms eg 1000 2 days 10h 7d a numeric value is interpreted as a seconds count if you use a string be sure you provide the time units days hours etc otherwise milliseconds unit is used by default 120 is equal to 120ms clocktimestamp the time in seconds that should be used as the current time for all necessary comparisons js verify a token symmetric synchronous var decoded jwt verify token shhhhh console log decoded foo bar verify a token symmetric jwt verify token shhhhh function err decoded console log decoded foo bar invalid token synchronous try var decoded jwt verify token wrong secret catch err err invalid token jwt verify token wrong secret function err decoded err decoded undefined verify a token asymmetric var cert fs readfilesync public pem get public key jwt verify token cert function err decoded console log decoded foo bar verify audience var cert fs readfilesync public pem get public key jwt verify token cert audience urn foo function err decoded if audience mismatch err invalid audience verify issuer var cert fs readfilesync public pem get public key jwt verify token cert audience urn foo issuer urn issuer function err decoded if issuer mismatch err invalid issuer verify jwt id var cert fs readfilesync public pem get public key jwt verify token cert audience urn foo issuer urn issuer jwtid jwtid function err decoded if jwt id mismatch err invalid jwt id verify subject var cert fs readfilesync public pem get public key jwt verify token cert audience urn foo issuer urn issuer jwtid jwtid subject subject function err decoded if subject mismatch err invalid subject alg mismatch var cert fs readfilesync public pem get public key jwt verify token cert algorithms rs256 function err payload if token alg rs256 err invalid signature verify using getkey callback example uses https github com auth0 node jwks rsa as a way to fetch the keys var jwksclient require jwks rsa var client jwksclient jwksuri https sandrino auth0 com well known jwks json function getkey header callback client getsigningkey header kid function err key var signingkey key publickey key rsapublickey callback null signingkey jwt verify token getkey options function err decoded console log decoded foo bar jwt decode token options synchronous returns the decoded payload without verifying if the signature is valid warning this will not verify whether the signature is valid you should not use this for untrusted messages you most likely want to use jwt verify instead token is the jsonwebtoken string options json force json parse on the payload even if the header doesnt contain typ jwt complete return an object with the decoded payload and header example js get the decoded payload ignoring signature no secretorprivatekey needed var decoded jwt decode token get the decoded payload and header var decoded jwt decode token complete true console log decoded header console log decoded payload errors codes possible thrown errors during verification error is the first argument of the verification callback tokenexpirederror thrown error if the token is expired error object name tokenexpirederror message jwt expired expiredat expdate js jwt verify token shhhhh function err decoded if err err name tokenexpirederror message jwt expired expiredat 1408621000 jsonwebtokenerror error object name jsonwebtokenerror message jwt malformed jwt signature is required invalid signature jwt audience invalid expected options audience jwt issuer invalid expected options issuer jwt id invalid expected options jwt id jwt subject invalid expected options subject js jwt verify token shhhhh function err decoded if err err name jsonwebtokenerror message jwt malformed algorithms supported array of supported algorithms the following algorithms are currently supported alg parameter value digital signature or mac algorithm hs256 hmac using sha 256 hash algorithm hs384 hmac using sha 384 hash algorithm hs512 hmac using sha 512 hash algorithm rs256 rsassa using sha 256 hash algorithm rs384 rsassa using sha 384 hash algorithm rs512 rsassa using sha 512 hash algorithm es256 ecdsa using p 256 curve and sha 256 hash algorithm es384 ecdsa using p 384 curve and sha 384 hash algorithm es512 ecdsa using p 521 curve and sha 512 hash algorithm none no digital signature or mac value included refreshing jwts first of all we recommend to think carefully if auto refreshing a jwt will not introduce any vulnerability in your system we are not comfortable including this as part of the library however you can take a look to this example to show how this could be accomplished apart from that example there are an issue and a pull request to get more knowledge about this topic todo x 509 certificate chain is not checked issue reporting if you have found a bug or if you have a feature request please report them at this repository issues section please do not report security vulnerabilities on the public github issue tracker the responsible disclosure program details the procedure for disclosing security issues author auth0 license this project is licensed under the mit license see the license file for more info