the official raywenderlich com swift style guide updated for swift 3 this style guide is different from others you may see because the focus is centered on readability for print and the web we created this style guide to keep the code in our books tutorials and starter kits nice and consistent — even though we have many different authors working on the books our overarching goals are clarity consistency and brevity in that order table of contents correctness naming prose delegates use type inferred context generics class prefixes language code organization protocol conformance unused code minimal imports spacing comments classes and structures use of self protocol conformance computed properties final function declarations closure expressions types constants static methods and variable type properties optionals lazy initialization type inference syntactic sugar functions vs methods memory management extending lifetime access control control flow golden path failing guards semicolons parentheses organization and bundle identifier copyright statement smiley face references correctness strive to make your code compile without warnings this rule informs many style decisions such as using selector types instead of string literals naming descriptive and consistent naming makes software easier to read and understand use the swift naming conventions described in the api design guidelines some key takeaways include striving for clarity at the call site prioritizing clarity over brevity using camel case not snake case using uppercase for types and protocols lowercase for everything else including all needed words while omitting needless words using names based on roles not types sometimes compensating for weak type information striving for fluent usage beginning factory methods with make naming methods for their side effects verb methods follow the ed ing rule for the non mutating version noun methods follow the formx rule for the mutating version boolean types should read like assertions protocols that describe what something is should read as nouns protocols that describe a capability should end in able or ible using terms that dont surprise experts or confuse beginners generally avoiding abbreviations using precedent for names preferring methods and properties to free functions casing acronyms and initialisms uniformly up or down giving the same base name to methods that share the same meaning avoiding overloads on return type choosing good parameter names that serve as documentation labeling closure and tuple parameters taking advantage of default parameters prose when referring to methods in prose being unambiguous is critical to refer to a method name use the simplest form possible write the method name with no parameters example next you need to call the method addtarget write the method name with argument labels example next you need to call the method addtarget action write the full method name with argument labels and types example next you need to call the method addtarget any action selector for the above example using uigesturerecognizer 1 is unambiguous and preferred pro tip you can use xcodes jump bar to lookup methods with argument labels class prefixes swift types are automatically namespaced by the module that contains them and you should not add a class prefix such as rw if two names from different modules collide you can disambiguate by prefixing the type name with the module name however only specify the module name when there is possibility for confusion which should be rare swift import somemodule let myclass mymodule usefulclass delegates when creating custom delegate methods an unnamed first parameter should be the delegate source uikit contains numerous examples of this preferred swift func namepickerview namepickerview namepickerview didselectname name string func namepickerviewshouldreload namepickerview namepickerview bool not preferred swift func didselectname namepicker namepickerviewcontroller name string func namepickershouldreload bool use type inferred context use compiler inferred context to write shorter clear code also see type inference preferred swift let selector selector viewdidload view backgroundcolor red let toview context view forkey to let view uiview frame zero not preferred swift let selector selector viewcontroller viewdidload view backgroundcolor uicolor red let toview context view forkey uitransitioncontextviewkey to let view uiview frame cgrect zero generics generic type parameters should be descriptive upper camel case names when a type name doesnt have a meaningful relationship or role use a traditional single uppercase letter such as t u or v preferred swift struct stack element func write target outputstream to target inout target func swap t a inout t b inout t not preferred swift struct stack t func write target outputstream to target inout target func swap thing a inout thing b inout thing language use us english spelling to match apples api preferred swift let color red not preferred swift let colour red code organization use extensions to organize your code into logical blocks of functionality each extension should be set off with a mark comment to keep things well organized protocol conformance in particular when adding protocol conformance to a model prefer adding a separate extension for the protocol methods this keeps the related methods grouped together with the protocol and can simplify instructions to add a protocol to a class with its associated methods preferred swift class myviewcontroller uiviewcontroller class stuff here mark uitableviewdatasource extension myviewcontroller uitableviewdatasource table view data source methods mark uiscrollviewdelegate extension myviewcontroller uiscrollviewdelegate scroll view delegate methods not preferred swift class myviewcontroller uiviewcontroller uitableviewdatasource uiscrollviewdelegate all methods since the compiler does not allow you to re declare protocol conformance in a derived class it is not always required to replicate the extension groups of the base class this is especially true if the derived class is a terminal class and a small number of methods are being overridden when to preserve the extension groups is left to the discretion of the author for uikit view controllers consider grouping lifecycle custom accessors and ibaction in separate class extensions unused code unused dead code including xcode template code and placeholder comments should be removed an exception is when your tutorial or book instructs the user to use the commented code aspirational methods not directly associated with the tutorial whose implementation simply calls the superclass should also be removed this includes any empty unused uiapplicationdelegate methods preferred swift override func tableview tableview uitableview numberofrowsinsection section int int return database contacts count not preferred swift override func didreceivememorywarning super didreceivememorywarning dispose of any resources that can be recreated override func numberofsections in tableview uitableview int warning incomplete implementation return the number of sections return 1 override func tableview tableview uitableview numberofrowsinsection section int int warning incomplete implementation return the number of rows return database contacts count minimal imports keep imports minimal for example dont import uikit when importing foundation will suffice spacing indent using 2 spaces rather than tabs to conserve space and help prevent line wrapping be sure to set this preference in xcode and in the project settings as shown below method braces and other braces if else switch while etc always open on the same line as the statement but close on a new line tip you can re indent by selecting some code or ⌘a to select all and then control i or editor\structure\re indent in the menu some of the xcode template code will have 4 space tabs hard coded so this is a good way to fix that preferred swift if user ishappy do something else do something else not preferred swift if user ishappy do something else do something else there should be exactly one blank line between methods to aid in visual clarity and organization whitespace within methods should separate functionality but having too many sections in a method often means you should refactor into several methods colons always have no space on the left and one space on the right exceptions are the ternary operator empty dictionary and selector syntax for unnamed parameters preferred swift class testdatabase database var data string cgfloat a 1 2 b 3 2 not preferred swift class testdatabase database var data string cgfloat a 1 2 b 3 2 long lines should be wrapped at around 70 characters a hard limit is intentionally not specified avoid trailing whitespaces at the ends of lines add a single newline character at the end of each file comments when they are needed use comments to explain why a particular piece of code does something comments must be kept up to date or deleted avoid block comments inline with code as the code should be as self documenting as possible exception this does not apply to those comments used to generate documentation classes and structures which one to use remember structs have value semantics use structs for things that do not have an identity an array that contains a b c is really the same as another array that contains a b c and they are completely interchangeable it doesnt matter whether you use the first array or the second because they represent the exact same thing thats why arrays are structs classes have reference semantics use classes for things that do have an identity or a specific life cycle you would model a person as a class because two person objects are two different things just because two people have the same name and birthdate doesnt mean they are the same person but the persons birthdate would be a struct because a date of 3 march 1950 is the same as any other date object for 3 march 1950 the date itself doesnt have an identity sometimes things should be structs but need to conform to anyobject or are historically modeled as classes already nsdate nsset try to follow these guidelines as closely as possible example definition heres an example of a well styled class definition swift class circle shape var x int y int var radius double var diameter double get return radius 2 set radius newvalue 2 init x int y int radius double self x x self y y self radius radius convenience init x int y int diameter double self init x x y y radius diameter 2 override func area double return double pi radius radius extension circle customstringconvertible var description string return center centerstring area area private var centerstring string return x y the example above demonstrates the following style guidelines specify types for properties variables constants argument declarations and other statements with a space after the colon but not before e g x int and circle shape define multiple variables and structures on a single line if they share a common purpose context indent getter and setter definitions and property observers dont add modifiers such as internal when theyre already the default similarly dont repeat the access modifier when overriding a method organize extra functionality e g printing in extensions hide non shared implementation details such as centerstring inside the extension using private access control use of self for conciseness avoid using self since swift does not require it to access an objects properties or invoke its methods use self only when required by the compiler in escaping closures or in initializers to disambiguate properties from arguments in other words if it compiles without self then omit it computed properties for conciseness if a computed property is read only omit the get clause the get clause is required only when a set clause is provided preferred swift var diameter double return radius 2 not preferred swift var diameter double get return radius 2 final marking classes or members as final in tutorials can distract from the main topic and is not required nevertheless use of final can sometimes clarify your intent and is worth the cost in the below example box has a particular purpose and customization in a derived class is not intended marking it final makes that clear swift turn any generic type into a reference type using this box class final class box t let value t init value t self value value function declarations keep short function declarations on one line including the opening brace swift func reticulatesplines spline double bool reticulate code goes here for functions with long signatures add line breaks at appropriate points and add an extra indent on subsequent lines swift func reticulatesplines spline double adjustmentfactor double translateconstant int comment string bool reticulate code goes here closure expressions use trailing closure syntax only if theres a single closure expression parameter at the end of the argument list give the closure parameters descriptive names preferred swift uiview animate withduration 1 0 self myview alpha 0 uiview animate withduration 1 0 animations self myview alpha 0 completion finished in self myview removefromsuperview not preferred swift uiview animate withduration 1 0 animations self myview alpha 0 uiview animate withduration 1 0 animations self myview alpha 0 f in self myview removefromsuperview for single expression closures where the context is clear use implicit returns swift attendeelist sort a b in a b chained methods using trailing closures should be clear and easy to read in context decisions on spacing line breaks and when to use named versus anonymous arguments is left to the discretion of the author examples swift let value numbers map 0 2 filter 0 3 0 index of 90 let value numbers map 0 2 filter 0 50 map 0 10 types always use swifts native types when available swift offers bridging to objective c so you can still use the full set of methods as needed preferred swift let width 120 0 double let widthstring width as nsnumber stringvalue string not preferred swift let width nsnumber 120 0 nsnumber let widthstring nsstring width stringvalue nsstring in sprite kit code use cgfloat if it makes the code more succinct by avoiding too many conversions constants constants are defined using the let keyword and variables with the var keyword always use let instead of var if the value of the variable will not change tip a good technique is to define everything using let and only change it to var if the compiler complains you can define constants on a type rather than on an instance of that type using type properties to declare a type property as a constant simply use static let type properties declared in this way are generally preferred over global constants because they are easier to distinguish from instance properties example preferred swift enum math static let e 2 718281828459045235360287 static let root2 1 41421356237309504880168872 let hypotenuse side math root2 note the advantage of using a case less enumeration is that it cant accidentally be instantiated and works as a pure namespace not preferred swift let e 2 718281828459045235360287 pollutes global namespace let root2 1 41421356237309504880168872 let hypotenuse side root2 what is root2 static methods and variable type properties static methods and type properties work similarly to global functions and global variables and should be used sparingly they are useful when functionality is scoped to a particular type or when objective c interoperability is required optionals declare variables and function return types as optional with where a nil value is acceptable use implicitly unwrapped types declared with only for instance variables that you know will be initialized later before use such as subviews that will be set up in viewdidload when accessing an optional value use optional chaining if the value is only accessed once or if there are many optionals in the chain swift self textcontainer textlabel setneedsdisplay use optional binding when its more convenient to unwrap once and perform multiple operations swift if let textcontainer self textcontainer do many things with textcontainer when naming optional variables and properties avoid naming them like optionalstring or maybeview since their optional ness is already in the type declaration for optional binding shadow the original name when appropriate rather than using names like unwrappedview or actuallabel preferred swift var subview uiview var volume double later on if let subview subview let volume volume do something with unwrapped subview and volume not preferred swift var optionalsubview uiview var volume double if let unwrappedsubview optionalsubview if let realvolume volume do something with unwrappedsubview and realvolume lazy initialization consider using lazy initialization for finer grain control over object lifetime this is especially true for uiviewcontroller that loads views lazily you can either use a closure that is immediately called or call a private factory method example swift lazy var locationmanager cllocationmanager self makelocationmanager private func makelocationmanager cllocationmanager let manager cllocationmanager manager desiredaccuracy kcllocationaccuracybest manager delegate self manager requestalwaysauthorization return manager notes unowned self is not required here a retain cycle is not created location manager has a side effect for popping up ui to ask the user for permission so fine grain control makes sense here type inference prefer compact code and let the compiler infer the type for constants or variables of single instances type inference is also appropriate for small non empty arrays and dictionaries when required specify the specific type such as cgfloat or int16 preferred swift let message click the button let currentbounds computeviewbounds var names mic sam christine let maximumwidth cgfloat 106 5 not preferred swift let message string click the button let currentbounds cgrect computeviewbounds let names string type annotation for empty arrays and dictionaries for empty arrays and dictionaries use type annotation for an array or dictionary assigned to a large multi line literal use type annotation preferred swift var names string var lookup string int not preferred swift var names string var lookup string int note following this guideline means picking descriptive names is even more important than before syntactic sugar prefer the shortcut versions of type declarations over the full generics syntax preferred swift var devicemodels string var employees int string var faxnumber int not preferred swift var devicemodels array string var employees dictionary int string var faxnumber optional int functions vs methods free functions which arent attached to a class or type should be used sparingly when possible prefer to use a method instead of a free function this aids in readability and discoverability free functions are most appropriate when they arent associated with any particular type or instance preferred swift let sorted items mergesorted easily discoverable rocket launch acts on the model not preferred swift let sorted mergesort items hard to discover launch rocket free function exceptions swift let tuples zip a b feels natural as a free function symmetry let value max x y z another free function that feels natural memory management code even non production tutorial demo code should not create reference cycles analyze your object graph and prevent strong cycles with weak and unowned references alternatively use value types struct enum to prevent cycles altogether extending object lifetime extend object lifetime using the weak self and guard let strongself self else return idiom weak self is preferred to unowned self where it is not immediately obvious that self outlives the closure explicitly extending lifetime is preferred to optional unwrapping preferred swift resource request oncomplete weak self response in guard let strongself self else return let model strongself updatemodel response strongself updateui model not preferred swift might crash if self is released before response returns resource request oncomplete unowned self response in let model self updatemodel response self updateui model not preferred swift deallocate could happen between updating the model and updating ui resource request oncomplete weak self response in let model self updatemodel response self updateui model access control full access control annotation in tutorials can distract from the main topic and is not required using private and fileprivate appropriately however adds clarity and promotes encapsulation prefer private to fileprivate when possible using extensions may require you to use fileprivate only explicitly use open public and internal when you require a full access control specification use access control as the leading property specifier the only things that should come before access control are the static specifier or attributes such as ibaction iboutlet and discardableresult preferred swift private let message great scott class timemachine fileprivate dynamic lazy var fluxcapacitor fluxcapacitor not preferred swift fileprivate let message great scott class timemachine lazy dynamic fileprivate var fluxcapacitor fluxcapacitor control flow prefer the for in style of for loop over the while condition increment style preferred swift for in 0 3 print hello three times for index person in attendeelist enumerated print person is at position index for index in stride from 0 to items count by 2 print index for index in 0 3 reversed print index not preferred swift var i 0 while i 3 print hello three times i 1 var i 0 while i attendeelist count let person attendeelist i print person is at position i i 1 golden path when coding with conditionals the left hand margin of the code should be the golden or happy path that is dont nest if statements multiple return statements are ok the guard statement is built for this preferred swift func computefft context context inputdata inputdata throws frequencies guard let context context else throw ffterror nocontext guard let inputdata inputdata else throw ffterror noinputdata use context and input to compute the frequencies return frequencies not preferred swift func computefft context context inputdata inputdata throws frequencies if let context context if let inputdata inputdata use context and input to compute the frequencies return frequencies else throw ffterror noinputdata else throw ffterror nocontext when multiple optionals are unwrapped either with guard or if let minimize nesting by using the compound version when possible example preferred swift guard let number1 number1 let number2 number2 let number3 number3 else fatalerror impossible do something with numbers not preferred swift if let number1 number1 if let number2 number2 if let number3 number3 do something with numbers else fatalerror impossible else fatalerror impossible else fatalerror impossible failing guards guard statements are required to exit in some way generally this should be simple one line statement such as return throw break continue and fatalerror large code blocks should be avoided if cleanup code is required for multiple exit points consider using a defer block to avoid cleanup code duplication semicolons swift does not require a semicolon after each statement in your code they are only required if you wish to combine multiple statements on a single line do not write multiple statements on a single line separated with semicolons preferred swift let swift not a scripting language not preferred swift let swift not a scripting language note swift is very different from javascript where omitting semicolons is generally considered unsafe parentheses parentheses around conditionals are not required and should be omitted preferred swift if name hello print world not preferred swift if name hello print world in larger expressions optional parentheses can sometimes make code read more clearly preferred swift let playermark player current x o organization and bundle identifier where an xcode project is involved the organization should be set to ray wenderlich and the bundle identifier set to com razeware tutorialname where tutorialname is the name of the tutorial project copyright statement the following copyright statement should be included at the top of every source file swift copyright c 2018 razeware llc permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the software to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software notwithstanding the foregoing you may not use copy modify merge publish distribute sublicense create a derivative work and or sell copies of the software in any work that is designed intended or marketed for pedagogical or instructional purposes related to programming coding application development or information technology permission for such use copying modification merger publication distribution sublicensing creation of derivative works or sale is expressly withheld the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall the authors or copyright holders be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software smiley face smiley faces are a very prominent style feature of the raywenderlich com site it is very important to have the correct smile signifying the immense amount of happiness and excitement for the coding topic the closing square bracket is used because it represents the largest smile able to be captured using ascii art a closing parenthesis creates a half hearted smile and thus is not preferred preferred not preferred references the swift api design guidelines the swift programming language using swift with cocoa and objective c swift standard library reference