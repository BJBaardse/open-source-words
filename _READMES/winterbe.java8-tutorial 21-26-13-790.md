modern java a guide to java 8 this article was originally posted on my blog “java is still not dead—and people are starting to figure that out ” welcome to my introduction to java 8 this tutorial guides you step by step through all new language features backed by short and simple code samples youll learn how to use default interface methods lambda expressions method references and repeatable annotations at the end of the article youll be familiar with the most recent api changes like streams functional interfaces map extensions and the new date api no walls of text just a bunch of commented code snippets enjoy ★★★ like this project leave a star follow on twitter or donate to support my work thanks ★★★ table of contents default methods for interfaces lambda expressions functional interfaces method and constructor references lambda scopes accessing local variables accessing fields and static variables accessing default interface methods built in functional interfaces predicates functions suppliers consumers comparators optionals streams filter sorted map match count reduce parallel streams sequential sort parallel sort maps date api clock timezones localtime localdate localdatetime annotations where to go from here default methods for interfaces java 8 enables us to add non abstract method implementations to interfaces by utilizing the default keyword this feature is also known as virtual extension methods here is our first example java interface formula double calculate int a default double sqrt int a return math sqrt a besides the abstract method calculate the interface formula also defines the default method sqrt concrete classes only have to implement the abstract method calculate the default method sqrt can be used out of the box java formula formula new formula override public double calculate int a return sqrt a 100 formula calculate 100 100 0 formula sqrt 16 4 0 the formula is implemented as an anonymous object the code is quite verbose 6 lines of code for such a simple calculation of sqrt a 100 as well see in the next section theres a much nicer way of implementing single method objects in java 8 lambda expressions lets start with a simple example of how to sort a list of strings in prior versions of java java list names arrays aslist peter anna mike xenia collections sort names new comparator override public int compare string a string b return b compareto a the static utility method collections sort accepts a list and a comparator in order to sort the elements of the given list you often find yourself creating anonymous comparators and pass them to the sort method instead of creating anonymous objects all day long java 8 comes with a much shorter syntax lambda expressions java collections sort names string a string b return b compareto a as you can see the code is much shorter and easier to read but it gets even shorter java collections sort names string a string b b compareto a for one line method bodies you can skip both the braces and the return keyword but it gets even shorter java names sort a b b compareto a list now has a sort method also the java compiler is aware of the parameter types so you can skip them as well lets dive deeper into how lambda expressions can be used in the wild functional interfaces how does lambda expressions fit into javas type system each lambda corresponds to a given type specified by an interface a so called functional interface must contain exactly one abstract method declaration each lambda expression of that type will be matched to this abstract method since default methods are not abstract youre free to add default methods to your functional interface we can use arbitrary interfaces as lambda expressions as long as the interface only contains one abstract method to ensure that your interface meet the requirements you should add the functionalinterface annotation the compiler is aware of this annotation and throws a compiler error as soon as you try to add a second abstract method declaration to the interface example java functionalinterface interface converter f t t convert f from java converter string integer converter from integer valueof from integer converted converter convert 123 system out println converted 123 keep in mind that the code is also valid if the functionalinterface annotation would be omitted method and constructor references the above example code can be further simplified by utilizing static method references java converter string integer converter integer valueof integer converted converter convert 123 system out println converted 123 java 8 enables you to pass references of methods or constructors via the keyword the above example shows how to reference a static method but we can also reference object methods java class something string startswith string s return string valueof s charat 0 java something something new something converter string string converter something startswith string converted converter convert java system out println converted j lets see how the keyword works for constructors first we define an example class with different constructors java class person string firstname string lastname person person string firstname string lastname this firstname firstname this lastname lastname next we specify a person factory interface to be used for creating new persons java interface personfactory p extends person p create string firstname string lastname instead of implementing the factory manually we glue everything together via constructor references java personfactory person personfactory person new person person personfactory create peter parker we create a reference to the person constructor via person new the java compiler automatically chooses the right constructor by matching the signature of personfactory create lambda scopes accessing outer scope variables from lambda expressions is very similar to anonymous objects you can access final variables from the local outer scope as well as instance fields and static variables accessing local variables we can read final local variables from the outer scope of lambda expressions java final int num 1 converter stringconverter from string valueof from num stringconverter convert 2 3 but different to anonymous objects the variable num does not have to be declared final this code is also valid java int num 1 converter stringconverter from string valueof from num stringconverter convert 2 3 however num must be implicitly final for the code to compile the following code does not compile java int num 1 converter integer string stringconverter from string valueof from num num 3 writing to num from within the lambda expression is also prohibited accessing fields and static variables in contrast to local variables we have both read and write access to instance fields and static variables from within lambda expressions this behaviour is well known from anonymous objects java class lambda4 static int outerstaticnum int outernum void testscopes converter integer string stringconverter1 from outernum 23 return string valueof from converter integer string stringconverter2 from outerstaticnum 72 return string valueof from accessing default interface methods remember the formula example from the first section interface formula defines a default method sqrt which can be accessed from each formula instance including anonymous objects this does not work with lambda expressions default methods cannot be accessed from within lambda expressions the following code does not compile java formula formula a sqrt a 100 built in functional interfaces the jdk 1 8 api contains many built in functional interfaces some of them are well known from older versions of java like comparator or runnable those existing interfaces are extended to enable lambda support via the functionalinterface annotation but the java 8 api is also full of new functional interfaces to make your life easier some of those new interfaces are well known from the google guava library even if youre familiar with this library you should keep a close eye on how those interfaces are extended by some useful method extensions predicates predicates are boolean valued functions of one argument the interface contains various default methods for composing predicates to complex logical terms and or negate java predicate predicate s s length 0 predicate test foo true predicate negate test foo false predicate nonnull objects nonnull predicate isnull objects isnull predicate isempty string isempty predicate isnotempty isempty negate functions functions accept one argument and produce a result default methods can be used to chain multiple functions together compose andthen java function tointeger integer valueof function backtostring tointeger andthen string valueof backtostring apply 123 123 suppliers suppliers produce a result of a given generic type unlike functions suppliers dont accept arguments java supplier person personsupplier person new personsupplier get new person consumers consumers represent operations to be performed on a single input argument java consumer person greeter p system out println hello p firstname greeter accept new person luke skywalker comparators comparators are well known from older versions of java java 8 adds various default methods to the interface java comparator comparator p1 p2 p1 firstname compareto p2 firstname person p1 new person john doe person p2 new person alice wonderland comparator compare p1 p2 0 comparator reversed compare p1 p2 0 optionals optionals are not functional interfaces but nifty utilities to prevent nullpointerexception its an important concept for the next section so lets have a quick look at how optionals work optional is a simple container for a value which may be null or non null think of a method which may return a non null result but sometimes return nothing instead of returning null you return an optional in java 8 java optional optional optional of bam optional ispresent true optional get bam optional orelse fallback bam optional ifpresent s system out println s charat 0 b streams a java util stream represents a sequence of elements on which one or more operations can be performed stream operations are either intermediate or terminal while terminal operations return a result of a certain type intermediate operations return the stream itself so you can chain multiple method calls in a row streams are created on a source e g a java util collection like lists or sets maps are not supported stream operations can either be executed sequentially or parallely streams are extremely powerful so i wrote a separate java 8 streams tutorial you should also check out sequency as a similiar library for the web lets first look how sequential streams work first we create a sample source in form of a list of strings java list string stringcollection new arraylist stringcollection add ddd2 stringcollection add aaa2 stringcollection add bbb1 stringcollection add aaa1 stringcollection add bbb3 stringcollection add ccc stringcollection add bbb2 stringcollection add ddd1 collections in java 8 are extended so you can simply create streams either by calling collection stream or collection parallelstream the following sections explain the most common stream operations filter filter accepts a predicate to filter all elements of the stream this operation is intermediate which enables us to call another stream operation foreach on the result foreach accepts a consumer to be executed for each element in the filtered stream foreach is a terminal operation its void so we cannot call another stream operation java stringcollection stream filter s s startswith a foreach system out println aaa2 aaa1 sorted sorted is an intermediate operation which returns a sorted view of the stream the elements are sorted in natural order unless you pass a custom comparator java stringcollection stream sorted filter s s startswith a foreach system out println aaa1 aaa2 keep in mind that sorted does only create a sorted view of the stream without manipulating the ordering of the backed collection the ordering of stringcollection is untouched java system out println stringcollection ddd2 aaa2 bbb1 aaa1 bbb3 ccc bbb2 ddd1 map the intermediate operation map converts each element into another object via the given function the following example converts each string into an upper cased string but you can also use map to transform each object into another type the generic type of the resulting stream depends on the generic type of the function you pass to map java stringcollection stream map string touppercase sorted a b b compareto a foreach system out println ddd2 ddd1 ccc bbb3 bbb2 aaa2 aaa1 match various matching operations can be used to check whether a certain predicate matches the stream all of those operations are terminal and return a boolean result java boolean anystartswitha stringcollection stream anymatch s s startswith a system out println anystartswitha true boolean allstartswitha stringcollection stream allmatch s s startswith a system out println allstartswitha false boolean nonestartswithz stringcollection stream nonematch s s startswith z system out println nonestartswithz true count count is a terminal operation returning the number of elements in the stream as a long java long startswithb stringcollection stream filter s s startswith b count system out println startswithb 3 reduce this terminal operation performs a reduction on the elements of the stream with the given function the result is an optional holding the reduced value java optional reduced stringcollection stream sorted reduce s1 s2 s1 s2 reduced ifpresent system out println aaa1 aaa2 bbb1 bbb2 bbb3 ccc ddd1 ddd2 parallel streams as mentioned above streams can be either sequential or parallel operations on sequential streams are performed on a single thread while operations on parallel streams are performed concurrently on multiple threads the following example demonstrates how easy it is to increase the performance by using parallel streams first we create a large list of unique elements java int max 1000000 list string values new arraylist max for int i 0 i max i uuid uuid uuid randomuuid values add uuid tostring now we measure the time it takes to sort a stream of this collection sequential sort java long t0 system nanotime long count values stream sorted count system out println count long t1 system nanotime long millis timeunit nanoseconds tomillis t1 t0 system out println string format sequential sort took d ms millis sequential sort took 899 ms parallel sort java long t0 system nanotime long count values parallelstream sorted count system out println count long t1 system nanotime long millis timeunit nanoseconds tomillis t1 t0 system out println string format parallel sort took d ms millis parallel sort took 472 ms as you can see both code snippets are almost identical but the parallel sort is roughly 50 faster all you have to do is change stream to parallelstream maps as already mentioned maps do not directly support streams theres no stream method available on the map interface itself however you can create specialized streams upon the keys values or entries of a map via map keyset stream map values stream and map entryset stream furthermore maps support various new and useful methods for doing common tasks java map map new hashmap for int i 0 i 10 i map putifabsent i val i map foreach id val system out println val the above code should be self explaining putifabsent prevents us from writing additional if null checks foreach accepts a consumer to perform operations for each value of the map this example shows how to compute code on the map by utilizing functions java map computeifpresent 3 num val val num map get 3 val33 map computeifpresent 9 num val null map containskey 9 false map computeifabsent 23 num val num map containskey 23 true map computeifabsent 3 num bam map get 3 val33 next we learn how to remove entries for a given key only if its currently mapped to a given value java map remove 3 val3 map get 3 val33 map remove 3 val33 map get 3 null another helpful method java map getordefault 42 not found not found merging entries of a map is quite easy java map merge 9 val9 value newvalue value concat newvalue map get 9 val9 map merge 9 concat value newvalue value concat newvalue map get 9 val9concat merge either put the key value into the map if no entry for the key exists or the merging function will be called to change the existing value date api java 8 contains a brand new date and time api under the package java time the new date api is comparable with the joda time library however its not the same the following examples cover the most important parts of this new api clock clock provides access to the current date and time clocks are aware of a timezone and may be used instead of system currenttimemillis to retrieve the current time in milliseconds since unix epoch such an instantaneous point on the time line is also represented by the class instant instants can be used to create legacy java util date objects java clock clock clock systemdefaultzone long millis clock millis instant instant clock instant date legacydate date from instant legacy java util date timezones timezones are represented by a zoneid they can easily be accessed via static factory methods timezones define the offsets which are important to convert between instants and local dates and times java system out println zoneid getavailablezoneids prints all available timezone ids zoneid zone1 zoneid of europe berlin zoneid zone2 zoneid of brazil east system out println zone1 getrules system out println zone2 getrules zonerules currentstandardoffset 01 00 zonerules currentstandardoffset 03 00 localtime localtime represents a time without a timezone e g 10pm or 17 30 15 the following example creates two local times for the timezones defined above then we compare both times and calculate the difference in hours and minutes between both times java localtime now1 localtime now zone1 localtime now2 localtime now zone2 system out println now1 isbefore now2 false long hoursbetween chronounit hours between now1 now2 long minutesbetween chronounit minutes between now1 now2 system out println hoursbetween 3 system out println minutesbetween 239 localtime comes with various factory methods to simplify the creation of new instances including parsing of time strings java localtime late localtime of 23 59 59 system out println late 23 59 59 datetimeformatter germanformatter datetimeformatter oflocalizedtime formatstyle short withlocale locale german localtime leettime localtime parse 13 37 germanformatter system out println leettime 13 37 localdate localdate represents a distinct date e g 2014 03 11 its immutable and works exactly analog to localtime the sample demonstrates how to calculate new dates by adding or subtracting days months or years keep in mind that each manipulation returns a new instance java localdate today localdate now localdate tomorrow today plus 1 chronounit days localdate yesterday tomorrow minusdays 2 localdate independenceday localdate of 2014 month july 4 dayofweek dayofweek independenceday getdayofweek system out println dayofweek friday parsing a localdate from a string is just as simple as parsing a localtime java datetimeformatter germanformatter datetimeformatter oflocalizeddate formatstyle medium withlocale locale german localdate xmas localdate parse 24 12 2014 germanformatter system out println xmas 2014 12 24 localdatetime localdatetime represents a date time it combines date and time as seen in the above sections into one instance localdatetime is immutable and works similar to localtime and localdate we can utilize methods for retrieving certain fields from a date time java localdatetime sylvester localdatetime of 2014 month december 31 23 59 59 dayofweek dayofweek sylvester getdayofweek system out println dayofweek wednesday month month sylvester getmonth system out println month december long minuteofday sylvester getlong chronofield minute of day system out println minuteofday 1439 with the additional information of a timezone it can be converted to an instant instants can easily be converted to legacy dates of type java util date java instant instant sylvester atzone zoneid systemdefault toinstant date legacydate date from instant system out println legacydate wed dec 31 23 59 59 cet 2014 formatting date times works just like formatting dates or times instead of using pre defined formats we can create formatters from custom patterns java datetimeformatter formatter datetimeformatter ofpattern mmm dd yyyy hh mm localdatetime parsed localdatetime parse nov 03 2014 07 13 formatter string string formatter format parsed system out println string nov 03 2014 07 13 unlike java text numberformat the new datetimeformatter is immutable and thread safe for details on the pattern syntax read here annotations annotations in java 8 are repeatable lets dive directly into an example to figure that out first we define a wrapper annotation which holds an array of the actual annotations java interface hints hint value repeatable hints class interface hint string value java 8 enables us to use multiple annotations of the same type by declaring the annotation repeatable variant 1 using the container annotation old school java hints hint hint1 hint hint2 class person variant 2 using repeatable annotations new school java hint hint1 hint hint2 class person using variant 2 the java compiler implicitly sets up the hints annotation under the hood thats important for reading annotation information via reflection java hint hint person class getannotation hint class system out println hint null hints hints1 person class getannotation hints class system out println hints1 value length 2 hint hints2 person class getannotationsbytype hint class system out println hints2 length 2 although we never declared the hints annotation on the person class its still readable via getannotation hints class however the more convenient method is getannotationsbytype which grants direct access to all annotated hint annotations furthermore the usage of annotations in java 8 is expanded to two new targets java target elementtype type parameter elementtype type use interface myannotation where to go from here my programming guide to java 8 ends here if you want to learn more about all the new classes and features of the jdk 8 api check out my jdk8 api explorer it helps you figuring out all the new classes and hidden gems of jdk 8 like arrays parallelsort stampedlock and completablefuture just to name a few ive also published a bunch of follow up articles on my blog that might be interesting to you java 8 stream tutorial java 8 nashorn tutorial java 8 concurrency tutorial threads and executors java 8 concurrency tutorial synchronization and locks java 8 concurrency tutorial atomic variables and concurrentmap java 8 api by example strings numbers math and files avoid null checks in java 8 fixing java 8 stream gotchas with intellij idea using backbone js with java 8 nashorn you should follow me on twitter thanks for reading