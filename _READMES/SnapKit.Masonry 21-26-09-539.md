masonry masonry is still actively maintained we are committed to fixing bugs and merging good quality prs from the wider community however if youre using swift in your project we recommend using snapkit as it provides better type safety with a simpler api masonry is a light weight layout framework which wraps autolayout with a nicer syntax masonry has its own layout dsl which provides a chainable way of describing your nslayoutconstraints which results in layout code that is more concise and readable masonry supports ios and mac os x for examples take a look at the masonry ios examples project in the masonry workspace you will need to run pod install after downloading whats wrong with nslayoutconstraints under the hood auto layout is a powerful and flexible way of organising and laying out your views however creating constraints from code is verbose and not very descriptive imagine a simple example in which you want to have a view fill its superview but inset by 10 pixels on every side obj c uiview superview self view uiview view1 uiview alloc init view1 translatesautoresizingmaskintoconstraints no view1 backgroundcolor uicolor greencolor superview addsubview view1 uiedgeinsets padding uiedgeinsetsmake 10 10 10 10 superview addconstraints view1 constraints nslayoutconstraint constraintwithitem view1 attribute nslayoutattributetop relatedby nslayoutrelationequal toitem superview attribute nslayoutattributetop multiplier 1 0 constant padding top nslayoutconstraint constraintwithitem view1 attribute nslayoutattributeleft relatedby nslayoutrelationequal toitem superview attribute nslayoutattributeleft multiplier 1 0 constant padding left nslayoutconstraint constraintwithitem view1 attribute nslayoutattributebottom relatedby nslayoutrelationequal toitem superview attribute nslayoutattributebottom multiplier 1 0 constant padding bottom nslayoutconstraint constraintwithitem view1 attribute nslayoutattributeright relatedby nslayoutrelationequal toitem superview attribute nslayoutattributeright multiplier 1 constant padding right even with such a simple example the code needed is quite verbose and quickly becomes unreadable when you have more than 2 or 3 views another option is to use visual format language vfl which is a bit less long winded however the ascii type syntax has its own pitfalls and its also a bit harder to animate asnslayoutconstraint constraintswithvisualformat returns an array prepare to meet your maker heres the same constraints created using masconstraintmaker obj c uiedgeinsets padding uiedgeinsetsmake 10 10 10 10 view1 mas makeconstraints masconstraintmaker make make top equalto superview mas top with offset padding top with is an optional semantic filler make left equalto superview mas left with offset padding left make bottom equalto superview mas bottom with offset padding bottom make right equalto superview mas right with offset padding right or even shorter obj c view1 mas makeconstraints masconstraintmaker make make edges equalto superview with insets padding also note in the first example we had to add the constraints to the superview superview addconstraints masonry however will automagically add constraints to the appropriate view masonry will also call view1 translatesautoresizingmaskintoconstraints no for you not all things are created equal equalto equivalent to nslayoutrelationequal lessthanorequalto equivalent to nslayoutrelationlessthanorequal greaterthanorequalto equivalent to nslayoutrelationgreaterthanorequal these three equality constraints accept one argument which can be any of the following 1 masviewattribute obj c make centerx lessthanorequalto view2 mas left masviewattribute nslayoutattribute view mas left nslayoutattributeleft view mas right nslayoutattributeright view mas top nslayoutattributetop view mas bottom nslayoutattributebottom view mas leading nslayoutattributeleading view mas trailing nslayoutattributetrailing view mas width nslayoutattributewidth view mas height nslayoutattributeheight view mas centerx nslayoutattributecenterx view mas centery nslayoutattributecentery view mas baseline nslayoutattributebaseline 2 uiview nsview if you want view left to be greater than or equal to label left obj c these two constraints are exactly the same make left greaterthanorequalto label make left greaterthanorequalto label mas left 3 nsnumber auto layout allows width and height to be set to constant values if you want to set view to have a minimum and maximum width you could pass a number to the equality blocks obj c width 200 width 400 make width greaterthanorequalto 200 make width lessthanorequalto 400 however auto layout does not allow alignment attributes such as left right centery etc to be set to constant values so if you pass a nsnumber for these attributes masonry will turn these into constraints relative to the viewâ€™s superview ie obj c creates view left view superview left 10 make left lessthanorequalto 10 instead of using nsnumber you can use primitives and structs to build your constraints like so obj c make top mas equalto 42 make height mas equalto 20 make size mas equalto cgsizemake 50 100 make edges mas equalto uiedgeinsetsmake 10 0 10 0 make left mas equalto view mas offset uiedgeinsetsmake 10 0 10 0 by default macros which support autoboxing are prefixed with mas unprefixed versions are available by defining mas shorthand globals before importing masonry 4 nsarray an array of a mixture of any of the previous types obj c make height equalto view1 mas height view2 mas height make height equalto view1 view2 make left equalto view1 100 view3 right learn to prioritize priority allows you to specify an exact priority priorityhigh equivalent to uilayoutprioritydefaulthigh prioritymedium is half way between high and low prioritylow equivalent to uilayoutprioritydefaultlow priorities are can be tacked on to the end of a constraint chain like so obj c make left greaterthanorequalto label mas left with prioritylow make top equalto label mas top with priority 600 composition composition composition masonry also gives you a few convenience methods which create multiple constraints at the same time these are called mascompositeconstraints edges obj c make top left bottom right equal view2 make edges equalto view2 make top superview top 5 left superview left 10 bottom superview bottom 15 right superview right 20 make edges equalto superview insets uiedgeinsetsmake 5 10 15 20 size obj c make width and height greater than or equal to titlelabel make size greaterthanorequalto titlelabel make width superview width 100 height superview height 50 make size equalto superview sizeoffset cgsizemake 100 50 center obj c make centerx and centery button1 make center equalto button1 make centerx superview centerx 5 centery superview centery 10 make center equalto superview centeroffset cgpointmake 5 10 you can chain view attributes for increased readability obj c all edges but the top should equal those of the superview make left right and bottom equalto superview make top equalto otherview hold on for dear life sometimes you need modify existing constraints in order to animate or remove replace constraints in masonry there are a few different approaches to updating constraints 1 references you can hold on to a reference of a particular constraint by assigning the result of a constraint make expression to a local variable or a class property you could also reference multiple constraints by storing them away in an array obj c in public private interface property nonatomic strong masconstraint topconstraint when making constraints view1 mas makeconstraints masconstraintmaker make self topconstraint make top equalto superview mas top with offset padding top make left equalto superview mas left with offset padding left then later you can call self topconstraint uninstall 2 mas updateconstraints alternatively if you are only updating the constant value of the constraint you can use the convience method mas updateconstraints instead of mas makeconstraints obj c this is apples recommended place for adding updating constraints this method can get called multiple times in response to setneedsupdateconstraints which can be called by uikit internally or in your code if you need to trigger an update to your constraints void updateconstraints self growingbutton mas updateconstraints masconstraintmaker make make center equalto self make width equalto self buttonsize width prioritylow make height equalto self buttonsize height prioritylow make width lessthanorequalto self make height lessthanorequalto self according to apple super should be called at end of method super updateconstraints 3 mas remakeconstraints mas updateconstraints is useful for updating a set of constraints but doing anything beyond updating constant values can get exhausting thats where mas remakeconstraints comes in mas remakeconstraints is similar to mas updateconstraints but instead of updating constant values it will remove all of its constraints before installing them again this lets you provide different constraints without having to keep around references to ones which you want to remove obj c void changebuttonposition self button mas remakeconstraints masconstraintmaker make make size equalto self buttonsize if topleft make top and left offset 10 else make bottom and right offset 10 you can find more detailed examples of all three approaches in the masonry ios examples project when the hits the fan laying out your views doesnt always goto plan so when things literally go pear shaped you dont want to be looking at console output like this obj c unable to simultaneously satisfy constraints blah blah blah 5000 will attempt to recover by breaking constraint 5000 masonry adds a category to nslayoutconstraint which overrides the default implementation of nsstring description now you can give meaningful names to views and constraints and also easily pick out the constraints created by masonry which means your console output can now look like this obj c unable to simultaneously satisfy constraints blah blah blah 5000 will attempt to recover by breaking constraint 5000 for an example of how to set this up take a look at the masonry ios examples project in the masonry workspace where should i create my constraints objc implementation diycustomview id init self super init if self return nil create your views here self button uibutton alloc init return self tell uikit that you are using autolayout bool requiresconstraintbasedlayout return yes this is apples recommended place for adding updating constraints void updateconstraints remake update constraints here self button remakeconstraints masconstraintmaker make make width equalto self buttonsize width make height equalto self buttonsize height according to apple super should be called at end of method super updateconstraints void didtapbutton uibutton button do your changes ie change variables that affect your layout etc self buttonsize cgsize 200 200 tell constraints they need updating self setneedsupdateconstraints end installation use the orsome cocoapods in your podfile pod masonry if you want to use masonry without all those pesky mas prefixes add define mas shorthand to your prefix pch before importing masonry define mas shorthand get busy masoning import masonry h code snippets copy the included code snippets to library developer xcode userdata codesnippets to write your masonry blocks at lightning speed mas make view mas makeconstraints masconstraintmaker make code mas update view mas updateconstraints masconstraintmaker make code mas remake view mas remakeconstraints masconstraintmaker make code features not limited to subset of auto layout anything nslayoutconstraint can do masonry can do too great debug support give your views and constraints meaningful names constraints read like sentences no crazy macro magic masonry wont pollute the global namespace with macros not string or dictionary based and hence you get compile time checking todo eye candy mac example project more tests and examples