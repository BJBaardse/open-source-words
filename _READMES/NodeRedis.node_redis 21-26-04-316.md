redis a node js redis client this is a complete and feature rich redis client for node js it supports all redis commands and focuses on high performance install with npm install redis usage example js var redis require redis client redis createclient if youd like to select database 3 instead of 0 default call client select 3 function client on error function err console log error err client set string key string val redis print client hset hash key hashtest 1 some value redis print client hset hash key hashtest 2 some other value redis print client hkeys hash key function err replies console log replies length replies replies foreach function reply i console log i reply client quit this will display mjr work node redis master node example js reply ok reply 0 reply 0 2 replies 0 hashtest 1 1 hashtest 2 mjr work node redis master note that the api is entirely asynchronous to get data back from the server youll need to use a callback from v 2 6 on the api supports camelcase and snake case and all options variables events etc can be used either way it is recommended to use camelcase as this is the default for the node js landscape promises native promises if you are using node v8 or higher you can promisify node redis with util promisify as in js const promisify require util const getasync promisify client get bind client now getasync is a promisified version of client get js we expect a value foo bar to be present so instead of writing client get foo cb you have to write return getasync foo then function res console log res bar or using async await js async myfunc const res await getasync foo console log res bluebird promises you can also use node redis with promises by promisifying node redis with bluebird as in js const redis require redis bluebird promisifyall redis itll add a async to all node redis functions e g return client getasync then js we expect a value foo bar to be present so instead of writing client get foo cb you have to write return client getasync foo then function res console log res bar using multi with promises looks like return client multi get foo execasync then function res console log res bar sending commands each redis command is exposed as a function on the client object all functions take either an args array plus optional callback function or a variable number of individual arguments followed by an optional callback examples js client hmset key test keys 1 test val 1 test keys 2 test val 2 function err res works the same as client hmset key test keys 1 test val 1 test keys 2 test val 2 function err res or client hmset key test keys 1 test val 1 test keys 2 test val 2 function err res care should be taken with user input if arrays are possible via body parser query string or other method as single arguments could be unintentionally interpreted as multiple args note that in either form the callback is optional js client set some key some val client set some other key some val if the key is missing reply will be null only if the redis command reference states something else it will not be null js client get missingkey function err reply reply is null when the key is missing console log reply for a list of redis commands see redis command reference minimal parsing is done on the replies commands that return a integer return javascript numbers arrays return javascript array hgetall returns an object keyed by the hash keys all strings will either be returned as string or as buffer depending on your setting please be aware that sending null undefined and boolean values will result in the value coerced to a string redis commands this library is a 1 to 1 mapping to redis commands it is not a cache library so please refer to redis commands page for full usage details example setting key to auto expire using set command js this key will expire after 10 seconds client set key value ex 10 api connection and other events client will emit some events about the state of the connection to the redis server ready client will emit ready once a connection is established commands issued before the ready event are queued then replayed just before this event is emitted connect client will emit connect as soon as the stream is connected to the server reconnecting client will emit reconnecting when trying to reconnect to the redis server after losing the connection listeners are passed an object containing delay in ms from the previous try and attempt the attempt attributes error client will emit error when encountering an error connecting to the redis server or when any other in node redis occurs if you use a command without callback and encounter a replyerror it is going to be emitted to the error listener so please attach the error listener to node redis end client will emit end when an established redis server connection has closed drain deprecated client will emit drain when the tcp connection to the redis server has been buffering but is now writable this event can be used to stream commands in to redis and adapt to backpressure if the stream is buffering client should buffer is set to true otherwise the variable is always set to false that way you can decide when to reduce your send rate and resume sending commands when you get drain you can also check the return value of each command as it will also return the backpressure indicator deprecated if false is returned the stream had to buffer warning client will emit warning when password was set but none is needed and if a deprecated option function similar is used idle deprecated client will emit idle when there are no outstanding commands that are awaiting a response redis createclient if you have redis server running on the same machine as node then the defaults for port and host are probably fine and you dont need to supply any arguments createclient returns a redisclient object otherwise createclient accepts these arguments redis createclient options redis createclient unix socket options redis createclient redis url options redis createclient port host options tip if the redis server runs on the same machine as the client consider using unix sockets if possible to increase throughput note using rediss for the protocol in a redis url will enable a tls socket connection however additional tls options will need to be passed in options if required options object properties property default description host 127 0 0 1 ip address of the redis server port 6379 port of the redis server path null the unix socket string of the redis server url null the url of the redis server format redis s user password host port db number db db number password bar option value more info avaliable at iana parser javascript deprecated use either the built in js parser javascript or the native hiredis parser note node redis 2 6 uses hiredis as default if installed this changed in v 2 6 0 string numbers null set to true node redis will return redis number values as strings instead of javascript numbers useful if you need to handle big numbers above number max safe integer 2 53 hiredis is incapable of this behavior so setting this option to true will result in the built in javascript parser being used no matter the value of the parser option return buffers false if set to true then all replies will be sent to callbacks as buffers instead of strings detect buffers false if set to true then replies will be sent to callbacks as buffers this option lets you switch between buffers and strings on a per command basis whereas return buffers applies to every command on a client note this doesnt work properly with the pubsub mode a subscriber has to either always return strings or buffers socket keepalive true if set to true the keep alive functionality is enabled on the underlying socket no ready check false when a connection is established to the redis server the server might still be loading the database from disk while loading the server will not respond to any commands to work around this node redis has a ready check which sends the info command to the server the response from the info command indicates whether the server is ready for more commands when ready node redis emits a ready event setting no ready check to true will inhibit this check enable offline queue true by default if there is no active connection to the redis server commands are added to a queue and are executed once the connection has been established setting enable offline queue to false will disable this feature and the callback will be executed immediately with an error or an error will be emitted if no callback is specified retry max delay null deprecated please use retry strategy instead by default every time the client tries to connect and fails the reconnection delay almost doubles this delay normally grows infinitely but setting retry max delay limits it to the maximum value provided in milliseconds connect timeout 3600000 deprecated please use retry strategy instead setting connect timeout limits the total time for the client to connect and reconnect the value is provided in milliseconds and is counted from the moment a new client is created or from the time the connection is lost the last retry is going to happen exactly at the timeout time default is to try connecting until the default system socket timeout has been exceeded and to try reconnecting until 1h has elapsed max attempts 0 deprecated please use retry strategy instead by default a client will try reconnecting until connected setting max attempts limits total amount of connection attempts setting this to 1 will prevent any reconnect attempt retry unfulfilled commands false if set to true all commands that were unfulfilled while the connection is lost will be retried after the connection has been reestablished use this with caution if you use state altering commands e g incr this is especially useful if you use blocking commands password null if set client will run redis auth command on connect alias auth pass note node redis 2 5 must use auth pass db null if set client will run redis select command on connect family ipv4 you can force using ipv6 if you set the family to ipv6 see node js net or dns modules on how to use the family type disable resubscribing false if set to true a client wont resubscribe after disconnecting rename commands null passing an object with renamed commands to use instead of the original functions for example if you renamed the command keys to do not use then the rename commands object would be keys do not use see the redis security topics for more info tls null an object containing options to pass to tls connect to set up a tls connection to redis if for example it is set up to be accessible via a tunnel prefix null a string used to prefix all used keys e g namespace test please be aware that the keys command will not be prefixed the keys command has a pattern as argument and no key and it would be impossible to determine the existing keys in redis if this would be prefixed retry strategy function a function that receives an options object as parameter including the retry attempt the total retry time indicating how much time passed since the last time connected the error why the connection was lost and the number of times connected in total if you return a number from this function the retry will happen exactly after that time in milliseconds if you return a non number no further retry will happen and all offline commands are flushed with errors return an error to return that specific error to all offline commands example below js var redis require redis var client redis createclient detect buffers true client set foo rand000000000000 ok this will return a javascript string client get foo rand000000000000 function err reply console log reply tostring will print ok this will return a buffer since original key is specified as a buffer client get new buffer foo rand000000000000 function err reply console log reply tostring will print buffer 4f 4b client quit retry strategy example js var client redis createclient retry strategy function options if options error options error code econnrefused end reconnecting on a specific error and flush all commands with a individual error return new error the server refused the connection if options total retry time 1000 60 60 end reconnecting after a specific timeout and flush all commands with a individual error return new error retry time exhausted if options attempt 10 end reconnecting with built in error return undefined reconnect after return math min options attempt 100 3000 client auth password callback when connecting to a redis server that requires authentication the auth command must be sent as the first command after connecting this can be tricky to coordinate with reconnections the ready check etc to make this easier client auth stashes password and will send it after each connection including reconnections callback is invoked only once after the response to the very first auth command sent note your call to client auth should not be inside the ready handler if you are doing this wrong client will emit an error that looks something like this error ready check failed err operation not permitted backpressure stream the client exposed the used stream in client stream and if the stream or client had to buffer the command in client should buffer in combination this can be used to implement backpressure by checking the buffer state before sending a command and listening to the stream drain event client quit this sends the quit command to the redis server and ends cleanly right after all running commands were properly handled if this is called while reconnecting and therefore no connection to the redis server exists it is going to end the connection right away instead of resulting in further reconnections all offline commands are going to be flushed with an error in that case client end flush forcibly close the connection to the redis server note that this does not wait until all replies have been parsed if you want to exit cleanly call client quit as mentioned above you should set flush to true if you are not absolutely sure you do not care about any other commands if you set flush to false all still running commands will silently fail this example closes the connection to the redis server before the replies have been read you probably dont want to do this js var redis require redis client redis createclient client set foo rand000000000000 some fantastic value function err reply this will either result in an error flush parameter is set to true or will silently fail and this callback will not be called at all flush set to false console log err client end true no further commands will be processed client get foo rand000000000000 function err reply console log err the connection has already been closed client end without the flush parameter set to true should not be used in production error handling v 2 6 currently the following error subclasses exist rediserror all errors returned by the client replyerror subclass of rediserror all errors returned by redis itself aborterror subclass of rediserror all commands that could not finish due to what ever reason parsererror subclass of rediserror returned in case of a parser error this should not happen aggregateerror subclass of aborterror emitted in case multiple unresolved commands without callback got rejected in debug mode instead of lots of aborterrors all error classes are exported by the module example js var redis require var assert require assert var client redis createclient client on error function err assert err instanceof error assert err instanceof redis aborterror assert err instanceof redis aggregateerror the set and get get aggregated in here assert strictequal err errors length 2 assert strictequal err code nr closed client set foo 123 bar function err res too many arguments assert err instanceof redis replyerror true assert strictequal err command set assert deepstrictequal err args foo 123 bar redis debug mode true client set foo bar client get foo process nexttick function force closing the connection while the command did not yet return client end true redis debug mode false every replyerror contains the command name in all caps and the arguments args if node redis emits a library error because of another error the triggering error is added to the returned error as origin attribute error codes node redis returns a nr closed error code if the clients connection dropped if a command unresolved command got rejected a uncertain state code is returned a connection broken error code is used in case node redis gives up to reconnect client unref call unref on the underlying socket connection to the redis server allowing the program to exit once no more commands are pending this is an experimental feature and only supports a subset of the redis protocol any commands where client state is saved on the redis server e g subscribe or the blocking bl commands will not work with unref js var redis require redis var client redis createclient calling unref will allow this program to exit immediately after the get command finishes otherwise the client would hang as long as the client server connection is alive client unref client get foo function err value if err throw err console log value friendlier hash commands most redis commands take a single string or an array of strings as arguments and replies are sent back as a single string or an array of strings when dealing with hash values there are a couple of useful exceptions to this client hgetall hash callback the reply from an hgetall command will be converted into a javascript object by node redis that way you can interact with the responses using javascript syntax example js client hmset hosts mjr 1 another 23 home 1234 client hgetall hosts function err obj console dir obj output js mjr 1 another 23 home 1234 client hmset hash obj callback multiple values in a hash can be set by supplying an object js client hmset key2 0123456789 abcdefghij note key and value will be coerced to strings some manner of key a type of value the properties and values of this object will be set as keys and values in the redis hash client hmset hash key1 val1 keyn valn callback multiple values may also be set by supplying a list js client hmset key1 0123456789 abcdefghij some manner of key a type of value publish subscribe example of the publish subscribe api this program opens two client connections subscribes to a channel on one of them and publishes to that channel on the other js var redis require redis var sub redis createclient pub redis createclient var msg count 0 sub on subscribe function channel count pub publish a nice channel i am sending a message pub publish a nice channel i am sending a second message pub publish a nice channel i am sending my last message sub on message function channel message console log sub channel channel message msg count 1 if msg count 3 sub unsubscribe sub quit pub quit sub subscribe a nice channel when a client issues a subscribe or psubscribe that connection is put into a subscriber mode at that point only commands that modify the subscription set are valid and quit and depending on the redis version ping as well when the subscription set is empty the connection is put back into regular mode if you need to send regular commands to redis while in subscriber mode just open another connection with a new client hint use client duplicate subscriber events if a client has subscriptions active it may emit these events message channel message client will emit message for every message received that matches an active subscription listeners are passed the channel name as channel and the message as message pmessage pattern channel message client will emit pmessage for every message received that matches an active subscription pattern listeners are passed the original pattern used with psubscribe as pattern the sending channel name as channel and the message as message message buffer channel message this is the same as the message event with the exception that it is always going to emit a buffer if you listen to the message event at the same time as the message buffer it is always going to emit a string pmessage buffer pattern channel message this is the same as the pmessage event with the exception that it is always going to emit a buffer if you listen to the pmessage event at the same time as the pmessage buffer it is always going to emit a string subscribe channel count client will emit subscribe in response to a subscribe command listeners are passed the channel name as channel and the new count of subscriptions for this client as count psubscribe pattern count client will emit psubscribe in response to a psubscribe command listeners are passed the original pattern as pattern and the new count of subscriptions for this client as count unsubscribe channel count client will emit unsubscribe in response to a unsubscribe command listeners are passed the channel name as channel and the new count of subscriptions for this client as count when count is 0 this client has left subscriber mode and no more subscriber events will be emitted punsubscribe pattern count client will emit punsubscribe in response to a punsubscribe command listeners are passed the channel name as channel and the new count of subscriptions for this client as count when count is 0 this client has left subscriber mode and no more subscriber events will be emitted client multi commands multi commands are queued up until an exec is issued and then all commands are run atomically by redis the interface in node redis is to return an individual multi object by calling client multi if any command fails to queue all commands are rolled back and none is going to be executed for further information look at transactions js var redis require index client redis createclient set size 20 client sadd bigset a member client sadd bigset another member while set size 0 client sadd bigset member set size set size 1 multi chain with an individual callback client multi scard bigset smembers bigset keys function err replies note code in this callback is not atomic this only happens after the the exec call finishes client mget replies redis print dbsize exec function err replies console log multi got replies length replies replies foreach function reply index console log reply index reply tostring multi exec callback client multi is a constructor that returns a multi object multi objects share all of the same command methods as client objects do commands are queued up inside the multi object until multi exec is invoked if your code contains an syntax error an execabort error is going to be thrown and all commands are going to be aborted that error contains a errors property that contains the concrete errors if all commands were queued successfully and an error is thrown by redis while processing the commands that error is going to be returned in the result array no other command is going to be aborted though than the onces failing you can either chain together multi commands as in the above example or you can queue individual commands while still sending regular client command as in this example js var redis require redis client redis createclient multi start a separate multi command queue multi client multi multi incr incr thing redis print multi incr incr other thing redis print runs immediately client mset incr thing 100 incr other thing 1 redis print drains multi queue and runs atomically multi exec function err replies console log replies 101 2 in addition to adding commands to the multi queue individually you can also pass an array of commands and arguments to the constructor js var redis require redis client redis createclient client multi mget multifoo multibar redis print incr multifoo incr multibar exec function err replies console log replies multi exec atomic callback identical to multi exec but with the difference that executing a single command will not use transactions client batch commands identical to multi without transactions this is recommended if you want to execute many commands at once but dont have to rely on transactions batch commands are queued up until an exec is issued and then all commands are run atomically by redis the interface in node redis is to return an individual batch object by calling client batch the only difference between batch and multi is that no transaction is going to be used be aware that the errors are just like in multi statements in the result otherwise both errors and results could be returned at the same time if you fire many commands at once this is going to boost the execution speed significantly compared to firing the same commands in a loop without waiting for the result see the benchmarks for further comparison please remember that all commands are kept in memory until they are fired optimistic locks using multi you can make sure your modifications run as a transaction but you cant be sure you got there first what if another client modified a key while you were working with its data to solve this redis supports the watch command which is meant to be used with multi js var redis require redis client redis createclient client watch foo function err if err throw err client get foo function err result if err throw err process result heavy and time consuming operation here client multi set foo some heavy computation exec function err results if err is null it means redis successfully attempted the operation if err throw err if results null it means that a concurrent client changed the key while we were processing it and thus the execution of the multi command was not performed notice failing an execution of multi is not considered an error so you will have err null and results null the above snippet shows the correct usage of watch with multi every time a watched key is changed before the execution of a multi command the execution will return null on a normal situation the execution will return an array of values with the results of the operations as stated in the snippet failing the execution of a multi command being watched is not considered an error the execution may return an error if for example the client cannot connect to redis an example where we can see the execution of a multi command fail is as follows js let clients clients watcher redis createclient clients alterer clients watcher duplicate clients watcher watch foo function err if err throw err if you comment out the next line the transaction will work clients alterer set foo math random err if err throw err using a settimeout here to ensure that the multi exec will come after the set normally you would use a callback to ensure order but i want the above set command to be easily comment out able settimeout function clients watcher multi set foo abc set bar 1234 exec err results if err throw err if results null console log transaction aborted because results were null else console log transaction worked and returned results clients watcher quit clients alterer quit 1000 watch limitations redis watch works only on whole key values for example with watch you can watch a hash for modifications but you cannot watch a specific field of a hash the following example would watch the keys foo and hello not the field hello of hash foo js var redis require redis client redis createclient client hget foo hello function err result do some processing with the value from this field and watch it after client watch foo hello function err if err throw err wrong this is now watching the keys foo and hello it is not watching the field hello of hash foo because the key foo refers to a hash this command is now watching the entire hash for modifications this limitation also applies to sets cannot watch individual set members and any other collections monitor mode redis supports the monitor command which lets you see all commands received by the redis server across all client connections including from other client libraries and other computers a monitor event is going to be emitted for every command fired from any client connected to the server including the monitoring client itself the callback for the monitor event takes a timestamp from the redis server an array of command arguments and the raw monitoring string example js var client require redis createclient client monitor function err res console log entering monitoring mode client set foo bar client on monitor function time args raw reply console log time args 1458910076 446514 set foo bar extras some other things you might like to know about client server info after the ready probe completes the results from the info command are saved in the client server info object the versions key contains an array of the elements of the version string for easy comparison client server info redis version 2 3 0 client server info versions 2 3 0 redis print a handy callback function for displaying return values when testing example js var redis require redis client redis createclient client on connect function client set foo rand000000000000 some fantastic value redis print client get foo rand000000000000 redis print this will print reply ok reply some fantastic value note that this program will not exit cleanly because the client is still connected multi word commands to execute redis multi word commands like script load or client list pass the second word as first parameter js client script load return 1 client multi script load return 1 exec client multi script load return 1 exec client duplicate options callback duplicate all current options and return a new redisclient instance all options passed to the duplicate function are going to replace the original option if you pass a callback duplicate is going to wait until the client is ready and returns it in the callback if an error occurs in the meanwhile that is going to return an error instead in the callback one example of when to use duplicate would be to accommodate the connection blocking redis commands brpop blpop and brpoplpush if these commands are used on the same redisclient instance as non blocking commands the non blocking ones may be queued up until after the blocking ones finish js var redis require redis var client redis createclient var clientblocking client duplicate var get function console log get called client get any key function console log get returned settimeout get 1000 var brpop function console log brpop called clientblocking brpop nonexistent 5 function console log brpop return settimeout brpop 1000 get brpop another reason to use duplicate is when multiple dbs on the same server are accessed via the redis select command each db could use its own connection client send command command name args callback all redis commands have been added to the client object however if new commands are introduced before this library is updated or if you want to add individual commands you can use send command to send arbitrary commands to redis all commands are sent as multi bulk commands args can either be an array of arguments or omitted set to undefined redis add command command name calling add command will add a new command to the prototype the exact command name will be used when calling using this new command using arbitrary arguments is possible as with any other command client connected boolean tracking the state of the connection to the redis server client command queue length the number of commands that have been sent to the redis server but not yet replied to you can use this to enforce some kind of maximum queue depth for commands while connected client offline queue length the number of commands that have been queued up for a future connection you can use this to enforce some kind of maximum queue depth for pre connection commands commands with optional and keyword arguments this applies to anything that uses an optional withscores or limit offset count in the redis io commands documentation example js var args myzset 1 one 2 two 3 three 99 ninety nine client zadd args function err response if err throw err console log added response items infinity and infinity also work var args1 myzset inf inf client zrevrangebyscore args1 function err response if err throw err console log example1 response write your code here var max 3 min 1 offset 1 count 2 var args2 myzset max min withscores limit offset count client zrevrangebyscore args2 function err response if err throw err console log example2 response write your code here performance much effort has been spent to make node redis as fast as possible for common operations lenovo t450s i7 5600u and 12gb memory clients 1 nodejs 6 2 0 redis 3 2 0 parser javascript connected by tcp ping 1 1 avg max 0 02 5 26 2501ms total 46916 ops sec ping batch 50 1 avg max 0 06 4 35 2501ms total 755178 ops sec set 4b str 1 1 avg max 0 02 4 75 2501ms total 40856 ops sec set 4b str batch 50 1 avg max 0 11 1 51 2501ms total 432727 ops sec set 4b buf 1 1 avg max 0 05 2 76 2501ms total 20659 ops sec set 4b buf batch 50 1 avg max 0 25 1 76 2501ms total 194962 ops sec get 4b str 1 1 avg max 0 02 1 55 2501ms total 45156 ops sec get 4b str batch 50 1 avg max 0 09 3 15 2501ms total 524110 ops sec get 4b buf 1 1 avg max 0 02 3 07 2501ms total 44563 ops sec get 4b buf batch 50 1 avg max 0 10 3 18 2501ms total 473171 ops sec set 4kib str 1 1 avg max 0 03 1 54 2501ms total 32627 ops sec set 4kib str batch 50 1 avg max 0 34 1 89 2501ms total 146861 ops sec set 4kib buf 1 1 avg max 0 05 2 85 2501ms total 20688 ops sec set 4kib buf batch 50 1 avg max 0 36 1 83 2501ms total 138165 ops sec get 4kib str 1 1 avg max 0 02 1 37 2501ms total 39389 ops sec get 4kib str batch 50 1 avg max 0 24 1 81 2501ms total 208157 ops sec get 4kib buf 1 1 avg max 0 02 2 63 2501ms total 39918 ops sec get 4kib buf batch 50 1 avg max 0 31 8 56 2501ms total 161575 ops sec incr 1 1 avg max 0 02 4 69 2501ms total 45685 ops sec incr batch 50 1 avg max 0 09 3 06 2501ms total 539964 ops sec lpush 1 1 avg max 0 02 3 04 2501ms total 41253 ops sec lpush batch 50 1 avg max 0 12 1 94 2501ms total 425090 ops sec lrange 10 1 1 avg max 0 02 2 28 2501ms total 39850 ops sec lrange 10 batch 50 1 avg max 0 25 1 85 2501ms total 194302 ops sec lrange 100 1 1 avg max 0 05 2 93 2501ms total 21026 ops sec lrange 100 batch 50 1 avg max 1 52 2 89 2501ms total 32767 ops sec set 4mib str 1 1 avg max 5 16 15 55 2502ms total 193 ops sec set 4mib str batch 20 1 avg max 89 73 99 96 2513ms total 223 ops sec set 4mib buf 1 1 avg max 2 23 8 35 2501ms total 446 ops sec set 4mib buf batch 20 1 avg max 41 47 50 91 2530ms total 482 ops sec get 4mib str 1 1 avg max 2 79 10 91 2502ms total 358 ops sec get 4mib str batch 20 1 avg max 101 61 118 11 2541ms total 197 ops sec get 4mib buf 1 1 avg max 2 32 14 93 2502ms total 430 ops sec get 4mib buf batch 20 1 avg max 65 01 84 72 2536ms total 308 ops sec debugging to get debug output run your node redis application with node debug redis this is also going to result in good stack traces opposed to useless ones otherwise for any async operation if you only want to have good stack traces but not the debug output run your application in development mode instead node env development good stack traces are only activated in development and debug mode as this results in a significant performance penalty comparison useless stack trace replyerror err wrong number of arguments for set command at parseerror home ruben repos redis node modules redis parser lib parser js 158 12 at parsetype home ruben repos redis node modules redis parser lib parser js 219 14 good stack trace replyerror err wrong number of arguments for set command at new command home ruben repos redis lib command js 9 902 at redisclient set home ruben repos redis lib commands js 9 3238 at context anonymous home ruben repos redis test good stacks spec js 20 20 at callfnasync home ruben repos redis node modules mocha lib runnable js 349 8 at test runnable run home ruben repos redis node modules mocha lib runnable js 301 7 at runner runtest home ruben repos redis node modules mocha lib runner js 422 10 at home ruben repos redis node modules mocha lib runner js 528 12 at next home ruben repos redis node modules mocha lib runner js 342 14 at home ruben repos redis node modules mocha lib runner js 352 7 at next home ruben repos redis node modules mocha lib runner js 284 14 at immediate onimmediate home ruben repos redis node modules mocha lib runner js 320 5 at processimmediate as immediatecallback timers js 383 17 how to contribute open a pull request or an issue about what you want to implement change were glad for any help please be aware that well only accept fully tested code contributors the original author of node redis is matthew ranney the current lead maintainer is ruben bridgewater many others contributed to node redis too thanks to all of them license mit consolidation its time for celebration right now there are two great redis clients around and both have some advantages above each other we speak about ioredis and node redis so after talking to each other about how we could improve in working together we that is luin and bridgear decided to work towards a single library on the long run but step by step first of all we want to split small parts of our libraries into others so that were both able to use the same code those libraries are going to be maintained under the noderedis organization this is going to reduce the maintenance overhead allows others to use the very same code if they need it and its way easyer for others to contribute to both libraries were very happy about this step towards working together as we both want to give you the best redis experience possible if you want to join our cause by help maintaining something please dont hesitate to contact either one of us