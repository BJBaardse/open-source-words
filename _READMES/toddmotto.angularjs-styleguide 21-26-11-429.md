angularjs styleguide es2015 up to date with angularjs 1 6 best practices architecture file structure components one way dataflow lifecycle hooks want an example structure as reference check out my component based architecture 1 5 app a sensible styleguide for teams by toddmotto this architecture and styleguide has been rewritten from the ground up for es2015 the changes in angularjs 1 5 for future upgrading your application to angular this guide includes new best practices for one way dataflow event delegation component architecture and component routing you can find the old styleguide here and the reasoning behind the new one here join the ultimate angularjs learning experience to fully master beginner and advanced angularjs features to build real world apps that are fast and scale table of contents modular architecture theory root module component module common module low level modules file naming conventions scalable file structure components theory supported properties controllers one way dataflow and events stateful components stateless components routed components directives theory recommended properties constants or classes services theory classes for service styles es2015 and tooling state management resources documentation contributing modular architecture each module in an angular app is a module component a module component is the root definition for that module that encapsulates the logic templates routing and child components module theory the design in the modules maps directly to our folder structure which keeps things maintainable and predictable we should ideally have three high level modules root component and common the root module defines the base module that bootstraps our app and the corresponding template we then import our component and common modules into the root module to include our dependencies the component and common modules then require lower level component modules which contain our components controllers services directives filters and tests for each reusable feature back to top root module a root module begins with a root component that defines the base element for the entire application with a routing outlet defined example shown using ui view from ui router js app component js export const appcomponent template header hello world header div div ui view div div footer copyright myapp 2016 footer a root module is then created with appcomponent imported and registered with component app appcomponent further imports for submodules component and common modules are made to include all components relevant for the application youll notice styles are also being imported here well come onto this in later chapters in this guide js app module js import angular from angular import uirouter from angular ui router import appcomponent from app component import componentsmodule from components components module import commonmodule from common common module import app scss export const appmodule angular module app componentsmodule commonmodule uirouter component app appcomponent name back to top component module a component module is the container reference for all reusable components see above how we import componentsmodule and inject them into the root module this gives us a single place to import all components for the app these modules we require are decoupled from all other modules and thus can be moved into any other application with ease js components components module js import angular from angular import calendarmodule from calendar calendar module import eventsmodule from events events module export const componentsmodule angular module app components calendarmodule eventsmodule name back to top common module the common module is the container reference for all application specific components that we dont want to use in another application this can be things like layout navigation and footers see above how we import commonmodule and inject them into the root module this gives us a single place to import all common components for the app js common common module js import angular from angular import navmodule from nav nav module import footermodule from footer footer module export const commonmodule angular module app common navmodule footermodule name back to top low level modules low level modules are individual component modules that contain the logic for each feature block these will each define a module to be imported to a higher level module such as a component or common module an example below always remember to add the name suffix to each export when creating a new module not when referencing one youll noticed routing definitions also exist here well come onto this in later chapters in this guide js calendar calendar module js import angular from angular import uirouter from angular ui router import calendarcomponent from calendar component import calendar scss export const calendarmodule angular module calendar uirouter component calendar calendarcomponent config stateprovider urlrouterprovider nginject stateprovider state calendar url calendar component calendar urlrouterprovider otherwise name back to top file naming conventions keep it simple and lowercase use the component name e g calendar js calendar grid js with the name of the type of file in the middle use module js for the module definition file as it keeps it verbose and consistent with angular calendar module js calendar component js calendar service js calendar directive js calendar filter js calendar spec js calendar html calendar scss back to top scalable file structure file structure is extremely important this describes a scalable and predictable structure an example file structure to illustrate a modular component architecture ├── app │ ├── components │ │ ├── calendar │ │ │ ├── calendar module js │ │ │ ├── calendar component js │ │ │ ├── calendar service js │ │ │ ├── calendar spec js │ │ │ ├── calendar html │ │ │ ├── calendar scss │ │ │ └── calendar grid │ │ │ ├── calendar grid module js │ │ │ ├── calendar grid component js │ │ │ ├── calendar grid directive js │ │ │ ├── calendar grid filter js │ │ │ ├── calendar grid spec js │ │ │ ├── calendar grid html │ │ │ └── calendar grid scss │ │ ├── events │ │ │ ├── events module js │ │ │ ├── events component js │ │ │ ├── events directive js │ │ │ ├── events service js │ │ │ ├── events spec js │ │ │ ├── events html │ │ │ ├── events scss │ │ │ └── events signup │ │ │ ├── events signup module js │ │ │ ├── events signup component js │ │ │ ├── events signup service js │ │ │ ├── events signup spec js │ │ │ ├── events signup html │ │ │ └── events signup scss │ │ └── components module js │ ├── common │ │ ├── nav │ │ │ ├── nav module js │ │ │ ├── nav component js │ │ │ ├── nav service js │ │ │ ├── nav spec js │ │ │ ├── nav html │ │ │ └── nav scss │ │ ├── footer │ │ │ ├── footer module js │ │ │ ├── footer component js │ │ │ ├── footer service js │ │ │ ├── footer spec js │ │ │ ├── footer html │ │ │ └── footer scss │ │ └── common module js │ ├── app module js │ ├── app component js │ └── app scss └── index html the high level folder structure simply contains index html and app a directory in which all our root component common and low level modules live along with the markup and styles for each component back to top components component theory components are essentially templates with a controller they are not directives nor should you replace directives with components unless you are upgrading template directives with controllers which are best suited as a component components also contain bindings that define inputs and outputs for data and events lifecycle hooks and the ability to use one way data flow and event objects to get data back up to a parent component these are the new defacto standard in angularjs 1 5 and above everything template and controller driven that we create will likely be a component which may be a stateful stateless or routed component you can think of a component as a complete piece of code not just the component definition object lets explore some best practices and advisories for components then dive into how you should be structuring them via stateful stateless and routed component concepts back to top supported properties these are the supported properties for component that you can should use property support bindings yes use only controller yes controlleras yes default is ctrl require yes new object syntax template yes templateurl yes transclude yes back to top controllers controllers should only be used alongside components never anywhere else if you feel you need a controller what you really need is likely a stateless component to manage that particular piece of behaviour here are some advisories for using class for controllers drop the name controller i e use controller class todocomponent to aid future angular migration always use the constructor for dependency injection purposes use ng annotates nginject syntax for inject annotations if you need to access the lexical scope use arrow functions alternatively to arrow functions let ctrl this is also acceptable and may make more sense depending on the use case bind all public functions directly to the class make use of the appropriate lifecycle hooks oninit onchanges postlink and ondestroy note onchanges is called before oninit see resources section for articles detailing this in more depth use require alongside oninit to reference any inherited logic do not override the default ctrl alias for the controlleras syntax therefore do not use controlleras anywhere back to top one way dataflow and events one way dataflow was introduced in angularjs 1 5 and redefines component communication here are some advisories for using one way dataflow in components that receive data always use one way databinding syntax do not use two way databinding syntax anymore anywhere components that have bindings should use onchanges to clone the one way binding data to break objects passing by reference and updating the parent data use event as a function argument in the parent method see stateful example below ctrl addtodo event pass an event object back up from a stateless component see stateless example below this onaddtodo bonus use an eventemitter wrapper with value to mirror angular avoids manual event object creation why this mirrors angular and keeps consistency inside every component it also makes state predictable back to top stateful components lets define what wed call a stateful component fetches state essentially communicating to a backend api through a service does not directly mutate state renders child components that mutate state also referred to as smart container components an example of a stateful component complete with its low level module definition this is only for demonstration so some code has been omitted for brevity js todo todo component js import templateurl from todo html export const todocomponent templateurl controller class todocomponent constructor todoservice nginject this todoservice todoservice oninit this newtodo title selected false this todos this todoservice gettodos then response this todos response addtodo todo if todo return this todos unshift todo this newtodo title selected false todo todo html todo todo module js import angular from angular import todocomponent from todo component import todo scss export const todomodule angular module todo component todo todocomponent name this example shows a stateful component that fetches state inside the controller through a service and then passes it down into stateless child components notice how there are no directives being used such as ng repeat and friends inside the template instead data and functions are delegated into todo form and todo list stateless components back to top stateless components lets define what wed call a stateless component has defined inputs and outputs using bindings data enters the component through attribute bindings inputs data leaves the component through events outputs mutates state passes data back up on demand such as a click or submit event doesnt care where data comes from its stateless are highly reusable components also referred to as dumb presentational components an example of a stateless component lets use todo form as an example complete with its low level module definition this is only for demonstration so some code has been omitted for brevity js todo todo form todo form component js import templateurl from todo form html export const todoformcomponent bindings todo onaddtodo templateurl controller class todoformcomponent constructor eventemitter nginject this eventemitter eventemitter onchanges changes if changes todo this todo object assign this todo onsubmit if this todo title return with eventemitter wrapper this onaddtodo this eventemitter todo this todo without eventemitter wrapper this onaddtodo event todo this todo todo todo form todo form html submit todo todo form todo form module js import angular from angular import todoformcomponent from todo form component import todo form scss export const todoformmodule angular module todo form component todoform todoformcomponent value eventemitter payload event payload name note how the todo form component fetches no state it simply receives it mutates an object via the controller logic associated with it and passes it back to the parent component through the property bindings in this example the onchanges lifecycle hook makes a clone of the initial this todo binding object and reassigns it which means the parent data is not affected until we submit the form alongside one way data flow new binding syntax back to top routed components lets define what wed call a routed component its essentially a stateful component with routing definitions no more router js files we use routed components to define their own routing logic data input for the component is done via the route resolve optional still available in the controller with service calls for this example were going to take the existing todo component refactor it to use a route definition and bindings on the component which receives data the secret here with ui router is the resolve properties we create in this case tododata directly map across to bindings for us we treat it as a routed component because its essentially a view js todo todo component js import templateurl from todo html export const todocomponent bindings tododata templateurl controller class todocomponent constructor nginject not actually needed but best practice to keep here incase dependencies needed in the future oninit this newtodo title selected false onchanges changes if changes tododata this todos object assign this tododata addtodo todo if todo return this todos unshift todo this newtodo title selected false todo todo html todo todo service js export class todoservice constructor http nginject this http http gettodos return this http get api todos then response response data todo todo module js import angular from angular import uirouter from angular ui router import todocomponent from todo component import todoservice from todo service import todo scss export const todomodule angular module todo uirouter component todo todocomponent service todoservice todoservice config stateprovider urlrouterprovider nginject stateprovider state todos url todos component todo resolve tododata todoservice todoservice gettodos urlrouterprovider otherwise name back to top directives directive theory directives gives us template scope bindings bindtocontroller link and many other things the usage of these should be carefully considered now that component exists directives should not declare templates and controllers anymore or receive data through bindings directives should be used solely for decorating the dom by this it means extending existing html created with component in a simple sense if you need custom dom events apis and logic use a directive and bind it to a template inside a component if you need a sensible amount of dom manipulation there is also the postlink lifecycle hook to consider however this is not a place to migrate all your dom manipulation to use a directive if you can for non angular things here are some advisories for using directives never use templates scope bindtocontroller or controllers always restrict a with directives use compile and link where necessary remember to destroy and unbind event handlers inside scope on destroy fn back to top recommended properties due to the fact directives support most of what component does template directives were the original component im recommending limiting your directive object definitions to only these properties to avoid using directives incorrectly property use it why bindtocontroller no use bindings in components compile yes for pre compile dom manipulation events controller no use a component controlleras no use a component link functions yes for pre post dom manipulation events multielement yes see docs priority yes see docs require no use a component restrict yes defines directive usage always use a scope no use a component template no use a component templatenamespace yes if you must see docs templateurl no use a component transclude no use a component back to top constants or classes there are a few ways to approach using es2015 and directives either with an arrow function and easier assignment or using an es2015 class choose whats best for you or your team keep in mind angular uses class heres an example using a constant with an arrow function an expression wrapper returning an object literal note the usage differences inside directive js todo todo autofocus directive js import angular from angular export const todoautofocus timeout nginject return restrict a link scope element attrs scope watch attrs todoautofocus newvalue oldvalue if newvalue return timeout element 0 focus todo todo module js import angular from angular import todocomponent from todo component import todoautofocus from todo autofocus directive import todo scss export const todomodule angular module todo component todo todocomponent directive todoautofocus todoautofocus name or using es2015 class note manually calling new todoautofocus when registering the directive to create the object js todo todo autofocus directive js import angular from angular export class todoautofocus constructor timeout nginject this restrict a this timeout timeout link scope element attrs scope watch attrs todoautofocus newvalue oldvalue if newvalue return this timeout element 0 focus todo todo module js import angular from angular import todocomponent from todo component import todoautofocus from todo autofocus directive import todo scss export const todomodule angular module todo component todo todocomponent directive todoautofocus timeout new todoautofocus timeout name back to top services service theory services are essentially containers for business logic that our components shouldnt request directly services contain other built in or external services such as http that we can then inject into component controllers elsewhere in our app we have two ways of doing services using service or factory with es2015 class we should only use service complete with dependency injection annotation using inject back to top classes for service heres an example implementation for our todo app using es2015 class js todo todo service js export class todoservice constructor http nginject this http http gettodos return this http get api todos then response response data todo todo module js import angular from angular import todocomponent from todo component import todoservice from todo service import todo scss export const todomodule angular module todo component todo todocomponent service todoservice todoservice name back to top styles using webpack we can now use import statements on our scss files in our module js to let webpack know to include that file in our stylesheet doing this lets us keep our components isolated for both functionality and style it also aligns more closely to how stylesheets are declared for use in angular doing this wont isolate our styles to just that component like it does with angular the styles will still be usable application wide but it is more manageable and makes our applications structure easier to reason about if you have some variables or globally used styles like form input elements then these files should still be placed into the root scss folder e g scss forms scss these global styles can then be imported into your root module app module js stylesheet like you would normally do back to top es2015 and tooling es2015 use babel to compile your es2015 code and any polyfills consider using typescript to make way for any angular upgrades tooling use ui router latest alpha see the readme if you want to support component routing otherwise youre stuck with template component and no bindings resolve mapping consider preloading templates into templatecache with angular templates or ngtemplate loader gulp version grunt version webpack version consider using webpack for compiling your es2015 code and styles use ngannotate to automatically annotate inject properties how to use ngannotate with es6 back to top state management consider using redux with angularjs 1 5 for data management angular redux back to top resources stateful and stateless components the missing manual understanding the component method using require with oninit understanding all the lifecycle hooks oninit onchanges postlink ondestroy using resolve in routes redux and angular state management sample application from community back to top documentation for anything else including api reference check the angularjs documentation contributing open an issue first to discuss potential changes additions please dont open issues for questions license the mit license copyright c 2016 2018 todd motto permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the software to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall the authors or copyright holders be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software