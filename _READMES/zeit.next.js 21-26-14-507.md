next js is a minimalistic framework for server rendered react applications visit nextjs org learn to get started with next js start doctoc generated toc please keep comment here to allow auto update dont edit this section instead re run doctoc to update https github com thlorenz doctoc how to use setup automatic code splitting css built in css support css in js importing css sass less stylus files static file serving e g images populating head fetching data and component lifecycle routing with link with url object replace instead of push url using a component that supports onclick forcing the link to expose href to its child disabling the scroll changes to top on page imperatively intercepting popstate with url object router events shallow routing using a higher order component prefetching pages with link imperatively custom server and routing disabling file system routing dynamic assetprefix dynamic import 1 basic usage also does ssr 2 with custom loading component 3 with no ssr 4 with multiple modules at once custom app custom document custom error handling reusing the built in error page custom configuration setting a custom build directory disabling etag generation configuring the ondemandentries configuring extensions looked for when resolving pages in pages configuring the build id customizing webpack config customizing babel config exposing configuration to the server client side cdn support with asset prefix production deployment static html export usage limitation multi zones how to define a zone how to merge them recipes faq contributing authors end doctoc generated toc please keep comment here to allow auto update how to use setup install it bash npm install save next react react dom and add a script to your package json like this json scripts dev next build next build start next start after that the file system is the main api every js file becomes a route that gets automatically processed and rendered populate pages index js inside your project jsx export default div welcome to next js div and then just run npm run dev and go to http localhost 3000 to use another port you can run npm run dev p your port here so far we get automatic transpilation and bundling with webpack and babel hot code reloading server rendering and indexing of pages static file serving static is mapped to static given you create a static directory inside your project to see how simple this is check out the sample app nextgram automatic code splitting every import you declare gets bundled and served with each page that means pages never load unnecessary code jsx import cowsay from cowsay browser export default cowsay say text hi there css built in css support examples basic css we bundle styled jsx to provide support for isolated scoped css the aim is to support shadow css similar to web components which unfortunately do not support server rendering and are js only jsx export default div hello world p scoped p style jsx p color blue div background red media max width 600px div background blue style style global jsx body background black style div please see the styled jsx documentation for more examples css in js examples styled componentsstyletronglamorglamorouscxsaphroditefela its possible to use any existing css in js solution the simplest one is inline styles jsx export default p style color red hi there p to use more sophisticated css in js solutions you typically have to implement style flushing for server side rendering we enable this by allowing you to define your own custom document component that wraps each page importing css sass less stylus files to support importing css scss less or styl files you can use these modules which configure sensible defaults for server rendered applications zeit next css zeit next sass zeit next less zeit next stylus static file serving e g images create a folder called static in your project root directory from your code you can then reference those files with static urls jsx export default img src static my image png alt my image note dont name the static directory anything else the name is required and is the only directory that next js uses for serving static assets populating head examples head elements layout component we expose a built in component for appending elements to the head of the page jsx import head from next head export default my page title hello world to avoid duplicate tags in your head you can use the key property which will make sure the tag is only rendered once jsx import head from next head export default div head title my page title title meta name viewport content initial scale 1 0 width device width key viewport head head meta name viewport content initial scale 1 2 width device width key viewport head p hello world p div in this case only the second meta name viewport is rendered note the contents of head get cleared upon unmounting the component so make sure each page completely defines what it needs in head without making assumptions about what other pages added fetching data and component lifecycle examples data fetch when you need state lifecycle hooks or initial data population you can export a react component instead of a stateless function like shown above jsx import react from react export default class extends react component static async getinitialprops req const useragent req req headers user agent navigator useragent return useragent render return hello world this props useragent notice that to load data when the page loads we use getinitialprops which is an async static method it can asynchronously fetch anything that resolves to a javascript plain object which populates props data returned from getinitialprops is serialized when server rendering similar to a json stringify make sure the returned object from getinitialprops is a plain object and not using date map or set for the initial page load getinitialprops will execute on the server only getinitialprops will only be executed on the client when navigating to a different route via the link component or using the routing apis note getinitialprops can not be used in children components only in pages if you are using some server only modules inside getinitialprops make sure to import them properly otherwise itll slow down your app you can also define the getinitialprops lifecycle method for stateless components jsx const page stars next stars stars page getinitialprops async req const res await fetch https api github com repos zeit next js const json await res json return stars json stargazers count export default page getinitialprops receives a context object with the following properties pathname path section of url query query string section of url parsed as an object aspath string of the actual path including the query shows in the browser req http request object server only res http response object server only jsonpageres fetch response object client only err error object if any error is encountered during the rendering routing with link examples hello world client side transitions between routes can be enabled via a link component consider these two pages jsx pages index js import link from next link export default click here to read more jsx pages about js export default p welcome to about p note use link prefetch for maximum performance to link and prefetch in the background at the same time client side routing behaves exactly like the browser the component is fetched if it defines getinitialprops data is fetched if an error occurs error js is rendered after 1 and 2 complete pushstate is performed and the new component is rendered deprecated use withrouter instead each top level component receives a url property with the following api pathname string of the current path excluding the query string query object with the parsed query string defaults to aspath string of the actual path including the query shows in the browser with url object examples with url object routing the component link can also receive an url object and it will automatically format it to create the url string jsx pages index js import link from next link export default click here to read more that will generate the url string about name zeit you can use every property as defined in the node js url module documentation replace instead of push url the default behaviour for the link component is to push a new url into the stack you can use the replace prop to prevent adding a new entry jsx pages index js import link from next link export default click here to read more using a component that supports onclick link supports any component that supports the onclick event in case you dont provide an a tag it will only add the onclick event handler and wont pass the href property jsx pages index js import link from next link export default click forcing the link to expose href to its child if child is an a tag and doesnt have a href attribute we specify it so that the repetition is not needed by the user however sometimes youll want to pass an a tag inside of a wrapper and the link wont recognize it as a hyperlink and consequently wont transfer its href to the child in cases like that you should define a boolean passhref property to the link forcing it to expose its href property to the child please note using a tag other than a and failing to pass passhref may result in links that appear to navigate correctly but when being crawled by search engines will not be recognized as links owing to the lack of href attribute this may result in negative effects on your sites seo jsx import link from next link import unexpected a from third library export default href name name disabling the scroll changes to top on page the default behaviour of link is to scroll to the top of the page when there is a hash defined it will scroll to the specific id just like a normal a tag to prevent scrolling to the top hash scroll false can be added to link jsx link scroll false href counter 10 a disables scrolling a link link href counter 10 a changes with scrolling to top a link imperatively examples basic routing with a page loading indicator you can also do client side page transitions using the next router jsx import router from next router export default click router push about here to read more intercepting popstate in some cases for example if using a custom router you may wish to listen to popstate and react before the router acts on it for example you could use this to manipulate the request or force an ssr refresh jsx import router from next router router beforepopstate url as options i only want to allow these two routes if as as other have ssr render bad routes as a 404 window location href as return false return true if you return a falsy value from beforepopstate router will not handle popstate youll be responsible for handling it in that case see disabling file system routing above router object comes with the following api route string of the current route pathname string of the current path excluding the query string query object with the parsed query string defaults to aspath string of the actual path including the query shows in the browser push url as url performs a pushstate call with the given url replace url as url performs a replacestate call with the given url beforepopstate cb function intercept popstate before router processes the event the second as parameter for push and replace is an optional decoration of the url useful if you configured custom routes on the server note in order to programmatically change the route without triggering navigation and component fetching use props url push and props url replace within a component with url object you can use an url object the same way you use it in a link component to push and replace an url jsx import router from next router const handler router push pathname about query name zeit export default click here to read more this uses the same exact parameters as in the link component router events you can also listen to different events happening inside the router heres a list of supported events onroutechangestart url fires when a route starts to change onroutechangecomplete url fires when a route changed completely onroutechangeerror err url fires when theres an error when changing routes onbeforehistorychange url fires just before changing the browsers history onhashchangestart url fires when the hash will change but not the page onhashchangecomplete url fires when the hash has changed but not the page here url is the url shown in the browser if you call router push url as or similar then the value of url will be as heres how to properly listen to the router event onroutechangestart js router onroutechangestart url console log app is changing to url if you no longer want to listen to that event you can simply unset the event listener like this js router onroutechangestart null if a route load is cancelled for example by clicking two links rapidly in succession routechangeerror will fire the passed err will contain a cancelled property set to true js router onroutechangeerror err url if err cancelled console log route to url was cancelled shallow routing examples shallow routing shallow routing allows you to change the url without running getinitialprops youll receive the updated pathname and the query via the url prop of the same page thats loaded without losing state you can do this by invoking either router push or router replace with the shallow true option heres an example js current url is const href counter 10 const as href router push href as shallow true now the url is updated to counter 10 you can see the updated url with this props url inside the component you can watch for url changes via componentwillreceiveprops hook as shown below js componentwillreceiveprops nextprops const pathname query nextprops url fetch data based on the new query notes shallow routing works only for same page url changes for an example lets assume we have another page called about and you run this js router push counter 10 about counter 10 shallow true since thats a new page itll unload the current page load the new one and call getinitialprops even though we asked to do shallow routing using a higher order component examples using the withrouter utility if you want to access the router object inside any component in your app you can use the withrouter higher order component heres how to use it jsx import withrouter from next router const activelink children router href const style marginright 10 color router pathname href red black const handleclick e e preventdefault router push href return children export default withrouter activelink the above router object comes with an api similar to next router prefetching pages ⚠️ this is a production only feature ⚠️ examples prefetching next js has an api which allows you to prefetch pages since next js server renders your pages this allows all the future interaction paths of your app to be instant effectively next js gives you the great initial download performance of a website with the ahead of time download capabilities of an app read more with prefetching next js only downloads js code when the page is getting rendered you may need to wait for the data with link you can add prefetch prop to any link and next js will prefetch those pages in the background jsx import link from next link example header component export default home about contact imperatively most prefetching needs are addressed by link but we also expose an imperative api for advanced usage jsx import router from next router export default url settimeout url pushto dynamic 100 a route transition will happen after 100ms but we can prefetch it router prefetch dynamic the router instance should be only used inside the client side of your app though in order to prevent any error regarding this subject when rendering the router on the server side use the imperatively prefetch method in the componentdidmount lifecycle method jsx import react from react import router from next router export default class mylink extends react component componentdidmount router prefetch dynamic render return settimeout url pushto dynamic 100 a route transition will happen after 100ms custom server and routing examples basic custom server express integration hapi integration koa integration parameterized routing ssr caching typically you start your next server with next start its possible however to start a server 100 programmatically in order to customize routes use route patterns etc when using a custom server with a server file for example called server js make sure you update the scripts key in package json to json scripts dev node server js build next build start node env production node server js this example makes a resolve to pages b and b resolve to pages a js this file doesnt go through babel or webpack transformation make sure the syntax and sources this file requires are compatible with the current node version you are running see https github com zeit next js issues 1245 for discussions on universal webpack or universal babel const createserver require http const parse require url const next require next const dev process env node env production const app next dev const handle app getrequesthandler app prepare then createserver req res be sure to pass true as the second argument to url parse this tells it to parse the query portion of the url const parsedurl parse req url true const pathname query parsedurl if pathname a app render req res b query else if pathname b app render req res a query else handle req res parsedurl listen 3000 err if err throw err console log ready on http localhost 3000 the next api is as follows next opts object supported options dev bool whether to launch next js in dev mode default false dir string where the next project is located default quiet bool hide error messages containing server information default false conf object the same object you would use in next config js default then change your start script to node env production node server js disabling file system routing by default next will serve each file in pages under a pathname matching the filename eg pages some file js is served at site com some file if your project uses custom routing this behavior may result in the same content being served from multiple paths which can present problems with seo and ux to disable this behavior prevent routing based on files in pages simply set the following option in your next config js js next config js module exports usefilesystempublicroutes false note that usefilesystempublicroutes simply disables filename routes from ssr client side routing may still access those paths if using this option you should guard against navigation to routes you do not want programmatically you may also wish to configure the client side router to disallow client side redirects to filename routes please refer to intercepting popstate dynamic assetprefix sometimes we need to set the assetprefix dynamically this is useful when changing the assetprefix based on incoming requests for that we can use app setassetprefix heres an example usage of it js const next require next const micro require micro const dev process env node env production const app next dev const handle app getrequesthandler app prepare then const server micro req res add assetprefix support based on the hostname if req headers host my app com app setassetprefix http cdn com myapp else app setassetprefix handlenextrequests req res server listen port err if err throw err console log ready on http localhost port dynamic import examples with dynamic import next js supports tc39 dynamic import proposal for javascript with that you could import javascript modules inc react components dynamically and work with them you can think dynamic imports as another way to split your code into manageable chunks since next js supports dynamic imports with ssr you could do amazing things with it here are a few ways to use dynamic imports 1 basic usage also does ssr jsx import dynamic from next dynamic const dynamiccomponent dynamic import components hello export default home page is here 2 with custom loading component jsx import dynamic from next dynamic const dynamiccomponentwithcustomloading dynamic import components hello2 loading export default home page is here 3 with no ssr jsx import dynamic from next dynamic const dynamiccomponentwithnossr dynamic import components hello3 ssr false export default home page is here 4 with multiple modules at once jsx import dynamic from next dynamic const hellobundle dynamic modules props const components hello1 import components hello1 hello2 import components hello2 add remove components based on props return components render props hello1 hello2 props title export default custom app examples using app js for layout using app js to override componentdidcatch next js uses the app component to initialize pages you can override it and control the page initialization which allows you to do amazing things like persisting layout between page changes keeping state when navigating pages custom error handling using componentdidcatch inject additional data into pages for example by processing graphql queries to override create the pages app js file and override the app class as shown below js import app container from next app import react from react export default class myapp extends app static async getinitialprops component router ctx let pageprops if component getinitialprops pageprops await component getinitialprops ctx return pageprops render const component pageprops this props return custom document examples styled components custom document google amp is rendered on the server side is used to change the initial server side rendered document markup commonly used to implement server side rendering for css in js libraries like styled components glamorous or emotion styled jsx is included with next js by default pages in next js skip the definition of the surrounding documents markup for example you never include html body etc to override that default behavior you must create a file at pages document js where you can extend the document class jsx document is only rendered on the server side and not on the client side event handlers like onclick cant be added to this file pages document js import document head main nextscript from next document export default class mydocument extends document static async getinitialprops ctx const initialprops await document getinitialprops ctx return initialprops render return code body margin 0 custom code the ctx object is equivalent to the one received in all getinitialprops hooks with one addition renderpage function a callback that executes the actual react rendering logic synchronously its useful to decorate this function in order to support server rendering wrappers like aphrodites renderstatic note react components outside of main will not be initialised by the browser do not add application logic here if you need shared components in all your pages like a menu or a toolbar take a look at the app component instead custom error handling 404 or 500 errors are handled both client and server side by a default component error js if you wish to override it define a error js in the pages folder jsx import react from react export default class error extends react component static getinitialprops res err const statuscode res res statuscode err err statuscode null return statuscode render return this props statuscode an error this props statuscode occurred on server an error occurred on client reusing the built in error page if you want to render the built in error page you can by using next error jsx import react from react import error from next error import fetch from isomorphic unfetch export default class page extends react component static async getinitialprops const res await fetch https api github com repos zeit next js const statuscode res statuscode 200 res statuscode false const json await res json return statuscode stars json stargazers count render if this props statuscode return return div next stars this props stars div if you have created a custom error page you have to import your own error component instead of next error custom configuration for custom advanced behavior of next js you can create a next config js in the root of your project directory next to pages and package json note next config js is a regular node js module not a json file it gets used by the next server and build phases and not included in the browser build js next config js module exports config options here or use a function js module exports phase defaultconfig https github com zeit return config options here phase is the current context in which the configuration is loaded you can see all phases here constants phases can be imported from next constants js const phase development server require next constants module exports phase defaultconfig if phase phase development server return development only config options here return config options for all phases except development here setting a custom build directory you can specify a name to use for a custom build directory for example the following config will create a build folder instead of a next folder if no configuration is specified then next will create a next folder js next config js module exports distdir build disabling etag generation you can disable etag generation for html pages depending on your cache strategy if no configuration is specified then next will generate etags for every page js next config js module exports generateetags false configuring the ondemandentries next exposes some options that give you some control over how the server will dispose or keep in memories pages built js module exports ondemandentries period in ms where the server will keep pages in the buffer maxinactiveage 25 1000 number of pages that should be kept simultaneously without being disposed pagesbufferlength 2 this is development only feature if you want to cache ssr pages in production please see ssr caching example configuring extensions looked for when resolving pages in pages aimed at modules like zeit next typescript that add support for pages ending in ts pageextensions allows you to configure the extensions looked for in the pages directory when resolving pages js next config js module exports pageextensions jsx js configuring the build id next js uses a constant generated at build time to identify which version of your application is being served this can cause problems in multi server deployments when next build is ran on every server in order to keep a static build id between builds you can provide the generatebuildid function js next config js module exports generatebuildid async for example get the latest git commit hash here return my build id customizing webpack config examples custom webpack bundle analyzer some commonly asked for features are available as modules zeit next css zeit next sass zeit next less zeit next preact zeit next typescript warning the webpack function is executed twice once for the server and once for the client this allows you to distinguish between client and server configuration using the isserver property multiple configurations can be combined together with function composition for example js const withtypescript require zeit next typescript const withsass require zeit next sass module exports withtypescript withsass webpack config options further custom configuration here return config in order to extend our usage of webpack you can define a function that extends its config via next config js js next config js is not transformed by babel so you can only use javascript features supported by your version of node js module exports webpack config buildid dev isserver defaultloaders perform customizations to webpack config important return the modified config return config webpackdevmiddleware config perform customizations to webpack dev middleware config important return the modified config return config the second argument to webpack is an object containing properties useful when customing the webpack configuration buildid string the build id used as a unique identifier between builds dev boolean shows if the compilation is done in development mode isserver boolean shows if the resulting configuration will be used for server side true or client size compilation false defaultloaders object holds loader objects next js uses internally so that you can use them in custom configuration babel object the babel loader configuration for next js hotselfaccept object the hot self accept loader configuration this loader should only be used for advanced use cases for example zeit next typescript adds it for top level typescript pages example usage of defaultloaders babel js example next config js for adding a loader that depends on babel loader this source was taken from the zeit next mdx plugin source https github com zeit next plugins blob master packages next mdx module exports webpack config config module rules push test mdx use options defaultloaders babel loader mdx js loader options pluginoptions options return config customizing babel config examples custom babel configuration in order to extend our usage of babel you can simply define a babelrc file at the root of your app this file is optional if found were going to consider it the source of truth therefore it needs to define what next needs as well which is the next babel preset this is designed so that you are not surprised by modifications we could make to the babel configurations heres an example babelrc file json presets next babel plugins the next babel preset includes everything needed to transpile react applications this includes preset env preset react plugin proposal class properties plugin proposal object rest spread plugin transform runtime styled jsx these presets plugins should not be added to your custom babelrc instead you can configure them on the next babel preset json presets next babel preset env transform runtime styled jsx class properties plugins the modules option on preset env should be kept to false otherwise webpack code splitting is disabled exposing configuration to the server client side the config key allows for exposing runtime configuration in your app all keys are server only by default to expose a configuration to both the server and client side you can use the public key js next config js module exports serverruntimeconfig will only be available on the server side mysecret secret publicruntimeconfig will be available on both server and client staticfolder static js pages index js import getconfig from next config only holds serverruntimeconfig and publicruntimeconfig from next config js nothing else const serverruntimeconfig publicruntimeconfig getconfig console log serverruntimeconfig mysecret will only be available on the server side console log publicruntimeconfig staticfolder will be available on both server and client export default publicruntimeconfig staticfolder logo png alt logo cdn support with asset prefix to set up a cdn you can set up the assetprefix setting and configure your cdns origin to resolve to the domain that next js is hosted on js const isprod process env node env production module exports you may only need to add assetprefix in the production assetprefix isprod https cdn mydomain com note next js will automatically use that prefix in the scripts it loads but this has no effect whatsoever on static if you want to serve those assets over the cdn youll have to introduce the prefix yourself one way of introducing a prefix that works inside your components and varies by environment is documented in this example production deployment to deploy instead of running next you want to build for production usage ahead of time therefore building and starting are separate commands bash next build next start for example to deploy with now a package json like follows is recommended json name my app dependencies next latest scripts dev next build next build start next start then run now and enjoy next js can be deployed to other hosting solutions too please have a look at the deployment section of the wiki note node env is properly configured by the next subcommands if absent to maximize performance if youre using next js programmatically its your responsibility to set node env production manually note we recommend putting next or your custom dist folder in gitignore or npmignore otherwise use files or now files to opt into a whitelist of files you want to deploy excluding next or your custom dist folder browser support next js supports ie11 and all modern browsers out of the box using babel preset env without polyfills in cases where your own code or any external npm dependencies you are using requires features not supported by your target browsers you will need to implement polyfills the polyfills example demonstrates the recommended approach to implement polyfills static html export examples static export next export is a way to run your next js app as a standalone static app without the need for a node js server the exported app supports almost every feature of next js including dynamic urls prefetching preloading and dynamic imports the way next export works is by pre rendering all pages possible to html it does so based on a mapping of pathname key to page object this mapping is called the exportpathmap the page object has 2 values page string the page inside the pages directory to render query object the query object passed to getinitialprops when pre rendering defaults to usage simply develop your app as you normally do with next js then run next build next export by default next export doesnt require any configuration it will generate a default exportpathmap containing the routes to pages inside the pages directory if your application has dynamic routes you can add a dynamic exportpathmap in next config js this function is asynchronous and gets the default exportpathmap as a parameter js next config js module exports exportpathmap async function defaultpathmap return page about page about readme md page readme p hello nextjs page post query title hello nextjs p learn nextjs page post query title learn nextjs p deploy nextjs page post query title deploy nextjs note that if the path ends with a directory it will be exported as dir name index html but if it ends with an extension it will be exported as the specified filename e g readme md above if you use a file extension other than html you may need to set the content type header to text html when serving this content then simply run these commands sh next build next export for that you may need to add a npm script to package json like this json scripts build next build export npm run build next export and run it at once with sh npm run export then you have a static version of your app in the out directory you can also customize the output directory for that run next export h for the help now you can deploy the out directory to any static hosting service note that there is an additional step for deploying to github pages documented here for an example simply visit the out directory and run following command to deploy your app to zeit now sh now limitation with next export we build a html version of your app at export time we will run getinitialprops of your pages the req and res fields of the context object passed to getinitialprops are not available as there is no server running you wont be able to render html dynamically when static exporting as we pre build the html files if you want to do dynamic rendering use next start or the custom server api multi zones examples with zones a zone is a single deployment of a next js app just like that you can have multiple zones then you can merge them as a single app for an example you can have two zones like this https docs my app com for serving docs https ui my app com for serving all other pages with multi zones support you can merge both these apps into a single one which allows your customers to browse it using a single url but you can develop and deploy both apps independently this is exactly the same concept as microservices but for frontend apps how to define a zone there are no special zones related apis you only need to do following things make sure to keep only the pages you need in your app for an example https ui my app com should not contain pages for docs make sure your app has an assetprefix you can also define the assetprefix dynamically how to merge them you can merge zones using any http proxy you can use micro proxy as your local proxy server it allows you to easily define routing rules like below json rules pathname docs method get post options dest https docs my app com pathname dest https ui my app com for the production deployment you can use the path alias feature if you are using zeit now otherwise you can configure your existing proxy server to route html pages using a set of rules as show above recipes setting up 301 redirects dealing with ssr and server only modules building with react material ui next express mongoose mongodb build a saas product with react material ui next mobx express mongoose mongodb typescript faq is this production ready next js has been powering https zeit co since its inception were ecstatic about both the developer experience and end user performance so we decided to share it with the community how big is it the client side bundle size should be measured in a per app basis a small next main bundle is around 65kb gzipped is this like create react app yes and no yes in that both make your life easier no in that it enforces a structure so that we can do more advanced things like server side rendering automatic code splitting in addition next js provides two built in features that are critical for every single website routing with lazy component loading link by importing next link a way for components to alter head head by importing next head if you want to create re usable react components that you can embed in your next js app or other react applications using create react app is a great idea you can later import it and keep your codebase clean how do i use css in js solutions next js bundles styled jsx supporting scoped css however you can use any css in js solution in your next app by just including your favorite library as mentioned before in the document what syntactic features are transpiled how do i change them we track v8 since v8 has wide support for es6 and async and await we transpile those since v8 doesnt support class decorators we dont transpile those see this and this why a new router next js is special in that routes dont need to be known ahead of time routes are always lazy loadable top level components can define getinitialprops that should block the loading of the route either when server rendering or lazy loading as a result we were able to introduce a very simple approach to routing that consists of two pieces every top level component receives a url object to inspect the url or perform modifications to the history a link component is used to wrap elements like anchors a to perform client side transitions we tested the flexibility of the routing with some interesting scenarios for an example check out nextgram how do i define a custom fancy route we added the ability to map between an arbitrary url and any component by supplying a request handler on the client side we have a parameter call as on link that decorates the url differently from the url it fetches how do i fetch data its up to you getinitialprops is an async function or a regular function that returns a promise it can retrieve data from anywhere can i use it with graphql yes heres an example with apollo can i use it with redux yes heres an example can i use next with my favorite javascript library or toolkit since our first release weve had many example contributions you can check them out in the examples directory what is this inspired by many of the goals we set out to accomplish were the ones listed in the 7 principles of rich web applications by guillermo rauch the ease of use of php is a great inspiration we feel next js is a suitable replacement for many scenarios where you otherwise would use php to output html unlike php we benefit from the es6 module system and every file exports a component or function that can be easily imported for lazy evaluation or testing as we were researching options for server rendering react that didnt involve a large number of steps we came across react page now deprecated a similar approach to next js by the creator of react jordan walke contributing please see our contributing md authors arunoda susiripala arunoda – zeit tim neutkens timneutkens – zeit naoyuki kanezawa nkzawa – zeit tony kovanen tonykovanen – zeit guillermo rauch rauchg – zeit dan zajdband impronunciable – knight mozilla coral project