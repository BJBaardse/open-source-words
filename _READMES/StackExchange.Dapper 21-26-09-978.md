dapper a simple object mapper for net release notes located at stackexchange github io dapper packages myget pre release feed https www myget org gallery dapper package nuget stable nuget pre release downloads myget dapper dapper contrib dapper entityframework dapper entityframework strongname dapper rainbow dapper sqlbuilder dapper strongname features dapper is a nuget library that you can add in to your project that will extend your idbconnection interface it provides 3 helpers execute a query and map the results to a strongly typed list csharp public static ienumerable t query t this idbconnection cnn string sql object param null sqltransaction transaction null bool buffered true example usage csharp public class dog public int age get set public guid id get set public string name get set public float weight get set public int ignoredproperty get return 1 var guid guid newguid var dog connection query select age age id id new age int null id guid assert equal 1 dog count assert null dog first age assert equal guid dog first id execute a query and map it to a list of dynamic objects csharp public static ienumerable dynamic query this idbconnection cnn string sql object param null sqltransaction transaction null bool buffered true this method will execute sql and return a dynamic list example usage csharp var rows connection query select 1 a 2 b union all select 3 4 assert equal 1 int rows 0 a assert equal 2 int rows 0 b assert equal 3 int rows 1 a assert equal 4 int rows 1 b execute a command that returns no results csharp public static int execute this idbconnection cnn string sql object param null sqltransaction transaction null example usage csharp var count connection execute set nocount on create table t i int set nocount off insert t select a a union all select b set nocount on drop table t new a 1 b 2 assert equal 2 count execute a command multiple times the same signature also allows you to conveniently and efficiently execute a command multiple times for example to bulk load data example usage csharp var count connection execute insert mytable cola colb values a b new new a 1 b 1 new a 2 b 2 new a 3 b 3 assert equal 3 count 3 rows inserted 1 1 2 2 and 3 3 this works for any parameter that implements ienumerable for some t performance a key feature of dapper is performance the following metrics show how long it takes to execute 500 select statements against a db and map the data returned to objects the performance tests are broken in to 3 lists poco serialization for frameworks that support pulling static typed objects from the db using raw sql dynamic serialization for frameworks that support returning dynamic lists of objects typical framework usage often typical framework usage differs from the optimal usage performance wise often it will not involve writing sql performance of select mapping over 500 iterations poco serialization method duration remarks hand coded using a sqldatareader 47ms dapper executemapperquery 49ms servicestack ormlite querybyid 50ms petapoco 52ms can be faster bltoolkit 80ms subsonic codinghorror 107ms nhibernate sql 104ms linq 2 sql executequery 181ms entity framework executestorequery 631ms performance of select mapping over 500 iterations dynamic serialization method duration remarks dapper executemapperquery dynamic 48ms massive 52ms simple data 95ms performance of select mapping over 500 iterations typical usage method duration remarks linq 2 sql compiledquery 81ms not super typical involves complex code nhibernate hql 118ms linq 2 sql 559ms entity framework 859ms subsonic activerecord singleordefault 3619ms performance benchmarks are available here feel free to submit patches that include other orms when running benchmarks be sure to compile in release and not attach a debugger ctrl f5 alternatively you might prefer frans boumas rawdataaccessbencher test suite or ormbenchmark parameterized queries parameters are passed in as anonymous classes this allow you to name your parameters easily and gives you the ability to simply cut and paste sql snippets and run them in your db platforms query analyzer csharp new a 1 b b a will be mapped to the param a b to the param b list support dapper allows you to pass in ienumerable int and will automatically parameterize your query for example csharp connection query int select from select 1 as id union all select 2 union all select 3 as x where id in ids new ids new int 1 2 3 will be translated to csharp select from select 1 as id union all select 2 union all select 3 as x where id in ids1 ids2 ids3 ids1 1 ids2 2 ids2 3 literal replacements dapper supports literal replacements for bool and numeric types csharp connection query select from user where userid id new id 1 the literal replacement is not sent as a parameter this allows better plans and filtered index usage but should usually be used sparingly and after testing this feature is particularly useful when the value being injected is actually a fixed value for example a fixed category id status code or region that is specific to the query for live data where you are considering literals you might also want to consider and test provider specific query hints like optimize for unknown with regular parameters buffered vs unbuffered readers dappers default behavior is to execute your sql and buffer the entire reader on return this is ideal in most cases as it minimizes shared locks in the db and cuts down on db network time however when executing huge queries you may need to minimize memory footprint and only load objects as needed to do so pass buffered false into the query method multi mapping dapper allows you to map a single row to multiple objects this is a key feature if you want to avoid extraneous querying and eager load associations example consider 2 classes post and user csharp class post public int id get set public string title get set public string content get set public user owner get set class user public int id get set public string name get set now let us say that we want to map a query that joins both the posts and the users table until now if we needed to combine the result of 2 queries wed need a new object to express it but it makes more sense in this case to put the user object inside the post object this is the user case for multi mapping you tell dapper that the query returns a post and a user object and then give it a function describing what you want to do with each of the rows containing both a post and a user object in our case we want to take the user object and put it inside the post object so we write the function csharp post user post owner user return post the 3 type arguments to the query method specify what objects dapper should use to deserialize the row and what is going to be returned were going to interpret both rows as a combination of post and user and were returning back a post object hence the type declaration becomes csharp post user post everything put together looks like this csharp var sql select from posts p left join users u on u id p ownerid order by p id var data connection query sql post user post owner user return post var post data first assert equal sams post1 post content assert equal 1 post id assert equal sam post owner name assert equal 99 post owner id dapper is able to split the returned row by making an assumption that your id columns are named id or id if your primary key is different or you would like to split the row at a point other than id use the optional spliton parameter multiple results dapper allows you to process multiple result grids in a single query example csharp var sql select from customers where customerid id select from orders where customerid id select from returns where customerid id using var multi connection querymultiple sql new id selectedid var customer multi read single var orders multi read tolist var returns multi read tolist stored procedures dapper fully supports stored procs csharp var user cnn query user spgetuser new id 1 commandtype commandtype storedprocedure singleordefault if you want something more fancy you can do csharp var p new dynamicparameters p add a 11 p add b dbtype dbtype int32 direction parameterdirection output p add c dbtype dbtype int32 direction parameterdirection returnvalue cnn execute spmagicproc p commandtype commandtype storedprocedure int b p get b int c p get c ansi strings and varchar dapper supports varchar params if you are executing a where clause on a varchar column using a param be sure to pass it in this way csharp query thing select from thing where name name new name new dbstring value abcde isfixedlength true length 10 isansi true on sql server it is crucial to use the unicode when querying unicode and ansi when querying non unicode type switching per row usually youll want to treat all rows from a given table as the same data type however there are some circumstances where its useful to be able to parse different rows as different data types this is where idatareader getrowparser comes in handy imagine you have a database table named shapes with the columns id type and data and you want to parse its rows into circle square or triangle objects based on the value of the type column csharp var shapes new list using var reader connection executereader select from shapes generate a row parser for each type you expect the generic type is what the parser will return the argument typeof is the concrete type to parse var circleparser reader getrowparser typeof circle var squareparser reader getrowparser typeof square var triangleparser reader getrowparser typeof triangle var typecolumnindex reader getordinal type while reader read ishape shape var type shapetype reader getint32 typecolumnindex switch type case shapetype circle shape circleparser reader break case shapetype square shape squareparser reader break case shapetype triangle shape triangleparser reader break default throw new notimplementedexception shapes add shape limitations and caveats dapper caches information about every query it runs this allow it to materialize objects quickly and process parameters quickly the current implementation caches this information in a concurrentdictionary object statements that are only used once are routinely flushed from this cache still if you are generating sql strings on the fly without using parameters it is possible you may hit memory issues dappers simplicity means that many feature that orms ship with are stripped out it worries about the 95 scenario and gives you the tools you need most of the time it doesnt attempt to solve every problem will dapper work with my db provider dapper has no db specific implementation details it works across all net ado providers including sqlite sql ce firebird oracle mysql postgresql and sql server do you have a comprehensive list of examples dapper has a comprehensive test suite in the test project who is using this dapper is in production use at stack overflow