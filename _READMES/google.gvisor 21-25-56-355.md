gvisor gvisor is a user space kernel written in go that implements a substantial portion of the linux system surface it includes an open container initiative oci runtime called runsc that provides an isolation boundary between the application and the host kernel the runsc runtime integrates with docker and kubernetes making it simple to run sandboxed containers gvisor takes a distinct approach to container sandboxing and makes a different set of technical trade offs compared to existing sandbox technologies thus providing new tools and ideas for the container security landscape why does gvisor exist containers are not a sandbox while containers have revolutionized how we develop package and deploy applications running untrusted or potentially malicious code without additional isolation is not a good idea the efficiency and performance gains from using a single shared kernel also mean that container escape is possible with a single vulnerability gvisor is a user space kernel for containers it limits the host kernel surface accessible to the application while still giving the application access to all the features it expects unlike most kernels gvisor does not assume or require a fixed set of physical resources instead it leverages existing host kernel functionality and runs as a normal user space process in other words gvisor implements linux by way of linux gvisor should not be confused with technologies and tools to harden containers against external threats provide additional integrity checks or limit the scope of access for a service one should always be careful about what data is made available to a container how is gvisor different from other container isolation mechanisms two other approaches are commonly taken to provide stronger isolation than native containers machine level virtualization such as kvm and xen exposes virtualized hardware to a guest kernel via a virtual machine monitor vmm this virtualized hardware is generally enlightened paravirtualized and additional mechanisms can be used to improve the visibility between the guest and host e g balloon drivers paravirtualized spinlocks running containers in distinct virtual machines can provide great isolation compatibility and performance though nested virtualization may bring challenges in this area but for containers it often requires additional proxies and agents and may require a larger resource footprint and slower start up times rule based execution such as seccomp selinux and apparmor allows the specification of a fine grained security policy for an application or container these schemes typically rely on hooks implemented inside the host kernel to enforce the rules if the surface can be made small enough i e a sufficiently complete policy defined then this is an excellent way to sandbox applications and maintain native performance however in practice it can be extremely difficult if not impossible to reliably define a policy for arbitrary previously unknown applications making this approach challenging to apply universally rule based execution is often combined with additional layers for defense in depth gvisor provides a third isolation mechanism distinct from those mentioned above gvisor intercepts application system calls and acts as the guest kernel without the need for translation through virtualized hardware gvisor may be thought of as either a merged guest kernel and vmm or as seccomp on steroids this architecture allows it to provide a flexible resource footprint i e one based on threads and memory mappings not fixed guest physical resources while also lowering the fixed costs of virtualization however this comes at the price of reduced application compatibility and higher per system call overhead on top of this gvisor employs rule based execution to provide defense in depth details below gvisors approach is similar to user mode linux uml although uml virtualizes hardware internally and thus provides a fixed resource footprint each of the above approaches may excel in distinct scenarios for example machine level virtualization will face challenges achieving high density while gvisor may provide poor performance for system call heavy workloads why go gvisor was written in go in order to avoid security pitfalls that can plague kernels with go there are strong types built in bounds checks no uninitialized variables no use after free no stack overflow and a built in race detector the use of go has its challenges too and isnt free architecture gvisor intercepts all system calls made by the application and does the necessary work to service them importantly gvisor does not simply redirect application system calls through to the host kernel instead gvisor implements most kernel primitives signals file systems futexes pipes mm etc and has complete system call handlers built on top of these primitives since gvisor is itself a user space application it will make some host system calls to support its operation but much like a vmm it will not allow the application to directly control the system calls it makes file system access in order to provide defense in depth and limit the host system surface the gvisor container runtime is normally split into two separate processes first the sentry process includes the kernel and is responsible for executing user code and handling system calls second file system operations that extend beyond the sandbox not internal proc or tmp files pipes etc are sent to a proxy called a gofer via a 9p connection the gofer acts as a file system proxy by opening host files on behalf of the application and passing them to the sentry process which has no host file access itself furthermore the sentry runs in an empty user namespace and the system calls made by gvisor to the host are restricted using seccomp filters in order to provide defense in depth network access the sentry implements its own network stack also written in go called netstack all aspects of the network stack are handled inside the sentry — including tcp connection state control messages and packet assembly — keeping it isolated from the host network stack data link layer packets are written directly to the virtual device inside the network namespace setup by docker or kubernetes a network passthrough mode is also supported but comes at the cost of reduced isolation see below platforms the sentry requires a platform to implement basic context switching and memory mapping functionality today gvisor supports two platforms the ptrace platform uses sysemu functionality to execute user code without executing host system calls this platform can run anywhere that ptrace works even vms without nested virtualization the kvm platform experimental allows the sentry to act as both guest os and vmm switching back and forth between the two worlds seamlessly the kvm platform can run on bare metal or on a vm with nested virtualization enabled while there is no virtualized hardware layer the sandbox retains a process model gvisor leverages virtualization extensions available on modern processors in order to improve isolation and performance of address space switches performance there are several factors influencing performance the platform choice has the largest direct impact that varies depending on the specific workload there is no best platform ptrace works universally including on vm instances but applications may perform at a fraction of their original levels beyond the platform choice passthrough modes may be useful for improving perfomance at the cost of some isolation installation these instructions will get you up and running sandboxed containers with gvisor and docker note that gvisor can only run on x86 64 linux 3 17 in addition gvisor only supports x86 64 binaries inside the sandbox i e it cannot run 32 bit binaries download a build the easiest way to get runsc is from the latest nightly build after you download the binary check it against the sha512 checksum file older builds can be found here https storage googleapis com gvisor releases nightly yyyy mm dd runsc and https storage googleapis com gvisor releases nightly yyyy mm dd runsc sha512 it is important to copy this binary to some place that is accessible to all users since runsc executes itself as user nobody to avoid unnecessary privileges the usr local bin directory is a good choice wget https storage googleapis com gvisor releases nightly latest runsc wget https storage googleapis com gvisor releases nightly latest runsc sha512 sha512sum c runsc sha512 chmod x runsc sudo mv runsc usr local bin configuring docker next configure docker to use runsc by adding a runtime entry to your docker configuration etc docker daemon json you may have to create this file if it does not exist also some docker versions also require you to specify the storage driver field in the end the file should look something like runtimes runsc path usr local bin runsc you must restart the docker daemon after making changes to this file typically this is done via sudo systemctl restart docker now run your container in runsc docker run runtime runsc hello world terminal support works too docker run runtime runsc it ubuntu bin bash kubernetes support experimental gvisor can run sandboxed containers in a kubernetes cluster with cri o although this is not recommended for production environments yet follow these instructions to run cri o on a node in a kubernetes cluster build runsc and put it on the node and set it as the runtime untrusted workload in etc crio crio conf any pod without the io kubernetes cri o trustedsandbox annotation or with the annotation set to false will be run with runsc currently gvisor only supports pods with a single container not counting the ever present pause container support for multiple containers within a single pod is coming soon advanced usage installing from source gvisor currently requires x86 64 linux to build requirements make sure the following dependencies are installed git bazel python docker version 17 09 0 or greater gold linker e g binutils gold package on ubuntu getting the source clone the gvisor repo git clone https gvisor googlesource com gvisor gvisor cd gvisor building build and install the runsc binary bazel build runsc sudo cp bazel bin runsc linux amd64 pure stripped runsc usr local bin testing the gvisor test suite can be run with bazel bazel test debugging to enable debug and system call logging add the runtimeargs below to your docker configuration etc docker daemon json runtimes runsc path usr local bin runsc runtimeargs debug log dir tmp runsc debug strace you may also want to pass log packets to troubleshoot network problems then restart the docker daemon sudo systemctl restart docker run your container again and inspect the files under tmp runsc the log file with name boot will contain the strace logs from your application which can be useful for identifying missing or broken system calls in gvisor enabling network passthrough for high performance networking applications you may choose to disable the user space network stack and instead use the host network stack note that this mode decreases the isolation to the host add the following runtimeargs to your docker configuration etc docker daemon json and restart the docker daemon runtimes runsc path usr local bin runsc runtimeargs network host selecting a different platform depending on hardware and performance characteristics you may choose to use a different platform the ptrace platform is the default but the kvm platform may be specified by passing the platform flag to runsc in your docker configuration etc docker daemon json runtimes runsc path usr local bin runsc runtimeargs platform kvm then restart the docker daemon faq known issues will my container work with gvisor gvisor implements a large portion of the linux surface and while we strive to make it broadly compatible there are and always will be unimplemented features and bugs the only real way to know if it will work is to try if you find a container that doesnt work and there is no known issue please file a bug indicating the full command you used to run the image providing the debug logs is also helpful what works the following applications images have been tested elasticsearch golang httpd java8 jenkins mariadb memcached mongo mysql nginx node php postgres prometheus python redis registry tomcat wordpress my container runs fine with runc but fails with runsc if youre having problems running a container with runsc its most likely due to a compatibility issue or a missing feature in gvisor see debugging above when i run my container docker fails with flag provided but not defined console youre using an old version of docker refer to the requirements section for the minimum version supported i cant see a file copied with docker cp or kubectl cp for performance reasons gvisor caches directory contents and therefore it may not realize a new file was copied to a given directory to invalidate the cache and force a refresh create a file under the directory in question and list the contents again this bug is tracked in bug 4 technical details we plan to release a full paper with technical details and will include it here when available community join the gvisor users mailing list to discuss all things gvisor sensitive security related questions and comments can be sent to the private gvisor security mailing list contributing see contributing md