pundit pundit provides a set of helpers which guide you in leveraging regular ruby classes and object oriented design patterns to build a simple robust and scaleable authorization system links api documentation source code contributing code of conduct sponsored by installation ruby gem pundit include pundit in your application controller ruby class applicationcontroller actioncontroller base include pundit protect from forgery end optionally you can run the generator which will set up an application policy with some useful defaults for you sh rails g pundit install after generating your application policy restart the rails server so that rails can pick up any classes in the new app policies directory policies pundit is focused around the notion of policy classes we suggest that you put these classes in app policies this is a simple example that allows updating a post if the user is an admin or if the post is unpublished ruby class postpolicy attr reader user post def initialize user post user user post post end def update user admin or not post published end end as you can see this is just a plain ruby class pundit makes the following assumptions about this class the class has the same name as some kind of model class only suffixed with the word policy the first argument is a user in your controller pundit will call the current user method to retrieve what to send into this argument the second argument is some kind of model object whose authorization you want to check this does not need to be an activerecord or even an activemodel object it can be anything really the class implements some kind of query method in this case update usually this will map to the name of a particular controller action thats it really usually youll want to inherit from the application policy created by the generator or set up your own base class to inherit from ruby class postpolicy applicationpolicy def update user admin or not record published end end in the generated applicationpolicy the model object is called record supposing that you have an instance of class post pundit now lets you do this in your controller ruby def update post post find params id authorize post if post update post params redirect to post else render edit end end the authorize method automatically infers that post will have a matching postpolicy class and instantiates this class handing in the current user and the given record it then infers from the action name that it should call update on this instance of the policy in this case you can imagine that authorize would have done something like this ruby unless postpolicy new current user post update raise pundit notauthorizederror not allowed to update this post inspect end you can pass a second argument to authorize if the name of the permission you want to check doesnt match the action name for example ruby def publish post post find params id authorize post update post publish redirect to post end you can pass an argument to override the policy class if necessary for example ruby def create publication find publication assume this method returns any model that behaves like a publication publication class post authorize publication policy class publicationpolicy publication publish redirect to publication end if you dont have an instance for the first argument to authorize then you can pass the class for example policy ruby class postpolicy applicationpolicy def admin list user admin end end controller ruby def admin list authorize post we dont have a particular post to authorize rest of controller action end authorize returns the object passed to it so you can chain it like this controller ruby def show user authorize user find params id end you can easily get a hold of an instance of the policy through the policy method in both the view and controller this is especially useful for conditionally showing links or buttons in the view erb if policy post update link to edit post edit post path post end headless policies given there is a policy without a corresponding model ruby class you can retrieve it by passing a symbol ruby app policies dashboard policy rb class dashboardpolicy struct new user dashboard end ruby in controllers authorize dashboard show erb in views if policy dashboard show link to dashboard dashboard path end scopes often you will want to have some kind of view listing records which a particular user has access to when using pundit you are expected to define a class called a policy scope it can look something like this ruby class postpolicy applicationpolicy class scope attr reader user scope def initialize user scope user user scope scope end def resolve if user admin scope all else scope where published true end end end def update user admin or not record published end end pundit makes the following assumptions about this class the class has the name scope and is nested under the policy class the first argument is a user in your controller pundit will call the current user method to retrieve what to send into this argument the second argument is a scope of some kind on which to perform some kind of query it will usually be an activerecord class or a activerecord relation but it could be something else entirely instances of this class respond to the method resolve which should return some kind of result which can be iterated over for activerecord classes this would usually be an activerecord relation youll probably want to inherit from the application policy scope generated by the generator or create your own base class to inherit from ruby class postpolicy applicationpolicy class scope scope def resolve if user admin scope all else scope where published true end end end def update user admin or not record published end end you can now use this class from your controller via the policy scope method ruby def index posts policy scope post end def show post policy scope post find params id end like with the authorize method you can also override the policy scope class ruby def index publication class post publications policy scope publication class policy scope class publicationpolicy scope end just as with your policy this will automatically infer that you want to use the postpolicy scope class it will instantiate this class and call resolve on the instance in this case it is a shortcut for doing ruby def index posts postpolicy scope new current user post resolve end you can and are encouraged to use this method in views erb policy scope user posts each do post p link to post title post path post p end ensuring policies and scopes are used when you are developing an application with pundit it can be easy to forget to authorize some action people are forgetful after all since pundit encourages you to add the authorize call manually to each controller action its really easy to miss one thankfully pundit has a handy feature which reminds you in case you forget pundit tracks whether you have called authorize anywhere in your controller action pundit also adds a method to your controllers called verify authorized this method will raise an exception if authorize has not yet been called you should run this method in an after action hook to ensure that you havent forgotten to authorize the action for example ruby class applicationcontroller actioncontroller base include pundit after action verify authorized end likewise pundit also adds verify policy scoped to your controller this will raise an exception similar to verify authorized however it tracks if policy scope is used instead of authorize this is mostly useful for controller actions like index which find collections with a scope and dont authorize individual instances ruby class applicationcontroller actioncontroller base include pundit after action verify authorized except index after action verify policy scoped only index end this verification mechanism only exists to aid you while developing your application so you dont forget to call authorize it is not some kind of failsafe mechanism or authorization mechanism you should be able to remove these filters without affecting how your app works in any way some people have found this feature confusing while many others find it extremely helpful if you fall into the category of people who find it confusing then you do not need to use it pundit will work just fine without using verify authorized and verify policy scoped conditional verification if youre using verify authorized in your controllers but need to conditionally bypass verification you can use skip authorization for bypassing verify policy scoped use skip policy scope these are useful in circumstances where you dont want to disable verification for the entire action but have some cases where you intend to not authorize ruby def show record record find by attribute value if record present authorize record else skip authorization end end manually specifying policy classes sometimes you might want to explicitly declare which policy to use for a given class instead of letting pundit infer it this can be done like so ruby class post def self policy class postablepolicy end end just plain old ruby as you can see pundit doesnt do anything you couldnt have easily done yourself its a very small library it just provides a few neat helpers together these give you the power of building a well structured fully working authorization system without using any special dsls or funky syntax or anything remember that all of the policy and scope classes are just plain ruby classes which means you can use the same mechanisms you always use to dry things up encapsulate a set of permissions into a module and include them in multiple policies use alias method to make some permissions behave the same as others inherit from a base set of permissions use metaprogramming if you really have to generator use the supplied generator to generate policies sh rails g pundit policy post closed systems in many applications only logged in users are really able to do anything if youre building such a system it can be kind of cumbersome to check that the user in a policy isnt nil for every single permission aside from policies you can add this check to the base class for scopes we suggest that you define a filter that redirects unauthenticated users to the login page as a secondary defence if youve defined an applicationpolicy it might be a good idea to raise an exception if somehow an unauthenticated user got through this way you can fail more gracefully ruby class applicationpolicy def initialize user record raise pundit notauthorizederror must be logged in unless user user user record record end class scope attr reader user scope def initialize user scope raise pundit notauthorizederror must be logged in unless user user user scope scope end end end nilclasspolicy to support a null object pattern you may find that you want to implement a nilclasspolicy this might be useful where you want to extend your applicationpolicy to allow some tolerance of for example associations which might be nil ruby class nilclasspolicy applicationpolicy class scope scope def resolve raise pundit notdefinederror cannot scope nilclass end end def show false nobody can see nothing end end rescuing a denied authorization in rails pundit raises a pundit notauthorizederror you can rescue from in your applicationcontroller you can customize the user not authorized method in every controller ruby class applicationcontroller actioncontroller base protect from forgery include pundit rescue from pundit notauthorizederror with user not authorized private def user not authorized flash alert you are not authorized to perform this action redirect to request referrer root path end end alternatively you can globally handle pundit notauthorizederrors by having rails handle them as a 403 error and serving a 403 error page add the following to application rb config action dispatch rescue responses pundit notauthorizederror forbidden creating custom error messages notauthorizederrors provide information on what query e g create what record e g an instance of post and what policy e g an instance of postpolicy caused the error to be raised one way to use these query record and policy properties is to connect them with i18n to generate error messages heres how you might go about doing that ruby class applicationcontroller actioncontroller base rescue from pundit notauthorizederror with user not authorized private def user not authorized exception policy name exception policy class to s underscore flash error t policy name exception query scope pundit default default redirect to request referrer root path end end yaml en pundit default you cannot perform this action post policy update you cannot edit this post create you cannot create posts of course this is just an example pundit is agnostic as to how you implement your error messaging manually retrieving policies and scopes sometimes you want to retrieve a policy for a record outside the controller or view for example when you delegate permissions from one policy to another you can easily retrieve policies and scopes like this ruby pundit policy user post pundit policy user post pundit policy scope user post pundit policy scope user post the bang methods will raise an exception if the policy does not exist whereas those without the bang will return nil customize pundit user in some cases your controller might not have access to current user or your current user is not the method that should be invoked by pundit simply define a method in your controller called pundit user ruby def pundit user user find by other means end policy namespacing in some cases it might be helpful to have multiple policies that serve different contexts for a resource a prime example of this is the case where user policies differ from admin policies to authorize with a namespaced policy pass the namespace into the authorize helper in an array ruby authorize post will look for a postpolicy authorize admin post will look for an admin postpolicy authorize foo bar post will look for a foo bar postpolicy policy scope post will look for a postpolicy scope policy scope admin post will look for an admin postpolicy scope policy scope foo bar post will look for a foo bar postpolicy scope if you are using namespaced policies for something like admin views it can be useful to override the policy scope and authorize helpers in your admincontroller to automatically apply the namespacing ruby class admincontroller applicationcontroller def policy scope scope super admin scope end def authorize record query nil super admin record query end end class admin postcontroller admincontroller def index policy scope post end def show post post find params id authorize post end end additional context pundit strongly encourages you to model your application in such a way that the only context you need for authorization is a user object and a domain model that you want to check authorization for if you find yourself needing more context than that consider whether you are authorizing the right domain model maybe another domain model or a wrapper around multiple domain models can provide the context you need pundit does not allow you to pass additional arguments to policies for precisely this reason however in very rare cases you might need to authorize based on more context than just the currently authenticated user suppose for example that authorization is dependent on ip address in addition to the authenticated user in that case one option is to create a special class which wraps up both user and ip and passes it to the policy ruby class usercontext attr reader user ip def initialize user ip user user ip ip end end class applicationcontroller include pundit def pundit user usercontext new current user request ip end end strong parameters in rails 4 or rails 3 2 with the strong parameters gem mass assignment protection is handled in the controller with pundit you can control which attributes a user has access to update via your policies you can set up a permitted attributes method in your policy like this ruby app policies post policy rb class postpolicy applicationpolicy def permitted attributes if user admin user owner of post title body tag list else tag list end end end you can now retrieve these attributes from the policy ruby app controllers posts controller rb class postscontroller applicationcontroller def update post post find params id if post update attributes post params redirect to post else render edit end end private def post params params require post permit policy post permitted attributes end end however this is a bit cumbersome so pundit provides a convenient helper method ruby app controllers posts controller rb class postscontroller applicationcontroller def update post post find params id if post update attributes permitted attributes post redirect to post else render edit end end end if you want to permit different attributes based on the current action you can define a permitted attributes for action method on your policy ruby app policies post policy rb class postpolicy applicationpolicy def permitted attributes for create title body end def permitted attributes for edit body end end if you have defined an action specific method on your policy for the current action the permitted attributes helper will call it instead of calling permitted attributes on your controller if you need to fetch parameters based on namespaces different from the suggested one override the below method in your controller and return an instance of actioncontroller parameters ruby def pundit params for record params require policyfinder new record param key end for example ruby if you dont want to use require def pundit params for record params fetch policyfinder new record param key end if you are using something like the json api spec def pundit params for record params fetch data fetch attributes end rspec policy specs pundit includes a mini dsl for writing expressive tests for your policies in rspec require pundit rspec in your spec helper rb ruby require pundit rspec then put your policy specs in spec policies and make them look somewhat like this ruby describe postpolicy do subject described class permissions update edit do it denies access if post is published do expect subject not to permit user new admin false post new published true end it grants access if post is published and user is an admin do expect subject to permit user new admin true post new published true end it grants access if post is unpublished do expect subject to permit user new admin false post new published false end end end an alternative approach to pundit policy specs is scoping them to a user context as outlined in this excellent post and implemented in the third party pundit matchers gem scope specs pundit does not provide a dsl for testing scopes just test it like a regular ruby class external resources railsapps example application pundit and devise migrating to pundit from cancan testing pundit policies with rspec using pundit outside of a rails controller straightforward rails authorization with pundit license licensed under the mit license see the separate license txt file