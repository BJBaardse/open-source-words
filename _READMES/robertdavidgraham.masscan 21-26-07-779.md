masscan mass ip port scanner this is the fastest internet port scanner it can scan the entire internet in under 6 minutes transmitting 10 million packets per second it produces results similar to nmap the most famous port scanner internally it operates more like scanrand unicornscan and zmap using asynchronous transmission the major difference is that its faster than these other scanners in addition its more flexible allowing arbitrary address ranges and port ranges note masscan uses a custom tcp ip stack anything other than simple port scans will cause conflict with the local tcp ip stack this means you need to either use the s option to use a separate ip address or configure your operating system to firewall the ports that masscan uses this tool is free but consider funding it here bitcoin wallet address 1masscanahuiyttr3bj2slgumw5kdbaj4t building on debian ubuntu it goes something like this sudo apt get install git gcc make libpcap dev git clone https github com robertdavidgraham masscan cd masscan make this puts the program in the masscan bin subdirectory youll have to manually copy it to something like usr local bin if you want to install it elsewhere on the system the source consists of a lot of small files so building goes a lot faster by using the multi threaded build make j while linux is the primary target platform the code runs well on many other systems heres some additional build info windows w visual studio use the vs10 project windows w minggw just type make windows w cygwin wont work mac os x w xcode use the xcode4 project mac os x w cmdline just type make freebsd type gmake other i dont know dont care pf ring to get beyond 2 million packets second you need an intel 10 gbps ethernet adapter and a special driver known as pf ring zc from ntop masscan doesnt need to be rebuilt in order to use pf ring to use pf ring you need to build the following components libpfring so installed in usr lib libpfring so pf ring ko their kernel driver ixgbe ko their version of the intel 10 gbps ethernet driver you dont need to build their version of libpcap so when masscan detects that an adapter is named something like zc enp1s0 instead of something like enp1s0 itll automatically switch to pf ring zc mode regression testing the project contains a built in self test make regress bin masscan regress selftest success this tests a lot of tricky bits of the code you should do this after building performance testing to test performance run something like the following bin masscan 0 0 0 0 4 p80 rate 100000000 router mac 66 55 44 33 22 11 the bogus router mac keeps packets on the local network segments so that they wont go out to the internet you can also test in offline mode which is how fast the program runs without the transmit overhead bin masscan 0 0 0 0 4 p80 rate 100000000 offline this second benchmark shows roughly how fast the program would run if it were using pf ring which has near zero overhead usage usage is similar to nmap to scan a network segment for some ports masscan p80 8000 8100 10 0 0 0 8 this will scan the 10 x x x subnet all 16 million addresses scans port 80 and the range 8000 to 8100 or 102 addresses total print output to stdout that can be redirected to a file to see the complete list of options use the echo feature this dumps the current configuration and exits this output can be used as input back into the program masscan p80 8000 8100 10 0 0 0 8 echo xxx conf masscan c xxx conf rate 1000 banner checking masscan can do more than just detect whether ports are open it can also complete the tcp connection and interaction with the application at that port in order to grab simple banner information the problem with this is that masscan contains its own tcp ip stack separate from the system you run it on when the local system receives a syn ack from the probed target it responds with a rst packet that kills the connection before masscan can grab the banner the easiest way to prevent this is to assign masscan a separate ip address this would look like the following masscan 10 0 0 0 8 p80 banners source ip 192 168 1 200 the address you choose has to be on the local subnet and not otherwise be used by another system in some cases such as wifi this isnt possible in those cases you can firewall the port that masscan uses this prevents the local tcp ip stack from seeing the packet but masscan still sees it since it bypasses the local stack for linux this would look like iptables a input p tcp dport 60000 j drop masscan 10 0 0 0 8 p80 banners source port 60000 on mac os x and bsd it might look like this sudo ipfw add 1 deny tcp from any to any 60000 in masscan 10 0 0 0 8 p80 banners source port 60000 windows doesnt respond with rst packets so neither of these techniques are necessary however masscan is still designed to work best using its own ip address so you should run that way when possible even when its not strictly necessary the same thing is needed for other checks such as the heartbleed check which is just a form of banner checking how to scan the entire internet while useful for smaller internal networks the program is really designed with the entire internet in mind it might look something like this masscan 0 0 0 0 0 p0 65535 scanning the entire internet is bad for one thing parts of the internet react badly to being scanned for another thing some sites track scans and add you to a ban list which will get you firewalled from useful parts of the internet therefore you want to exclude a lot of ranges to blacklist or exclude ranges you want to use the following syntax masscan 0 0 0 0 0 p0 65535 excludefile exclude txt this just prints the results to the command line you probably want them saved to a file instead therefore you want something like masscan 0 0 0 0 0 p0 65535 ox scan xml this saves the results in an xml file allowing you to easily dump the results in a database or something but this only goes at the default rate of 100 packets second which will take forever to scan the internet you need to speed it up as so masscan 0 0 0 0 0 p0 65535 max rate 100000 this increases the rate to 100 000 packets second which will scan the entire internet minus excludes in about 10 hours per port or 655 360 hours if scanning all ports the thing to notice about this command line is that these are all nmap compatible options in addition invisible options compatible with nmap are also set for you ss pn n randomize hosts send eth likewise the format of the xml file is inspired by nmap there are of course a lot of differences because the asynchronous nature of the program leads to a fundamentally different approach to the problem the above command line is a bit cumbersome instead of putting everything on the command line it can be stored in a file instead the above settings would look like this my scan rate 100000 00 output format xml output status all output filename scan xml ports 0 65535 range 0 0 0 0 255 255 255 255 excludefile exclude txt to use this configuration file use the c masscan c myscan conf this also makes things easier when you repeat a scan by default masscan first loads the configuration file etc masscan masscan conf any later configuration parameters override whats in this default configuration file thats where i put my excludefile parameter so that i dont ever forget it it just works automatically getting output by default masscan produces fairly large text files but its easy to convert them into any other format there are five supported output formats xml just use the parameter ox filename or use the parameters output format xml and output filename filename binary this is the masscan builtin format it produces much smaller files so that when i scan the internet my disk doesnt fill up they need to be parsed though the command line option readscan will read binary scan files using readscan with the ox option will produce a xml version of the results file grepable this is an implementation of the nmap og output that can be easily parsed by command line tools just use the parameter og filename or use the parameters output format grepable and output filename filename json this saves the results in json format just use the parameter oj filename or use the parameters output format json and output filename filename list this is a simple list with one host and port pair per line just use the parameter ol filename or use the parameters output format list and output filename filename the format is port state protocol port number ip address posix timestamp open tcp 80 xxx xxx xxx xxx 1390380064 comparison with nmap where reasonable every effort has been taken to make the program familiar to nmap users even though its fundamentally different two important differences are no default ports to scan you must specify p ports target hosts are ip addresses or simple ranges not dns names nor the funky subnet ranges nmap can use like 10 0 0 255 0 255 you can think of masscan as having the following settings permanently enabled ss this does syn scan only currently will change in the future pn doesnt ping hosts first which is fundamental to the async operation n no dns resolution happens randomize hosts scan completely randomized send eth sends using raw libpcap if you want a list of additional nmap compatible settings use the following command masscan nmap transmit rate important this program spews out packets very fast on windows or from vms it can do 300 000 packets second on linux no virtualization itll do 1 6 million packets per second thats fast enough to melt most networks note that itll only melt your own network it randomizes the target ip addresses so that it shouldnt overwhelm any distant network by default the rate is set to 100 packets second to increase the rate to a million use something like rate 1000000 design this section describes the major design issues of the program code layout the file main c contains the main function as youd expect it also contains the transmit thread and receive thread functions these functions have been deliberately flattened and heavily commented so that you can read the design of the program simply by stepping line by line through each of these asynchronous this is an asynchronous design in other words it is to nmap what the nginx web server is to apache it has separate transmit and receive threads that are largely independent from each other its the same sort of design found in scanrand unicornscan and zmap because its asynchronous it runs as fast as the underlying packet transmit allows randomization a key difference between masscan and other scanners is the way it randomizes targets the fundamental principle is to have a single index variable that starts at zero and is incremented by one for every probe in c code this is expressed as for i 0 i range i scan i we have to translate the index into an ip address lets say that you want to scan all private ip addresses that would be the table of ranges like 192 168 0 0 16 10 0 0 0 8 172 16 0 0 12 in this example the first 64k indexes are appended to 192 168 x x to form the target address then the next 16 million are appended to 10 x x x the remaining indexes in the range are applied to 172 16 x x in this example we only have three ranges when scanning the entire internet we have in practice more than 100 ranges thats because you have to blacklist or exclude a lot of sub ranges this chops up the desired range into hundreds of smaller ranges this leads to one of the slowest parts of the code we transmit 10 million packets per second and have to convert an index variable to an ip address for each and every probe we solve this by doing a binary search in a small amount of memory at this packet rate cache efficiencies start to dominate over algorithm efficiencies there are a lot of more efficient techniques in theory but they all require so much memory as to be slower in practice we call the function that translates from an index into an ip address the pick function in use it looks like for i 0 i range i ip pick addresses i scan ip masscan supports not only ip address ranges but also port ranges this means we need to pick from the index variable both an ip address and a port this is fairly straightforward range ip count port count for i 0 i range i ip pick addresses i port count port pick ports i port count scan ip port this leads to another expensive part of the code the division modulus instructions are around 90 clock cycles or 30 nanoseconds on x86 cpus when transmitting at a rate of 10 million packets second we have only 100 nanoseconds per packet i see no way to optimize this any better luckily though two such operations can be executed simultaneously so doing two of these as shown above is no more expensive than doing one there are actually some easy optimizations for the above performance problems but they all rely upon i the fact that the index variable increases one by one through the scan actually we need to randomize this variable we need to randomize the order of ip addresses that we scan or well blast the heck out of target networks that arent built for this level of speed we need to spread our traffic evenly over the target the way we randomize is simply by encrypting the index variable by definition encryption is random and creates a 1 to 1 mapping between the original index variable and the output this means that while we linearly go through the range the output ip addresses are completely random in code this looks like range ip count port count for i 0 i range i x encrypt i ip pick addresses x port count port pick ports x port count scan ip port this also has a major cost since the range is an unpredictable size instead of a nice even power of 2 we cant use cheap binary techniques like and and xor instead we have to use expensive operations like modulus in my current benchmarks its taking 40 nanoseconds to encrypt the variable this architecture allows for lots of cool features for example it supports shards you can setup 5 machines each doing a fifth of the scan or range shard count shards can be multiple machines or simply multiple network adapters on the same machine or even if you want multiple ip source addresses on the same network adapter or you can use a seed or key to the encryption function so that you get a different order each time you scan like x encrypt seed i we can also pause the scan by exiting out of the program and simply remembering the current value of i and restart it later i do that a lot during development i see something going wrong with my internet scan so i hit to stop the scan then restart it after ive fixed the bug another feature is retransmits retries packets sometimes get dropped on the internet so you can send two packets back to back however something that drops one packet may drop the immediately following packet therefore you want to send the copy about 1 second apart this is simple we already have a rate variable which is the number of packets per second rate we are transmitting at so the retransmit function is simply to use i rate as the index one of these days im going to do a study of the internet and differentiate back to back 1 second 10 second and 1 minute retransmits this way in order to see if there is any difference in what gets dropped c10 scalability the asynchronous technique is known as a solution to the c10k problem masscan is designed for the next level of scalability the c10m problem the c10m solution is to bypass the kernel there are three primary kernel bypasses in masscan custom network driver user mode tcp stack user mode synchronization masscan can use the pf ring dna driver this driver dmas packets directly from user mode memory to the network driver with zero kernel involvement that allows software even with a slow cpu to transmit packets at the maximum rate the hardware allows if you put 8 10 gbps network cards in a computer this means it could transmit at 100 million packets second masscan has its own built in tcp stack for grabbing banners from tcp connections this means it can easily support 10 million concurrent tcp connections assuming of course that the computer has enough memory masscan has no mutex modern mutexes aka futexes are mostly user mode but they have two problems the first problem is that they cause cache lines to bounce quickly back and forth between cpus the second is that when there is contention theyll do a system call into the kernel which kills performance mutexes on the fast path of a program severely limits scalability instead masscan uses rings to synchronize things such as when the user mode tcp stack in the receive thread needs to transmit a packet without interfering with the transmit thread portability the code runs well on linux windows and mac os x all the important bits are in standard c c90 it therefore compiles on visual studio with microsofts compiler the clang llvm compiler on mac os x and gcc on linux windows and macs arent tuned for packet transmit and get only about 300 000 packets per second whereas linux can do 1 500 000 packets second thats probably faster than you want anyway safe code a bounty is offered for vulnerabilities see the vulninfo md file for more information this project uses safe functions like strcpy s instead of unsafe functions like strcpy this project has automated unit regression tests make regress compatibility a lot of effort has gone into making the input output look like nmap which everyone who does port scans is or should be familiar with authors this tool created by robert graham email robert david graham yahoo com twitter erratarob