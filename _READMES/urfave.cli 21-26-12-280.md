cli this is the library formerly known as github com codegangsta cli github will automatically redirect requests to this repository but we recommend updating your references for clarity cli is a simple fast and fun package for building command line apps in go the goal is to enable developers to write fast and distributable command line applications in an expressive way toc overview installation supported platforms using the v2 branch pinning to the v1 releases getting started examples arguments flags placeholder values alternate names ordering values from the environment values from files values from alternate input sources yaml toml and others precedence subcommands subcommands categories exit code bash completion enabling distribution customization generated help text customization version flag customization full api example combining short bool options contribution guidelines tocstop overview command line apps are usually so tiny that there is absolutely no reason why your code should not be self documenting things like generating help text and parsing command flags options should not hinder productivity when writing a command line app this is where cli comes into play cli makes command line programming fun organized and expressive installation make sure you have a working go environment go version 1 2 is supported see the install instructions for go to install cli simply run go get github com urfave cli make sure your path includes the gopath bin directory so your commands can be easily used export path path gopath bin supported platforms cli is tested against multiple versions of go on linux and against the latest released version of go on os x and windows for full details see travis yml and appveyor yml using the v2 branch warning the v2 branch is currently unreleased and considered unstable there is currently a long lived branch named v2 that is intended to land as the new master branch once development there has settled down the current master branch mirrored as v1 is being manually merged into v2 on an irregular human based schedule but generally if one wants to upgrade to v2 now and accept the volatility read awesomeness that comes along with that please use whatever version pinning of your preference such as via gopkg in go get gopkg in urfave cli v2 go import gopkg in urfave cli v2 imports as package cli pinning to the v1 releases similarly to the section above describing use of the v2 branch if one wants to avoid any unexpected compatibility pains once v2 becomes master then pinning to v1 is an acceptable option e g go get gopkg in urfave cli v1 go import gopkg in urfave cli v1 imports as package cli this will pull the latest tagged v1 release e g v1 18 1 at the time of writing getting started one of the philosophies behind cli is that an api should be playful and full of discovery so a cli app can be as little as one line of code in main args 45 45 help output a new cli application go package main import log os github com urfave cli func main err cli newapp run os args if err nil log fatal err this app will run and show help text but is not very useful lets give an action to execute and some help documentation output boom i say go package main import fmt log os github com urfave cli func main app cli newapp app name boom app usage make an explosive entrance app action func c cli context error fmt println boom i say return nil err app run os args if err nil log fatal err running this already gives you a ton of functionality plus support for things like subcommands and flags which are covered below examples being a programmer can be a lonely job thankfully by the power of automation that is not the case lets create a greeter app to fend off our demons of loneliness start by creating a directory named greet and within it add a file greet go with the following code in it output hello friend go package main import fmt log os github com urfave cli func main app cli newapp app name greet app usage fight the loneliness app action func c cli context error fmt println hello friend return nil err app run os args if err nil log fatal err install our command to the gopath bin directory go install finally run our new command greet hello friend cli also generates neat help text greet help name greet fight the loneliness usage greet global options command command options arguments version 0 0 0 commands help h shows a list of commands or help for one command global options version shows version information arguments you can lookup arguments by calling the args function on cli context e g output hello \ go package main import fmt log os github com urfave cli func main app cli newapp app action func c cli context error fmt printf hello q c args get 0 return nil err app run os args if err nil log fatal err flags setting and querying flags is simple output hello nefertiti go package main import fmt log os github com urfave cli func main app cli newapp app flags cli flag cli stringflag name lang value english usage language for the greeting app action func c cli context error name nefertiti if c narg 0 name c args get 0 if c string lang spanish fmt println hola name else fmt println hello name return nil err app run os args if err nil log fatal err you can also set a destination variable for a flag to which the content will be scanned output hello someone go package main import log os fmt github com urfave cli func main var language string app cli newapp app flags cli flag cli stringflag name lang value english usage language for the greeting destination language app action func c cli context error name someone if c narg 0 name c args 0 if language spanish fmt println hola name else fmt println hello name return nil err app run os args if err nil log fatal err see full list of flags at http godoc org github com urfave cli placeholder values sometimes its useful to specify a flags value within the usage string itself such placeholders are indicated with back quotes for example this args 45 45 help output 45 45 config file 45 c file go package main import log os github com urfave cli func main app cli newapp app flags cli flag cli stringflag name config c usage load configuration from file err app run os args if err nil log fatal err will result in help output like config file c file load configuration from file note that only the first placeholder is used subsequent back quoted words will be left as is alternate names you can set alternate or short names for flags by providing a comma delimited list for the name e g args 45 45 help output 45 45 lang value 45 l value language for the greeting default \ english\ go package main import log os github com urfave cli func main app cli newapp app flags cli flag cli stringflag name lang l value english usage language for the greeting err app run os args if err nil log fatal err that flag can then be set with lang spanish or l spanish note that giving two different forms of the same flag in the same command invocation is an error ordering flags for the application and commands are shown in the order they are defined however its possible to sort them from outside this library by using flagsbyname or commandsbyname with sort for example this args 45 45 help output add a task to the list\n complete a task on the list\n \n\n \n load configuration from file\n language for the greeting go package main import log os sort github com urfave cli func main app cli newapp app flags cli flag cli stringflag name lang l value english usage language for the greeting cli stringflag name config c usage load configuration from file app commands cli command name complete aliases string c usage complete a task on the list action func c cli context error return nil name add aliases string a usage add a task to the list action func c cli context error return nil sort sort cli flagsbyname app flags sort sort cli commandsbyname app commands err app run os args if err nil log fatal err will result in help output like config file c file load configuration from file lang value l value language for the greeting default english values from the environment you can also have the default value set from the environment via envvar e g args 45 45 help output language for the greeting app lang go package main import log os github com urfave cli func main app cli newapp app flags cli flag cli stringflag name lang l value english usage language for the greeting envvar app lang err app run os args if err nil log fatal err the envvar may also be given as a comma delimited cascade where the first environment variable that resolves is used as the default args 45 45 help output language for the greeting legacy compat lang app lang lang go package main import log os github com urfave cli func main app cli newapp app flags cli flag cli stringflag name lang l value english usage language for the greeting envvar legacy compat lang app lang lang err app run os args if err nil log fatal err values from files you can also have the default value set from file via filepath e g args 45 45 help output password for the mysql database go package main import log os github com urfave cli func main app cli newapp app flags cli flag cli stringflag name password p usage password for the mysql database filepath etc mysql password err app run os args if err nil log fatal err note that default values set from file e g filepath take precedence over default values set from the enviornment e g envvar values from alternate input sources yaml toml and others there is a separate package altsrc that adds support for getting flag values from other file input sources currently supported input source formats yaml toml in order to get values for a flag from an alternate input source the following code would be added to wrap an existing cli flag like below go altsrc newintflag cli intflag name test initialization must also occur for these flags below is an example initializing getting data from a yaml file below go command before altsrc initinputsourcewithcontext command flags newyamlsourcefromflagfunc load the code above will use the load string as a flag name to get the file name of a yaml file from the cli context it will then use that file name to initialize the yaml input source for any flags that are defined on that command as a note the load flag used would also have to be defined on the command flags in order for this code snipped to work currently only yaml and json files are supported but developers can add support for other input sources by implementing the altsrc inputsourcecontext for their given sources here is a more complete sample of a command using yaml support args test cmd 45 45 help output 45 45 test value default 0 go package notmain import fmt log os github com urfave cli github com urfave cli altsrc func main app cli newapp flags cli flag altsrc newintflag cli intflag name test cli stringflag name load app action func c cli context error fmt println yaml ist rad return nil app before altsrc initinputsourcewithcontext flags altsrc newyamlsourcefromflagfunc load app flags flags err app run os args if err nil log fatal err precedence the precedence for flag value sources is as follows highest to lowest command line flag value from user environment variable if specified configuration file if specified default defined on the flag subcommands subcommands can be defined for a more git like command line app args template add output new task template go package main import fmt log os github com urfave cli func main app cli newapp app commands cli command name add aliases string a usage add a task to the list action func c cli context error fmt println added task c args first return nil name complete aliases string c usage complete a task on the list action func c cli context error fmt println completed task c args first return nil name template aliases string t usage options for task templates subcommands cli command name add usage add a new template action func c cli context error fmt println new task template c args first return nil name remove usage remove an existing template action func c cli context error fmt println removed task template c args first return nil err app run os args if err nil log fatal err subcommands categories for additional organization in apps that have many subcommands you can associate a category for each command to group them together in the help output e g go package main import log os github com urfave cli func main app cli newapp app commands cli command name noop name add category template actions name remove category template actions err app run os args if err nil log fatal err will include commands noop template actions add remove exit code calling app run will not automatically call os exit which means that by default the exit code will fall through to being 0 an explicit exit code may be set by returning a non nil error that fulfills cli exitcoder or a cli multierror that includes an error that fulfills cli exitcoder e g go package main import log os github com urfave cli func main app cli newapp app flags cli flag cli booltflag name ginger crouton usage is it in the soup app action func ctx cli context error if ctx bool ginger crouton return cli newexiterror it is not in the soup 86 return nil err app run os args if err nil log fatal err bash completion you can enable completion commands by setting the enablebashcompletion flag on the app object by default this setting will only auto complete to show an apps subcommands but you can write your own completion methods for the app or its subcommands args complete 45 45 generate 45 bash 45 completion output laundry go package main import fmt log os github com urfave cli func main tasks string cook clean laundry eat sleep code app cli newapp app enablebashcompletion true app commands cli command name complete aliases string c usage complete a task on the list action func c cli context error fmt println completed task c args first return nil bashcomplete func c cli context this will complete if no args are passed if c narg 0 return for t range tasks fmt println t err app run os args if err nil log fatal err enabling source the autocomplete bash autocomplete file in your bashrc file while setting the prog variable to the name of your program prog myprogram source cli autocomplete bash autocomplete distribution copy autocomplete bash autocomplete into etc bash completion d and rename it to the name of the program you wish to add autocomplete support for or automatically install it there if you are distributing a package dont forget to source the file to make it active in the current shell sudo cp src bash autocomplete etc bash completion d myprogram source etc bash completion d myprogram alternatively you can just document that users should source the generic autocomplete bash autocomplete in their bash configuration with prog set to the name of their program as above customization the default bash completion flag generate bash completion is defined as cli bashcompletionflag and may be redefined if desired e g args 45 45 compgen output wat\nhelp\nh go package main import log os github com urfave cli func main cli bashcompletionflag cli boolflag name compgen hidden true app cli newapp app enablebashcompletion true app commands cli command name wat err app run os args if err nil log fatal err generated help text the default help flag h help is defined as cli helpflag and is checked by the cli internals in order to print generated help text for the app command or subcommand and break execution customization all of the help text generation may be customized and at multiple levels the templates are exposed as variables apphelptemplate commandhelptemplate and subcommandhelptemplate which may be reassigned or augmented and full override is possible by assigning a compatible func to the cli helpprinter variable e g output ha ha i pwnd the help 1 go package main import fmt log io os github com urfave cli func main example append to an existing template cli apphelptemplate fmt sprintf s website http awesometown example com support support awesometown example com cli apphelptemplate example override a template cli apphelptemplate name name usage usage helpname if visibleflags global options end if commands command command options end if argsusage argsusage else arguments end if len authors author range authors end end if commands commands range commands if not hidehelp join names \t usage \n end end end if visibleflags global options range visibleflags end end if copyright copyright copyright end if version version version end example replace the helpprinter func cli helpprinter func w io writer templ string data interface fmt println ha ha i pwnd the help 1 err cli newapp run os args if err nil log fatal err the default flag may be customized to something other than h help by setting cli helpflag e g args 45 45halp output haaaaalp halp go package main import log os github com urfave cli func main cli helpflag cli boolflag name halp haaaaalp usage halp envvar show halp halpplz err cli newapp run os args if err nil log fatal err version flag the default version flag v version is defined as cli versionflag which is checked by the cli internals in order to print the app version via cli versionprinter and break execution customization the default flag may be customized to something other than v version by setting cli versionflag e g args 45 45print version output partay version 19\\ 99\\ 0 go package main import log os github com urfave cli func main cli versionflag cli boolflag name print version v usage print only the version app cli newapp app name partay app version 19 99 0 err app run os args if err nil log fatal err alternatively the version printer at cli versionprinter may be overridden e g args 45 45version output version 19\\ 99\\ 0 revision fafafaf go package main import fmt log os github com urfave cli var revision fafafaf func main cli versionprinter func c cli context fmt printf version s revision s\n c app version revision app cli newapp app name partay app version 19 99 0 err app run os args if err nil log fatal err full api example notice this is a contrived functioning example meant strictly for api demonstration purposes use of ones imagination is encouraged output made it \nphew go package main import errors flag fmt io io ioutil os time github com urfave cli func init cli apphelptemplate \ncustomized you bet ur muffins\n cli commandhelptemplate \nymmv\n cli subcommandhelptemplate \nor something\n cli helpflag cli boolflag name halp cli bashcompletionflag cli boolflag name compgen hidden true cli versionflag cli boolflag name print version v cli helpprinter func w io writer templ string data interface fmt fprintf w best of luck to you\n cli versionprinter func c cli context fmt fprintf c app writer version s\n c app version cli osexiter func c int fmt fprintf cli errwriter refusing to exit d\n c cli errwriter ioutil discard cli flagstringer func fl cli flag string return fmt sprintf \t\t s fl getname type hexwriter struct func w hexwriter write p byte int error for b range p fmt printf x b fmt printf \n return len p nil type generictype struct s string func g generictype set value string error g s value return nil func g generictype string string return g s func main app cli newapp app name kənˈtrīv app version 19 99 0 app compiled time now app authors cli author cli author name example human email human example com app copyright c 1999 serious enterprise app helpname contrive app usage demonstrate available api app usagetext contrive demonstrating the available api app argsusage args and such app commands cli command cli command name doo aliases string do category motion usage do the doo usagetext doo does the dooing description no really there is a lot of dooing to be done argsusage arrgh flags cli flag cli boolflag name forever forevvarr subcommands cli commands cli command name wop action wopaction skipflagparsing false hidehelp false hidden false helpname doo bashcomplete func c cli context fmt fprintf c app writer better\n before func c cli context error fmt fprintf c app writer brace for impact\n return nil after func c cli context error fmt fprintf c app writer did we lose anyone \n return nil action func c cli context error c command fullname c command hasname wop c command names c command visibleflags fmt fprintf c app writer dodododododoodododddooooododododooo\n if c bool forever c command run c return nil onusageerror func c cli context err error issubcommand bool error fmt fprintf c app writer for shame\n return err app flags cli flag cli boolflag name fancy cli booltflag name fancier cli durationflag name howlong h value time second 3 cli float64flag name howmuch cli genericflag name wat value generictype cli int64flag name longdistance cli int64sliceflag name intervals cli intflag name distance cli intsliceflag name times cli stringflag name dance move d cli stringsliceflag name names n cli uintflag name age cli uint64flag name bigage app enablebashcompletion true app hidehelp false app hideversion false app bashcomplete func c cli context fmt fprintf c app writer lipstick\nkiss\nme\nlipstick\nringo\n app before func c cli context error fmt fprintf c app writer heeeere goes\n return nil app after func c cli context error fmt fprintf c app writer phew \n return nil app commandnotfound func c cli context command string fmt fprintf c app writer thar be no q here \n command app onusageerror func c cli context err error issubcommand bool error if issubcommand return err fmt fprintf c app writer wrong v\n err return nil app action func c cli context error cli defaultappcomplete c cli handleexitcoder errors new not an exit coder though cli showapphelp c cli showcommandcompletions c nope cli showcommandhelp c also nope cli showcompletions c cli showsubcommandhelp c cli showversion c categories c app categories categories addcommand sounds cli command name bloop for category range c app categories fmt fprintf c app writer s\n category name fmt fprintf c app writer v\n category commands fmt fprintf c app writer v\n category visiblecommands fmt printf v\n c app command doo if c bool infinite c app run string app doo wop if c bool forevar c app runassubcommand c c app setup fmt printf v\n c app visiblecategories fmt printf v\n c app visiblecommands fmt printf v\n c app visibleflags fmt printf v\n c args first if len c args 0 fmt printf v\n c args 1 fmt printf v\n c args present fmt printf v\n c args tail set flag newflagset contrive 0 nc cli newcontext c app set c fmt printf v\n nc args fmt printf v\n nc bool nope fmt printf v\n nc boolt nerp fmt printf v\n nc duration howlong fmt printf v\n nc float64 hay fmt printf v\n nc generic bloop fmt printf v\n nc int64 bonk fmt printf v\n nc int64slice burnks fmt printf v\n nc int bips fmt printf v\n nc intslice blups fmt printf v\n nc string snurt fmt printf v\n nc stringslice snurkles fmt printf v\n nc uint flub fmt printf v\n nc uint64 florb fmt printf v\n nc globalbool global nope fmt printf v\n nc globalboolt global nerp fmt printf v\n nc globalduration global howlong fmt printf v\n nc globalfloat64 global hay fmt printf v\n nc globalgeneric global bloop fmt printf v\n nc globalint global bips fmt printf v\n nc globalintslice global blups fmt printf v\n nc globalstring global snurt fmt printf v\n nc globalstringslice global snurkles fmt printf v\n nc flagnames fmt printf v\n nc globalflagnames fmt printf v\n nc globalisset wat fmt printf v\n nc globalset wat nope fmt printf v\n nc narg fmt printf v\n nc numflags fmt printf v\n nc parent nc set wat also nope ec cli newexiterror ohwell 86 fmt fprintf c app writer d ec exitcode fmt printf made it \n return nil if os getenv hexy app writer hexwriter app errwriter hexwriter app metadata map string interface layers many explicable false whatever values 19 99 ignore error so we dont exit non zero and break gfmrun readme example tests app run os args func wopaction c cli context error fmt fprintf c app writer wave over here eh\n return nil combining short bool options traditional use of boolean options using their shortnames look like this cmd foobar s o suppose you want users to be able to combine your bool options with their shortname this can be done using the useshortoptionhandling bool in your commands suppose your program has a two bool flags such as serve and option with the short options of o and s respectively with useshortoptionhandling set to true a user can use a syntax like cmd foobar so if you enable the useshortoptionhandling then you must not use any flags that have a single leading or this will result in failures for example option can no longer be used flags with two leading dashes such as options are still valid contribution guidelines see contributing md