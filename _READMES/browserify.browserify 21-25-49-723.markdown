browserify require modules in the browser use a node style require to organize your browser code and load modules installed by npm browserify will recursively analyze all the require calls in your app in order to build a bundle you can serve up to the browser in a single script tag getting started if youre new to browserify check out the browserify handbook and the resources on browserify org example whip up a file main js with some require s in it you can use relative paths like foo js and lib bar js or module paths like gamma that will search node modules using nodes module lookup algorithm js var foo require foo js var bar require lib bar js var gamma require gamma var elem document getelementbyid result var x foo 100 bar baz elem textcontent gamma x export functionality by assigning onto module exports or exports js module exports function n return n 111 now just use the browserify command to build a bundle starting at main js browserify main js bundle js all of the modules that main js needs are included in the bundle js from a recursive walk of the require graph using required to use this bundle just toss a script src bundle js script into your html install with npm do npm install g browserify usage usage browserify entry files options standard options outfile o write the browserify bundle to this file if unspecified browserify prints to stdout require r a module name or file to bundle require optionally use a colon separator to set the target entry e an entry point of your app ignore i replace a file with an empty stub files can be globs exclude u omit a file from the output bundle files can be globs external x reference a file from another bundle files can be globs transform t use a transform module on top level files command c use a transform command on top level files standalone s generate a umd bundle for the supplied export name this bundle works with other module systems and sets the name given as a window global if no module system is found debug d enable source maps that allow you to debug your files separately help h show this message for advanced options type browserify help advanced specify a parameter advanced options insert globals ig fast default false skip detection and always insert definitions for process global filename and dirname benefit faster builds cost extra bytes insert global vars igv comma separated list of global variables to detect and define default filename dirname process buffer global detect globals dg default true detect the presence of process global filename and dirname and define these values when present benefit npm modules more likely to work cost slower builds ignore missing im default false ignore require statements that dont resolve to anything noparse file dont parse file at all this will make bundling much much faster for giant libs like jquery or threejs no builtins turn off builtins this is handy when you want to run a bundle in node which provides the core builtins no commondir turn off setting a commondir this is useful if you want to preserve the original paths that a bundle was generated with no bundle external turn off bundling of all external modules this is useful if you only want to bundle your local files bare alias for both no builtins no commondir and sets insert global vars to just filename dirname this is handy if you want to run bundles in node no browser field no bf turn off package json browser field resolution this is also handy if you need to run a bundle in node transform key instead of the default package json browserify transform field to list all transforms to apply when running browserify a custom field like e g package json browserify production or package json browserify staging can be used by for example running browserify index js transform key production bundle js browserify index js transform key staging bundle js node alias for bare and no browser field full paths turn off converting module ids into numerical indexes this is useful for preserving the original paths that a bundle was generated with deps instead of standard bundle output print the dependency array generated by module deps no dedupe turn off deduping list print each file in the dependency graph useful for makefiles extension extension consider files with specified extension as modules this option can used multiple times global transform module g module use a transform module on all files after any ordinary transforms have run ignore transform module it module do not run certain transformations even if specified elsewhere plugin module p module register module as a plugin passing arguments to transforms and plugins for t g and p you may use subarg syntax to pass options to the transforms or plugin function as the second parameter for example t foo x 3 beep will call the foo transform for each applicable file by calling foo file x 3 beep true compatibility many npm modules that dont do io will just work after being browserified others take more work many node built in modules have been wrapped to work in the browser but only when you explicitly require or use their functionality when you require any of these modules you will get a browser specific shim assert buffer console constants crypto domain events http https os path punycode querystring stream string decoder timers tty url util vm zlib additionally if you use any of these variables they will be defined in the bundled output in a browser appropriate way process buffer global top level scope object window filename file path of the currently executing file dirname directory path of the currently executing file more examples external requires you can just as easily create a bundle that will export a require function so you can require modules from another script tag here well create a bundle js with the through and duplexer modules browserify r through r duplexer r my file js my module bundle js then in your page you can do html script src bundle js script script var through require through var duplexer require duplexer var mymodule require my module script external source maps if you prefer the source maps be saved to a separate js map source map file you may use exorcist in order to achieve that its as simple as browserify main js debug exorcist bundle js map bundle js learn about additional options here multiple bundles if browserify finds a required function already defined in the page scope it will fall back to that function if it didnt find any matches in its own set of bundled modules in this way you can use browserify to split up bundles among multiple pages to get the benefit of caching for shared infrequently changing modules while still being able to use require just use a combination of external and require to factor out common dependencies for example if a website with 2 pages beep js js var robot require robot js console log robot beep and boop js js var robot require robot js console log robot boop both depend on robot js js module exports function s return s touppercase browserify r robot js static common js browserify x robot js beep js static beep js browserify x robot js boop js static boop js then on the beep page you can have html script src common js script script src beep js script while the boop page can have html script src common js script script src boop js script this approach using r and x works fine for a small number of split assets but there are plugins for automatically factoring out components which are described in the partitioning section of the browserify handbook api example you can use the api directly too js var browserify require browserify var b browserify b add browser main js b bundle pipe process stdout methods js var browserify require browserify browserify files opts returns a new browserify instance files string file object or array of those types they may be mixed specifying entry file s opts object files and opts are both optional but must be in the order shown if both are passed entry files may be passed in files and or opts entries external requires may be specified in opts require accepting the same formats that the files argument does if an entry file is a stream its contents will be used you should pass opts basedir when using streaming files so that relative requires can be resolved opts entries has the same definition as files opts noparse is an array which will skip all require and global parsing for each file in the array use this for giant libs like jquery or threejs that dont have any requires or node style globals but take forever to parse opts transform is an array of transform functions or modules names which will transform the source code before the parsing opts ignoretransform is an array of transformations that will not be run even if specified elsewhere opts plugin is an array of plugin functions or module names to use see the plugins section below for details opts extensions is an array of optional extra extensions for the module lookup machinery to use when the extension has not been specified by default browserify considers only js and json files in such cases opts basedir is the directory that browserify starts bundling from for filenames that start with opts paths is an array of directories that browserify searches when looking for modules which are not referenced using relative path can be absolute or relative to basedir equivalent of setting node path environmental variable when calling browserify command opts commondir sets the algorithm used to parse out the common paths use false to turn this off otherwise it uses the commondir module opts fullpaths disables converting module ids into numerical indexes this is useful for preserving the original paths that a bundle was generated with opts builtins sets the list of built ins to use which by default is set in lib builtins js in this distribution opts bundleexternal boolean option to set if external modules should be bundled defaults to true when opts browserfield is false the package json browser field will be ignored when opts insertglobals is true always insert process global filename and dirname without analyzing the ast for faster builds but larger output bundles default false when opts detectglobals is true scan all files for process global filename and dirname defining as necessary with this option npm modules are more likely to work but bundling takes longer default true when opts ignoremissing is true ignore require statements that dont resolve to anything when opts debug is true add a source map inline to the end of the bundle this makes debugging easier because you can see all the original files if you are in a modern enough browser when opts standalone is a non empty string a standalone module is created with that name and a umd wrapper you can use namespaces in the standalone global export using a in the string name as a separator for example a b c the global export will be sanitized and camel cased note that in standalone mode the require calls from the original source will still be around which may trip up amd loaders scanning for require calls you can remove these calls with derequire npm install g derequire browserify main js standalone foo derequire bundle js opts insertglobalvars will be passed to insert module globals as the opts vars parameter opts externalrequirename defaults to require in expose mode but you can use another name opts bare creates a bundle that does not include node builtins and does not replace global node variables except for dirname and filename opts node creates a bundle that runs in node and does not use the browser versions of dependencies same as passing bare true browserfield false note that if files do not contain javascript source code then you also need to specify a corresponding transform for them all other options are forwarded along to module deps and browser pack directly b add file opts add an entry file from file that will be executed when the bundle loads if file is an array each item in file will be added as an entry file b require file opts make file available from outside the bundle with require file the file param is anything that can be resolved by require resolve including files from node modules like with require resolve you must prefix file with to require a local file not in node modules file can also be a stream but you should also use opts basedir so that relative requires will be resolvable if file is an array each item in file will be required in file array form you can use a string or object for each item object items should have a file property and the rest of the parameters will be used for the opts use the expose property of opts to specify a custom dependency name require vendor angular angular js expose angular enables require angular b bundle cb bundle the files and their dependencies into a single javascript file return a readable stream with the javascript file contents or optionally specify a cb err buf to get the buffered results b external file prevent file from being loaded into the current bundle instead referencing from another bundle if file is an array each item in file will be externalized if file is another bundle that bundles contents will be read and excluded from the current bundle as the bundle in file gets bundled b ignore file prevent the module name or file at file from showing up in the output bundle if file is an array each item in file will be ignored instead you will get a file with module exports b exclude file prevent the module name or file at file from showing up in the output bundle if file is an array each item in file will be excluded if your code tries to require that file it will throw unless youve provided another mechanism for loading it b transform tr opts transform source code before parsing it for require calls with the transform function or module name tr if tr is a function it will be called with tr file and it should return a through stream that takes the raw file contents and produces the transformed source if tr is a string it should be a module name or file path of a transform module with a signature of js var through require through module exports function file return through you dont need to necessarily use the through module browserify is compatible with the newer more verbose transform streams built into node v0 10 heres how you might compile coffee script on the fly using transform js var coffee require coffee script var through require through b transform function file var data return through write end function write buf data buf function end this queue coffee compile data this queue null note that on the command line with the c flag you can just do browserify c coffee sc main coffee bundle js or better still use the coffeeify module npm install coffeeify browserify t coffeeify main coffee bundle js if opts global is true the transform will operate on all files despite whether they exist up a level in a node modules directory use global transforms cautiously and sparingly since most of the time an ordinary transform will suffice you can also not configure global transforms in a package json like you can with ordinary transforms global transforms always run after any ordinary transforms have run transforms may obtain options from the command line with subarg syntax browserify t foo bar 555 main js or from the api b transform foo bar 555 in both cases these options are provided as the second argument to the transform function module exports function file opts opts bar 555 options sent to the browserify constructor are also provided under opts flags these browserify options are sometimes required if your transform needs to do something different when browserify is run in debug mode for example b plugin plugin opts register a plugin with opts plugins can be a string module name or a function the same as transforms plugin b opts is called with the browserify instance b for more information consult the plugins section below b pipeline there is an internal labeled stream splicer pipeline with these labels record save inputs to play back later on subsequent bundle calls deps module deps json adds module exports to the beginning of json files unbom remove byte order markers unshebang remove labels on the first line syntax check for syntax errors sort sort the dependencies for deterministic bundles dedupe remove duplicate source contents label apply integer labels to files emit deps emit dep event debug apply source maps pack browser pack wrap apply final wrapping require and a newline and semicolon you can call b pipeline get with a label name to get a handle on a stream pipeline that you can push unshift or splice to insert your own transform streams b reset opts reset the pipeline back to a normal state this function is called automatically when bundle is called multiple times this function triggers a reset event package json browserify uses the package json in its module resolution algorithm just like node if there is a main field browserify will start resolving the package at that point if there is no main field browserify will look for an index js file in the module root directory here are some more sophisticated things you can do in the package json browser field there is a special browser field you can set in your package json on a per module basis to override file resolution for browser specific versions of files for example if you want to have a browser specific module entry point for your main field you can just set the browser field to a string json browser browser js or you can have overrides on a per file basis json browser fs level fs lib ops js browser opts js note that the browser field only applies to files in the local module and like transforms it doesnt apply into node modules directories browserify transform you can specify source transforms in the package json in the browserify transform field there is more information about how source transforms work in package json on the module deps readme for example if your module requires brfs you can add json browserify transform brfs to your package json now when somebody require s your module brfs will automatically be applied to the files in your module without explicit intervention by the person using your module make sure to add transforms to your package json dependencies field events b on file function file id parent b pipeline on file function file id parent when a file is resolved for the bundle the bundle emits a file event with the full file path the id string passed to require and the parent object used by browser resolve you could use the file event to implement a file watcher to regenerate bundles when files change b on package function pkg b pipeline on package function pkg when a package file is read this event fires with the contents the package directory is available at pkg dirname b on bundle function bundle when bundle is called this event fires with the bundle output stream b on reset function when the reset method is called or implicitly called by another call to bundle this event fires b on transform function tr file b pipeline on transform function tr file when a transform is applied to a file the transform event fires on the bundle stream with the transform stream tr and the file that the transform is being applied to plugins for some more advanced use cases a transform is not sufficiently extensible plugins are modules that take the bundle instance as their first parameter and an option hash as their second plugins can be used to do perform some fancy features that transforms cant do for example factor bundle is a plugin that can factor out common dependencies from multiple entry points into a common bundle use plugins with p and pass options to plugins with subarg syntax browserify x js y js p factor bundle o bundle x js o bundle y js \ bundle common js for a list of plugins consult the browserify plugin tag on npm list of source transforms there is a wiki page that lists the known browserify transforms if you write a transform make sure to add your transform to that wiki page and add a package json keyword of browserify transform so that people can browse for all the browserify transforms on npmjs org third party tools there is a wiki page that lists the known browserify tools if you write a tool make sure to add it to that wiki page and add a package json keyword of browserify tool so that people can browse for all the browserify tools on npmjs org changelog releases are documented in changelog markdown and on the browserify twitter feed license mit