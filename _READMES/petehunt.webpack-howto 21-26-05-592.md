webpack howto goal of this guide this is a cookbook of how to get things done with webpack this includes most things we use at instagram and nothing we dont use my advice start with this as your webpack docs then look at the official docs for clarification prerequisites you know browserify requirejs or something similar you see the value in bundle splitting async loading packaging static assets like images and css 1 why webpack its like browserify but can split your app into multiple files if you have multiple pages in a single page app the user only downloads code for just that page if they go to another page they dont redownload common code it often replaces grunt or gulp because it can build and bundle css preprocessed css compile to js languages and images among other things it supports amd and commonjs among other module systems angular es6 if you dont know what to use use commonjs 2 webpack for browserify people these are equivalent js browserify main js bundle js js webpack main js bundle js however webpack is more powerful than browserify so you generally want to make a webpack config js to keep things organized js webpack config js module exports entry main js output filename bundle js this is just js so feel free to put real code in there 3 how to invoke webpack switch to the directory containing webpack config js and run webpack for building once for development webpack p for building once for production minification webpack watch for continuous incremental build in development fast webpack d to include source maps 4 compile to js languages webpacks equivalent of browserify transforms and requirejs plugins is a loader heres how you can teach webpack to load coffeescript and facebook jsx es6 support you must npm install babel loader coffee loader see also the babel loader installation instructions for additional dependencies tl dr run npm install babel core babel preset es2015 babel preset react js webpack config js module exports entry main js output filename bundle js module loaders test \ coffee loader coffee loader test \ js loader babel loader query presets es2015 react to enable requiring files without specifying the extension you must add a resolve extensions parameter specifying which files webpack searches for js webpack config js module exports entry main js output filename bundle js module loaders test \ coffee loader coffee loader test \ js loader babel loader query presets es2015 react resolve you can now require file instead of require file coffee extensions js json coffee 5 stylesheets and images first update your code to require your static assets named as they would with nodes require js require bootstrap css require myapp less var img document createelement img img src require glyph png when you require css or less etc webpack inlines the css as a string inside the js bundle and require will insert a style tag into the page when you require images webpack inlines a url to the image into the bundle and returns it from require but you need to teach webpack to do this again with loaders js webpack config js module exports entry main js output path build this is where images and js will go publicpath http mycdn com this is used to generate urls to e g images filename bundle js module loaders test \ less loader style loader css loader less loader use to chain loaders test \ css loader style loader css loader test \ png jpg loader url loader limit 8192 inline base64 urls for 8k images direct urls for the rest 6 feature flags we have code we want to gate only to our dev environments like logging and our internal dogfooding servers like unreleased features were testing with employees in your code refer to magic globals js if dev console warn extra logging if prerelease showsecretfeature then teach webpack those magic globals js webpack config js defineplugin takes raw strings and inserts them so you can put strings of js if you want var defineplugin new webpack defineplugin dev json stringify json parse process env build dev true prerelease json stringify json parse process env build prerelease false module exports entry main js output filename bundle js plugins defineplugin then you can build with build dev 1 build prerelease 1 webpack from the console note that since webpack p runs uglify dead code elimination anything wrapped in one of these blocks will be stripped out so you wont leak secret features or strings 7 multiple entrypoints lets say you have a profile page and a feed page you dont want to make the user download the code for the feed if they just want the profile so make multiple bundles create one main module called an entrypoint per page js webpack config js module exports entry profile profile js feed feed js output path build filename name js template based on keys in entry above for profile insert script src build profile js script into your page do a similar thing for feed 8 optimizing common code feed and profile share a lot in common like react and the common stylesheets and components webpack can figure out what they have in common and make a shared bundle that can be cached between pages js webpack config js var webpack require webpack var commonsplugin new webpack optimize commonschunkplugin common js module exports entry profile profile js feed feed js output path build filename name js template based on keys in entry above plugins commonsplugin add script src build common js script before the script tag you added in the previous step and enjoy the free caching 9 async loading commonjs is synchronous but webpack provides a way to asynchronously specify dependencies this is useful for client side routers where you want the router on every page but you dont want to have to download features until you actually need them specify the split point where you want to load asynchronously for example js if window location pathname feed showloadingstate require ensure function this syntax is weird but it works hideloadingstate require feed show when this function is called the module is guaranteed to be synchronously available else if window location pathname profile showloadingstate require ensure function hideloadingstate require profile show webpack will do the rest and generate extra chunk files and load them for you webpack will assume that those files are in your root directory when you load then into a html script tag for example you can use output publicpath to configure that js webpack config js output path home proj public assets path to where webpack will build your stuff publicpath assets path that will be considered when requiring your files additional resources take a look at a real world example on how a successful team is leveraging webpack http youtu be vktcl6nqm6y this is pete hunt at oscon talking about webpack at instagram com faq webpack doesnt seem modular webpack is extremely modular what makes webpack great is that it lets plugins inject themselves into more places in the build process when compared to alternatives like browserify and requirejs many things that may seem built into the core are just plugins that are loaded by default and can be overridden i e the commonjs require parser