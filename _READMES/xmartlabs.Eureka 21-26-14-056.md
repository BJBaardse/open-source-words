made with ❤️ by xmartlabs this is the re creation of xlform in swift 简体中文 overview contents requirements usage how to create a form getting row values operators using the callbacks section header and footer dynamically hide and show rows or sections list sections multivalued sections validations swipe actions custom rows basic custom rows custom inline rows custom presenter rows row catalog installation faq for more information look at our blog post that introduces eureka requirements xcode 9 2 swift 4 example project you can clone and run the example project to see examples of most of eurekas features usage how to create a form by extending formviewcontroller you can then simply add sections and rows to the form variable swift import eureka class myformviewcontroller formviewcontroller override func viewdidload super viewdidload form section section1 textrow row in row title text row row placeholder enter text here phonerow 0 title phone row 0 placeholder and numbers here section section2 daterow 0 title date row 0 value date timeintervalsincereferencedate 0 in the example we create two sections with standard rows the result is this you could create a form by just setting up the form property by yourself without extending from formviewcontroller but this method is typically more convenient configuring the keyboard navigation accesory to change the behaviour of this you should set the navigation options of your controller the formviewcontroller has a navigationoptions variable which is an enum and can have one or more of the following values disabled no view at all enabled enable view at the bottom stopdisabledrow if the navigation should stop when the next row is disabled skipcannotbecomefirstresponderrow if the navigation should skip the rows that return false to canbecomefirstresponder the default value is enabled skipcannotbecomefirstresponderrow to enable smooth scrolling to off screen rows enable it via the animatescroll property by default the formviewcontroller jumps immediately between rows when the user hits the next or previous buttons in the keyboard navigation accesory including when the next row is off screen to set the amount of space between the keyboard and the highlighted row following a navigation event set the rowkeyboardspacing property by default when the form scrolls to an offscreen view no space will be left between the top of the keyboard and the bottom of the row swift class myformviewcontroller formviewcontroller override func viewdidload super viewdidload form enables the navigation accessory and stops navigation when a disabled row is encountered navigationoptions rownavigationoptions enabled union stopdisabledrow enables smooth scrolling on navigation to off screen rows animatescroll true leaves 20pt of space between the keyboard and the highlighted row after scrolling to an off screen row rowkeyboardspacing 20 if you want to change the whole navigation accessory view you will have to override the navigationaccessoryview variable in your subclass of formviewcontroller getting row values the row object holds a value of a specific type for example a switchrow holds a bool value while a textrow holds a string value swift get the value of a single row let row textrow form rowby tag myrowtag let value row value get the value of all rows which have a tag assigned the dictionary contains the rowtag value pairs let valuesdictionary form values operators eureka includes custom operators to make form creation easy add a section swift form section chain it to add multiple sections form section first section section another section or use it with rows and get a blank section for free form textrow textrow each row will be on a separate section insert a row swift form section textrow daterow or implicitly create the section form textrow daterow append an array swift append sections into a form form section a section b section c append rows into a section section textrow daterow using the callbacks eureka includes callbacks to change the appearance and behavior of a row understanding row and cell a row is an abstraction eureka uses which holds a value and contains the view cell the cell manages the view and subclasses uitableviewcell here is an example swift let row switchrow switchrow row in initializer row title the title onchange row in row title row value false the title expands when on the title row updatecell cellsetup cell row in cell backgroundcolor lightgray cellupdate cell row in cell textlabel font italicsystemfont ofsize 18 0 callbacks list onchange called when the value of a row changes you might be interested in adjusting some parameters here or even make some other rows appear or disappear oncellselection called each time the user taps on the row and it gets selected cellsetup called only once when the cell is first configured set permanent settings here cellupdate called each time the cell appears on screen you can change the appearance here using variables that may not be present on cellsetup oncellhighlightchanged called whenever the cell or any subview become or resign the first responder onrowvalidationchanged called whenever the the validation errors associated with a row changes onexpandinlinerow called before expanding the inline row applies to rows conforming inlinerowtype protocol oncollapseinlinerow called before collapsing the inline row applies to rows conforming inlinerowtype protocol onpresent called by a row just before presenting another view controller applies to rows conforming presenterrowtype protocol use it to set up the presented controller section header and footer you can set a title string or a custom view as the header or footer of a section string title swift section title section header title footer footer title section footer footer title custom view you can use a custom view from a xib file swift section section in var header headerfooterview nibfile name myheadernibfile bundle nil will be called every time the header appears on screen header onsetupview view in commonly used to setup texts inside the view dont change the view hierarchy or size here section header header or a custom uiview created programmatically swift section section in var header headerfooterview mycustomuiview class header height 100 header onsetupview view in view backgroundcolor red section header header or just build the view with a callback swift section section in section header var header headerfooterview uiview callback let view uiview frame cgrect x 0 y 0 width 100 height 100 view backgroundcolor red return view header height 100 return header dynamically hide and show rows or sections in this case we are hiding and showing whole sections to accomplish this each row has a hidden variable of optional type condition which can be set using a function or nspredicate hiding using a function condition using the function case of condition swift condition function string form bool the array of string to pass should contain the tags of the rows this row depends on each time the value of any of those rows changes the function is reevaluated the function then takes the form and returns a bool indicating whether the row should be hidden or not this the most powerful way of setting up the hidden property as it has no explicit limitations of what can be done swift form section switchrow switchrowtag 0 title show message labelrow 0 hidden condition function switchrowtag form in return form rowby tag switchrowtag as switchrow value false 0 title switch is on swift public enum condition case function string form bool case predicate nspredicate hiding using an nspredicate the hidden variable can also be set with a nspredicate in the predicate string you can reference values of other rows by their tags to determine if a row should be hidden or visible this will only work if the values of the rows the predicate has to check are nsobjects string and int will work as they are bridged to their objc counterparts but enums wont work why could it then be useful to use predicates when they are more limited well they can be much simpler shorter and readable than functions look at this example swift 0 hidden condition predicate nspredicate format switchtag false and we can write it even shorter since condition conforms to expressiblebystringliteral swift 0 hidden switchtag false note we will substitute the value of the row whose tag is switchtag instead of switchtag for all of this to work all of the implicated rows must have a tag as the tag will identify them we can also hide a row by doing swift 0 hidden true as condition conforms to expressiblebybooleanliteral not setting the hidden variable will leave the row always visible sections for sections this works just the same that means we can set up section hidden property to show hide it dynamically disabling rows to disable rows each row has an disabled variable which is also an optional condition type property this variable also works the same as the hidden variable so that it requires the rows to have a tag note that if you want to disable a row permanently you can also set disabled variable to true list sections to display a list of options eureka includes a special section called selectablesection when creating one you need to pass the type of row to use in the options and the selectiontype the selectiontype is an enum which can be either multipleselection or singleselection enabledeselection bool where the enabledeselection parameter determines if the selected rows can be deselected or not swift form selectablesection where do you live selectiontype singleselection enabledeselection true let continents africa antarctica asia australia europe north america south america for option in continents form last listcheckrow option listrow in listrow title option listrow selectablevalue option listrow value nil what kind of rows can be used to create such a section you have to create a row that conforms the selectablerowtype protocol swift public protocol selectablerowtype rowtype var selectablevalue value get set this selectablevalue is where the value of the row will be permanently stored the value variable will be used to determine if the row is selected or not being selectablevalue if selected or nil otherwise eureka includes the listcheckrow which is used for example in the custom rows of the examples project you can also find the imagecheckrow getting the selected rows to easily get the selected row s of a selectablesection there are two methods selectedrow and selectedrows which can be called to get the selected row in case it is a singleselection section or all the selected rows if it is a multipleselection section grouping options in sections additionally you can setup list of options to be grouped by sections using following properties of selectorviewcontroller sectionkeyforvalue a closure that should return key for particular row value this key is later used to break options by sections sectionheadertitleforkey a closure that returns header title for a section for particular key by default returns the key itself sectionfootertitleforkey a closure that returns footer title for a section for particular key multivalued sections eureka supports multiple values for a certain field such as telephone numbers in a contact by using multivalued sections it allows us to easily create insertable deletable and reorderable sections how to create a multivalued section in order to create a multivalued section we have to use multivaluedsection type instead of the regular section type multivaluedsection extends section and has some additional properties to configure multivalued section behavior lets dive into a code example swift form multivaluedsection multivaluedoptions reorder insert delete header multivalued textfield footer insert adds a add item add new tag button row as last cell 0 addbuttonprovider section in return buttonrow 0 title add new tag 0 multivaluedrowtoinsertat index in return namerow 0 placeholder tag name 0 namerow 0 placeholder tag name previous code snippet shows how to create a multivalued section in this case we want to insert delete and reorder rows as multivaluedoptions argument indicates addbuttonprovider allows us to customize the button row which inserts a new row when tapped and multivaluedoptions contains insert value multivaluedrowtoinsertat closure property is called by eureka each time a new row needs to be inserted in order to provide the row to add into multivalued section we should set this property eureka passes the index as closure parameter notice that we can return any kind of row even custom rows even though in most cases multivalued section rows are of the same type eureka automatically adds a button row when we create a insertable multivalued section we can customize how the this button row looks like as we explained before showinserticoninaddbutton property indicates if plus button insert style should appear in the left of the button true by default there are some considerations we need to have in mind when creating insertable sections any row added to the insertable multivalued section should be placed above the row that eureka automatically adds to insert new rows this can be easily achieved by adding these additional rows to the section from inside the sections initializer closure last parameter of section initializer so then eureka adds the adds insert button at the end of the section editing mode by default eureka will set the tableviews isediting to true only if there is a multivaluedsection in the form this will be done in viewwillappear the first time a form is presented for more information on how to use multivalued sections please take a look at eureka example project which contains several usage examples validations eureka 2 0 0 introduces the much requested built in validations feature a row has a collection of rules and a specific configuration that determines when validation rules should be evaluated there are some rules provided by default but you can also create new ones on your own the provided rules are rulerequired ruleemail ruleurl rulegreaterthan rulegreaterorequalthan rulesmallerthan rulesmallerorequalthan ruleminlength rulemaxlength ruleclosure lets see how to set up the validation rules swift override func viewdidload super viewdidload form section header required rule footer options validates on change textrow 0 title required rule 0 add rule rulerequired this could also have been achieved using a closure that returns nil if valid or a validationerror otherwise let rulerequiredviaclosure ruleclosure string rowvalue in return rowvalue nil rowvalue isempty validationerror msg field required nil 0 add rule rulerequiredviaclosure 0 validationoptions validatesonchange cellupdate cell row in if row isvalid cell titlelabel textcolor red section header email rule required rule footer options validates on change after blurred textrow 0 title email rule 0 add rule rulerequired 0 add rule ruleemail 0 validationoptions validatesonchangeafterblurred cellupdate cell row in if row isvalid cell titlelabel textcolor red as you can see in the previous code snippet we can set up as many rules as we want in a row by invoking rows add rule function row also provides func remove rulewithidentifier identifier string to remove a rule in order to use it we must assign an id to the rule after creating it sometimes the collection of rules we want to use on a row is the same we want to use on many other rows in this case we can set up all validation rules using a ruleset which is a collection of validation rules swift var rules ruleset rules add rule rulerequired rules add rule ruleemail let row textrow 0 title email rule 0 add ruleset rules 0 validationoptions validatesonchangeafterblurred eureka allows us to specify when validation rules should be evaluated we can do it by setting up validationoptions rows property which can have the following values validatesonchange validates whenever a row value changes validatesonblur default value validates right after the cell resigns first responder not applicable for all rows validatesonchangeafterblurred validates whenever the row value changes after it resigns first responder for the first time validatesondemand we should manually validate the row or form by invoking validate method if you want to validate the entire form all the rows you can manually invoke form validate method how to get validation errors each row has the validationerrors property that can be used to retrieve all validation errors this property just holds the validation error list of the latest row validation execution which means it doesnt evaluate the validation rules of the row note on types as expected the rules must use the same types as the row object be extra careful to check the row type used you might see a compiler error incorrect arugment label in call have rule expected ruleset that is not pointing to the problem when mixing types swipe actions eureka 4 1 0 introduces the swipe feature you are now able to define multiple leadingswipe and trailingswipe actions per row as swipe actions depend on ios system features leadingswipe is available on ios 11 0 only lets see how to define swipe actions swift let row textrow let deleteaction swipeaction style destructive title delete handler action row completionhandler in add your code here make sure you call the completionhandler once done completionhandler true deleteaction image uiimage named icon trash 0 trailingswipe actions deleteaction 0 trailingswipe performsfirstactionwithfullswipe true please be aware leadingswipe is only available on ios 11 only let infoaction swipeaction style normal title info handler action row completionhandler in add your code here make sure you call the completionhandler once done completionhandler true infoaction backgroundcolor blue infoaction image uiimage named icon info 0 leadingswipe actions infoaction 0 leadingswipe performsfirstactionwithfullswipe true swipe actions need tableview isediting be set to false eureka will set this to true if there is a multivaluedsection in the form in the viewwillappear if you have both multivaluedsections and swipe actions in the same form you should set isediting according to your needs custom rows it is very common that you need a row that is different from those included in eureka if this is the case you will have to create your own row but this should not be difficult you can read this tutorial on how to create custom rows to get started you might also want to have a look at eurekacommunity which includes some extra rows ready to be added to eureka basic custom rows to create a row with custom behaviour and appearance youll probably want to create subclasses of row and cell remember that row is the abstraction eureka uses while the cell is the actual uitableviewcell in charge of the view as the row contains the cell both row and cell must be defined for the same value type swift custom cell with value type bool the cell is defined using a xib so we can set outlets public class customcell cell celltype iboutlet weak var switchcontrol uiswitch iboutlet weak var label uilabel public override func setup super setup switchcontrol addtarget self action selector customcell switchvaluechanged for valuechanged func switchvaluechanged row value switchcontrol on row updatecell re draws the cell which calls update bellow public override func update super update backgroundcolor row value false white black the custom row also has the cell customcell and its correspond value public final class customrow row rowtype required public init tag string super init tag tag we set the cellprovider to load the xib corresponding to our cell cellprovider cellprovider nibname customcell the result custom rows need to subclass row celltype and conform to rowtype protocol custom cells need to subclass cell valuetype and conform to celltype protocol just like the callbacks cellsetup and cellupdate the cell has the setup and update methods where you can customize it custom inline rows a inline row is a specific type of row that shows dynamically a row below it normally an inline row changes between a expand and collapse mode whenever the row is tapped so to create a inline row we need 2 rows the row that are always visible and the row that will expand collapse another requirement is that the value type of these 2 rows must be the same once we have these 2 rows we should make the top row type conforms to inlinerowtype which will add some methods to the top row class type such as swift func expandinlinerow func hideinlinerow func toggleinlinerow finally we must invoke toggleinlinerow when the row is selected for example overriding the customdidselect row method swift public override func customdidselect toggleinlinerow custom presenter rows note a presenter row is a row that presents a new uiviewcontroller to create a custom presenter row you must create a class that conforms the presenterrowtype protocol it is highly recommended to subclass selectorrow as it does conform to that protocol and adds other useful functionality the presenterrowtype protocol is defined as follows swift public protocol presenterrowtype typedrowtype associatedtype presentedcontrollertype uiviewcontroller typedrowcontrollertype defines how the view controller will be presented pushed etc var presentationmode presentationmode presentedcontrollertype get set will be called before the presentation occurs var onpresentcallback formviewcontroller presentedcontrollertype void get set the onpresentcallback will be called when the row is about to present another view controller this is done in the selectorrow so if you do not subclass it you will have to call it yourself the presentationmode is what defines how the controller is presented and which controller is presented this presentation can be using a segue identifier a segue class presenting a controller modally or pushing to a specific view controller for example a custompushrow can be defined like this lets see an example swift generic row type where a user must select a value among several options open class selectorrow optionsrow presenterrowtype where cell basecell defines how the view controller will be presented pushed etc open var presentationmode presentationmode selectorviewcontroller selectorrow cell will be called before the presentation occurs open var onpresentcallback formviewcontroller selectorviewcontroller selectorrow cell void required public init tag string super init tag tag extends didselect method open override func customdidselect super customdidselect guard let presentationmode presentationmode isdisabled else return if let controller presentationmode makecontroller controller row self controller title selectortitle controller title onpresentcallback cell formviewcontroller controller presentationmode present controller row self presentingcontroller self cell formviewcontroller else presentationmode present nil row self presentingcontroller self cell formviewcontroller prepares the pushed row setting its title and completion callback open override func prepare for segue uistoryboardsegue super prepare for segue guard let rowvc segue destination as any as selectorviewcontroller selectorrow cell else return rowvc title selectortitle rowvc title rowvc ondismisscallback presentationmode ondismisscallback rowvc ondismisscallback onpresentcallback cell formviewcontroller rowvc rowvc row self selectorrow conforms to presenterrowtype public final class custompushrow selectorrow rowtype public required init tag string super init tag tag presentationmode show controllerprovider controllerprovider callback return selectorviewcontroller t in ondismiss vc in vc navigationcontroller popviewcontroller animated true subclassing cells using the same row sometimes we want to change the ui look of one of our rows but without changing the row type and all the logic associated to one row there is currently one way to do this if you are using cells that are instantiated from nib files currently none of eurekas core rows are instantiated from nib files but some of the custom rows in eurekacommunity are in particular the postaladdressrow which was moved there what you have to do is create a nib file containing the cell you want to create then set the class of the cell to be the existing cell you want to modify if you want to change something more apart from pure ui then you should subclass that cell make sure the module of that class is correctly set connect the outlets to your class tell your row to use the new nib file this is done by setting the cellprovider variable to use this nib you should do this in the initialiser either in each concrete instantiation or using the defaultrowinitializer for example swift postaladdressrow 0 cellprovider cellprovider postaladdresscell nibname customnib bundle bundle main you could also create a new row for this in that case try to inherit from the same superclass as the row you want to change to inherit its logic there are some things to consider when you do this if you want to see an example have a look at the postaladdressrow or the creditcardrow which have use a custom nib file in their examples if you get an error saying unknown class your class name in interface builder file it might be that you have to instantiate that new type somewhere in your code to load it in the runtime calling let t yourclass self helped in my case row catalog controls rows label row button row check row switch row slider row stepper row text area row field rows these rows have a textfield on the right side of the cell the difference between each one of them consists in a different capitalization autocorrection and keyboard type configuration textrow namerow urlrow introw phonerow passwordrow emailrow decimalrow twitterrow accountrow zipcoderow all of the fieldrow subtypes above have a formatter property of type nsformatter which can be set to determine how that rows value should be displayed a custom formatter for numbers with two digits after the decimal mark is included with eureka decimalformatter the example project also contains a currencyformatter which displays a number as currency according to the users locale by default setting a rows formatter only affects how a value is displayed when it is not being edited to also format the value while the row is being edited set useformatterduringinput to true when initializing the row formatting the value as it is being edited may require updating the cursor position and eureka provides the following protocol that your formatter should conform to in order to handle cursor position swift public protocol formatterprotocol func getnewposition forposition forposition uitextposition intextinput textinput uitextinput oldvalue string newvalue string uitextposition additionally fieldrow subtypes have a useformatterondidbeginediting property when using a decimalrow with a formatter that allows decimal values and conforms to the users locale e g decimalformatter if useformatterduringinput is false useformatterondidbeginediting must be set to true so that the decimal mark in the value being edited matches the decimal mark on the keyboard date rows date rows hold a date and allow us to set up a new value through uidatepicker control the mode of the uidatepicker and the way how the date picker view is shown is what changes between them date row picker shown in the keyboard date row inline the row expands date row picker the picker is always visible with those 3 styles normal inline picker eureka includes daterow timerow datetimerow countdownrow option rows these are rows with a list of options associated from which the user must choose swift actionsheetrow string 0 title actionsheetrow 0 selectortitle pick a number 0 options one two three 0 value two initially selected alert row will show an alert with the options to choose from actionsheet row will show an action sheet with the options to choose from push row will push to a new controller from where to choose options listed using check rows multiple selector row like pushrow but allows the selection of multiple options segmented row segmented row w title picker row presents options of a generic type through a picker view there is also picker inline row built your own custom row let us know about it we would be glad to mention it here locationrow included as custom row in the example project installation cocoapods cocoapods is a dependency manager for cocoa projects specify eureka into your projects podfile ruby source https github com cocoapods specs git platform ios 9 0 use frameworks pod eureka then run the following command bash pod install carthage carthage is a simple decentralized dependency manager for cocoa specify eureka into your projects cartfile ogdl github xmartlabs eureka 4 0 manually as embedded framework clone eureka as a git submodule by running the following command from your project root git folder bash git submodule add https github com xmartlabs eureka git open eureka folder that was created by the previous git submodule command and drag the eureka xcodeproj into the project navigator of your applications xcode project select the eureka xcodeproj in the project navigator and verify the deployment target matches with your application deployment target select your project in the xcode navigation and then select your application target from the sidebar next select the general tab and click on the button under the embedded binaries section select eureka framework and we are done getting involved if you want to contribute please feel free to submit pull requests if you have a feature request please open an issue if you found a bug check older issues before submitting an issue if you need help or would like to ask general question use stackoverflow tag eureka forms before contribute check the contributing file for more info if you use eureka in your app we would love to hear about it drop us a line on twitter authors martin barreto mtnbarreto mathias claassen mclaassen26 faq how to change the text representation of the row value shown in the cell every row has the following property swift block variable used to get the string that should be displayed for the value of this row public var displayvaluefor t string return 0 map string describing 0 you can set displayvaluefor according the string value you want to display how to get a row using its tag value we can get a particular row by invoking any of the following functions exposed by the form class swift public func rowby t equatable tag string rowof t public func rowby row rowtype tag string row public func rowby tag string baserow for instance swift let daterow daterow form rowby tag daterowtag let labelrow labelrow form rowby tag labelrowtag let daterow2 row form rowby tag daterowtag let labelrow2 baserow form rowby tag labelrowtag how to get a section using its tag value swift let section section form sectionby tag sectiontag how to set the form values using a dictionary invoking setvalues values string any which is exposed by form class for example swift form setvalues introwtag 8 textrowtag hello world pushrowtag company name xmartlabs where introwtag textrowtag pushrowtag are row tags each one uniquely identifies a row and 8 hello world company name xmartlabs are the corresponding row value to assign the value type of a row must match with the value type of the corresponding dictionary value otherwise nil will be assigned if the form was already displayed we have to reload the visible rows either by reloading the table view tableview reloaddata or invoking updatecell to each visible row row does not update after changing hidden or disabled condition after setting a condition this condition is not automatically evaluated if you want it to do so immediately you can call evaluatehidden or evaluatedisabled this functions are just called when a row is added to the form and when a row it depends on changes if the condition is changed when the row is being displayed then it must be reevaluated manually oncellunhighlight doesnt get called unless oncellhighlight is also defined look at this issue how to update a section header footer set up a new header footer data swift section header headerfooterview title header title \ variable use string interpolation or var header headerfooterview uiview class most flexible way to set up a header using any view type header height 60 height can be calculated header onsetupview view section in each time the view is about to be displayed onsetupview is invoked view backgroundcolor orange section header header reload the section to perform the changes swift section reload how to customize selector and multipleselector option cells selectablerowsetup selectablerowcellupdate and selectablerowcellsetup properties are provided to be able to customize selectorviewcontroller and multipleselectorviewcontroller selectable cells swift let row pushrow 0 title pushrow 0 options 💁🏻 🍐 👦🏼 🐗 🐼 🐻 0 value 👦🏼 0 selectortitle choose an emoji onpresent from to in to dismissonselection false to dismissonchange false to selectablerowsetup row in row cellprovider cellprovider nibname emojicell bundle bundle main to selectablerowcellupdate cell row in cell textlabel text text row selectablevalue customization cell detailtextlabel text detail row selectablevalue dont want to use eureka custom operators as weve said form and section types conform to mutablecollection and rangereplaceablecollection a form is a collection of sections and a section is a collection of rows rangereplaceablecollection protocol extension provides many useful methods to modify collection swift extension rangereplaceablecollection public mutating func append newelement self element public mutating func append s contentsof newelements s where s sequence self element s element public mutating func insert newelement self element at i self index public mutating func insert s contentsof newelements s at i self index where s collection self element s element public mutating func remove at i self index self element public mutating func removesubrange bounds range self index public mutating func removefirst n int public mutating func removefirst self element public mutating func removeall keepingcapacity keepcapacity bool public mutating func reservecapacity n self indexdistance these methods are used internally to implement the custom operators as shown bellow swift public func left form right section form left append right return left public func inout lhs form rhs c where c element section lhs append contentsof rhs public func left section right baserow section left append right return left public func inout lhs section rhs c where c element baserow lhs append contentsof rhs you can see how the rest of custom operators are implemented here its up to you to decide if you want to use eureka custom operators or not in file in project external donate to eureka so we can make eureka even better change log this can be found in the changelog md file