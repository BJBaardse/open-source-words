dont edit this file manually instead you should generate it by using wiki2markdown pl doc httpluamodule wiki name ngx http lua module embed the power of lua into nginx http servers this module is not distributed with the nginx source see the installation instructions table of contents name status version synopsis description typical uses nginx compatibility installation building as a dynamic module c macro configurations installation on ubuntu 11 10 community english mailing list chinese mailing list code repository bugs and patches lua luajit bytecode support system environment variable support http 1 0 support statically linking pure lua modules data sharing within an nginx worker known issues tcp socket connect operation issues lua coroutine yielding resuming lua variable scope locations configured by subrequest directives of other modules cosockets not available everywhere special escaping sequences mixing with ssi not supported spdy mode not fully supported missing data on short circuited requests todo changes test suite copyright and license see also directives nginx api for lua obsolete sections special pcre sequences status production ready version this document describes ngx lua v0 10 13 released on 22 april 2018 synopsis nginx set search paths for pure lua external libraries is the default path lua package path foo bar lua blah lua set search paths for lua external libraries written in c can also use lua package cpath bar baz so blah blah so server location lua content mime type determined by default type default type text plain content by lua block ngx say hello world location nginx var mime type determined by default type default type text plain try access nginx var a hello world content by lua block ngx say ngx var arg a location request body client max body size 50k client body buffer size 50k content by lua block ngx req read body explicitly read the req body local data ngx req get body data if data then ngx say body data ngx print data return end body may get buffered in a temp file local file ngx req get body file if file then ngx say body is in file file else ngx say no body found end transparent non blocking i o in lua via subrequests well a better way is to use cosockets location lua mime type determined by default type default type text plain content by lua block local res ngx location capture some other location if res then ngx say status res status ngx say body ngx print res body end location foo rewrite by lua block res ngx location capture memc args cmd incr key ngx var uri proxy pass http blah blah com location mixed rewrite by lua file path to rewrite lua access by lua file path to access lua content by lua file path to content lua use nginx var in code path caution contents in nginx var must be carefully filtered otherwise therell be great security risk location app a za z0 9 set path 1 content by lua file path to lua app root path lua location client max body size 100k client body buffer size 100k access by lua block check the client ip address is in our black list if ngx var remote addr 132 5 72 3 then ngx exit ngx http forbidden end check if the uri contains bad words if ngx var uri and string match ngx var request body evil then return ngx redirect terms of use html end tests passed proxy pass fastcgi pass etc settings back to toc description this module embeds lua via the standard lua 5 1 interpreter or luajit 2 0 2 1 into nginx and by leveraging nginxs subrequests allows the integration of the powerful lua threads lua coroutines into the nginx event model unlike apaches mod lua and lighttpds mod magnet lua code executed using this module can be 100 non blocking on network traffic as long as the nginx api for lua provided by this module is used to handle requests to upstream services such as mysql postgresql memcached redis or upstream http web services at least the following lua libraries and nginx modules can be used with this ngx lua module lua resty memcached lua resty mysql lua resty redis lua resty dns lua resty upload lua resty websocket lua resty lock lua resty logger socket lua resty lrucache lua resty string ngx memc ngx postgres ngx redis2 ngx redis ngx proxy ngx fastcgi almost all the nginx modules can be used with this ngx lua module by means of ngx location capture or ngx location capture multi but it is recommended to use those lua resty libraries instead of creating subrequests to access the nginx upstream modules because the former is usually much more flexible and memory efficient the lua interpreter or luajit instance is shared across all the requests in a single nginx worker process but request contexts are segregated using lightweight lua coroutines loaded lua modules persist in the nginx worker process level resulting in a small memory footprint in lua even when under heavy loads this module is plugged into nginxs http subsystem so it can only speaks downstream communication protocols in the http family http 0 9 1 0 1 1 2 0 websockets and etc if you want to do generic tcp communications with the downstream clients then you should use the ngx stream lua module instead which has a compatible lua api back to toc typical uses just to name a few mashuping and processing outputs of various nginx upstream outputs proxy drizzle postgres redis memcached and etc in lua doing arbitrarily complex access control and security checks in lua before requests actually reach the upstream backends manipulating response headers in an arbitrary way by lua fetching backend information from external storage backends like redis memcached mysql postgresql and use that information to choose which upstream backend to access on the fly coding up arbitrarily complex web applications in a content handler using synchronous but still non blocking access to the database backends and other storage doing very complex url dispatch in lua at rewrite phase using lua to implement advanced caching mechanism for nginxs subrequests and arbitrary locations the possibilities are unlimited as the module allows bringing together various elements within nginx as well as exposing the power of the lua language to the user the module provides the full flexibility of scripting while offering performance levels comparable with native c language programs both in terms of cpu time as well as memory footprint this is particularly the case when luajit 2 x is enabled other scripting language implementations typically struggle to match this performance level the lua state lua vm instance is shared across all the requests handled by a single nginx worker process to minimize memory use back to toc nginx compatibility the latest version of this module is compatible with the following versions of nginx 1 13 x last tested 1 13 6 1 12 x 1 11 x last tested 1 11 2 1 10 x 1 9 x last tested 1 9 15 1 8 x 1 7 x last tested 1 7 10 1 6 x nginx cores older than 1 6 0 exclusive are not supported back to toc installation it is highly recommended to use openresty releases which integrate nginx ngx lua luajit 2 1 as well as other powerful companion nginx modules and lua libraries it is discouraged to build this module with nginx yourself since it is tricky to set up exactly right also the stock nginx cores have various limitations and long standing bugs that can make some of this modules features become disabled not work properly or run slower the same applies to luajit as well openresty includes its own version of luajit which gets specifically optimized and enhanced for the openresty environment alternatively ngx lua can be manually compiled into nginx install luajit 2 0 or 2 1 recommended or lua 5 1 lua 5 2 is not supported yet luajit can be downloaded from the luajit project website and lua 5 1 from the lua project website some distribution package managers also distribute luajit and or lua download the latest version of the ngx devel kit ndk module here download the latest version of ngx lua here download the latest version of nginx here see nginx compatibility build the source with this module bash wget http nginx org download nginx 1 13 6 tar gz tar xzvf nginx 1 13 6 tar gz cd nginx 1 13 6 tell nginxs build system where to find luajit 2 0 export luajit lib path to luajit lib export luajit inc path to luajit include luajit 2 0 tell nginxs build system where to find luajit 2 1 export luajit lib path to luajit lib export luajit inc path to luajit include luajit 2 1 or tell where to find lua if using lua instead export lua lib path to lua lib export lua inc path to lua include here we assume nginx is to be installed under opt nginx configure prefix opt nginx \ with ld opt wl rpath path to luajit or lua lib \ add module path to ngx devel kit \ add module path to lua nginx module note that you may also want to add configure options which are used in your current nginx build you can get usually those options using command nginx v you can change the parallism number 2 below to fit the number of spare cpu cores in your machine make j2 make install back to toc building as a dynamic module starting from nginx 1 9 11 you can also compile this module as a dynamic module by using the add dynamic module path option instead of add module path on the configure command line above and then you can explicitly load the module in your nginx conf via the load module directive for example nginx load module path to modules ndk http module so assuming ndk is built as a dynamic module too load module path to modules ngx http lua module so back to toc c macro configurations while building this module either via openresty or with the nginx core you can define the following c macros via the c compiler options ngx lua use assert when defined will enable assertions in the ngx lua c code base recommended for debugging or testing builds it can introduce some small runtime overhead when enabled this macro was first introduced in the v0 9 10 release ngx lua abort at panic when the lua luajit vm panics ngx lua will instruct the current nginx worker process to quit gracefully by default by specifying this c macro ngx lua will abort the current nginx worker process which usually result in a core dump file immediately this option is useful for debugging vm panics this option was first introduced in the v0 9 8 release ngx lua no ffi api excludes pure c api functions for ffi based lua api for nginx as required by lua resty core for example enabling this macro can make the resulting binary code size smaller to enable one or more of these macros just pass extra c compiler options to the configure script of either nginx or openresty for instance configure with cc opt dngx lua use assert dngx lua abort at panic back to toc installation on ubuntu 11 10 note that it is recommended to use luajit 2 0 or luajit 2 1 instead of the standard lua 5 1 interpreter wherever possible if the standard lua 5 1 interpreter is required however run the following command to install it from the ubuntu repository bash apt get install y lua5 1 liblua5 1 0 liblua5 1 0 dev everything should be installed correctly except for one small tweak library name liblua so has been changed in liblua5 1 package it only comes with liblua5 1 so which needs to be symlinked to usr lib so it could be found during the configuration process bash ln s usr lib x86 64 linux gnu liblua5 1 so usr lib liblua so back to toc community back to toc english mailing list the openresty en mailing list is for english speakers back to toc chinese mailing list the openresty mailing list is for chinese speakers back to toc code repository the code repository of this project is hosted on github at openresty lua nginx module back to toc bugs and patches please submit bug reports wishlists or patches by creating a ticket on the github issue tracker or posting to the openresty community back to toc lua luajit bytecode support as from the v0 5 0rc32 release all by lua file configure directives such as content by lua file support loading lua 5 1 and luajit 2 0 2 1 raw bytecode files directly please note that the bytecode format used by luajit 2 0 2 1 is not compatible with that used by the standard lua 5 1 interpreter so if using luajit 2 0 2 1 with ngx lua luajit compatible bytecode files must be generated as shown bash path to luajit bin luajit b path to input file lua path to output file ljbc the bg option can be used to include debug information in the luajit bytecode file bash path to luajit bin luajit bg path to input file lua path to output file ljbc please refer to the official luajit documentation on the b option for more details http luajit org running html opt b also the bytecode files generated by luajit 2 1 is not compatible with luajit 2 0 and vice versa the support for luajit 2 1 bytecode was first added in ngx lua v0 9 3 similarly if using the standard lua 5 1 interpreter with ngx lua lua compatible bytecode files must be generated using the luac commandline utility as shown bash luac o path to output file luac path to input file lua unlike as with luajit debug information is included in standard lua 5 1 bytecode files by default this can be striped out by specifying the s option as shown bash luac s o path to output file luac path to input file lua attempts to load standard lua 5 1 bytecode files into ngx lua instances linked to luajit 2 0 2 1 or vice versa will result in an error message such as that below being logged into the nginx error log file error 13909 0 1 failed to load lua inlined code bad byte code header in path to test file luac loading bytecode files via the lua primitives like require and dofile should always work as expected back to toc system environment variable support if you want to access the system environment variable say foo in lua via the standard lua api os getenv then you should also list this environment variable name in your nginx conf file via the env directive for example nginx env foo back to toc http 1 0 support the http 1 0 protocol does not support chunked output and requires an explicit content length header when the response body is not empty in order to support the http 1 0 keep alive so when a http 1 0 request is made and the lua http10 buffering directive is turned on ngx lua will buffer the output of ngx say and ngx print calls and also postpone sending response headers until all the response body output is received at that time ngx lua can calculate the total length of the body and construct a proper content length header to return to the http 1 0 client if the content length response header is set in the running lua code however this buffering will be disabled even if the lua http10 buffering directive is turned on for large streaming output responses it is important to disable the lua http10 buffering directive to minimise memory usage note that common http benchmark tools such as ab and http load issue http 1 0 requests by default to force curl to send http 1 0 requests use the 0 option back to toc statically linking pure lua modules when luajit 2 x is used it is possible to statically link the bytecode of pure lua modules into the nginx executable basically you use the luajit executable to compile lua lua module files to o object files containing the exported bytecode data and then link the o files directly in your nginx build below is a trivial example to demonstrate this consider that we have the following lua file named foo lua lua foo lua local m function m go print hello from foo end return m and then we compile this lua file to foo o file path to luajit bin luajit bg foo lua foo o what matters here is the name of the lua file which determines how you use this module later on the lua land the file name foo o does not matter at all except the o file extension which tells luajit what output format is used if you want to strip the lua debug information from the resulting bytecode you can just specify the b option above instead of bg then when building nginx or openresty pass the with ld opt foo o option to the configure script bash configure with ld opt path to foo o finally you can just do the following in any lua code run by ngx lua lua local foo require foo foo go and this piece of code no longer depends on the external foo lua file any more because it has already been compiled into the nginx executable if you want to use dot in the lua module name when calling require as in lua local foo require resty foo then you need to rename the foo lua file to resty foo lua before compiling it down to a o file with the luajit command line utility it is important to use exactly the same version of luajit when compiling lua files to o files as building nginx ngx lua this is because the luajit bytecode format may be incompatible between different luajit versions when the bytecode format is incompatible you will see a lua runtime error saying that the lua module is not found when you have multiple lua files to compile and link then just specify their o files at the same time in the value of the with ld opt option for instance bash configure with ld opt path to foo o path to bar o if you have just too many o files then it might not be feasible to name them all in a single command in this case you can build a static library or archive for your o files as in bash ar rcus libmyluafiles a o then you can link the myluafiles archive as a whole to your nginx executable bash configure \ with ld opt l path to lib wl whole archive lmyluafiles wl no whole archive where path to lib is the path of the directory containing the libmyluafiles a file it should be noted that the linker option whole archive is required here because otherwise our archive will be skipped because no symbols in our archive are mentioned in the main parts of the nginx executable back to toc data sharing within an nginx worker to globally share data among all the requests handled by the same nginx worker process encapsulate the shared data into a lua module use the lua require builtin to import the module and then manipulate the shared data in lua this works because required lua modules are loaded only once and all coroutines will share the same copy of the module both its code and data note however that lua global variables note not module level variables will not persist between requests because of the one coroutine per request isolation design here is a complete small example lua mydata lua local m local data dog 3 cat 4 pig 5 function m get age name return data name end return m and then accessing it from nginx conf nginx location lua content by lua block local mydata require mydata ngx say mydata get age dog the mydata module in this example will only be loaded and run on the first request to the location lua and all subsequent requests to the same nginx worker process will use the reloaded instance of the module as well as the same copy of the data in it until a hup signal is sent to the nginx master process to force a reload this data sharing technique is essential for high performance lua applications based on this module note that this data sharing is on a per worker basis and not on a per server basis that is when there are multiple nginx worker processes under an nginx master data sharing cannot cross the process boundary between these workers it is usually recommended to share read only data this way you can also share changeable data among all the concurrent requests of each nginx worker process as long as there is no nonblocking i o operations including ngx sleep in the middle of your calculations as long as you do not give the control back to the nginx event loop and ngx luas light thread scheduler even implicitly there can never be any race conditions in between for this reason always be very careful when you want to share changeable data on the worker level buggy optimizations can easily lead to hard to debug race conditions under load if server wide data sharing is required then use one or more of the following approaches use the ngx shared dict api provided by this module use only a single nginx worker and a single server this is however not recommended when there is a multi core cpu or multiple cpus in a single machine use data storage mechanisms such as memcached redis mysql or postgresql the openresty bundle associated with this module comes with a set of companion nginx modules and lua libraries that provide interfaces with these data storage mechanisms back to toc known issues back to toc tcp socket connect operation issues the tcpsock connect method may indicate success despite connection failures such as with connection refused errors however later attempts to manipulate the cosocket object will fail and return the actual error status message generated by the failed connect operation this issue is due to limitations in the nginx event model and only appears to affect mac os x back to toc lua coroutine yielding resuming because luas dofile and require builtins are currently implemented as c functions in both lua 5 1 and luajit 2 0 2 1 if the lua file being loaded by dofile or require invokes ngx location capture ngx exec ngx exit or other api functions requiring yielding in the top level scope of the lua file then the lua error attempt to yield across c call boundary will be raised to avoid this put these calls requiring yielding into your own lua functions in the lua file instead of the top level scope of the file as the standard lua 5 1 interpreters vm is not fully resumable the methods ngx location capture ngx location capture multi ngx redirect ngx exec and ngx exit cannot be used within the context of a lua pcall or xpcall or even the first line of the for in statement when the standard lua 5 1 interpreter is used and the attempt to yield across metamethod c call boundary error will be produced please use luajit 2 x which supports a fully resumable vm to avoid this back to toc lua variable scope care must be taken when importing modules and this form should be used lua local xxx require xxx instead of the old deprecated form lua require xxx here is the reason by design the global environment has exactly the same lifetime as the nginx request handler associated with it each request handler has its own set of lua global variables and that is the idea of request isolation the lua module is actually loaded by the first nginx request handler and is cached by the require built in in the package loaded table for later reference and the module builtin used by some lua modules has the side effect of setting a global variable to the loaded module table but this global variable will be cleared at the end of the request handler and every subsequent request handler all has its own clean global environment so one will get lua exception for accessing the nil value the use of lua global variables is a generally inadvisable in the ngx lua context as the misuse of lua globals has detrimental side effects on concurrent requests when such variables should instead be local in scope lua global variables require lua table look ups in the global environment which is computationally expensive and some lua global variable references may include typing errors which make such difficult to debug it is therefore highly recommended to always declare such within an appropriate local scope instead lua avoid foo 123 recommended local foo 123 avoid function foo return 123 end recommended local function foo return 123 end to find all instances of lua global variables in your lua code run the lua releng tool across all lua source files lua releng checking use of lua global variables in file lib foo bar lua 1 1489 setglobal 7 1 contains 55 1506 getglobal 7 3 setvar 3 1545 getglobal 3 4 varexpand the output says that the line 1489 of file lib foo bar lua writes to a global variable named contains the line 1506 reads from the global variable setvar and line 1545 reads the global varexpand this tool will guarantee that local variables in the lua module functions are all declared with the local keyword otherwise a runtime exception will be thrown it prevents undesirable race conditions while accessing such variables see data sharing within an nginx worker for the reasons behind this back to toc locations configured by subrequest directives of other modules the ngx location capture and ngx location capture multi directives cannot capture locations that include the add before body add after body auth request echo location echo location async echo subrequest or echo subrequest async directives nginx location foo content by lua block res ngx location capture bar location bar echo location blah location blah echo success nginx curl i http example com foo will not work as expected back to toc cosockets not available everywhere due to internal limitations in the nginx core the cosocket api is disabled in the following contexts set by lua log by lua header filter by lua and body filter by lua the cosockets are currently also disabled in the init by lua and init worker by lua directive contexts but we may add support for these contexts in the future because there is no limitation in the nginx core or the limitation might be worked around there exists a work around however when the original context does not need to wait for the cosocket results that is creating a zero delay timer via the ngx timer at api and do the cosocket results in the timer handler which runs asynchronously as to the original context creating the timer back to toc special escaping sequences note following the v0 9 17 release this pitfall can be avoided by using the by lua block configuration directives pcre sequences such as \d \s or \w require special attention because in string literals the backslash character \ is stripped out by both the lua language parser and by the nginx config file parser before processing if not within a by lua block directive so the following snippet will not work as expected nginx nginx conf location test content by lua local regex \d this is wrong outside of a by lua block directive local m ngx re match hello 1234 regex if m then ngx say m 0 else ngx say not matched end evaluates to not matched to avoid this double escape the backslash nginx nginx conf location test content by lua local regex \\d local m ngx re match hello 1234 regex if m then ngx say m 0 else ngx say not matched end evaluates to 1234 here \\\\d is stripped down to \\d by the nginx config file parser and this is further stripped down to \d by the lua language parser before running alternatively the regex pattern can be presented as a long bracketed lua string literal by encasing it in long brackets in which case backslashes have to only be escaped once for the nginx config file parser nginx nginx conf location test content by lua local regex \d local m ngx re match hello 1234 regex if m then ngx say m 0 else ngx say not matched end evaluates to 1234 here \\d is stripped down to \d by the nginx config file parser and this is processed correctly note that a longer from of the long bracket may be required if the regex pattern contains sequences the form may be used as the default form if desired nginx nginx conf location test content by lua local regex 0 9 local m ngx re match hello 1234 regex if m then ngx say m 0 else ngx say not matched end evaluates to 1234 an alternative approach to escaping pcre sequences is to ensure that lua code is placed in external script files and executed using the various by lua file directives with this approach the backslashes are only stripped by the lua language parser and therefore only need to be escaped once each lua test lua local regex \d local m ngx re match hello 1234 regex if m then ngx say m 0 else ngx say not matched end evaluates to 1234 within external script files pcre sequences presented as long bracketed lua string literals do not require modification lua test lua local regex \d local m ngx re match hello 1234 regex if m then ngx say m 0 else ngx say not matched end evaluates to 1234 as noted earlier pcre sequences presented within by lua block directives available following the v0 9 17 release do not require modification nginx nginx conf location test content by lua block local regex \d local m ngx re match hello 1234 regex if m then ngx say m 0 else ngx say not matched end evaluates to 1234 back to toc mixing with ssi not supported mixing ssi with ngx lua in the same nginx request is not supported at all just use ngx lua exclusively everything you can do with ssi can be done atop ngx lua anyway and it can be more efficient when using ngx lua back to toc spdy mode not fully supported certain lua apis provided by ngx lua do not work in nginxs spdy mode yet ngx location capture ngx location capture multi and ngx req socket back to toc missing data on short circuited requests nginx may terminate a request early with at least 400 bad request 405 not allowed 408 request timeout 413 request entity too large 414 request uri too large 494 request headers too large 499 client closed request 500 internal server error 501 not implemented this means that phases that normally run are skipped such as the rewrite or access phase this also means that later phases that are run regardless e g log by lua will not have access to information that is normally set in those phases back to toc todo cosocket implement luasockets unconnected udp api port this module to the datagram subsystem of nginx for implementing general udp servers instead of http servers in lua for example lua datagram server listen 1953 handler by lua block custom lua code implementing the special udp server shm implement a shared queue api to complement the existing shared dict lua shared dict api cosocket add support in the context of init by lua init by lua cosocket implement thebind method for stream typed cosockets cosocket pool based backend concurrency level control implement automaticconnectqueueing when the backend concurrency exceeds its connection pool limit cosocket review and merge aviramcs patch https github com openresty lua nginx module pull 290 for adding thebsdrecvmethod add new api functionngx resp add headerto emulate the standardadd headerconfig directive review and apply vadim pavlovs patch for ngx location capture ngxlocationcapture sextra headersoption usengx hash tto optimize the built in header look up process for ngx req set header ngxreqset header ngx header header ngxheaderheader and etc add configure options for different strategies of handling the cosocket connection exceeding in the pools add directives to run lua codes when nginx stops addignore resp headers ignore resp body andignore respoptions to ngx location capture ngxlocationcapture and ngx location capture multi ngxlocationcapture multi methods to allow micro performance tuning on the user side add automatic lua code time slicing support by yielding and resuming the lua vm actively via luas debug hooks addstat mode similar to mod lua cosocket add client ssl certificate support back to toc changes the changes made in every release of this module are listed in the change logs of the openresty bundle http openresty org changes back to toc test suite the following dependencies are required to run the test suite nginx version 1 4 2 perl modules test nginx https github com openresty test nginx nginx modules ngx devel kit ngx set misc ngx auth request this is not needed if youre using nginx 1 5 4 ngx echo ngx memc ngx srcache ngx lua i e this module ngx lua upstream ngx headers more ngx drizzle ngx rds json ngx coolkit ngx redis2 the order in which these modules are added during configuration is important because the position of any filter module in the filtering chain determines the final output for example the correct adding order is shown above 3rd party lua libraries lua cjson applications mysql create database ngx test grant all privileges to user ngx test password is ngx test memcached listening on the default port 11211 redis listening on the default port 6379 see also the developer build script for more details on setting up the testing environment to run the whole test suite in the default testing mode cd path to lua nginx module export path path to your nginx sbin path prove i path to test nginx lib r t to run specific test files cd path to lua nginx module export path path to your nginx sbin path prove i path to test nginx lib t 002 content t t 003 errors t to run a specific test block in a particular test file add the line only to the test block you want to run and then use the prove utility to run that t file there are also various testing modes based on mockeagain valgrind and etc refer to the test nginx documentation for more details for various advanced testing modes see also the test reports for the nginx test cluster running on amazon ec2 http qa openresty org back to toc copyright and license this module is licensed under the bsd license copyright c 2009 2017 by xiaozhe wang chaoslawful chaoslawful gmail com copyright c 2009 2018 by yichun agentzh zhang 章亦春 agentzh gmail com openresty inc all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution this software is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the copyright holder or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage back to toc see also ngx stream lua module for an official port of this module for the nginx stream subsystem doing generic downstream tcp communications lua resty memcached library based on ngx lua cosocket lua resty redis library based on ngx lua cosocket lua resty mysql library based on ngx lua cosocket lua resty upload library based on ngx lua cosocket lua resty dns library based on ngx lua cosocket lua resty websocket library for both websocket server and client based on ngx lua cosocket lua resty string library based on luajit ffi lua resty lock library for a nonblocking simple lock api lua resty cookie library for http cookie manipulation routing requests to different mysql queries based on uri arguments dynamic routing based on redis and lua using luarocks with ngx lua introduction to ngx lua ngx devel kit echo nginx module drizzle nginx module postgres nginx module memc nginx module the openresty bundle nginx systemtap toolkit back to toc directives lua capture error log lua use default type lua malloc trim lua code cache lua regex cache max entries lua regex match limit lua package path lua package cpath init by lua init by lua block init by lua file init worker by lua init worker by lua block init worker by lua file set by lua set by lua block set by lua file content by lua content by lua block content by lua file rewrite by lua rewrite by lua block rewrite by lua file access by lua access by lua block access by lua file header filter by lua header filter by lua block header filter by lua file body filter by lua body filter by lua block body filter by lua file log by lua log by lua block log by lua file balancer by lua block balancer by lua file lua need request body ssl certificate by lua block ssl certificate by lua file ssl session fetch by lua block ssl session fetch by lua file ssl session store by lua block ssl session store by lua file lua shared dict lua socket connect timeout lua socket send timeout lua socket send lowat lua socket read timeout lua socket buffer size lua socket pool size lua socket keepalive timeout lua socket log errors lua ssl ciphers lua ssl crl lua ssl protocols lua ssl trusted certificate lua ssl verify depth lua http10 buffering rewrite by lua no postpone access by lua no postpone lua transform underscores in response headers lua check client abort lua max pending timers lua max running timers the basic building blocks of scripting nginx with lua are directives directives are used to specify when the user lua code is run and how the result will be used below is a diagram showing the order in which directives are executed back to toc lua capture error log syntax lua capture error log size default none context http enables a buffer of the specified size for capturing all the nginx error log message data not just those produced by this module or the nginx http subsystem but everything without touching files or disks you can use units like k and m in the size value as in nginx lua capture error log 100k as a rule of thumb a 4kb buffer can usually hold about 20 typical error log messages so do the maths this buffer never grows if it is full new error log messages will replace the oldest ones in the buffer the size of the buffer must be bigger than the maximum length of a single error log message which is 4k in openresty and 2k in stock nginx you can read the messages in the buffer on the lua land via the get logs function of the ngx errlog module of the lua resty core library this lua api function will return the captured error log messages and also remove these already read from the global capturing buffer making room for any new error log data for this reason the user should not configure this buffer to be too big if the user read the buffered error log data fast enough note that the log level specified in the standard error log directive does have effect on this capturing facility it only captures log messages of a level no lower than the specified log level in the error log directive the user can still choose to set an even higher filtering log level on the fly via the lua api function errlog set filter level so it is more flexible than the static error log directive it is worth noting that there is no way to capture the debugging logs without building openresty or nginx with the configure option with debug and enabling debugging logs is strongly discouraged in production builds due to high overhead this directive was first introduced in the v0 10 9 release back to toc lua use default type syntax lua use default type on off default lua use default type on context http server location location if specifies whether to use the mime type specified by the default type directive for the default value of the content type response header deactivate this directive if a default content type response header for lua request handlers is not desired this directive is turned on by default this directive was first introduced in the v0 9 1 release back to toc lua malloc trim syntax lua malloc trim request count default lua malloc trim 1000 context http asks the underlying libc runtime library to release its cached free memory back to the operating system every n requests processed by the nginx core by default n is 1000 you can configure the request count by using your own numbers smaller numbers mean more frequent releases which may introduce higher cpu time consumption and smaller memory footprint while larger numbers usually lead to less cpu time overhead and relatively larger memory footprint just tune the number for your own use cases configuring the argument to 0 essentially turns off the periodical memory trimming altogether nginx lua malloc trim 0 turn off trimming completely the current implementation uses an nginx log phase handler to do the request counting so the appearance of the log subrequest on directives in nginx conf may make the counting faster when subrequests are involved by default only main requests count note that this directive does not affect the memory allocated by luajits own allocator based on the mmap system call this directive was first introduced in the v0 10 7 release back to toc lua code cache syntax lua code cache on off default lua code cache on context http server location location if enables or disables the lua code cache for lua code in by lua file directives like set by lua file and content by lua file and lua modules when turning off every request served by ngx lua will run in a separate lua vm instance starting from the 0 9 3 release so the lua files referenced in set by lua file content by lua file access by lua file and etc will not be cached and all lua modules used will be loaded from scratch with this in place developers can adopt an edit and refresh approach please note however that lua code written inlined within nginx conf such as those specified by set by lua content by lua access by lua and rewrite by lua will not be updated when you edit the inlined lua code in your nginx conf file because only the nginx config file parser can correctly parse the nginx conf file and the only way is to reload the config file by sending a hup signal or just to restart nginx even when the code cache is enabled lua files which are loaded by dofile or loadfile in by lua file cannot be cached unless you cache the results yourself usually you can either use the init by lua or init by lua file directives to load all such files or just make these lua files true lua modules and load them via require the ngx lua module does not support the stat mode available with the apache mod lua module yet disabling the lua code cache is strongly discouraged for production use and should only be used during development as it has a significant negative impact on overall performance for example the performance of a hello world lua example can drop by an order of magnitude after disabling the lua code cache back to toc lua regex cache max entries syntax lua regex cache max entries num default lua regex cache max entries 1024 context http specifies the maximum number of entries allowed in the worker process level compiled regex cache the regular expressions used in ngx re match ngx re gmatch ngx re sub and ngx re gsub will be cached within this cache if the regex option o i e compile once flag is specified the default number of entries allowed is 1024 and when this limit is reached new regular expressions will not be cached as if the o option was not specified and there will be one and only one warning in the error log file 2011 08 27 23 18 26 warn 31997 0 1 lua exceeding regex cache max entries 1024 if you are using the ngx re implementation of lua resty core by loading the resty core regex module or just the resty core module then an lru cache is used for the regex cache being used here do not activate the o option for regular expressions and or replace string arguments for ngx re sub and ngx re gsub that are generated on the fly and give rise to infinite variations to avoid hitting the specified limit back to toc lua regex match limit syntax lua regex match limit num default lua regex match limit 0 context http specifies the match limit used by the pcre library when executing the ngx re api to quote the pcre manpage the limit has the effect of limiting the amount of backtracking that can take place when the limit is hit the error string pcre exec failed 8 will be returned by the ngx re api functions on the lua land when setting the limit to 0 the default match limit when compiling the pcre library is used and this is the default value of this directive this directive was first introduced in the v0 8 5 release back to toc lua package path syntax lua package path lua style path str default the content of lua path environment variable or luas compiled in defaults context http sets the lua module search path used by scripts specified by set by lua content by lua and others the path string is in standard lua path form and can be used to stand for the original search paths as from the v0 5 0rc29 release the special notation prefix or prefix can be used in the search path string to indicate the path of the server prefix usually determined by the p path command line option while starting the nginx server back to toc lua package cpath syntax lua package cpath lua style cpath str default the content of lua cpath environment variable or luas compiled in defaults context http sets the lua c module search path used by scripts specified by set by lua content by lua and others the cpath string is in standard lua cpath form and can be used to stand for the original cpath as from the v0 5 0rc29 release the special notation prefix or prefix can be used in the search path string to indicate the path of the server prefix usually determined by the p path command line option while starting the nginx server back to toc init by lua syntax init by lua lua script str context http phase loading config note use of this directive is discouraged following the v0 9 17 release use the init by lua block directive instead runs the lua code specified by the argument lua script str on the global lua vm level when the nginx master process if any is loading the nginx config file when nginx receives the hup signal and starts reloading the config file the lua vm will also be re created and init by lua will run again on the new lua vm in case that the lua code cache directive is turned off default on the init by lua handler will run upon every request because in this special mode a standalone lua vm is always created for each request usually you can pre load lua modules at server start up by means of this hook and take advantage of modern operating systems copy on write cow optimization here is an example for pre loading lua modules nginx this runs before forking out nginx worker processes init by lua block require cjson server location api content by lua block the following require will just return the alrady loaded module from package loaded ngx say require cjson encode dog 5 cat 6 you can also initialize the lua shared dict shm storage at this phase here is an example for this nginx lua shared dict dogs 1m init by lua block local dogs ngx shared dogs dogs set tom 56 server location api content by lua block local dogs ngx shared dogs ngx say dogs get tom but note that the lua shared dicts shm storage will not be cleared through a config reload via the hup signal for example so if you do not want to re initialize the shm storage in your init by lua code in this case then you just need to set a custom flag in the shm storage and always check the flag in your init by lua code because the lua code in this context runs before nginx forks its worker processes if any data or code loaded here will enjoy the copy on write cow feature provided by many operating systems among all the worker processes thus saving a lot of memory do not initialize your own lua global variables in this context because use of lua global variables have performance penalties and can lead to global namespace pollution see the lua variable scope section for more details the recommended way is to use proper lua module files but do not use the standard lua function module to define lua modules because it pollutes the global namespace as well and call require to load your own module files in init by lua or other contexts require does cache the loaded lua modules in the global package loaded table in the lua registry so your modules will only loaded once for the whole lua vm instance only a small set of the nginx api for lua is supported in this context logging apis ngx log and print shared dictionary api ngx shared dict more nginx apis for lua may be supported in this context upon future user requests basically you can safely use lua libraries that do blocking i o in this very context because blocking the master process during server start up is completely okay even the nginx core does blocking i o at least on resolving upstreams host names at the configure loading phase you should be very careful about potential security vulnerabilities in your lua code registered in this context because the nginx master process is often run under the root account this directive was first introduced in the v0 5 5 release back to toc init by lua block syntax init by lua block lua script context http phase loading config similar to the init by lua directive except that this directive inlines the lua source directly inside a pair of curly braces instead of in an nginx string literal which requires special character escaping for instance nginx init by lua block print i need no extra escaping here for example \r\nblah this directive was first introduced in the v0 9 17 release back to toc init by lua file syntax init by lua file path to lua script file context http phase loading config equivalent to init by lua except that the file specified by path to lua script file contains the lua code or lua luajit bytecode to be executed when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server this directive was first introduced in the v0 5 5 release back to toc init worker by lua syntax init worker by lua lua script str context http phase starting worker note use of this directive is discouraged following the v0 9 17 release use the init worker by lua block directive instead runs the specified lua code upon every nginx worker processs startup when the master process is enabled when the master process is disabled this hook will just run after init by lua this hook is often used to create per worker reoccurring timers via the ngx timer at lua api either for backend health check or other timed routine work below is an example nginx init worker by lua local delay 3 in seconds local new timer ngx timer at local log ngx log local err ngx err local check check function premature if not premature then do the health check or other routine work local ok err new timer delay check if not ok then log err failed to create timer err return end end end local hdl err new timer delay check if not hdl then log err failed to create timer err return end this directive was first introduced in the v0 9 5 release this hook no longer runs in the cache manager and cache loader processes since the v0 10 12 release back to toc init worker by lua block syntax init worker by lua block lua script context http phase starting worker similar to the init worker by lua directive except that this directive inlines the lua source directly inside a pair of curly braces instead of in an nginx string literal which requires special character escaping for instance nginx init worker by lua block print i need no extra escaping here for example \r\nblah this directive was first introduced in the v0 9 17 release this hook no longer runs in the cache manager and cache loader processes since the v0 10 12 release back to toc init worker by lua file syntax init worker by lua file lua file path context http phase starting worker similar to init worker by lua but accepts the file path to a lua source file or lua bytecode file this directive was first introduced in the v0 9 5 release this hook no longer runs in the cache manager and cache loader processes since the v0 10 12 release back to toc set by lua syntax set by lua res lua script str arg1 arg2 context server server if location location if phase rewrite note use of this directive is discouraged following the v0 9 17 release use the set by lua block directive instead executes code specified in lua script str with optional input arguments arg1 arg2 and returns string output to res the code in lua script str can make api calls and can retrieve input arguments from the ngx arg table index starts from 1 and increases sequentially this directive is designed to execute short fast running code blocks as the nginx event loop is blocked during code execution time consuming code sequences should therefore be avoided this directive is implemented by injecting custom commands into the standard ngx http rewrite modules command list because ngx http rewrite module does not support nonblocking i o in its commands lua apis requiring yielding the current lua light thread cannot work in this directive at least the following api functions are currently disabled within the context of set by lua output api functions e g ngx say and ngx send headers control api functions e g ngx exit subrequest api functions e g ngx location capture and ngx location capture multi cosocket api functions e g ngx socket tcp and ngx req socket sleeping api function ngx sleep in addition note that this directive can only write out a value to a single nginx variable at a time however a workaround is possible using the ngx var variable interface nginx location foo set diff we have to predefine the diff variable here set by lua sum local a 32 local b 56 ngx var diff a b write to diff directly return a b return the sum value normally echo sum sum diff diff this directive can be freely mixed with all directives of the ngx http rewrite module set misc nginx module and array var nginx module modules all of these directives will run in the same order as they appear in the config file nginx set foo 32 set by lua bar return tonumber ngx var foo 1 set baz bar bar baz bar 33 as from the v0 5 0rc29 release nginx variable interpolation is disabled in the lua script str argument of this directive and therefore the dollar sign character can be used directly this directive requires the ngx devel kit module back to toc set by lua block syntax set by lua block res lua script context server server if location location if phase rewrite similar to the set by lua directive except that this directive inlines the lua source directly inside a pair of curly braces instead of in an nginx string literal which requires special character escaping and this directive does not support extra arguments after the lua script as in set by lua for example nginx set by lua block res return 32 math cos 32 res now has the value 32 834223360507 or alike no special escaping is required in the lua code block this directive was first introduced in the v0 9 17 release back to toc set by lua file syntax set by lua file res path to lua script file arg1 arg2 context server server if location location if phase rewrite equivalent to set by lua except that the file specified by path to lua script file contains the lua code or as from the v0 5 0rc32 release the lua luajit bytecode to be executed nginx variable interpolation is supported in the path to lua script file argument string of this directive but special care must be taken for injection attacks when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server when the lua code cache is turned on by default the user code is loaded once at the first request and cached and the nginx config must be reloaded each time the lua source file is modified the lua code cache can be temporarily disabled during development by switching lua code cache off in nginx conf to avoid reloading nginx this directive requires the ngx devel kit module back to toc content by lua syntax content by lua lua script str context location location if phase content note use of this directive is discouraged following the v0 9 17 release use the content by lua block directive instead acts as a content handler and executes lua code string specified in lua script str for every request the lua code may make api calls and is executed as a new spawned coroutine in an independent global environment i e a sandbox do not use this directive and other content handler directives in the same location for example this directive and the proxy pass directive should not be used in the same location back to toc content by lua block syntax content by lua block lua script context location location if phase content similar to the content by lua directive except that this directive inlines the lua source directly inside a pair of curly braces instead of in an nginx string literal which requires special character escaping for instance nginx content by lua block ngx say i need no extra escaping here for example \r\nblah this directive was first introduced in the v0 9 17 release back to toc content by lua file syntax content by lua file path to lua script file context location location if phase content equivalent to content by lua except that the file specified by path to lua script file contains the lua code or as from the v0 5 0rc32 release the lua luajit bytecode to be executed nginx variables can be used in the path to lua script file string to provide flexibility this however carries some risks and is not ordinarily recommended when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server when the lua code cache is turned on by default the user code is loaded once at the first request and cached and the nginx config must be reloaded each time the lua source file is modified the lua code cache can be temporarily disabled during development by switching lua code cache off in nginx conf to avoid reloading nginx nginx variables are supported in the file path for dynamic dispatch for example nginx caution contents in nginx var must be carefully filtered otherwise therell be great security risk location app a za z0 9 set path 1 content by lua file path to lua app root path lua but be very careful about malicious user inputs and always carefully validate or filter out the user supplied path components back to toc rewrite by lua syntax rewrite by lua lua script str context http server location location if phase rewrite tail note use of this directive is discouraged following the v0 9 17 release use the rewrite by lua block directive instead acts as a rewrite phase handler and executes lua code string specified in lua script str for every request the lua code may make api calls and is executed as a new spawned coroutine in an independent global environment i e a sandbox note that this handler always runs after the standard ngx http rewrite module so the following will work as expected nginx location foo set a 12 create and initialize a set b create and initialize b rewrite by lua ngx var b tonumber ngx var a 1 echo res b because set a 12 and set b run before rewrite by lua on the other hand the following will not work as expected nginx location foo set a 12 create and initialize a set b create and initialize b rewrite by lua ngx var b tonumber ngx var a 1 if b 13 rewrite bar redirect break echo res b because if runs before rewrite by lua even if it is placed after rewrite by lua in the config the right way of doing this is as follows nginx location foo set a 12 create and initialize a set b create and initialize b rewrite by lua ngx var b tonumber ngx var a 1 if tonumber ngx var b 13 then return ngx redirect bar end echo res b note that the ngx eval module can be approximated by using rewrite by lua for example nginx location eval res proxy pass http foo com check spam if res spam rewrite terms of use html redirect fastcgi pass can be implemented in ngx lua as nginx location check spam internal proxy pass http foo com check spam location rewrite by lua local res ngx location capture check spam if res body spam then return ngx redirect terms of use html end fastcgi pass just as any other rewrite phase handlers rewrite by lua also runs in subrequests note that when calling ngx exit ngx ok within a rewrite by lua handler the nginx request processing control flow will still continue to the content handler to terminate the current request from within a rewrite by lua handler calling ngx exit with status 200 ngx http ok and status 300 ngx http special response for successful quits and ngx exit ngx http internal server error or its friends for failures if the ngx http rewrite modules rewrite directive is used to change the uri and initiate location re lookups internal redirections then any rewrite by lua or rewrite by lua file code sequences within the current location will not be executed for example nginx location foo rewrite bar rewrite by lua ngx exit 503 location bar here the lua code ngx exit 503 will never run this will be the case if rewrite bar last is used as this will similarly initiate an internal redirection if the break modifier is used instead there will be no internal redirection and the rewrite by lua code will be executed the rewrite by lua code will always run at the end of the rewrite request processing phase unless rewrite by lua no postpone is turned on back to toc rewrite by lua block syntax rewrite by lua block lua script context http server location location if phase rewrite tail similar to the rewrite by lua directive except that this directive inlines the lua source directly inside a pair of curly braces instead of in an nginx string literal which requires special character escaping for instance nginx rewrite by lua block do something hello world \nhiya\n this directive was first introduced in the v0 9 17 release back to toc rewrite by lua file syntax rewrite by lua file path to lua script file context http server location location if phase rewrite tail equivalent to rewrite by lua except that the file specified by path to lua script file contains the lua code or as from the v0 5 0rc32 release the lua luajit bytecode to be executed nginx variables can be used in the path to lua script file string to provide flexibility this however carries some risks and is not ordinarily recommended when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server when the lua code cache is turned on by default the user code is loaded once at the first request and cached and the nginx config must be reloaded each time the lua source file is modified the lua code cache can be temporarily disabled during development by switching lua code cache off in nginx conf to avoid reloading nginx the rewrite by lua file code will always run at the end of the rewrite request processing phase unless rewrite by lua no postpone is turned on nginx variables are supported in the file path for dynamic dispatch just as in content by lua file back to toc access by lua syntax access by lua lua script str context http server location location if phase access tail note use of this directive is discouraged following the v0 9 17 release use the access by lua block directive instead acts as an access phase handler and executes lua code string specified in lua script str for every request the lua code may make api calls and is executed as a new spawned coroutine in an independent global environment i e a sandbox note that this handler always runs after the standard ngx http access module so the following will work as expected nginx location deny 192 168 1 1 allow 192 168 1 0 24 allow 10 1 1 0 16 deny all access by lua local res ngx location capture mysql proxy pass fastcgi pass that is if a client ip address is in the blacklist it will be denied before the mysql query for more complex authentication is executed by access by lua note that the ngx auth request module can be approximated by using access by lua nginx location auth request auth proxy pass fastcgi pass postgres pass can be implemented in ngx lua as nginx location access by lua local res ngx location capture auth if res status ngx http ok then return end if res status ngx http forbidden then ngx exit res status end ngx exit ngx http internal server error proxy pass fastcgi pass postgres pass as with other access phase handlers access by lua will not run in subrequests note that when calling ngx exit ngx ok within a access by lua handler the nginx request processing control flow will still continue to the content handler to terminate the current request from within a access by lua handler calling ngx exit with status 200 ngx http ok and status 300 ngx http special response for successful quits and ngx exit ngx http internal server error or its friends for failures starting from the v0 9 20 release you can use the access by lua no postpone directive to control when to run this handler inside the access request processing phase of nginx back to toc access by lua block syntax access by lua block lua script context http server location location if phase access tail similar to the access by lua directive except that this directive inlines the lua source directly inside a pair of curly braces instead of in an nginx string literal which requires special character escaping for instance nginx access by lua block do something hello world \nhiya\n this directive was first introduced in the v0 9 17 release back to toc access by lua file syntax access by lua file path to lua script file context http server location location if phase access tail equivalent to access by lua except that the file specified by path to lua script file contains the lua code or as from the v0 5 0rc32 release the lua luajit bytecode to be executed nginx variables can be used in the path to lua script file string to provide flexibility this however carries some risks and is not ordinarily recommended when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server when the lua code cache is turned on by default the user code is loaded once at the first request and cached and the nginx config must be reloaded each time the lua source file is modified the lua code cache can be temporarily disabled during development by switching lua code cache off in nginx conf to avoid repeatedly reloading nginx nginx variables are supported in the file path for dynamic dispatch just as in content by lua file back to toc header filter by lua syntax header filter by lua lua script str context http server location location if phase output header filter note use of this directive is discouraged following the v0 9 17 release use the header filter by lua block directive instead uses lua code specified in lua script str to define an output header filter note that the following api functions are currently disabled within this context output api functions e g ngx say and ngx send headers control api functions e g ngx redirect and ngx exec subrequest api functions e g ngx location capture and ngx location capture multi cosocket api functions e g ngx socket tcp and ngx req socket here is an example of overriding a response header or adding one if absent in our lua header filter nginx location proxy pass http mybackend header filter by lua ngx header foo blah this directive was first introduced in the v0 2 1rc20 release back to toc header filter by lua block syntax header filter by lua block lua script context http server location location if phase output header filter similar to the header filter by lua directive except that this directive inlines the lua source directly inside a pair of curly braces instead of in an nginx string literal which requires special character escaping for instance nginx header filter by lua block ngx header content length nil this directive was first introduced in the v0 9 17 release back to toc header filter by lua file syntax header filter by lua file path to lua script file context http server location location if phase output header filter equivalent to header filter by lua except that the file specified by path to lua script file contains the lua code or as from the v0 5 0rc32 release the lua luajit bytecode to be executed when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server this directive was first introduced in the v0 2 1rc20 release back to toc body filter by lua syntax body filter by lua lua script str context http server location location if phase output body filter note use of this directive is discouraged following the v0 9 17 release use the body filter by lua block directive instead uses lua code specified in lua script str to define an output body filter the input data chunk is passed via ngx arg 1 as a lua string value and the eof flag indicating the end of the response body data stream is passed via ngx arg 2 as a lua boolean value behind the scene the eof flag is just the last buf for main requests or last in chain for subrequests flag of the nginx chain link buffers before the v0 7 14 release the eof flag does not work at all in subrequests the output data stream can be aborted immediately by running the following lua statement lua return ngx error this will truncate the response body and usually result in incomplete and also invalid responses the lua code can pass its own modified version of the input data chunk to the downstream nginx output body filters by overriding ngx arg 1 with a lua string or a lua table of strings for example to transform all the lowercase letters in the response body we can just write nginx location proxy pass http mybackend body filter by lua ngx arg 1 string upper ngx arg 1 when setting nil or an empty lua string value to ngx arg 1 no data chunk will be passed to the downstream nginx output filters at all likewise new eof flag can also be specified by setting a boolean value to ngx arg 2 for example nginx location t echo hello world echo hiya globe body filter by lua local chunk ngx arg 1 if string match chunk hello then ngx arg 2 true new eof return end just throw away any remaining chunk data ngx arg 1 nil then get t will just return the output hello world that is when the body filter sees a chunk containing the word hello then it will set the eof flag to true immediately resulting in truncated but still valid responses when the lua code may change the length of the response body then it is required to always clear out the content length response header if any in a header filter to enforce streaming output as in nginx location foo fastcgi pass proxy pass header filter by lua block ngx header content length nil body filter by lua ngx arg 1 string len ngx arg 1 \\n note that the following api functions are currently disabled within this context due to the limitations in nginx output filters current implementation output api functions e g ngx say and ngx send headers control api functions e g ngx exit and ngx exec subrequest api functions e g ngx location capture and ngx location capture multi cosocket api functions e g ngx socket tcp and ngx req socket nginx output filters may be called multiple times for a single request because response body may be delivered in chunks thus the lua code specified by in this directive may also run multiple times in the lifetime of a single http request this directive was first introduced in the v0 5 0rc32 release back to toc body filter by lua block syntax body filter by lua block lua script str context http server location location if phase output body filter similar to the body filter by lua directive except that this directive inlines the lua source directly inside a pair of curly braces instead of in an nginx string literal which requires special character escaping for instance nginx body filter by lua block local data eof ngx arg 1 ngx arg 2 this directive was first introduced in the v0 9 17 release back to toc body filter by lua file syntax body filter by lua file path to lua script file context http server location location if phase output body filter equivalent to body filter by lua except that the file specified by path to lua script file contains the lua code or as from the v0 5 0rc32 release the lua luajit bytecode to be executed when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server this directive was first introduced in the v0 5 0rc32 release back to toc log by lua syntax log by lua lua script str context http server location location if phase log note use of this directive is discouraged following the v0 9 17 release use the log by lua block directive instead runs the lua source code inlined as the lua script str at the log request processing phase this does not replace the current access logs but runs before note that the following api functions are currently disabled within this context output api functions e g ngx say and ngx send headers control api functions e g ngx exit subrequest api functions e g ngx location capture and ngx location capture multi cosocket api functions e g ngx socket tcp and ngx req socket here is an example of gathering average data for upstream response time nginx lua shared dict log dict 5m server location proxy pass http mybackend log by lua local log dict ngx shared log dict local upstream time tonumber ngx var upstream response time local sum log dict get upstream time sum or 0 sum sum upstream time log dict set upstream time sum sum local newval err log dict incr upstream time nb 1 if not newval and err not found then log dict add upstream time nb 0 log dict incr upstream time nb 1 end location status content by lua block local log dict ngx shared log dict local sum log dict get upstream time sum local nb log dict get upstream time nb if nb and sum then ngx say average upstream response time sum nb nb reqs else ngx say no data yet end this directive was first introduced in the v0 5 0rc31 release back to toc log by lua block syntax log by lua block lua script context http server location location if phase log similar to the log by lua directive except that this directive inlines the lua source directly inside a pair of curly braces instead of in an nginx string literal which requires special character escaping for instance nginx log by lua block print i need no extra escaping here for example \r\nblah this directive was first introduced in the v0 9 17 release back to toc log by lua file syntax log by lua file path to lua script file context http server location location if phase log equivalent to log by lua except that the file specified by path to lua script file contains the lua code or as from the v0 5 0rc32 release the lua luajit bytecode to be executed when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server this directive was first introduced in the v0 5 0rc31 release back to toc balancer by lua block syntax balancer by lua block lua script context upstream phase content this directive runs lua code as an upstream balancer for any upstream entities defined by the upstream configuration block for instance nginx upstream foo server 127 0 0 1 balancer by lua block use lua to do something interesting here as a dynamic balancer server location proxy pass http foo the resulting lua load balancer can work with any existing nginx upstream modules like ngx proxy and ngx fastcgi also the lua load balancer can work with the standard upstream connection pool mechanism i e the standard keepalive directive just ensure that the keepalive directive is used after this balancer by lua block directive in a single upstream configuration block the lua load balancer can totally ignore the list of servers defined in the upstream block and select peer from a completely dynamic server list even changing per request via the ngx balancer module from the lua resty core library the lua code handler registered by this directive might get called more than once in a single downstream request when the nginx upstream mechanism retries the request on conditions specified by directives like the proxy next upstream directive this lua code execution context does not support yielding so lua apis that may yield like cosockets and light threads are disabled in this context one can usually work around this limitation by doing such operations in an earlier phase handler like access by lua and passing along the result into this context via the ngx ctx table this directive was first introduced in the v0 10 0 release back to toc balancer by lua file syntax balancer by lua file path to lua script file context upstream phase content equivalent to balancer by lua block except that the file specified by path to lua script file contains the lua code or as from the v0 5 0rc32 release the lua luajit bytecode to be executed when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server this directive was first introduced in the v0 10 0 release back to toc lua need request body syntax lua need request body on off default off context http server location location if phase depends on usage determines whether to force the request body data to be read before running rewrite access access by lua or not the nginx core does not read the client request body by default and if request body data is required then this directive should be turned on or the ngx req read body function should be called within the lua code to read the request body data within the request body variable client body buffer size must have the same value as client max body size because when the content length exceeds client body buffer size but less than client max body size nginx will buffer the data into a temporary file on the disk which will lead to empty value in the request body variable if the current location includes rewrite by lua directives then the request body will be read just before the rewrite by lua code is run and also at the rewrite phase similarly if only content by lua is specified the request body will not be read until the content handlers lua code is about to run i e the request body will be read during the content phase it is recommended however to use the ngx req read body and ngx req discard body functions for finer control over the request body reading process instead this also applies to access by lua back to toc ssl certificate by lua block syntax ssl certificate by lua block lua script context server phase right before ssl handshake this directive runs user lua code when nginx is about to start the ssl handshake for the downstream ssl https connections it is particularly useful for setting the ssl certificate chain and the corresponding private key on a per request basis it is also useful to load such handshake configurations nonblockingly from the remote for example with the cosocket api and one can also do per request ocsp stapling handling in pure lua here as well another typical use case is to do ssl handshake traffic control nonblockingly in this context with the help of the lua resty limit traffic readme library for example one can also do interesting things with the ssl handshake requests from the client side like rejecting old ssl clients using the sslv3 protocol or even below selectively the ngx ssl and ngx ocsp lua modules provided by the lua resty core library are particularly useful in this context you can use the lua api offered by these two lua modules to manipulate the ssl certificate chain and private key for the current ssl connection being initiated this lua handler does not run at all however when nginx openssl successfully resumes the ssl session via ssl session ids or tls session tickets for the current ssl connection in other words this lua handler only runs when nginx has to initiate a full ssl handshake below is a trivial example using the ngx ssl module at the same time nginx server listen 443 ssl server name test com ssl certificate by lua block print about to initiate a new ssl handshake location root html see more complicated examples in the ngx ssl and ngx ocsp lua modules official documentation uncaught lua exceptions in the user lua code immediately abort the current ssl session so does the ngx exit call with an error code like ngx error this lua code execution context does support yielding so lua apis that may yield like cosockets sleeping and light threads are enabled in this context note however you still need to configure the ssl certificate and ssl certificate key directives even though you will not use this static certificate and private key at all this is because the nginx core requires their appearance otherwise you are seeing the following error while starting nginx nginx emerg no ssl configured for the server this directive currently requires the following nginx core patch to work correctly http mailman nginx org pipermail nginx devel 2016 january 007748 html the bundled version of the nginx core in openresty 1 9 7 2 or above already has this patch applied furthermore one needs at least openssl 1 0 2e for this directive to work this directive was first introduced in the v0 10 0 release back to toc ssl certificate by lua file syntax ssl certificate by lua file path to lua script file context server phase right before ssl handshake equivalent to ssl certificate by lua block except that the file specified by path to lua script file contains the lua code or as from the v0 5 0rc32 release the lua luajit bytecode to be executed when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server this directive was first introduced in the v0 10 0 release back to toc ssl session fetch by lua block syntax ssl session fetch by lua block lua script context http phase right before ssl handshake this directive runs lua code to look up and load the ssl session if any according to the session id provided by the current ssl handshake request for the downstream the lua api for obtaining the current session id and loading a cached ssl session data is provided in the ngx ssl session lua module shipped with the lua resty core library lua apis that may yield like ngx sleep and cosockets are enabled in this context this hook together with the ssl session store by lua hook can be used to implement distributed caching mechanisms in pure lua based on the cosocket api for example if a cached ssl session is found and loaded into the current ssl connection context ssl session resumption can then get immediately initiated and bypass the full ssl handshake process which is very expensive in terms of cpu time please note that tls session tickets are very different and it is the clients responsibility to cache the ssl session state when session tickets are used ssl session resumptions based on tls session tickets would happen automatically without going through this hook nor the ssl session store by lua hook this hook is mainly for older or less capable ssl clients that can only do ssl sessions by session ids when ssl certificate by lua is specified at the same time this hook usually runs before ssl certificate by lua when the ssl session is found and successfully loaded for the current ssl connection ssl session resumption will happen and thus bypass the ssl certificate by lua hook completely in this case nginx also bypasses the ssl session store by lua hook for obvious reasons to easily test this hook locally with a modern web browser you can temporarily put the following line in your https server block to disable the tls session ticket support ssl session tickets off but do not forget to comment this line out before publishing your site to the world if you are using the official pre built packages for openresty 1 11 2 1 or later then everything should work out of the box if you are using openssl libraries not provided by openresty then you need to apply the following patch for openssl 1 0 2h or later https github com openresty openresty blob master patches openssl 1 0 2h sess set get cb yield patch if you are not using the nginx core shipped with openresty 1 11 2 1 or later then you need to apply the following patch to the standard nginx core 1 11 2 or later http openresty org download nginx 1 11 2 nonblocking ssl handshake hooks patch this directive was first introduced in the v0 10 6 release note that this directive is only allowed to used in http context from the v0 10 7 release because ssl session resumption happens before server name dispatch back to toc ssl session fetch by lua file syntax ssl session fetch by lua file path to lua script file context http phase right before ssl handshake equivalent to ssl session fetch by lua block except that the file specified by path to lua script file contains the lua code or rather the lua luajit bytecode to be executed when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server this directive was first introduced in the v0 10 6 release note that this directive is only allowed to used in http context from the v0 10 7 release because ssl session resumption happens before server name dispatch back to toc ssl session store by lua block syntax ssl session store by lua block lua script context http phase right after ssl handshake this directive runs lua code to fetch and save the ssl session if any according to the session id provided by the current ssl handshake request for the downstream the saved or cached ssl session data can be used for future ssl connections to resume ssl sessions without going through the full ssl handshake process which is very expensive in terms of cpu time lua apis that may yield like ngx sleep and cosockets are disabled in this context you can still however use the ngx timer at api to create 0 delay timers to save the ssl session data asynchronously to external services like redis or memcached the lua api for obtaining the current session id and the associated session state data is provided in the ngx ssl session lua module shipped with the lua resty core library to easily test this hook locally with a modern web browser you can temporarily put the following line in your https server block to disable the tls session ticket support ssl session tickets off but do not forget to comment this line out before publishing your site to the world this directive was first introduced in the v0 10 6 release note that this directive is only allowed to used in http context from the v0 10 7 release because ssl session resumption happens before server name dispatch back to toc ssl session store by lua file syntax ssl session store by lua file path to lua script file context http phase right after ssl handshake equivalent to ssl session store by lua block except that the file specified by path to lua script file contains the lua code or rather the lua luajit bytecode to be executed when a relative path like foo bar lua is given they will be turned into the absolute path relative to the server prefix path determined by the p path command line option while starting the nginx server this directive was first introduced in the v0 10 6 release note that this directive is only allowed to used in http context from the v0 10 7 release because ssl session resumption happens before server name dispatch back to toc lua shared dict syntax lua shared dict name size default no context http phase depends on usage declares a shared memory zone name to serve as storage for the shm based lua dictionary ngx shared name shared memory zones are always shared by all the nginx worker processes in the current nginx server instance the size argument accepts size units such as k and m nginx http lua shared dict dogs 10m the hard coded minimum size is 8kb while the practical minimum size depends on actual user data set some people start with 12kb see ngx shared dict for details this directive was first introduced in the v0 3 1rc22 release back to toc lua socket connect timeout syntax lua socket connect timeout time default lua socket connect timeout 60s context http server location this directive controls the default timeout value used in tcp unix domain socket objects connect method and can be overridden by the settimeout or settimeouts methods the time argument can be an integer with an optional time unit like s second ms millisecond m minute the default time unit is s i e second the default setting is 60s this directive was first introduced in the v0 5 0rc1 release back to toc lua socket send timeout syntax lua socket send timeout time default lua socket send timeout 60s context http server location controls the default timeout value used in tcp unix domain socket objects send method and can be overridden by the settimeout or settimeouts methods the time argument can be an integer with an optional time unit like s second ms millisecond m minute the default time unit is s i e second the default setting is 60s this directive was first introduced in the v0 5 0rc1 release back to toc lua socket send lowat syntax lua socket send lowat size default lua socket send lowat 0 context http server location controls the lowat low water value for the cosocket send buffer back to toc lua socket read timeout syntax lua socket read timeout time default lua socket read timeout 60s context http server location phase depends on usage this directive controls the default timeout value used in tcp unix domain socket objects receive method and iterator functions returned by the receiveuntil method this setting can be overridden by the settimeout or settimeouts methods the time argument can be an integer with an optional time unit like s second ms millisecond m minute the default time unit is s i e second the default setting is 60s this directive was first introduced in the v0 5 0rc1 release back to toc lua socket buffer size syntax lua socket buffer size size default lua socket buffer size 4k 8k context http server location specifies the buffer size used by cosocket reading operations this buffer does not have to be that big to hold everything at the same time because cosocket supports 100 non buffered reading and parsing so even 1 byte buffer size should still work everywhere but the performance could be terrible this directive was first introduced in the v0 5 0rc1 release back to toc lua socket pool size syntax lua socket pool size size default lua socket pool size 30 context http server location specifies the size limit in terms of connection count for every cosocket connection pool associated with every remote server i e identified by either the host port pair or the unix domain socket file path default to 30 connections for every pool when the connection pool exceeds the available size limit the least recently used idle connection already in the pool will be closed to make room for the current connection note that the cosocket connection pool is per nginx worker process rather than per nginx server instance so size limit specified here also applies to every single nginx worker process this directive was first introduced in the v0 5 0rc1 release back to toc lua socket keepalive timeout syntax lua socket keepalive timeout time default lua socket keepalive timeout 60s context http server location this directive controls the default maximal idle time of the connections in the cosocket built in connection pool when this timeout reaches idle connections will be closed and removed from the pool this setting can be overridden by cosocket objects setkeepalive method the time argument can be an integer with an optional time unit like s second ms millisecond m minute the default time unit is s i e second the default setting is 60s this directive was first introduced in the v0 5 0rc1 release back to toc lua socket log errors syntax lua socket log errors on off default lua socket log errors on context http server location this directive can be used to toggle error logging when a failure occurs for the tcp or udp cosockets if you are already doing proper error handling and logging in your lua code then it is recommended to turn this directive off to prevent data flushing in your nginx error log files which is usually rather expensive this directive was first introduced in the v0 5 13 release back to toc lua ssl ciphers syntax lua ssl ciphers ciphers default lua ssl ciphers default context http server location specifies the enabled ciphers for requests to a ssl tls server in the tcpsock sslhandshake method the ciphers are specified in the format understood by the openssl library the full list can be viewed using the “openssl ciphers” command this directive was first introduced in the v0 9 11 release back to toc lua ssl crl syntax lua ssl crl file default no context http server location specifies a file with revoked certificates crl in the pem format used to verify the certificate of the ssl tls server in the tcpsock sslhandshake method this directive was first introduced in the v0 9 11 release back to toc lua ssl protocols syntax lua ssl protocols sslv2 sslv3 tlsv1 tlsv1 1 tlsv1 2 tlsv1 3 default lua ssl protocols sslv3 tlsv1 tlsv1 1 tlsv1 2 context http server location enables the specified protocols for requests to a ssl tls server in the tcpsock sslhandshake method the support for the tlsv1 3 parameter requires version v0 10 12 and openssl 1 1 1 this directive was first introduced in the v0 9 11 release back to toc lua ssl trusted certificate syntax lua ssl trusted certificate file default no context http server location specifies a file path with trusted ca certificates in the pem format used to verify the certificate of the ssl tls server in the tcpsock sslhandshake method this directive was first introduced in the v0 9 11 release see also lua ssl verify depth back to toc lua ssl verify depth syntax lua ssl verify depth number default lua ssl verify depth 1 context http server location sets the verification depth in the server certificates chain this directive was first introduced in the v0 9 11 release see also lua ssl trusted certificate back to toc lua http10 buffering syntax lua http10 buffering on off default lua http10 buffering on context http server location location if enables or disables automatic response buffering for http 1 0 or older requests this buffering mechanism is mainly used for http 1 0 keep alive which relies on a proper content length response header if the lua code explicitly sets a content length response header before sending the headers either explicitly via ngx send headers or implicitly via the first ngx say or ngx print call then the http 1 0 response buffering will be disabled even when this directive is turned on to output very large response data in a streaming fashion via the ngx flush call for example this directive must be turned off to minimize memory usage this directive is turned on by default this directive was first introduced in the v0 5 0rc19 release back to toc rewrite by lua no postpone syntax rewrite by lua no postpone on off default rewrite by lua no postpone off context http controls whether or not to disable postponing rewrite by lua directives to run at the end of the rewrite request processing phase by default this directive is turned off and the lua code is postponed to run at the end of the rewrite phase this directive was first introduced in the v0 5 0rc29 release back to toc access by lua no postpone syntax access by lua no postpone on off default access by lua no postpone off context http controls whether or not to disable postponing access by lua directives to run at the end of the access request processing phase by default this directive is turned off and the lua code is postponed to run at the end of the access phase this directive was first introduced in the v0 9 20 release back to toc lua transform underscores in response headers syntax lua transform underscores in response headers on off default lua transform underscores in response headers on context http server location location if controls whether to transform underscores in the response header names specified in the ngx header header api to hypens this directive was first introduced in the v0 5 0rc32 release back to toc lua check client abort syntax lua check client abort on off default lua check client abort off context http server location location if this directive controls whether to check for premature client connection abortion when this directive is on the ngx lua module will monitor the premature connection close event on the downstream connections and when there is such an event it will call the user lua function callback registered by ngx on abort or just stop and clean up all the lua light threads running in the current requests request handler when there is no user callback function registered according to the current implementation however if the client closes the connection before the lua code finishes reading the request body data via ngx req socket then ngx lua will neither stop all the running light threads nor call the user callback if ngx on abort has been called instead the reading operation on ngx req socket will just return the error message client aborted as the second return value the first return value is surely nil when tcp keepalive is disabled it is relying on the client side to close the socket gracefully by sending a fin packet or something like that for soft real time web applications it is highly recommended to configure the tcp keepalive support in your systems tcp stack implementation in order to detect half open tcp connections in time for example on linux you can configure the standard listen directive in your nginx conf file like this nginx listen 80 so keepalive 2s 2s 8 on freebsd you can only tune the system wide configuration for tcp keepalive for example sysctl net inet tcp keepintvl 2000 sysctl net inet tcp keepidle 2000 this directive was first introduced in the v0 7 4 release see also ngx on abort back to toc lua max pending timers syntax lua max pending timers count default lua max pending timers 1024 context http controls the maximum number of pending timers allowed pending timers are those timers that have not expired yet when exceeding this limit the ngx timer at call will immediately return nil and the error string too many pending timers this directive was first introduced in the v0 8 0 release back to toc lua max running timers syntax lua max running timers count default lua max running timers 256 context http controls the maximum number of running timers allowed running timers are those timers whose user callback functions are still running when exceeding this limit nginx will stop running the callbacks of newly expired timers and log an error message n lua max running timers are not enough where n is the current value of this directive this directive was first introduced in the v0 8 0 release back to toc nginx api for lua introduction ngx arg ngx var variable core constants http method constants http status constants nginx log level constants print ngx ctx ngx location capture ngx location capture multi ngx status ngx header header ngx resp get headers ngx req is internal ngx req start time ngx req http version ngx req raw header ngx req get method ngx req set method ngx req set uri ngx req set uri args ngx req get uri args ngx req get post args ngx req get headers ngx req set header ngx req clear header ngx req read body ngx req discard body ngx req get body data ngx req get body file ngx req set body data ngx req set body file ngx req init body ngx req append body ngx req finish body ngx req socket ngx exec ngx redirect ngx send headers ngx headers sent ngx print ngx say ngx log ngx flush ngx exit ngx eof ngx sleep ngx escape uri ngx unescape uri ngx encode args ngx decode args ngx encode base64 ngx decode base64 ngx crc32 short ngx crc32 long ngx hmac sha1 ngx md5 ngx md5 bin ngx sha1 bin ngx quote sql str ngx today ngx time ngx now ngx update time ngx localtime ngx utctime ngx cookie time ngx http time ngx parse http time ngx is subrequest ngx re match ngx re find ngx re gmatch ngx re sub ngx re gsub ngx shared dict ngx shared dict get ngx shared dict get stale ngx shared dict set ngx shared dict safe set ngx shared dict add ngx shared dict safe add ngx shared dict replace ngx shared dict delete ngx shared dict incr ngx shared dict lpush ngx shared dict rpush ngx shared dict lpop ngx shared dict rpop ngx shared dict llen ngx shared dict ttl ngx shared dict expire ngx shared dict flush all ngx shared dict flush expired ngx shared dict get keys ngx shared dict capacity ngx shared dict free space ngx socket udp udpsock setpeername udpsock send udpsock receive udpsock close udpsock settimeout ngx socket stream ngx socket tcp tcpsock connect tcpsock sslhandshake tcpsock send tcpsock receive tcpsock receiveany tcpsock receiveuntil tcpsock close tcpsock settimeout tcpsock settimeouts tcpsock setoption tcpsock setkeepalive tcpsock getreusedtimes ngx socket connect ngx get phase ngx thread spawn ngx thread wait ngx thread kill ngx on abort ngx timer at ngx timer every ngx timer running count ngx timer pending count ngx config subsystem ngx config debug ngx config prefix ngx config nginx version ngx config nginx configure ngx config ngx lua version ngx worker exiting ngx worker pid ngx worker count ngx worker id ngx semaphore ngx balancer ngx ssl ngx ocsp ndk set var directive coroutine create coroutine resume coroutine yield coroutine wrap coroutine running coroutine status back to toc introduction the various by lua by lua block and by lua file configuration directives serve as gateways to the lua api within the nginx conf file the nginx lua api described below can only be called within the user lua code run in the context of these configuration directives the api is exposed to lua in the form of two standard packages ngx and ndk these packages are in the default global scope within ngx lua and are always available within ngx lua directives the packages can be introduced into external lua modules like this lua local say ngx say local m function m foo a say a end return m use of the package seeall flag is strongly discouraged due to its various bad side effects it is also possible to directly require the packages in external lua modules lua local ngx require ngx local ndk require ndk the ability to require these packages was introduced in the v0 2 1rc19 release network i o operations in user code should only be done through the nginx lua api calls as the nginx event loop may be blocked and performance drop off dramatically otherwise disk operations with relatively small amount of data can be done using the standard lua io library but huge file reading and writing should be avoided wherever possible as they may block the nginx process significantly delegating all network and disk i o operations to nginxs subrequests via the ngx location capture method and similar is strongly recommended for maximum performance back to toc ngx arg syntax val ngx arg index context set by lua body filter by lua when this is used in the context of the set by lua directives this table is read only and holds the input arguments to the config directives lua value ngx arg n here is an example nginx location foo set a 32 set b 56 set by lua sum return tonumber ngx arg 1 tonumber ngx arg 2 a b echo sum that writes out 88 the sum of 32 and 56 when this table is used in the context of body filter by lua the first element holds the input data chunk to the output filter code and the second element holds the boolean flag for the eof flag indicating the end of the whole output data stream the data chunk and eof flag passed to the downstream nginx output filters can also be overridden by assigning values directly to the corresponding table elements when setting nil or an empty lua string value to ngx arg 1 no data chunk will be passed to the downstream nginx output filters at all back to toc ngx var variable syntax ngx var var name context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua read and write nginx variable values nginx value ngx var some nginx variable name ngx var some nginx variable name value note that only already defined nginx variables can be written to for example nginx location foo set my var this line is required to create my var at config time content by lua block ngx var my var 123 that is nginx variables cannot be created on the fly some special nginx variables like args and limit rate can be assigned a value many others are not like query string arg parameter and http name nginx regex group capturing variables 1 2 3 and etc can be read by this interface as well by writing ngx var 1 ngx var 2 ngx var 3 and etc setting ngx var foo to a nil value will unset the foo nginx variable lua ngx var args nil caution when reading from an nginx variable nginx will allocate memory in the per request memory pool which is freed only at request termination so when you need to read from an nginx variable repeatedly in your lua code cache the nginx variable value to your own lua variable for example lua local val ngx var some var use the val repeatedly later to prevent temporary memory leaking within the current requests lifetime another way of caching the result is to use the ngx ctx table undefined nginx variables are evaluated to nil while uninitialized but defined nginx variables are evaluated to an empty lua string this api requires a relatively expensive metamethod call and it is recommended to avoid using it on hot code paths back to toc core constants context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua lua ngx ok 0 ngx error 1 ngx again 2 ngx done 4 ngx declined 5 note that only three of these constants are utilized by the nginx api for lua i e ngx exit accepts ngx ok ngx error and ngx declined as input lua ngx null the ngx null constant is a null light userdata usually used to represent nil values in lua tables etc and is similar to the lua cjson librarys cjson null constant this constant was first introduced in the v0 5 0rc5 release the ngx declined constant was first introduced in the v0 5 0rc19 release back to toc http method constants context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua ngx http get ngx http head ngx http put ngx http post ngx http delete ngx http options added in the v0 5 0rc24 release ngx http mkcol added in the v0 8 2 release ngx http copy added in the v0 8 2 release ngx http move added in the v0 8 2 release ngx http propfind added in the v0 8 2 release ngx http proppatch added in the v0 8 2 release ngx http lock added in the v0 8 2 release ngx http unlock added in the v0 8 2 release ngx http patch added in the v0 8 2 release ngx http trace added in the v0 8 2 release these constants are usually used in ngx location capture and ngx location capture multi method calls back to toc http status constants context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua nginx value ngx http continue 100 first added in the v0 9 20 release value ngx http switching protocols 101 first added in the v0 9 20 release value ngx http ok 200 value ngx http created 201 value ngx http accepted 202 first added in the v0 9 20 release value ngx http no content 204 first added in the v0 9 20 release value ngx http partial content 206 first added in the v0 9 20 release value ngx http special response 300 value ngx http moved permanently 301 value ngx http moved temporarily 302 value ngx http see other 303 value ngx http not modified 304 value ngx http temporary redirect 307 first added in the v0 9 20 release value ngx http permanent redirect 308 value ngx http bad request 400 value ngx http unauthorized 401 value ngx http payment required 402 first added in the v0 9 20 release value ngx http forbidden 403 value ngx http not found 404 value ngx http not allowed 405 value ngx http not acceptable 406 first added in the v0 9 20 release value ngx http request timeout 408 first added in the v0 9 20 release value ngx http conflict 409 first added in the v0 9 20 release value ngx http gone 410 value ngx http upgrade required 426 first added in the v0 9 20 release value ngx http too many requests 429 first added in the v0 9 20 release value ngx http close 444 first added in the v0 9 20 release value ngx http illegal 451 first added in the v0 9 20 release value ngx http internal server error 500 value ngx http method not implemented 501 value ngx http bad gateway 502 first added in the v0 9 20 release value ngx http service unavailable 503 value ngx http gateway timeout 504 first added in the v0 3 1rc38 release value ngx http version not supported 505 first added in the v0 9 20 release value ngx http insufficient storage 507 first added in the v0 9 20 release back to toc nginx log level constants context init by lua init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua lua ngx stderr ngx emerg ngx alert ngx crit ngx err ngx warn ngx notice ngx info ngx debug these constants are usually used by the ngx log method back to toc print syntax print context init by lua init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua writes argument values into the nginx error log file with the ngx notice log level it is equivalent to lua ngx log ngx notice lua nil arguments are accepted and result in literal nil strings while lua booleans result in literal true or false strings and the ngx null constant will yield the null string output there is a hard coded 2048 byte limitation on error message lengths in the nginx core this limit includes trailing newlines and leading time stamps if the message size exceeds this limit nginx will truncate the message text accordingly this limit can be manually modified by editing the ngx max error str macro definition in the src core ngx log h file in the nginx source tree back to toc ngx ctx context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua this table can be used to store per request lua context data and has a life time identical to the current request as with the nginx variables consider the following example nginx location test rewrite by lua block ngx ctx foo 76 access by lua block ngx ctx foo ngx ctx foo 3 content by lua block ngx say ngx ctx foo then get test will yield the output bash 79 that is the ngx ctx foo entry persists across the rewrite access and content phases of a request every request including subrequests has its own copy of the table for example nginx location sub content by lua block ngx say sub pre ngx ctx blah ngx ctx blah 32 ngx say sub post ngx ctx blah location main content by lua block ngx ctx blah 73 ngx say main pre ngx ctx blah local res ngx location capture sub ngx print res body ngx say main post ngx ctx blah then get main will give the output bash main pre 73 sub pre nil sub post 32 main post 73 here modification of the ngx ctx blah entry in the subrequest does not affect the one in the parent request this is because they have two separate versions of ngx ctx blah internal redirection will destroy the original request ngx ctx data if any and the new request will have an empty ngx ctx table for instance nginx location new content by lua block ngx say ngx ctx foo location orig content by lua block ngx ctx foo hello ngx exec new then get orig will give bash nil rather than the original hello value arbitrary data values including lua closures and nested tables can be inserted into this magic table it also allows the registration of custom meta methods overriding ngx ctx with a new lua table is also supported for example lua ngx ctx foo 32 bar 54 when being used in the context of init worker by lua this table just has the same lifetime of the current lua handler the ngx ctx lookup requires relatively expensive metamethod calls and it is much slower than explicitly passing per request data along by your own function arguments so do not abuse this api for saving your own function arguments because it usually has quite some performance impact because of the metamethod magic never local the ngx ctx table outside your lua function scope on the lua module level due to worker level data sharing for example the following is bad lua mymodule lua local m the following line is bad since ngx ctx is a per request data while this ctx variable is on the lua module level and thus is per nginx worker local ctx ngx ctx function m main ctx foo bar end return m use the following instead lua mymodule lua local m function m main ctx ctx foo bar end return m that is let the caller pass the ctx table explicitly via a function argument back to toc ngx location capture syntax res ngx location capture uri options context rewrite by lua access by lua content by lua issues a synchronous but still non blocking nginx subrequest using uri nginxs subrequests provide a powerful way to make non blocking internal requests to other locations configured with disk file directory or any other nginx c modules like ngx proxy ngx fastcgi ngx memc ngx postgres ngx drizzle and even ngx lua itself and etc etc etc also note that subrequests just mimic the http interface but there is no extra http tcp traffic nor ipc involved everything works internally efficiently on the c level subrequests are completely different from http 301 302 redirection via ngx redirect and internal redirection via ngx exec you should always read the request body by either calling ngx req read body or configuring lua need request body on before initiating a subrequest this api function as well as ngx location capture multi always buffers the whole response body of the subrequest in memory thus you should use cosockets and streaming processing instead if you have to handle large subrequest responses here is a basic example lua res ngx location capture uri returns a lua table with 4 slots res status res header res body and res truncated res status holds the response status code for the subrequest response res header holds all the response headers of the subrequest and it is a normal lua table for multi value response headers the value is a lua array table that holds all the values in the order that they appear for instance if the subrequest response headers contain the following lines bash set cookie a 3 set cookie foo bar set cookie baz blah then res header set cookie will be evaluated to the table value a 3 foo bar baz blah res body holds the subrequests response body data which might be truncated you always need to check the res truncated boolean flag to see if res body contains truncated data the data truncation here can only be caused by those unrecoverable errors in your subrequests like the cases that the remote end aborts the connection prematurely in the middle of the response body data stream or a read timeout happens when your subrequest is receiving the response body data from the remote uri query strings can be concatenated to uri itself for instance lua res ngx location capture foo bar a 3 b 4 named locations like foo are not allowed due to a limitation in the nginx core use normal locations combined with the internal directive to prepare internal only locations an optional option table can be fed as the second argument which supports the options method specify the subrequests request method which only accepts constants like ngx http post body specify the subrequests request body string value only args specify the subrequests uri query arguments both string value and lua tables are accepted ctx specify a lua table to be the ngx ctx table for the subrequest it can be the current requests ngx ctx table which effectively makes the parent and its subrequest to share exactly the same context table this option was first introduced in the v0 3 1rc25 release vars take a lua table which holds the values to set the specified nginx variables in the subrequest as this options value this option was first introduced in the v0 3 1rc31 release copy all vars specify whether to copy over all the nginx variable values of the current request to the subrequest in question modifications of the nginx variables in the subrequest will not affect the current parent request this option was first introduced in the v0 3 1rc31 release share all vars specify whether to share all the nginx variables of the subrequest with the current parent request modifications of the nginx variables in the subrequest will affect the current parent request enabling this option may lead to hard to debug issues due to bad side effects and is considered bad and harmful only enable this option when you completely know what you are doing always forward body when set to true the current parent requests request body will always be forwarded to the subrequest being created if the body option is not specified the request body read by either ngx req read body or lua need request body on will be directly forwarded to the subrequest without copying the whole request body data when creating the subrequest no matter the request body data is buffered in memory buffers or temporary files by default this option is false and when the body option is not specified the request body of the current parent request is only forwarded when the subrequest takes the put or post request method issuing a post subrequest for example can be done as follows lua res ngx location capture foo bar method ngx http post body hello world see http method constants methods other than post the method option is ngx http get by default the args option can specify extra uri arguments for instance lua ngx location capture foo a 1 args b 3 c is equivalent to lua ngx location capture foo a 1 b 3 c 3a that is this method will escape argument keys and values according to uri rules and concatenate them together into a complete query string the format for the lua table passed as the args argument is identical to the format used in the ngx encode args method the args option can also take plain query strings lua ngx location capture foo a 1 args b 3 c 3a this is functionally identical to the previous examples the share all vars option controls whether to share nginx variables among the current request and its subrequests if this option is set to true then the current request and associated subrequests will share the same nginx variable scope hence changes to nginx variables made by a subrequest will affect the current request care should be taken in using this option as variable scope sharing can have unexpected side effects the args vars or copy all vars options are generally preferable instead this option is set to false by default nginx location other set dog dog world echo uri dog dog location lua set dog hello content by lua block res ngx location capture other share all vars true ngx print res body ngx say ngx var uri ngx var dog accessing location lua gives other dog hello world lua hello world the copy all vars option provides a copy of the parent requests nginx variables to subrequests when such subrequests are issued changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent requests variables nginx location other set dog dog world echo uri dog dog location lua set dog hello content by lua block res ngx location capture other copy all vars true ngx print res body ngx say ngx var uri ngx var dog request get lua will give the output other dog hello world lua hello note that if both share all vars and copy all vars are set to true then share all vars takes precedence in addition to the two settings above it is possible to specify values for variables in the subrequest using the vars option these variables are set after the sharing or copying of variables has been evaluated and provides a more efficient method of passing specific values to a subrequest over encoding them as url arguments and unescaping them in the nginx config file nginx location other content by lua block ngx say dog ngx var dog ngx say cat ngx var cat location lua set dog set cat content by lua block res ngx location capture other vars dog hello cat 32 ngx print res body accessing lua will yield the output dog hello cat 32 the ctx option can be used to specify a custom lua table to serve as the ngx ctx table for the subrequest nginx location sub content by lua block ngx ctx foo bar location lua content by lua block local ctx res ngx location capture sub ctx ctx ngx say ctx foo ngx say ngx ctx foo then request get lua gives bar nil it is also possible to use this ctx option to share the same ngx ctx table between the current parent request and the subrequest nginx location sub content by lua block ngx ctx foo bar location lua content by lua block res ngx location capture sub ctx ngx ctx ngx say ngx ctx foo request get lua yields the output bar note that subrequests issued by ngx location capture inherit all the request headers of the current request by default and that this may have unexpected side effects on the subrequest responses for example when using the standard ngx proxy module to serve subrequests an accept encoding gzip header in the main request may result in gzipped responses that cannot be handled properly in lua code original request headers should be ignored by setting proxy pass request headers to off in subrequest locations when the body option is not specified and the always forward body option is false the default value the post and put subrequests will inherit the request bodies of the parent request if any there is a hard coded upper limit on the number of concurrent subrequests possible for every main request in older versions of nginx the limit was 50 concurrent subrequests and in more recent versions nginx 1 1 x onwards this was increased to 200 concurrent subrequests when this limit is exceeded the following error message is added to the error log file error 13983 0 1 subrequests cycle while processing uri the limit can be manually modified if required by editing the definition of the ngx http max subrequests macro in the nginx src http ngx http request h file in the nginx source tree please also refer to restrictions on capturing locations configured by subrequest directives of other modules back to toc ngx location capture multi syntax res1 res2 ngx location capture multi uri options uri options context rewrite by lua access by lua content by lua just like ngx location capture but supports multiple subrequests running in parallel this function issues several parallel subrequests specified by the input table and returns their results in the same order for example lua res1 res2 res3 ngx location capture multi foo args a 3 b 4 bar baz method ngx http post body hello if res1 status ngx http ok then end if res2 body blah then end this function will not return until all the subrequests terminate the total latency is the longest latency of the individual subrequests rather than the sum lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance lua construct the requests table local reqs table insert reqs mysql table insert reqs postgres table insert reqs redis table insert reqs memcached issue all the requests at once and wait until they all return local resps ngx location capture multi reqs loop over the responses table for i resp in ipairs resps do process the response table resp end the ngx location capture function is just a special form of this function logically speaking the ngx location capture can be implemented like this lua ngx location capture function uri args return ngx location capture multi uri args end please also refer to restrictions on capturing locations configured by subrequest directives of other modules back to toc ngx status context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua read and write the current requests response status this should be called before sending out the response headers lua ngx status ngx http created status ngx status setting ngx status after the response header is sent out has no effect but leaving an error message in your nginxs error log file attempt to set ngx status after sending out response headers back to toc ngx header header syntax ngx header header value syntax value ngx header header context rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua set add to or clear the current requests header response header that is to be sent underscores in the header names will be replaced by hyphens by default this transformation can be turned off via the lua transform underscores in response headers directive the header names are matched case insensitively lua equivalent to ngx header content type text plain ngx header content type text plain ngx header x my header blah blah multi value headers can be set this way lua ngx header set cookie a 32 path b 4 path will yield bash set cookie a 32 path set cookie b 4 path in the response headers only lua tables are accepted only the last element in the table will take effect for standard headers such as content type that only accept a single value lua ngx header content type a b is equivalent to lua ngx header content type b setting a slot to nil effectively removes it from the response headers lua ngx header x my header nil the same applies to assigning an empty table lua ngx header x my header setting ngx header header after sending out response headers either explicitly with ngx send headers or implicitly with ngx print and similar will log an error message reading ngx header header will return the value of the response header named header underscores in the header names will also be replaced by dashes and the header names will be matched case insensitively if the response header is not present at all nil will be returned this is particularly useful in the context of header filter by lua for example nginx location test set footer proxy pass http some backend header filter by lua block if ngx header x my header blah then ngx var footer some value end echo after body footer for multi value headers all of the values of header will be collected in order and returned as a lua table for example response headers foo bar foo baz will result in lua bar baz to be returned when reading ngx header foo note that ngx header is not a normal lua table and as such it is not possible to iterate through it using the lua ipairs function for reading request headers use the ngx req get headers function instead back to toc ngx resp get headers syntax headers err ngx resp get headers max headers raw context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua balancer by lua returns a lua table holding all the current response headers for the current request lua local h err ngx resp get headers if err truncated then one can choose to ignore or reject the current response here end for k v in pairs h do end this function has the same signature as ngx req get headers except getting response headers instead of request headers note that a maximum of 100 response headers are parsed by default including those with the same name and that additional response headers are silently discarded to guard against potential denial of service attacks since v0 10 13 when the limit is exceeded it will return a second value which is the string truncated this api was first introduced in the v0 9 5 release back to toc ngx req is internal syntax is internal ngx req is internal context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua returns a boolean indicating whether the current request is an internal request i e a request initiated from inside the current nginx server instead of from the client side subrequests are all internal requests and so are requests after internal redirects this api was first introduced in the v0 9 20 release back to toc ngx req start time syntax secs ngx req start time context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua returns a floating point number representing the timestamp including milliseconds as the decimal part when the current request was created the following example emulates the request time variable value provided by ngx http log module in pure lua lua local request time ngx now ngx req start time this function was first introduced in the v0 7 7 release see also ngx now and ngx update time back to toc ngx req http version syntax num ngx req http version context set by lua rewrite by lua access by lua content by lua header filter by lua returns the http version number for the current request as a lua number current possible values are 2 0 1 0 1 1 and 0 9 returns nil for unrecognized values this method was first introduced in the v0 7 17 release back to toc ngx req raw header syntax str ngx req raw header no request line context set by lua rewrite by lua access by lua content by lua header filter by lua returns the original raw http protocol header received by the nginx server by default the request line and trailing cr lf terminator will also be included for example lua ngx print ngx req raw header gives something like this get t http 1 1 host localhost connection close foo bar you can specify the optional no request line argument as a true value to exclude the request line from the result for example lua ngx print ngx req raw header true outputs something like this host localhost connection close foo bar this method was first introduced in the v0 7 17 release this method does not work in http 2 requests yet back to toc ngx req get method syntax method name ngx req get method context set by lua rewrite by lua access by lua content by lua header filter by lua balancer by lua retrieves the current requests request method name strings like get and post are returned instead of numerical method constants if the current request is an nginx subrequest then the subrequests method name will be returned this method was first introduced in the v0 5 6 release see also ngx req set method back to toc ngx req set method syntax ngx req set method method id context set by lua rewrite by lua access by lua content by lua header filter by lua overrides the current requests request method with the method id argument currently only numerical method constants are supported like ngx http post and ngx http get if the current request is an nginx subrequest then the subrequests method will be overridden this method was first introduced in the v0 5 6 release see also ngx req get method back to toc ngx req set uri syntax ngx req set uri uri jump context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua rewrite the current requests parsed uri by the uri argument the uri argument must be a lua string and cannot be of zero length or a lua exception will be thrown the optional boolean jump argument can trigger location rematch or location jump as ngx http rewrite modules rewrite directive that is when jump is true default to false this function will never return and it will tell nginx to try re searching locations with the new uri value at the later post rewrite phase and jumping to the new location location jump will not be triggered otherwise and only the current requests uri will be modified which is also the default behavior this function will return but with no returned values when the jump argument is false or absent altogether for example the following nginx config snippet nginx rewrite foo last can be coded in lua like this lua ngx req set uri foo true similarly nginx config nginx rewrite foo break can be coded in lua as lua ngx req set uri foo false or equivalently lua ngx req set uri foo the jump argument can only be set to true in rewrite by lua use of jump in other contexts is prohibited and will throw out a lua exception a more sophisticated example involving regex substitutions is as follows nginx location test rewrite by lua block local uri ngx re sub ngx var uri test 1 o ngx req set uri uri proxy pass http my backend which is functionally equivalent to nginx location test rewrite test 1 break proxy pass http my backend note that it is not possible to use this interface to rewrite uri arguments and that ngx req set uri args should be used for this instead for instance nginx config nginx rewrite foo a 3 last can be coded as nginx ngx req set uri args a 3 ngx req set uri foo true or nginx ngx req set uri args a 3 ngx req set uri foo true this interface was first introduced in the v0 3 1rc14 release back to toc ngx req set uri args syntax ngx req set uri args args context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua rewrite the current requests uri query arguments by the args argument the args argument can be either a lua string as in lua ngx req set uri args a 3 b hello 20world or a lua table holding the query arguments key value pairs as in lua ngx req set uri args a 3 b hello world where in the latter case this method will escape argument keys and values according to the uri escaping rule multi value arguments are also supported lua ngx req set uri args a 3 b 5 6 which will result in a query string like a 3 b 5 b 6 this interface was first introduced in the v0 3 1rc13 release see also ngx req set uri back to toc ngx req get uri args syntax args err ngx req get uri args max args context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua balancer by lua returns a lua table holding all the current request url query arguments nginx location test content by lua block local args err ngx req get uri args if err truncated then one can choose to ignore or reject the current request here end for key val in pairs args do if type val table then ngx say key table concat val else ngx say key val end end then get test foo bar bar baz bar blah will yield the response body bash foo bar bar baz blah multiple occurrences of an argument key will result in a table value holding all the values for that key in order keys and values are unescaped according to uri escaping rules in the settings above get test a 20b 1 61 2 will yield bash a b 1a 2 arguments without the value parts are treated as boolean arguments get test foo bar will yield bash foo true bar true that is they will take lua boolean values true however they are different from arguments taking empty string values get test foo bar will give something like bash foo bar empty key arguments are discarded get test hello world will yield an empty output for instance updating query arguments via the nginx variable args or ngx var args in lua at runtime is also supported lua ngx var args a 3 b 42 local args err ngx req get uri args here the args table will always look like lua a 3 b 42 regardless of the actual request query string note that a maximum of 100 request arguments are parsed by default including those with the same name and that additional request arguments are silently discarded to guard against potential denial of service attacks since v0 10 13 when the limit is exceeded it will return a second value which is the string truncated however the optional max args function argument can be used to override this limit lua local args err ngx req get uri args 10 if err truncated then one can choose to ignore or reject the current request here end this argument can be set to zero to remove the limit and to process all request arguments received lua local args err ngx req get uri args 0 removing the max args cap is strongly discouraged back to toc ngx req get post args syntax args err ngx req get post args max args context rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua returns a lua table holding all the current request post query arguments of the mime type application x www form urlencoded call ngx req read body to read the request body first or turn on the lua need request body directive to avoid errors nginx location test content by lua block ngx req read body local args err ngx req get post args if err truncated then one can choose to ignore or reject the current request here end if not args then ngx say failed to get post args err return end for key val in pairs args do if type val table then ngx say key table concat val else ngx say key val end end then bash post request with the body foo bar bar baz bar blah curl data foo bar bar baz bar blah localhost test will yield the response body like bash foo bar bar baz blah multiple occurrences of an argument key will result in a table value holding all of the values for that key in order keys and values will be unescaped according to uri escaping rules with the settings above bash post request with body a 20b 1 61 2 curl d a 20b 1 61 2 localhost test will yield bash a b 1a 2 arguments without the value parts are treated as boolean arguments post test with the request body foo bar will yield bash foo true bar true that is they will take lua boolean values true however they are different from arguments taking empty string values post test with request body foo bar will return something like bash foo bar empty key arguments are discarded post test with body hello world will yield empty outputs for instance note that a maximum of 100 request arguments are parsed by default including those with the same name and that additional request arguments are silently discarded to guard against potential denial of service attacks since v0 10 13 when the limit is exceeded it will return a second value which is the string truncated however the optional max args function argument can be used to override this limit lua local args err ngx req get post args 10 if err truncated then one can choose to ignore or reject the current request here end this argument can be set to zero to remove the limit and to process all request arguments received lua local args err ngx req get post args 0 removing the max args cap is strongly discouraged back to toc ngx req get headers syntax headers err ngx req get headers max headers raw context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua returns a lua table holding all the current request headers lua local h err ngx req get headers if err truncated then one can choose to ignore or reject the current request here end for k v in pairs h do end to read an individual header lua ngx say host ngx req get headers host note that the ngx var header api call which uses core http header variables may be more preferable for reading individual request headers for multiple instances of request headers such as bash foo foo foo bar foo baz the value of ngx req get headers foo will be a lua array table such as lua foo bar baz note that a maximum of 100 request headers are parsed by default including those with the same name and that additional request headers are silently discarded to guard against potential denial of service attacks since v0 10 13 when the limit is exceeded it will return a second value which is the string truncated however the optional max headers function argument can be used to override this limit lua local headers err ngx req get headers 10 if err truncated then one can choose to ignore or reject the current request here end this argument can be set to zero to remove the limit and to process all request headers received lua local headers err ngx req get headers 0 removing the max headers cap is strongly discouraged since the 0 6 9 release all the header names in the lua table returned are converted to the pure lower case form by default unless the raw argument is set to true default to false also by default an index metamethod is added to the resulting lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss for example if a request header my foo header is present then the following invocations will all pick up the value of this header correctly lua ngx say headers my foo header ngx say headers my foo header ngx say headers my foo header the index metamethod will not be added when the raw argument is set to true back to toc ngx req set header syntax ngx req set header header name header value context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua set the current requests request header named header name to value header value overriding any existing ones by default all the subrequests subsequently initiated by ngx location capture and ngx location capture multi will inherit the new header here is an example of setting the content type header lua ngx req set header content type text css the header value can take an array list of values for example lua ngx req set header foo a abc will produce two new request headers bash foo a foo abc and old foo headers will be overridden if there is any when the header value argument is nil the request header will be removed so lua ngx req set header x foo nil is equivalent to lua ngx req clear header x foo back to toc ngx req clear header syntax ngx req clear header header name context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua clears the current requests request header named header name none of the current requests existing subrequests will be affected but subsequently initiated subrequests will inherit the change by default back to toc ngx req read body syntax ngx req read body context rewrite by lua access by lua content by lua reads the client request body synchronously without blocking the nginx event loop lua ngx req read body local args ngx req get post args if the request body is already read previously by turning on lua need request body or by using other modules then this function does not run and returns immediately if the request body has already been explicitly discarded either by the ngx req discard body function or other modules this function does not run and returns immediately in case of errors such as connection errors while reading the data this method will throw out a lua exception or terminate the current request with a 500 status code immediately the request body data read using this function can be retrieved later via ngx req get body data or alternatively the temporary file name for the body data cached to disk using ngx req get body file this depends on whether the current request body is already larger than the client body buffer size and whether client body in file only has been switched on in cases where current request may have a request body and the request body data is not required the ngx req discard body function must be used to explicitly discard the request body to avoid breaking things under http 1 1 keepalive or http 1 1 pipelining this function was first introduced in the v0 3 1rc17 release back to toc ngx req discard body syntax ngx req discard body context rewrite by lua access by lua content by lua explicitly discard the request body i e read the data on the connection and throw it away immediately without using the request body by any means this function is an asynchronous call and returns immediately if the request body has already been read this function does nothing and returns immediately this function was first introduced in the v0 3 1rc17 release see also ngx req read body back to toc ngx req get body data syntax data ngx req get body data context rewrite by lua access by lua content by lua log by lua retrieves in memory request body data it returns a lua string rather than a lua table holding all the parsed query arguments use the ngx req get post args function instead if a lua table is required this function returns nil if the request body has not been read the request body has been read into disk temporary files or the request body has zero size if the request body has not been read yet call ngx req read body first or turn on lua need request body to force this module to read the request body this is not recommended however if the request body has been read into disk files try calling the ngx req get body file function instead to force in memory request bodies try setting client body buffer size to the same size value in client max body size note that calling this function instead of using ngx var request body or ngx var echo request body is more efficient because it can save one dynamic memory allocation and one data copy this function was first introduced in the v0 3 1rc17 release see also ngx req get body file back to toc ngx req get body file syntax file name ngx req get body file context rewrite by lua access by lua content by lua retrieves the file name for the in file request body data returns nil if the request body has not been read or has been read into memory the returned file is read only and is usually cleaned up by nginxs memory pool it should not be manually modified renamed or removed in lua code if the request body has not been read yet call ngx req read body first or turn on lua need request body to force this module to read the request body this is not recommended however if the request body has been read into memory try calling the ngx req get body data function instead to force in file request bodies try turning on client body in file only this function was first introduced in the v0 3 1rc17 release see also ngx req get body data back to toc ngx req set body data syntax ngx req set body data data context rewrite by lua access by lua content by lua set the current requests request body using the in memory data specified by the data argument if the request body has not been read yet call ngx req read body first or turn on lua need request body to force this module to read the request body this is not recommended however additionally the request body must not have been previously discarded by ngx req discard body whether the previous request body has been read into memory or buffered into a disk file it will be freed or the disk file will be cleaned up immediately respectively this function was first introduced in the v0 3 1rc18 release see also ngx req set body file back to toc ngx req set body file syntax ngx req set body file file name auto clean context rewrite by lua access by lua content by lua set the current requests request body using the in file data specified by the file name argument if the request body has not been read yet call ngx req read body first or turn on lua need request body to force this module to read the request body this is not recommended however additionally the request body must not have been previously discarded by ngx req discard body if the optional auto clean argument is given a true value then this file will be removed at request completion or the next time this function or ngx req set body data are called in the same request the auto clean is default to false please ensure that the file specified by the file name argument exists and is readable by an nginx worker process by setting its permission properly to avoid lua exception errors whether the previous request body has been read into memory or buffered into a disk file it will be freed or the disk file will be cleaned up immediately respectively this function was first introduced in the v0 3 1rc18 release see also ngx req set body data back to toc ngx req init body syntax ngx req init body buffer size context set by lua rewrite by lua access by lua content by lua creates a new blank request body for the current request and inializes the buffer for later request body data writing via the ngx req append body and ngx req finish body apis if the buffer size argument is specified then its value will be used for the size of the memory buffer for body writing with ngx req append body if the argument is omitted then the value specified by the standard client body buffer size directive will be used instead when the data can no longer be hold in the memory buffer for the request body then the data will be flushed onto a temporary file just like the standard request body reader in the nginx core it is important to always call the ngx req finish body after all the data has been appended onto the current request body also when this function is used together with ngx req socket it is required to call ngx req socket before this function or you will get the request body already exists error message the usage of this function is often like this lua ngx req init body 128 1024 buffer is 128kb for chunk in next data chunk do ngx req append body chunk each chunk can be 4kb end ngx req finish body this function can be used with ngx req append body ngx req finish body and ngx req socket to implement efficient input filters in pure lua in the context of rewrite by lua or access by lua which can be used with other nginx content handler or upstream modules like ngx http proxy module and ngx http fastcgi module this function was first introduced in the v0 5 11 release back to toc ngx req append body syntax ngx req append body data chunk context set by lua rewrite by lua access by lua content by lua append new data chunk specified by the data chunk argument onto the existing request body created by the ngx req init body call when the data can no longer be hold in the memory buffer for the request body then the data will be flushed onto a temporary file just like the standard request body reader in the nginx core it is important to always call the ngx req finish body after all the data has been appended onto the current request body this function can be used with ngx req init body ngx req finish body and ngx req socket to implement efficient input filters in pure lua in the context of rewrite by lua or access by lua which can be used with other nginx content handler or upstream modules like ngx http proxy module and ngx http fastcgi module this function was first introduced in the v0 5 11 release see also ngx req init body back to toc ngx req finish body syntax ngx req finish body context set by lua rewrite by lua access by lua content by lua completes the construction process of the new request body created by the ngx req init body and ngx req append body calls this function can be used with ngx req init body ngx req append body and ngx req socket to implement efficient input filters in pure lua in the context of rewrite by lua or access by lua which can be used with other nginx content handler or upstream modules like ngx http proxy module and ngx http fastcgi module this function was first introduced in the v0 5 11 release see also ngx req init body back to toc ngx req socket syntax tcpsock err ngx req socket syntax tcpsock err ngx req socket raw context rewrite by lua access by lua content by lua returns a read only cosocket object that wraps the downstream connection only receive and receiveuntil methods are supported on this object in case of error nil will be returned as well as a string describing the error the socket object returned by this method is usually used to read the current requests body in a streaming fashion do not turn on the lua need request body directive and do not mix this call with ngx req read body and ngx req discard body if any request body data has been pre read into the nginx core request header buffer the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre reading chunked request bodies are not yet supported in this api since the v0 9 0 release this function accepts an optional boolean raw argument when this argument is true this function returns a full duplex cosocket object wrapping around the raw downstream connection socket upon which you can call the receive receiveuntil and send methods when the raw argument is true it is required that no pending data from any previous ngx say ngx print or ngx send headers calls exists so if you have these downstream output calls previously you should call ngx flush true before calling ngx req socket true to ensure that there is no pending output data if the request body has not been read yet then this raw socket can also be used to read the request body you can use the raw request socket returned by ngx req socket true to implement fancy protocols like websocket or just emit your own raw http response header or body data you can refer to the lua resty websocket library for a real world example this function was first introduced in the v0 5 0rc1 release back to toc ngx exec syntax ngx exec uri args context rewrite by lua access by lua content by lua does an internal redirect to uri with args and is similar to the echo exec directive of the echo nginx module lua ngx exec some location ngx exec some location a 3 b 5 c 6 ngx exec some location a 3 b 5 c 6 the optional second args can be used to specify extra uri query arguments for example lua ngx exec foo a 3 b hello 20world alternatively a lua table can be passed for the args argument for ngx lua to carry out uri escaping and string concatenation lua ngx exec foo a 3 b hello world the result is exactly the same as the previous example the format for the lua table passed as the args argument is identical to the format used in the ngx encode args method named locations are also supported but the second args argument will be ignored if present and the querystring for the new target is inherited from the referring location if any get foo file php a hello will return hello and not goodbye in the example below nginx location foo content by lua block ngx exec bar a goodbye location bar content by lua block local args ngx req get uri args for key val in pairs args do if key a then ngx say val end end note that the ngx exec method is different from ngx redirect in that it is purely an internal redirect and that no new external http traffic is involved also note that this method call terminates the processing of the current request and that it must be called before ngx send headers or explicit response body outputs by either ngx print or ngx say it is recommended that a coding style that combines this method call with the return statement i e return ngx exec be adopted when this method call is used in contexts other than header filter by lua to reinforce the fact that the request processing is being terminated back to toc ngx redirect syntax ngx redirect uri status context rewrite by lua access by lua content by lua issue an http 301 or 302 redirection to uri the optional status parameter specifies the http status code to be used the following status codes are supported right now 301 302 default 303 307 308 it is 302 ngx http moved temporarily by default here is an example assuming the current server name is localhost and that it is listening on port 1984 lua return ngx redirect foo which is equivalent to lua return ngx redirect foo ngx http moved temporarily redirecting arbitrary external urls is also supported for example lua return ngx redirect http www google com we can also use the numerical code directly as the second status argument lua return ngx redirect foo 301 this method is similar to the rewrite directive with the redirect modifier in the standard ngx http rewrite module for example this nginx conf snippet nginx rewrite foo redirect nginx config is equivalent to the following lua code lua return ngx redirect foo lua code while nginx rewrite foo permanent nginx config is equivalent to lua return ngx redirect foo ngx http moved permanently lua code uri arguments can be specified as well for example lua return ngx redirect foo a 3 b 4 note that this method call terminates the processing of the current request and that it must be called before ngx send headers or explicit response body outputs by either ngx print or ngx say it is recommended that a coding style that combines this method call with the return statement i e return ngx redirect be adopted when this method call is used in contexts other than header filter by lua to reinforce the fact that the request processing is being terminated back to toc ngx send headers syntax ok err ngx send headers context rewrite by lua access by lua content by lua explicitly send out the response headers since v0 8 3 this function returns 1 on success or returns nil and a string describing the error otherwise note that there is normally no need to manually send out response headers as ngx lua will automatically send headers out before content is output with ngx say or ngx print or when content by lua exits normally back to toc ngx headers sent syntax value ngx headers sent context set by lua rewrite by lua access by lua content by lua returns true if the response headers have been sent by ngx lua and false otherwise this api was first introduced in ngx lua v0 3 1rc6 back to toc ngx print syntax ok err ngx print context rewrite by lua access by lua content by lua emits arguments concatenated to the http client as response body if response headers have not been sent this function will send headers out first and then output body data since v0 8 3 this function returns 1 on success or returns nil and a string describing the error otherwise lua nil values will output nil strings and lua boolean values will output true and false literal strings respectively nested arrays of strings are permitted and the elements in the arrays will be sent one by one lua local table hello world true or false nil ngx print table will yield the output bash hello world true or false nil non array table arguments will cause a lua exception to be thrown the ngx null constant will yield the null string output this is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer to run in synchronous mode call ngx flush true after calling ngx print this can be particularly useful for streaming output see ngx flush for more details please note that both ngx print and ngx say will always invoke the whole nginx output body filter chain which is an expensive operation so be careful when calling either of these two in a tight loop buffer the data yourself in lua and save the calls back to toc ngx say syntax ok err ngx say context rewrite by lua access by lua content by lua just as ngx print but also emit a trailing newline back to toc ngx log syntax ngx log log level context init by lua init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua log arguments concatenated to error log with the given logging level lua nil arguments are accepted and result in literal nil string while lua booleans result in literal true or false string outputs and the ngx null constant will yield the null string output the log level argument can take constants like ngx err and ngx warn check out nginx log level constants for details there is a hard coded 2048 byte limitation on error message lengths in the nginx core this limit includes trailing newlines and leading time stamps if the message size exceeds this limit nginx will truncate the message text accordingly this limit can be manually modified by editing the ngx max error str macro definition in the src core ngx log h file in the nginx source tree back to toc ngx flush syntax ok err ngx flush wait context rewrite by lua access by lua content by lua flushes response output to the client ngx flush accepts an optional boolean wait argument default false first introduced in the v0 3 1rc34 release when called with the default argument it issues an asynchronous call returns immediately without waiting for output data to be written into the system send buffer calling the function with the wait argument set to true switches to synchronous mode in synchronous mode the function will not return until all output data has been written into the system send buffer or until the send timeout setting has expired note that using the lua coroutine mechanism means that this function does not block the nginx event loop even in the synchronous mode when ngx flush true is called immediately after ngx print or ngx say it causes the latter functions to run in synchronous mode this can be particularly useful for streaming output note that ngx flush is not functional when in the http 1 0 output buffering mode see http 1 0 support since v0 8 3 this function returns 1 on success or returns nil and a string describing the error otherwise back to toc ngx exit syntax ngx exit status context rewrite by lua access by lua content by lua header filter by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua when status 200 i e ngx http ok and above it will interrupt the execution of the current request and return status code to nginx when status 0 i e ngx ok it will only quit the current phase handler or the content handler if the content by lua directive is used and continue to run later phases if any for the current request the status argument can be ngx ok ngx error ngx http not found ngx http moved temporarily or other http status constants to return an error page with custom contents use code snippets like this lua ngx status ngx http gone ngx say this is our own content to cause quit the whole request rather than the current phase handler ngx exit ngx http ok the effect in action bash curl i http localhost test http 1 1 410 gone server nginx 1 0 6 date thu 15 sep 2011 00 51 48 gmt content type text plain transfer encoding chunked connection keep alive this is our own content number literals can be used directly as the argument for instance lua ngx exit 501 note that while this method accepts all http status constants as input it only accepts ngx ok and ngx error of the core constants also note that this method call terminates the processing of the current request and that it is recommended that a coding style that combines this method call with the return statement i e return ngx exit be used to reinforce the fact that the request processing is being terminated when being used in the contexts of header filter by lua balancer by lua and ssl session store by lua ngx exit is an asynchronous operation and will return immediately this behavior may change in future and it is recommended that users always use return in combination as suggested above back to toc ngx eof syntax ok err ngx eof context rewrite by lua access by lua content by lua explicitly specify the end of the response output stream in the case of http 1 1 chunked encoded output it will just trigger the nginx core to send out the last chunk when you disable the http 1 1 keep alive feature for your downstream connections you can rely on well written http clients to close the connection actively for you when you call this method this trick can be used do back ground jobs without letting the http clients to wait on the connection as in the following example nginx location async keepalive timeout 0 content by lua block ngx say got the task ngx eof well written http clients will close the connection at this point access mysql postgresql redis memcached and etc here but if you create subrequests to access other locations configured by nginx upstream modules then you should configure those upstream modules to ignore client connection abortions if they are not by default for example by default the standard ngx http proxy module will terminate both the subrequest and the main request as soon as the client closes the connection so it is important to turn on the proxy ignore client abort directive in your location block configured by ngx http proxy module nginx proxy ignore client abort on a better way to do background jobs is to use the ngx timer at api since v0 8 3 this function returns 1 on success or returns nil and a string describing the error otherwise back to toc ngx sleep syntax ngx sleep seconds context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua sleeps for the specified seconds without blocking one can specify time resolution up to 0 001 seconds i e one milliseconds behind the scene this method makes use of the nginx timers since the 0 7 20 release the 0 time argument can also be specified this method was introduced in the 0 5 0rc30 release back to toc ngx escape uri syntax newstr ngx escape uri str context init by lua init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua escape str as a uri component back to toc ngx unescape uri syntax newstr ngx unescape uri str context init by lua init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua unescape str as an escaped uri component for example lua ngx say ngx unescape uri b 20r56 7 gives the output b r56 7 back to toc ngx encode args syntax str ngx encode args table context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua encode the lua table to a query args string according to the uri encoded rules for example lua ngx encode args foo 3 b r hello world yields foo 3 b 20r hello 20world the table keys must be lua strings multi value query args are also supported just use a lua table for the arguments value for example lua ngx encode args baz 32 hello gives baz 32 baz hello if the value table is empty and the effect is equivalent to the nil value boolean argument values are also supported for instance lua ngx encode args a true b 1 yields a b 1 if the argument value is false then the effect is equivalent to the nil value this method was first introduced in the v0 3 1rc27 release back to toc ngx decode args syntax table err ngx decode args str max args context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua decodes a uri encoded query string into a lua table this is the inverse function of ngx encode args the optional max args argument can be used to specify the maximum number of arguments parsed from the str argument by default a maximum of 100 request arguments are parsed including those with the same name and that additional uri arguments are silently discarded to guard against potential denial of service attacks since v0 10 13 when the limit is exceeded it will return a second value which is the string truncated this argument can be set to zero to remove the limit and to process all request arguments received lua local args ngx decode args str 0 removing the max args cap is strongly discouraged this method was introduced in the v0 5 0rc29 back to toc ngx encode base64 syntax newstr ngx encode base64 str no padding context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua encodes str to a base64 digest since the 0 9 16 release an optional boolean typed no padding argument can be specified to control whether the base64 padding should be appended to the resulting digest default to false i e with padding enabled back to toc ngx decode base64 syntax newstr ngx decode base64 str context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua decodes the str argument as a base64 digest to the raw form returns nil if str is not well formed back to toc ngx crc32 short syntax intval ngx crc32 short str context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua calculates the crc 32 cyclic redundancy code digest for the str argument this method performs better on relatively short str inputs i e less than 30 60 bytes as compared to ngx crc32 long the result is exactly the same as ngx crc32 long behind the scene it is just a thin wrapper around the ngx crc32 short function defined in the nginx core this api was first introduced in the v0 3 1rc8 release back to toc ngx crc32 long syntax intval ngx crc32 long str context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua calculates the crc 32 cyclic redundancy code digest for the str argument this method performs better on relatively long str inputs i e longer than 30 60 bytes as compared to ngx crc32 short the result is exactly the same as ngx crc32 short behind the scene it is just a thin wrapper around the ngx crc32 long function defined in the nginx core this api was first introduced in the v0 3 1rc8 release back to toc ngx hmac sha1 syntax digest ngx hmac sha1 secret key str context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua computes the hmac sha1 digest of the argument str and turns the result using the secret key secret key the raw binary form of the hmac sha1 digest will be generated use ngx encode base64 for example to encode the result to a textual representation if desired for example lua local key thisisverysecretstuff local src some string we want to sign local digest ngx hmac sha1 key src ngx say ngx encode base64 digest yields the output r pvxzhc4nltj7s kxfg neptmk this api requires the openssl library enabled in the nginx build usually by passing the with http ssl module option to the configure script this function was first introduced in the v0 3 1rc29 release back to toc ngx md5 syntax digest ngx md5 str context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns the hexadecimal representation of the md5 digest of the str argument for example nginx location md5 content by lua block ngx say ngx md5 hello yields the output 5d41402abc4b2a76b9719d911017c592 see ngx md5 bin if the raw binary md5 digest is required back to toc ngx md5 bin syntax digest ngx md5 bin str context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns the binary form of the md5 digest of the str argument see ngx md5 if the hexadecimal form of the md5 digest is required back to toc ngx sha1 bin syntax digest ngx sha1 bin str context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns the binary form of the sha 1 digest of the str argument this function requires sha 1 support in the nginx build this usually just means openssl should be installed while building nginx this function was first introduced in the v0 5 0rc6 back to toc ngx quote sql str syntax quoted value ngx quote sql str raw value context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns a quoted sql string literal according to the mysql quoting rules back to toc ngx today syntax str ngx today context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns current date in the format yyyy mm dd from the nginx cached time no syscall involved unlike luas date library this is the local time back to toc ngx time syntax secs ngx time context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns the elapsed seconds from the epoch for the current time stamp from the nginx cached time no syscall involved unlike luas date library updates of the nginx time cache can be forced by calling ngx update time first back to toc ngx now syntax secs ngx now context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns a floating point number for the elapsed time in seconds including milliseconds as the decimal part from the epoch for the current time stamp from the nginx cached time no syscall involved unlike luas date library you can forcibly update the nginx time cache by calling ngx update time first this api was first introduced in v0 3 1rc32 back to toc ngx update time syntax ngx update time context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua forcibly updates the nginx current time cache this call involves a syscall and thus has some overhead so do not abuse it this api was first introduced in v0 3 1rc32 back to toc ngx localtime syntax str ngx localtime context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns the current time stamp in the format yyyy mm dd hh mm ss of the nginx cached time no syscall involved unlike luas os date function this is the local time back to toc ngx utctime syntax str ngx utctime context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns the current time stamp in the format yyyy mm dd hh mm ss of the nginx cached time no syscall involved unlike luas os date function this is the utc time back to toc ngx cookie time syntax str ngx cookie time sec context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns a formatted string can be used as the cookie expiration time the parameter sec is the time stamp in seconds like those returned from ngx time nginx ngx say ngx cookie time 1290079655 yields thu 18 nov 10 11 27 35 gmt back to toc ngx http time syntax str ngx http time sec context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns a formated string can be used as the http header time for example being used in last modified header the parameter sec is the time stamp in seconds like those returned from ngx time nginx ngx say ngx http time 1290079655 yields thu 18 nov 2010 11 27 35 gmt back to toc ngx parse http time syntax sec ngx parse http time str context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua parse the http time string as returned by ngx http time into seconds returns the seconds or nil if the input string is in bad forms nginx local time ngx parse http time thu 18 nov 2010 11 27 35 gmt if time nil then end back to toc ngx is subrequest syntax value ngx is subrequest context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua returns true if the current request is an nginx subrequest or false otherwise back to toc ngx re match syntax captures err ngx re match subject regex options ctx res table context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua matches the subject string using the perl compatible regular expression regex with the optional options only the first occurrence of the match is returned or nil if no match is found in case of errors like seeing a bad regular expression or exceeding the pcre stack limit nil and a string describing the error will be returned when a match is found a lua table captures is returned where captures 0 holds the whole substring being matched and captures 1 holds the first parenthesized sub patterns capturing captures 2 the second and so on lua local m err ngx re match hello 1234 0 9 if m then m 0 1234 else if err then ngx log ngx err error err return end ngx say match not found end lua local m err ngx re match hello 1234 0 9 0 9 m 0 1234 m 1 1 named captures are also supported since the v0 7 14 release and are returned in the same lua table as key value pairs as the numbered captures lua local m err ngx re match hello 1234 0 9 0 9 m 0 1234 m 1 1 m 2 234 m remaining 234 unmatched subpatterns will have false values in their captures table fields lua local m err ngx re match hello world world hello howdy m 0 hello m 1 false m 2 hello m 3 false m named false specify options to control how the match operation will be performed the following option characters are supported a anchored mode only match from the beginning d enable the dfa mode or the longest token match semantics this requires pcre 6 0 or else a lua exception will be thrown first introduced in ngx lua v0 3 1rc30 d enable duplicate named pattern support this allows named subpattern names to be repeated returning the captures in an array like lua table for example local m ngx re match hello world named \w named \w d m named hello world this option was first introduced in the v0 7 14 release this option requires at least pcre 8 12 i case insensitive mode similar to perls i modifier j enable pcre jit compilation this requires pcre 8 21 which must be built with the enable jit option for optimum performance this option should always be used together with the o option first introduced in ngx lua v0 3 1rc30 j enable the pcre javascript compatible mode this option was first introduced in the v0 7 14 release this option requires at least pcre 8 12 m multi line mode similar to perls m modifier o compile once mode similar to perls o modifier to enable the worker process level compiled regex cache s single line mode similar to perls s modifier u utf 8 mode this requires pcre to be built with the enable utf8 option or else a lua exception will be thrown u similar to u but disables pcres utf 8 validity check on the subject string first introduced in ngx lua v0 8 1 x extended mode similar to perls x modifier these options can be combined nginx local m err ngx re match hello world hel lo ix m 0 hello nginx local m err ngx re match hello 美好生活 hello 2 iu m 0 hello 美好 m 1 美好 the o option is useful for performance tuning because the regex pattern in question will only be compiled once cached in the worker process level and shared among all requests in the current nginx worker process the upper limit of the regex cache can be tuned via the lua regex cache max entries directive the optional fourth argument ctx can be a lua table holding an optional pos field when the pos field in the ctx table argument is specified ngx re match will start matching from that offset starting from 1 regardless of the presence of the pos field in the ctx table ngx re match will always set this pos field to the position after the substring matched by the whole pattern in case of a successful match when match fails the ctx table will be left intact lua local ctx local m err ngx re match 1234 hello 0 9 ctx m 0 1234 ctx pos 5 lua local ctx pos 2 local m err ngx re match 1234 hello 0 9 ctx m 0 234 ctx pos 5 the ctx table argument combined with the a regex modifier can be used to construct a lexer atop ngx re match note that the options argument is not optional when the ctx argument is specified and that the empty lua string must be used as placeholder for options if no meaningful regex options are required this method requires the pcre library enabled in nginx known issue with special escaping sequences to confirm that pcre jit is enabled activate the nginx debug log by adding the with debug option to nginx or openrestys configure script then enable the debug error log level in error log directive the following message will be generated if pcre jit is enabled pcre jit compiling result 1 starting from the 0 9 4 release this function also accepts a 5th argument res table for letting the caller supply the lua table used to hold all the capturing results starting from 0 9 6 it is the callers responsibility to ensure this table is empty this is very useful for recycling lua tables and saving gc and table allocation overhead this feature was introduced in the v0 2 1rc11 release back to toc ngx re find syntax from to err ngx re find subject regex options ctx nth context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua similar to ngx re match but only returns the beginning index from and end index to of the matched substring the returned indexes are 1 based and can be fed directly into the string sub api function to obtain the matched substring in case of errors like bad regexes or any pcre runtime errors this api function returns two nil values followed by a string describing the error if no match is found this function just returns a nil value below is an example lua local s hello 1234 local from to err ngx re find s 0 9 jo if from then ngx say from from ngx say to to ngx say matched string sub s from to else if err then ngx say error err return end ngx say not matched end this example produces the output from 8 to 11 matched 1234 because this api function does not create new lua strings nor new lua tables it is much faster than ngx re match it should be used wherever possible since the 0 9 3 release an optional 5th argument nth is supported to specify which submatch captures indexes to return when nth is 0 which is the default the indexes for the whole matched substring is returned when nth is 1 then the 1st submatch captures indexes are returned when nth is 2 then the 2nd submatch capture is returned and so on when the specified submatch does not have a match then two nil values will be returned below is an example for this lua local str hello 1234 local from to ngx re find str 0 9 0 9 jo nil 2 if from then ngx say matched 2nd submatch string sub str from to yields 234 end this api function was first introduced in the v0 9 2 release back to toc ngx re gmatch syntax iterator err ngx re gmatch subject regex options context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua similar to ngx re match but returns a lua iterator instead so as to let the user programmer iterate all the matches over the subject string argument with the pcre regex in case of errors like seeing an ill formed regular expression nil and a string describing the error will be returned here is a small example to demonstrate its basic usage lua local iterator err ngx re gmatch hello world a z i if not iterator then ngx log ngx err error err return end local m m err iterator m 0 m 1 hello if err then ngx log ngx err error err return end m err iterator m 0 m 1 world if err then ngx log ngx err error err return end m err iterator m nil if err then ngx log ngx err error err return end more often we just put it into a lua loop lua local it err ngx re gmatch hello world a z i if not it then ngx log ngx err error err return end while true do local m err it if err then ngx log ngx err error err return end if not m then no match found any more break end found a match ngx say m 0 ngx say m 1 end the optional options argument takes exactly the same semantics as the ngx re match method the current implementation requires that the iterator returned should only be used in a single request that is one should not assign it to a variable belonging to persistent namespace like a lua package this method requires the pcre library enabled in nginx known issue with special escaping sequences this feature was first introduced in the v0 2 1rc12 release back to toc ngx re sub syntax newstr n err ngx re sub subject regex replace options context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua substitutes the first match of the perl compatible regular expression regex on the subject argument string with the string or function argument replace the optional options argument has exactly the same meaning as in ngx re match this method returns the resulting new string as well as the number of successful substitutions in case of failures like syntax errors in the regular expressions or the replace string argument it will return nil and a string describing the error when the replace is a string then it is treated as a special template for string replacement for example lua local newstr n err ngx re sub hello 1234 0 9 0 9 0 1 if newstr then newstr hello 12 1 34 n 1 else ngx log ngx err error err return end where 0 referring to the whole substring matched by the pattern and 1 referring to the first parenthesized capturing substring curly braces can also be used to disambiguate variable names from the background string literals lua local newstr n err ngx re sub hello 1234 0 9 0 00 newstr hello 100234 n 1 literal dollar sign characters in the replace string argument can be escaped by another dollar sign for instance lua local newstr n err ngx re sub hello 1234 0 9 newstr hello 234 n 1 do not use backlashes to escape dollar signs it will not work as expected when the replace argument is of type function then it will be invoked with the match table as the argument to generate the replace string literal for substitution the match table fed into the replace function is exactly the same as the return value of ngx re match here is an example lua local func function m return m 0 m 1 end local newstr n err ngx re sub hello 1234 0 9 0 9 func x newstr hello 12 1 34 n 1 the dollar sign characters in the return value of the replace function argument are not special at all this method requires the pcre library enabled in nginx known issue with special escaping sequences this feature was first introduced in the v0 2 1rc13 release back to toc ngx re gsub syntax newstr n err ngx re gsub subject regex replace options context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua just like ngx re sub but does global substitution here is some examples lua local newstr n err ngx re gsub hello world a z a z 0 1 i if newstr then newstr hello h world w n 2 else ngx log ngx err error err return end lua local func function m return m 0 m 1 end local newstr n err ngx re gsub hello world a z a z func i newstr hello h world w n 2 this method requires the pcre library enabled in nginx known issue with special escaping sequences this feature was first introduced in the v0 2 1rc15 release back to toc ngx shared dict syntax dict ngx shared dict syntax dict ngx shared name var context init by lua init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua fetching the shm based lua dictionary object for the shared memory zone named dict defined by the lua shared dict directive shared memory zones are always shared by all the nginx worker processes in the current nginx server instance the resulting object dict has the following methods get get stale set safe set add safe add replace delete incr lpush rpush lpop rpop llen ttl expire flush all flush expired get keys capacity free space all these methods are atomic operations that is safe from concurrent accesses from multiple nginx worker processes for the same lua shared dict zone here is an example nginx http lua shared dict dogs 10m server location set content by lua block local dogs ngx shared dogs dogs set jim 8 ngx say stored location get content by lua block local dogs ngx shared dogs ngx say dogs get jim let us test it bash curl localhost set stored curl localhost get 8 curl localhost get 8 the number 8 will be consistently output when accessing get regardless of how many nginx workers there are because the dogs dictionary resides in the shared memory and visible to all of the worker processes the shared dictionary will retain its contents through a server config reload either by sending the hup signal to the nginx process or by using the s reload command line option the contents in the dictionary storage will be lost however when the nginx server quits this feature was first introduced in the v0 3 1rc22 release back to toc ngx shared dict get syntax value flags ngx shared dict get key context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua retrieving the value in the dictionary ngx shared dict for the key key if the key does not exist or has expired then nil will be returned in case of errors nil and a string describing the error will be returned the value returned will have the original data type when they were inserted into the dictionary for example lua booleans numbers or strings the first argument to this method must be the dictionary object itself for example lua local cats ngx shared cats local value flags cats get cats marry or use luas syntactic sugar for method calls lua local cats ngx shared cats local value flags cats get marry these two forms are fundamentally equivalent if the user flags is 0 the default then no flags value will be returned this feature was first introduced in the v0 3 1rc22 release see also ngx shared dict back to toc ngx shared dict get stale syntax value flags stale ngx shared dict get stale key context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua similar to the get method but returns the value even if the key has already expired returns a 3rd value stale indicating whether the key has expired or not note that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items this method was first introduced in the 0 8 6 release see also ngx shared dict back to toc ngx shared dict set syntax success err forcible ngx shared dict set key value exptime flags context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua unconditionally sets a key value pair into the shm based dictionary ngx shared dict returns three values success boolean value to indicate whether the key value pair is stored or not err textual error message can be no memory forcible a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone the value argument inserted can be lua booleans numbers strings or nil their value type will also be stored into the dictionary and the same data type can be retrieved later via the get method the optional exptime argument specifies expiration time in seconds for the inserted key value pair the time resolution is 0 001 seconds if the exptime takes the value 0 which is the default then the item will never expire the optional flags argument specifies a user flags value associated with the entry to be stored it can also be retrieved later with the value the user flags is stored as an unsigned 32 bit integer internally defaults to 0 the user flags argument was first introduced in the v0 5 0rc2 release when it fails to allocate memory for the current key value item then set will try removing existing items in the storage according to the least recently used lru algorithm note that lru takes priority over expiration time here if up to tens of existing items have been removed and the storage left is still insufficient either due to the total capacity limit specified by lua shared dict or memory segmentation then the err return value will be no memory and success will be false if this method succeeds in storing the current item by forcibly removing other not yet expired items in the dictionary via lru the forcible return value will be true if it stores the item without forcibly removing other valid items then the return value forcible will be false the first argument to this method must be the dictionary object itself for example lua local cats ngx shared cats local succ err forcible cats set cats marry it is a nice cat or use luas syntactic sugar for method calls lua local cats ngx shared cats local succ err forcible cats set marry it is a nice cat these two forms are fundamentally equivalent this feature was first introduced in the v0 3 1rc22 release please note that while internally the key value pair is set atomically the atomicity does not go across the method call boundary see also ngx shared dict back to toc ngx shared dict safe set syntax ok err ngx shared dict safe set key value exptime flags context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua similar to the set method but never overrides the least recently used unexpired items in the store when running out of storage in the shared memory zone in this case it will immediately return nil and the string no memory this feature was first introduced in the v0 7 18 release see also ngx shared dict back to toc ngx shared dict add syntax success err forcible ngx shared dict add key value exptime flags context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua just like the set method but only stores the key value pair into the dictionary ngx shared dict if the key does not exist if the key argument already exists in the dictionary and not expired for sure the success return value will be false and the err return value will be exists this feature was first introduced in the v0 3 1rc22 release see also ngx shared dict back to toc ngx shared dict safe add syntax ok err ngx shared dict safe add key value exptime flags context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua similar to the add method but never overrides the least recently used unexpired items in the store when running out of storage in the shared memory zone in this case it will immediately return nil and the string no memory this feature was first introduced in the v0 7 18 release see also ngx shared dict back to toc ngx shared dict replace syntax success err forcible ngx shared dict replace key value exptime flags context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua just like the set method but only stores the key value pair into the dictionary ngx shared dict if the key does exist if the key argument does not exist in the dictionary or expired already the success return value will be false and the err return value will be not found this feature was first introduced in the v0 3 1rc22 release see also ngx shared dict back to toc ngx shared dict delete syntax ngx shared dict delete key context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua unconditionally removes the key value pair from the shm based dictionary ngx shared dict it is equivalent to ngx shared dict set key nil this feature was first introduced in the v0 3 1rc22 release see also ngx shared dict back to toc ngx shared dict incr syntax newval err forcible ngx shared dict incr key value init init ttl context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua optional requirement resty core shdict or resty core increments the numerical value for key in the shm based dictionary ngx shared dict by the step value value returns the new resulting number if the operation is successfully completed or nil and an error message otherwise when the key does not exist or has already expired in the shared dictionary if the init argument is not specified or takes the value nil this method will return nil and the error string not found or if the init argument takes a number value this method will create a new key with the value init value like the add method it also overrides the least recently used unexpired items in the store when running out of storage in the shared memory zone the optional init ttl argument specifies expiration time in seconds of the value when it is initialized via the init argument the time resolution is 0 001 seconds if init ttl takes the value 0 which is the default then the item will never expire this argument cannot be provided without providing the init argument as well and has no effect if the value already exists e g if it was previously inserted via set or the likes note usage of the init ttl argument requires the resty core shdict or resty core modules from the lua resty core library example lua require resty core local cats ngx shared cats local newval err cats incr black cats 1 0 0 1 print newval 1 ngx sleep 0 2 local val err cats get black cats print val nil the forcible return value will always be nil when the init argument is not specified if this method succeeds in storing the current item by forcibly removing other not yet expired items in the dictionary via lru the forcible return value will be true if it stores the item without forcibly removing other valid items then the return value forcible will be false if the original value is not a valid lua number in the dictionary it will return nil and not a number the value argument and init argument can be any valid lua numbers like negative numbers or floating point numbers this method was first introduced in the v0 3 1rc22 release the optional init parameter was first added in the v0 10 6 release the optional init ttl parameter was introduced in the v0 10 12rc2 release see also ngx shared dict back to toc ngx shared dict lpush syntax length err ngx shared dict lpush key value context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua inserts the specified numerical or string value at the head of the list named key in the shm based dictionary ngx shared dict returns the number of elements in the list after the push operation if key does not exist it is created as an empty list before performing the push operation when the key already takes a value that is not a list it will return nil and value not a list it never overrides the least recently used unexpired items in the store when running out of storage in the shared memory zone in this case it will immediately return nil and the string no memory this feature was first introduced in the v0 10 6 release see also ngx shared dict back to toc ngx shared dict rpush syntax length err ngx shared dict rpush key value context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua similar to the lpush method but inserts the specified numerical or string value at the tail of the list named key this feature was first introduced in the v0 10 6 release see also ngx shared dict back to toc ngx shared dict lpop syntax val err ngx shared dict lpop key context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua removes and returns the first element of the list named key in the shm based dictionary ngx shared dict if key does not exist it will return nil when the key already takes a value that is not a list it will return nil and value not a list this feature was first introduced in the v0 10 6 release see also ngx shared dict back to toc ngx shared dict rpop syntax val err ngx shared dict rpop key context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua removes and returns the last element of the list named key in the shm based dictionary ngx shared dict if key does not exist it will return nil when the key already takes a value that is not a list it will return nil and value not a list this feature was first introduced in the v0 10 6 release see also ngx shared dict back to toc ngx shared dict llen syntax len err ngx shared dict llen key context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns the number of elements in the list named key in the shm based dictionary ngx shared dict if key does not exist it is interpreted as an empty list and 0 is returned when the key already takes a value that is not a list it will return nil and value not a list this feature was first introduced in the v0 10 6 release see also ngx shared dict back to toc ngx shared dict ttl syntax ttl err ngx shared dict ttl key context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua requires resty core shdict or resty core retrieves the remaining ttl time to live in seconds of a key value pair in the shm based dictionary ngx shared dict returns the ttl as a number if the operation is successfully completed or nil and an error message otherwise if the key does not exist or has already expired this method will return nil and the error string not found the ttl is originally determined by the exptime argument of the set add replace and the likes methods it has a time resolution of 0 001 seconds a value of 0 means that the item will never expire example lua require resty core local cats ngx shared cats local succ err cats set marry a nice cat 0 5 ngx sleep 0 2 local ttl err cats ttl marry ngx say ttl 0 3 this feature was first introduced in the v0 10 11 release note this method requires the resty core shdict or resty core modules from the lua resty core library see also ngx shared dict back to toc ngx shared dict expire syntax success err ngx shared dict expire key exptime context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua requires resty core shdict or resty core updates the exptime in second of a key value pair in the shm based dictionary ngx shared dict returns a boolean indicating success if the operation completes or nil and an error message otherwise if the key does not exist this method will return nil and the error string not found the exptime argument has a resolution of 0 001 seconds if exptime is 0 then the item will never expire example lua require resty core local cats ngx shared cats local succ err cats set marry a nice cat 0 1 succ err cats expire marry 0 5 ngx sleep 0 2 local val err cats get marry ngx say val a nice cat this feature was first introduced in the v0 10 11 release note this method requires the resty core shdict or resty core modules from the lua resty core library see also ngx shared dict back to toc ngx shared dict flush all syntax ngx shared dict flush all context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua flushes out all the items in the dictionary this method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired this feature was first introduced in the v0 5 0rc17 release see also ngx shared dict flush expired and ngx shared dict back to toc ngx shared dict flush expired syntax flushed ngx shared dict flush expired max count context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua flushes out the expired items in the dictionary up to the maximal number specified by the optional max count argument when the max count argument is given 0 or not given at all then it means unlimited returns the number of items that have actually been flushed unlike the flush all method this method actually free up the memory used by the expired items this feature was first introduced in the v0 6 3 release see also ngx shared dict flush all and ngx shared dict back to toc ngx shared dict get keys syntax keys ngx shared dict get keys max count context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua fetch a list of the keys from the dictionary up to max count by default only the first 1024 keys if any are returned when the max count argument is given the value 0 then all the keys will be returned even there is more than 1024 keys in the dictionary caution avoid calling this method on dictionaries with a very large number of keys as it may lock the dictionary for significant amount of time and block nginx worker processes trying to access the dictionary this feature was first introduced in the v0 7 3 release back to toc ngx shared dict capacity syntax capacity bytes ngx shared dict capacity context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua requires resty core shdict or resty core retrieves the capacity in bytes for the shm based dictionary ngx shared dict declared with the lua shared dict directive example lua require resty core shdict local cats ngx shared cats local capacity bytes cats capacity this feature was first introduced in the v0 10 11 release note this method requires the resty core shdict or resty core modules from the lua resty core library this feature requires at least nginx core version 0 7 3 see also ngx shared dict back to toc ngx shared dict free space syntax free page bytes ngx shared dict free space context init by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua requires resty core shdict or resty core retrieves the free page size in bytes for the shm based dictionary ngx shared dict note the memory for ngx shared dict is allocated via the nginx slab allocator which has each slot for data size ranges like \ 8 9\ 16 17\ 32 1025\ 2048 2048\ bytes and pages are assigned to a slot if there is no room in already assigned pages for the slot so even if the return value of the free space method is zero there may be room in already assigned pages so you may successfully set a new key value pair to the shared dict without getting true for forcible or non nil err from the ngx shared dict set on the other hand if already assigned pages for a slot are full and a new key value pair is added to the slot and there is no free page you may get true for forcible or non nil err from the ngx shared dict set method example lua require resty core shdict local cats ngx shared cats local free page bytes cats free space this feature was first introduced in the v0 10 11 release note this method requires the resty core shdict or resty core modules from the lua resty core library this feature requires at least nginx core version 1 11 7 see also ngx shared dict back to toc ngx socket udp syntax udpsock ngx socket udp context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua creates and returns a udp or datagram oriented unix domain socket object also known as one type of the cosocket objects the following methods are supported on this object setpeername send receive close settimeout it is intended to be compatible with the udp api of the luasocket library but is 100 nonblocking out of the box this feature was first introduced in the v0 5 7 release see also ngx socket tcp back to toc udpsock setpeername syntax ok err udpsock setpeername host port syntax ok err udpsock setpeername unix path to unix domain socket context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua attempts to connect a udp socket object to a remote server or to a datagram unix domain socket file because the datagram protocol is actually connection less this method does not really establish a connection but only just set the name of the remote peer for subsequent read write operations both ip addresses and domain names can be specified as the host argument in case of domain names this method will use nginx cores dynamic resolver to parse the domain name without blocking and it is required to configure the resolver directive in the nginx conf file like this nginx resolver 8 8 8 8 use googles public dns nameserver if the nameserver returns multiple ip addresses for the host name this method will pick up one randomly in case of error the method returns nil followed by a string describing the error in case of success the method returns 1 here is an example for connecting to a udp memcached server nginx location test resolver 8 8 8 8 content by lua block local sock ngx socket udp local ok err sock setpeername my memcached server domain 11211 if not ok then ngx say failed to connect to memcached err return end ngx say successfully connected to memcached sock close since the v0 7 18 release connecting to a datagram unix domain socket file is also possible on linux lua local sock ngx socket udp local ok err sock setpeername unix tmp some datagram service sock if not ok then ngx say failed to connect to the datagram unix domain socket err return end assuming the datagram service is listening on the unix domain socket file tmp some datagram service sock and the client socket will use the autobind feature on linux calling this method on an already connected socket object will cause the original connection to be closed first this method was first introduced in the v0 5 7 release back to toc udpsock send syntax ok err udpsock send data context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua sends data on the current udp or datagram unix domain socket object in case of success it returns 1 otherwise it returns nil and a string describing the error the input argument data can either be a lua string or a nested lua table holding string fragments in case of table arguments this method will copy all the string elements piece by piece to the underlying nginx socket send buffers which is usually optimal than doing string concatenation operations on the lua land this feature was first introduced in the v0 5 7 release back to toc udpsock receive syntax data err udpsock receive size context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua receives data from the udp or datagram unix domain socket object with an optional receive buffer size argument size this method is a synchronous operation and is 100 nonblocking in case of success it returns the data received in case of error it returns nil with a string describing the error if the size argument is specified then this method will use this size as the receive buffer size but when this size is greater than 8192 then 8192 will be used instead if no argument is specified then the maximal buffer size 8192 is assumed timeout for the reading operation is controlled by the lua socket read timeout config directive and the settimeout method and the latter takes priority for example lua sock settimeout 1000 one second timeout local data err sock receive if not data then ngx say failed to read a packet err return end ngx say successfully read a packet data it is important here to call the settimeout method before calling this method this feature was first introduced in the v0 5 7 release back to toc udpsock close syntax ok err udpsock close context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua closes the current udp or datagram unix domain socket it returns the 1 in case of success and returns nil with a string describing the error otherwise socket objects that have not invoked this method and associated connections will be closed when the socket object is released by the lua gc garbage collector or the current client http request finishes processing this feature was first introduced in the v0 5 7 release back to toc udpsock settimeout syntax udpsock settimeout time context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua set the timeout value in milliseconds for subsequent socket operations like receive settings done by this method takes priority over those config directives like lua socket read timeout this feature was first introduced in the v0 5 7 release back to toc ngx socket stream just an alias to ngx socket tcp if the stream typed cosocket may also connect to a unix domain socket then this api name is preferred this api function was first added to the v0 10 1 release back to toc ngx socket tcp syntax tcpsock ngx socket tcp context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua creates and returns a tcp or stream oriented unix domain socket object also known as one type of the cosocket objects the following methods are supported on this object connect sslhandshake send receive close settimeout settimeouts setoption receiveany receiveuntil setkeepalive getreusedtimes it is intended to be compatible with the tcp api of the luasocket library but is 100 nonblocking out of the box also we introduce some new apis to provide more functionalities the cosocket object created by this api function has exactly the same lifetime as the lua handler creating it so never pass the cosocket object to any other lua handler including ngx timer callback functions and never share the cosocket object between different nginx requests for every cosocket objects underlying connection if you do not explicitly close it via close or put it back to the connection pool via setkeepalive then it is automatically closed when one of the following two events happens the current request handler completes or the lua cosocket object value gets collected by the lua gc fatal errors in cosocket operations always automatically close the current connection note that read timeout error is the only error that is not fatal and if you call close on a closed connection you will get the closed error starting from the 0 9 9 release the cosocket object here is full duplex that is a reader light thread and a writer light thread can operate on a single cosocket object simultaneously both light threads must belong to the same lua handler though see reasons above but you cannot have two light threads both reading or writing or connecting the same cosocket otherwise you might get an error like socket busy reading when calling the methods of the cosocket object this feature was first introduced in the v0 5 0rc1 release see also ngx socket udp back to toc tcpsock connect syntax ok err tcpsock connect host port options table syntax ok err tcpsock connect unix path to unix domain socket options table context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua attempts to connect a tcp socket object to a remote server or to a stream unix domain socket file without blocking before actually resolving the host name and connecting to the remote backend this method will always look up the connection pool for matched idle connections created by previous calls of this method or the ngx socket connect function both ip addresses and domain names can be specified as the host argument in case of domain names this method will use nginx cores dynamic resolver to parse the domain name without blocking and it is required to configure the resolver directive in the nginx conf file like this nginx resolver 8 8 8 8 use googles public dns nameserver if the nameserver returns multiple ip addresses for the host name this method will pick up one randomly in case of error the method returns nil followed by a string describing the error in case of success the method returns 1 here is an example for connecting to a tcp server nginx location test resolver 8 8 8 8 content by lua block local sock ngx socket tcp local ok err sock connect www google com 80 if not ok then ngx say failed to connect to google err return end ngx say successfully connected to google sock close connecting to a unix domain socket file is also possible lua local sock ngx socket tcp local ok err sock connect unix tmp memcached sock if not ok then ngx say failed to connect to the memcached unix domain socket err return end assuming memcached or something else is listening on the unix domain socket file tmp memcached sock timeout for the connecting operation is controlled by the lua socket connect timeout config directive and the settimeout method and the latter takes priority for example lua local sock ngx socket tcp sock settimeout 1000 one second timeout local ok err sock connect host port it is important here to call the settimeout method before calling this method calling this method on an already connected socket object will cause the original connection to be closed first an optional lua table can be specified as the last argument to this method to specify various connect options pool specify a custom name for the connection pool being used if omitted then the connection pool name will be generated from the string template host port or unix socket path the support for the options table argument was first introduced in the v0 5 7 release this method was first introduced in the v0 5 0rc1 release back to toc tcpsock sslhandshake syntax session err tcpsock sslhandshake reused session server name ssl verify send status req context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua does ssl tls handshake on the currently established connection the optional reused session argument can take a former ssl session userdata returned by a previous sslhandshake call for exactly the same target for short lived connections reusing ssl sessions can usually speed up the handshake by one order by magnitude but it is not so useful if the connection pool is enabled this argument defaults to nil if this argument takes the boolean false value no ssl session userdata would return by this call and only a lua boolean will be returned as the first return value otherwise the current ssl session will always be returned as the first argument in case of successes the optional server name argument is used to specify the server name for the new tls extension server name indication sni use of sni can make different servers share the same ip address on the server side also when ssl verification is enabled this server name argument is also used to validate the server name specified in the server certificate sent from the remote the optional ssl verify argument takes a lua boolean value to control whether to perform ssl verification when set to true the server certificate will be verified according to the ca certificates specified by the lua ssl trusted certificate directive you may also need to adjust the lua ssl verify depth directive to control how deep we should follow along the certificate chain also when the ssl verify argument is true and the server name argument is also specified the latter will be used to validate the server name in the server certificate the optional send status req argument takes a boolean that controls whether to send the ocsp status request in the ssl handshake request which is for requesting ocsp stapling for connections that have already done ssl tls handshake this method returns immediately this method was first introduced in the v0 9 11 release back to toc tcpsock send syntax bytes err tcpsock send data context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua sends data without blocking on the current tcp or unix domain socket connection this method is a synchronous operation that will not return until all the data has been flushed into the system socket send buffer or an error occurs in case of success it returns the total number of bytes that have been sent otherwise it returns nil and a string describing the error the input argument data can either be a lua string or a nested lua table holding string fragments in case of table arguments this method will copy all the string elements piece by piece to the underlying nginx socket send buffers which is usually optimal than doing string concatenation operations on the lua land timeout for the sending operation is controlled by the lua socket send timeout config directive and the settimeout method and the latter takes priority for example lua sock settimeout 1000 one second timeout local bytes err sock send request it is important here to call the settimeout method before calling this method in case of any connection errors this method always automatically closes the current connection this feature was first introduced in the v0 5 0rc1 release back to toc tcpsock receive syntax data err partial tcpsock receive size syntax data err partial tcpsock receive pattern context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua receives data from the connected socket according to the reading pattern or size this method is a synchronous operation just like the send method and is 100 nonblocking in case of success it returns the data received in case of error it returns nil with a string describing the error and the partial data received so far if a number like argument is specified including strings that look like numbers then it is interpreted as a size this method will not return until it reads exactly this size of data or an error occurs if a non number like string argument is specified then it is interpreted as a pattern the following patterns are supported a reads from the socket until the connection is closed no end of line translation is performed l reads a line of text from the socket the line is terminated by a line feed lf character ascii 10 optionally preceded by a carriage return cr character ascii 13 the cr and lf characters are not included in the returned line in fact all cr characters are ignored by the pattern if no argument is specified then it is assumed to be the pattern l that is the line reading pattern timeout for the reading operation is controlled by the lua socket read timeout config directive and the settimeout method and the latter takes priority for example lua sock settimeout 1000 one second timeout local line err partial sock receive if not line then ngx say failed to read a line err return end ngx say successfully read a line line it is important here to call the settimeout method before calling this method since the v0 8 8 release this method no longer automatically closes the current connection when the read timeout error happens for other connection errors this method always automatically closes the connection this feature was first introduced in the v0 5 0rc1 release back to toc tcpsock receiveany syntax data err tcpsock receiveany max context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua returns any data received by the connected socket at most max bytes this method is a synchronous operation just like the send method and is 100 nonblocking in case of success it returns the data received in case of error it returns nil with a string describing the error if the received data is more than this size this method will return with exactly this size of data the remaining data in the underlying receive buffer could be returned in the next reading operation timeout for the reading operation is controlled by the lua socket read timeout config directive and the settimeouts method and the latter takes priority for example lua sock settimeouts 1000 1000 1000 one second timeout for connect read write local data err sock receiveany 10 1024 1024 read any data at most 10k if not data then ngx say failed to read any data err return end ngx say successfully read data this method doesnt automatically close the current connection when the read timeout error occurs for other connection errors this method always automatically closes the connection this feature was first introduced in the v0 10 14 release back to toc tcpsock receiveuntil syntax iterator tcpsock receiveuntil pattern options context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua this method returns an iterator lua function that can be called to read the data stream until it sees the specified pattern or an error occurs here is an example for using this method to read a data stream with the boundary sequence abcedhb lua local reader sock receiveuntil \r\n abcedhb local data err partial reader if not data then ngx say failed to read the data stream err end ngx say read the data stream data when called without any argument the iterator function returns the received data right before the specified pattern string in the incoming data stream so for the example above if the incoming data stream is hello world agentzh\r\n abcedhb blah blah then the string hello world agentzh will be returned in case of error the iterator function will return nil along with a string describing the error and the partial data bytes that have been read so far the iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls the iterator function behaves differently i e like a real iterator when it is called with a size argument that is it will read that size of data on each invocation and will return nil at the last invocation either sees the boundary pattern or meets an error for the last successful invocation of the iterator function the err return value will be nil too the iterator function will be reset after the last successful invocation that returns nil data and nil error consider the following example lua local reader sock receiveuntil \r\n abcedhb while true do local data err partial reader 4 if not data then if err then ngx say failed to read the data stream err break end ngx say read done break end ngx say read chunk data end then for the incoming data stream hello world agentzh\r\n abcedhb blah blah we shall get the following output from the sample code above read chunk hell read chunk o w read chunk orld read chunk a read chunk gent read chunk zh read done note that the actual data returned might be a little longer than the size limit specified by the size argument when the boundary pattern has ambiguity for streaming parsing near the boundary of the data stream the data string actually returned could also be shorter than the size limit timeout for the iterator functions reading operation is controlled by the lua socket read timeout config directive and the settimeout method and the latter takes priority for example lua local readline sock receiveuntil \r\n sock settimeout 1000 one second timeout line err partial readline if not line then ngx say failed to read a line err return end ngx say successfully read a line line it is important here to call the settimeout method before calling the iterator function note that the receiveuntil call is irrelevant here as from the v0 5 1 release this method also takes an optional options table argument to control the behavior the following options are supported inclusive the inclusive takes a boolean value to control whether to include the pattern string in the returned data string default to false for example lua local reader tcpsock receiveuntil end inclusive true local data reader ngx say data then for the input data stream hello world end blah blah blah then the example above will output hello world end including the pattern string end itself since the v0 8 8 release this method no longer automatically closes the current connection when the read timeout error happens for other connection errors this method always automatically closes the connection this method was first introduced in the v0 5 0rc1 release back to toc tcpsock close syntax ok err tcpsock close context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua closes the current tcp or stream unix domain socket it returns the 1 in case of success and returns nil with a string describing the error otherwise note that there is no need to call this method on socket objects that have invoked the setkeepalive method because the socket object is already closed and the current connection is saved into the built in connection pool socket objects that have not invoked this method and associated connections will be closed when the socket object is released by the lua gc garbage collector or the current client http request finishes processing this feature was first introduced in the v0 5 0rc1 release back to toc tcpsock settimeout syntax tcpsock settimeout time context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua set the timeout value in milliseconds for subsequent socket operations connect receive and iterators returned from receiveuntil settings done by this method takes priority over those config directives i e lua socket connect timeout lua socket send timeout and lua socket read timeout note that this method does not affect the lua socket keepalive timeout setting the timeout argument to the setkeepalive method should be used for this purpose instead this feature was first introduced in the v0 5 0rc1 release back to toc tcpsock settimeouts syntax tcpsock settimeouts connect timeout send timeout read timeout context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua sets the connect timeout thresold send timeout threshold and read timeout threshold respetively in milliseconds for subsequent socket operations connect send receive and iterators returned from receiveuntil settings done by this method takes priority over those config directives i e lua socket connect timeout lua socket send timeout and lua socket read timeout you are recommended to use settimeouts instead of settimeout note that this method does not affect the lua socket keepalive timeout setting the timeout argument to the setkeepalive method should be used for this purpose instead this feature was first introduced in the v0 10 7 release back to toc tcpsock setoption syntax tcpsock setoption option value context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua this function is added for luasocket api compatibility and does nothing for now its functionality will be implemented in future this feature was first introduced in the v0 5 0rc1 release back to toc tcpsock setkeepalive syntax ok err tcpsock setkeepalive timeout size context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua puts the current sockets connection immediately into the cosocket built in connection pool and keep it alive until other connect method calls request it or the associated maximal idle timeout is expired the first optional argument timeout can be used to specify the maximal idle timeout in milliseconds for the current connection if omitted the default setting in the lua socket keepalive timeout config directive will be used if the 0 value is given then the timeout interval is unlimited the second optional argument size can be used to specify the maximal number of connections allowed in the connection pool for the current server i e the current host port pair or the unix domain socket file path note that the size of the connection pool cannot be changed once the pool is created when this argument is omitted the default setting in the lua socket pool size config directive will be used when the connection pool exceeds the available size limit the least recently used idle connection already in the pool will be closed to make room for the current connection note that the cosocket connection pool is per nginx worker process rather than per nginx server instance so the size limit specified here also applies to every single nginx worker process idle connections in the pool will be monitored for any exceptional events like connection abortion or unexpected incoming data on the line in which cases the connection in question will be closed and removed from the pool in case of success this method returns 1 otherwise it returns nil and a string describing the error when the system receive buffer for the current connection has unread data then this method will return the connection in dubious state error message as the second return value because the previous session has unread data left behind for the next session and the connection is not safe to be reused this method also makes the current cosocket object enter the closed state so there is no need to manually call the close method on it afterwards this feature was first introduced in the v0 5 0rc1 release back to toc tcpsock getreusedtimes syntax count err tcpsock getreusedtimes context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua this method returns the successfully reused times for the current connection in case of error it returns nil and a string describing the error if the current connection does not come from the built in connection pool then this method always returns 0 that is the connection has never been reused yet if the connection comes from the connection pool then the return value is always non zero so this method can also be used to determine if the current connection comes from the pool this feature was first introduced in the v0 5 0rc1 release back to toc ngx socket connect syntax tcpsock err ngx socket connect host port syntax tcpsock err ngx socket connect unix path to unix domain socket context rewrite by lua access by lua content by lua ngx timer this function is a shortcut for combining ngx socket tcp and the connect method call in a single operation it is actually implemented like this lua local sock ngx socket tcp local ok err sock connect if not ok then return nil err end return sock there is no way to use the settimeout method to specify connecting timeout for this method and the lua socket connect timeout directive must be set at configure time instead this feature was first introduced in the v0 5 0rc1 release back to toc ngx get phase syntax str ngx get phase context init by lua init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua retrieves the current running phase name possible return values are init for the context of init by lua init worker for the context of init worker by lua ssl cert for the context of ssl certificate by lua ssl session fetch for the context of ssl session fetch by lua ssl session store for the context of ssl session store by lua set for the context of set by lua rewrite for the context of rewrite by lua balancer for the context of balancer by lua access for the context of access by lua content for the context of content by lua header filter for the context of header filter by lua body filter for the context of body filter by lua log for the context of log by lua timer for the context of user callback functions for ngx timer this api was first introduced in the v0 5 10 release back to toc ngx thread spawn syntax co ngx thread spawn func arg1 arg2 context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua spawns a new user light thread with the lua function func as well as those optional arguments arg1 arg2 and etc returns a lua thread or lua coroutine object represents this light thread light threads are just a special kind of lua coroutines that are scheduled by the ngx lua module before ngx thread spawn returns the func will be called with those optional arguments until it returns aborts with an error or gets yielded due to i o operations via the nginx api for lua like tcpsock receive after ngx thread spawn returns the newly created light thread will keep running asynchronously usually at various i o events all the lua code chunks running by rewrite by lua access by lua and content by lua are in a boilerplate light thread created automatically by ngx lua such boilerplate light thread are also called entry threads by default the corresponding nginx handler e g rewrite by lua handler will not terminate until both the entry thread and all the user light threads terminates a light thread either the entry thread or a user light thread aborts by calling ngx exit ngx exec ngx redirect or ngx req set uri uri true or the entry thread terminates with a lua error when the user light thread terminates with a lua error however it will not abort other running light threads like the entry thread does due to the limitation in the nginx subrequest model it is not allowed to abort a running nginx subrequest in general so it is also prohibited to abort a running light thread that is pending on one ore more nginx subrequests you must call ngx thread wait to wait for those light thread to terminate before quitting the world a notable exception here is that you can abort pending subrequests by calling ngx exit with and only with the status code ngx error 1 408 444 or 499 the light threads are not scheduled in a pre emptive way in other words no time slicing is performed automatically a light thread will keep running exclusively on the cpu until a nonblocking i o operation cannot be completed in a single run it calls coroutine yield to actively give up execution or it is aborted by a lua error or an invocation of ngx exit ngx exec ngx redirect or ngx req set uri uri true for the first two cases the light thread will usually be resumed later by the ngx lua scheduler unless a stop the world event happens user light threads can create light threads themselves and normal user coroutines created by coroutine create can also create light threads the coroutine be it a normal lua coroutine or a light thread that directly spawns the light thread is called the parent coroutine for the light thread newly spawned the parent coroutine can call ngx thread wait to wait on the termination of its child light thread you can call coroutine status and coroutine yield on the light thread coroutines the status of the light thread coroutine can be zombie if the current light thread already terminates either successfully or with an error its parent coroutine is still alive and its parent coroutine is not waiting on it with ngx thread wait the following example demonstrates the use of coroutine yield in the light thread coroutines to do manual time slicing lua local yield coroutine yield function f local self coroutine running ngx say f 1 yield self ngx say f 2 yield self ngx say f 3 end local self coroutine running ngx say 0 yield self ngx say 1 ngx thread spawn f ngx say 2 yield self ngx say 3 yield self ngx say 4 then it will generate the output 0 1 f 1 2 f 2 3 f 3 4 light threads are mostly useful for making concurrent upstream requests in a single nginx request handler much like a generalized version of ngx location capture multi that can work with all the nginx api for lua the following example demonstrates parallel requests to mysql memcached and upstream http services in a single lua handler and outputting the results in the order that they actually return similar to facebooks bigpipe model lua query mysql memcached and a remote http service at the same time output the results in the order that they actually return the results local mysql require resty mysql local memcached require resty memcached local function query mysql local db mysql new db connect host 127 0 0 1 port 3306 database test user monty password mypass local res err errno sqlstate db query select from cats order by id asc db set keepalive 0 100 ngx say mysql done cjson encode res end local function query memcached local memc memcached new memc connect 127 0 0 1 11211 local res err memc get some key ngx say memcached done res end local function query http local res ngx location capture my http proxy ngx say http done res body end ngx thread spawn query mysql create thread 1 ngx thread spawn query memcached create thread 2 ngx thread spawn query http create thread 3 this api was first enabled in the v0 7 0 release back to toc ngx thread wait syntax ok res1 res2 ngx thread wait thread1 thread2 context rewrite by lua access by lua content by lua ngx timer ssl certificate by lua ssl session fetch by lua waits on one or more child light threads and returns the results of the first light thread that terminates either successfully or with an error the arguments thread1 thread2 and etc are the lua thread objects returned by earlier calls of ngx thread spawn the return values have exactly the same meaning as coroutine resume that is the first value returned is a boolean value indicating whether the light thread terminates successfully or not and subsequent values returned are the return values of the user lua function that was used to spawn the light thread in case of success or the error object in case of failure only the direct parent coroutine can wait on its child light thread otherwise a lua exception will be raised the following example demonstrates the use of ngx thread wait and ngx location capture to emulate ngx location capture multi lua local capture ngx location capture local spawn ngx thread spawn local wait ngx thread wait local say ngx say local function fetch uri return capture uri end local threads spawn fetch foo spawn fetch bar spawn fetch baz for i 1 threads do local ok res wait threads i if not ok then say i failed to run res else say i status res status say i body res body end end here it essentially implements the wait all model and below is an example demonstrating the wait any model lua function f ngx sleep 0 2 ngx say f hello return f done end function g ngx sleep 0 1 ngx say g hello return g done end local tf err ngx thread spawn f if not tf then ngx say failed to spawn thread f err return end ngx say f thread created coroutine status tf local tg err ngx thread spawn g if not tg then ngx say failed to spawn thread g err return end ngx say g thread created coroutine status tg ok res ngx thread wait tf tg if not ok then ngx say failed to wait res return end ngx say res res stop the world aborting other running threads ngx exit ngx ok and it will generate the following output f thread created running g thread created running g hello res g done this api was first enabled in the v0 7 0 release back to toc ngx thread kill syntax ok err ngx thread kill thread context rewrite by lua access by lua content by lua ngx timer kills a running light thread created by ngx thread spawn returns a true value when successful or nil and a string describing the error otherwise according to the current implementation only the parent coroutine or light thread can kill a thread also a running light thread with pending nginx subrequests initiated by ngx location capture for example cannot be killed due to a limitation in the nginx core this api was first enabled in the v0 9 9 release back to toc ngx on abort syntax ok err ngx on abort callback context rewrite by lua access by lua content by lua registers a user lua function as the callback which gets called automatically when the client closes the downstream connection prematurely returns 1 if the callback is registered successfully or returns nil and a string describing the error otherwise all the nginx api for lua can be used in the callback function because the function is run in a special light thread just as those light threads created by ngx thread spawn the callback function can decide what to do with the client abortion event all by itself for example it can simply ignore the event by doing nothing and the current lua request handler will continue executing without interruptions and the callback function can also decide to terminate everything by calling ngx exit for example lua local function my cleanup custom cleanup work goes here like cancelling a pending db transaction now abort all the light threads running in the current request handler ngx exit 499 end local ok err ngx on abort my cleanup if not ok then ngx log ngx err failed to register the on abort callback err ngx exit 500 end when lua check client abort is set to off which is the default then this function call will always return the error message lua check client abort is off according to the current implementation this function can only be called once in a single request handler subsequent calls will return the error message duplicate call this api was first introduced in the v0 7 4 release see also lua check client abort back to toc ngx timer at syntax hdl err ngx timer at delay callback user arg1 user arg2 context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua creates an nginx timer with a user callback function as well as optional user arguments the first argument delay specifies the delay for the timer in seconds one can specify fractional seconds like 0 001 to mean 1 millisecond here 0 delay can also be specified in which case the timer will immediately expire when the current handler yields execution the second argument callback can be any lua function which will be invoked later in a background light thread after the delay specified the user callback will be called automatically by the nginx core with the arguments premature user arg1 user arg2 and etc where the premature argument takes a boolean value indicating whether it is a premature timer expiration or not and user arg1 user arg2 and etc are those extra user arguments specified when calling ngx timer at as the remaining arguments premature timer expiration happens when the nginx worker process is trying to shut down as in an nginx configuration reload triggered by the hup signal or in an nginx server shutdown when the nginx worker is trying to shut down one can no longer call ngx timer at to create new timers with nonzero delays and in that case ngx timer at will return a conditional false value and a string describing the error that is process exiting starting from the v0 9 3 release it is allowed to create zero delay timers even when the nginx worker process starts shutting down when a timer expires the user lua code in the timer callback is running in a light thread detached completely from the original request creating the timer so objects with the same lifetime as the request creating them like cosockets cannot be shared between the original request and the timer user callback function here is a simple example nginx location log by lua block local function push data premature uri args status push the data uri args and status to the remote via ngx socket tcp or ngx socket udp one may want to buffer the data in lua a bit to save i o operations end local ok err ngx timer at 0 push data ngx var uri ngx var args ngx header status if not ok then ngx log ngx err failed to create timer err return end one can also create infinite re occurring timers for instance a timer getting triggered every 5 seconds by calling ngx timer at recursively in the timer callback function here is such an example lua local delay 5 local handler handler function premature do some routine job in lua just like a cron job if premature then return end local ok err ngx timer at delay handler if not ok then ngx log ngx err failed to create the timer err return end end local ok err ngx timer at delay handler if not ok then ngx log ngx err failed to create the timer err return end it is recommended however to use the ngx timer every api function instead for creating recurring timers since it is more robust because timer callbacks run in the background and their running time will not add to any client requests response time they can easily accumulate in the server and exhaust system resources due to either lua programming mistakes or just too much client traffic to prevent extreme consequences like crashing the nginx server there are built in limitations on both the number of pending timers and the number of running timers in an nginx worker process the pending timers here mean timers that have not yet been expired and running timers are those whose user callbacks are currently running the maximal number of pending timers allowed in an nginx worker is controlled by the lua max pending timers directive the maximal number of running timers is controlled by the lua max running timers directive according to the current implementation each running timer will take one fake connection record from the global connection record list configured by the standard worker connections directive in nginx conf so ensure that the worker connections directive is set to a large enough value that takes into account both the real connections and fake connections required by timer callbacks as limited by the lua max running timers directive a lot of the lua apis for nginx are enabled in the context of the timer callbacks like stream datagram cosockets ngx socket tcp and ngx socket udp shared memory dictionaries ngx shared dict user coroutines coroutine user light threads ngx thread ngx exit ngx now ngx time ngx md5 ngx sha1 bin are all allowed but the subrequest api like ngx location capture the ngx req api the downstream output api like ngx say ngx print and ngx flush are explicitly disabled in this context you can pass most of the standard lua values nils booleans numbers strings tables closures file handles and etc into the timer callback either explicitly as user arguments or implicitly as upvalues for the callback closure there are several exceptions however you cannot pass any thread objects returned by coroutine create and ngx thread spawn or any cosocket objects returned by ngx socket tcp ngx socket udp and ngx req socket because these objects lifetime is bound to the request context creating them while the timer callback is detached from the creating requests context by design and runs in its own fake request context if you try to share the thread or cosocket objects across the boundary of the creating request then you will get the no co ctx found error for threads or bad request for cosockets it is fine however to create all these objects inside your timer callback this api was first introduced in the v0 8 0 release back to toc ngx timer every syntax hdl err ngx timer every delay callback user arg1 user arg2 context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua similar to the ngx timer at api function but delay cannot be zero timer will be created every delay seconds until the current nginx worker process starts exiting when success returns a conditional true value but not a true otherwise returns a conditional false value and a string describing the error this api also respect the lua max pending timers and lua max running timers this api was first introduced in the v0 10 9 release back to toc ngx timer running count syntax count ngx timer running count context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns the number of timers currently running this directive was first introduced in the v0 9 20 release back to toc ngx timer pending count syntax count ngx timer pending count context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua returns the number of pending timers this directive was first introduced in the v0 9 20 release back to toc ngx config subsystem syntax subsystem ngx config subsystem context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer init by lua init worker by lua this string field indicates the current nginx subsystem the current lua environment is based on for this module this field always takes the string value http for ngx stream lua module however this field takes the value stream this field was first introduced in the 0 10 1 back to toc ngx config debug syntax debug ngx config debug context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer init by lua init worker by lua this boolean field indicates whether the current nginx is a debug build i e being built by the configure option with debug this field was first introduced in the 0 8 7 back to toc ngx config prefix syntax prefix ngx config prefix context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer init by lua init worker by lua returns the nginx server prefix path as determined by the p command line option when running the nginx executable or the path specified by the prefix command line option when building nginx with the configure script this function was first introduced in the 0 9 2 back to toc ngx config nginx version syntax ver ngx config nginx version context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer init by lua init worker by lua this field take an integral value indicating the version number of the current nginx core being used for example the version number 1 4 3 results in the lua number 1004003 this api was first introduced in the 0 9 3 release back to toc ngx config nginx configure syntax str ngx config nginx configure context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer init by lua this function returns a string for the nginx configure commands arguments string this api was first introduced in the 0 9 5 release back to toc ngx config ngx lua version syntax ver ngx config ngx lua version context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer init by lua this field take an integral value indicating the version number of the current ngx lua module being used for example the version number 0 9 3 results in the lua number 9003 this api was first introduced in the 0 9 3 release back to toc ngx worker exiting syntax exiting ngx worker exiting context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer init by lua init worker by lua this function returns a boolean value indicating whether the current nginx worker process already starts exiting nginx worker process exiting happens on nginx server quit or configuration reload aka hup reload this api was first introduced in the 0 9 3 release back to toc ngx worker pid syntax pid ngx worker pid context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer init by lua init worker by lua this function returns a lua number for the process id pid of the current nginx worker process this api is more efficient than ngx var pid and can be used in contexts where the ngx var variable api cannot be used like init worker by lua this api was first introduced in the 0 9 5 release back to toc ngx worker count syntax count ngx worker count context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer init by lua init worker by lua returns the total number of the nginx worker processes i e the value configured by the worker processes directive in nginx conf this api was first introduced in the 0 9 20 release back to toc ngx worker id syntax count ngx worker id context set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer init worker by lua returns the ordinal number of the current nginx worker processes starting from number 0 so if the total number of workers is n then this method may return a number between 0 and n 1 inclusive this function returns meaningful values only for nginx 1 9 1 with earlier versions of nginx it always returns nil see also ngx worker count this api was first introduced in the 0 9 20 release back to toc ngx semaphore syntax local semaphore require ngx semaphore this is a lua module that implements a classic style semaphore api for efficient synchronizations among different light threads sharing the same semaphore among different light threads created in different request contexts are also supported as long as the light threads reside in the same nginx worker process and the lua code cache directive is turned on which is the default this lua module does not ship with this ngx lua module itself rather it is shipped with the lua resty core library please refer to the documentation for this ngx semaphore lua module in lua resty core for more details this feature requires at least ngx lua v0 10 0 back to toc ngx balancer syntax local balancer require ngx balancer this is a lua module that provides a lua api to allow defining completely dynamic load balancers in pure lua this lua module does not ship with this ngx lua module itself rather it is shipped with the lua resty core library please refer to the documentation for this ngx balancer lua module in lua resty core for more details this feature requires at least ngx lua v0 10 0 back to toc ngx ssl syntax local ssl require ngx ssl this lua module provides api functions to control the ssl handshake process in contexts like ssl certificate by lua this lua module does not ship with this ngx lua module itself rather it is shipped with the lua resty core library please refer to the documentation for this ngx ssl lua module for more details this feature requires at least ngx lua v0 10 0 back to toc ngx ocsp syntax local ocsp require ngx ocsp this lua module provides api to perform ocsp queries ocsp response validations and ocsp stapling planting usually this module is used together with the ngx ssl module in the context of ssl certificate by lua this lua module does not ship with this ngx lua module itself rather it is shipped with the lua resty core library please refer to the documentation for this ngx ocsp lua module for more details this feature requires at least ngx lua v0 10 0 back to toc ndk set var directive syntax res ndk set var directive name context init worker by lua set by lua rewrite by lua access by lua content by lua header filter by lua body filter by lua log by lua ngx timer balancer by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua this mechanism allows calling other nginx c modules directives that are implemented by nginx devel kit ndk s set var submodules ndk set var value for example the following set misc nginx module directives can be invoked this way set quote sql str set quote pgsql str set quote json str set unescape uri set escape uri set encode base32 set decode base32 set encode base64 set decode base64 set encode hex set decode hex set sha1 set md5 for instance lua local res ndk set var set escape uri a b now res a 2fb similarly the following directives provided by encrypted session nginx module can be invoked from within lua too set encrypt session set decrypt session this feature requires the ngx devel kit module back to toc coroutine create syntax co coroutine create f context rewrite by lua access by lua content by lua init by lua ngx timer header filter by lua body filter by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua creates a user lua coroutines with a lua function and returns a coroutine object similar to the standard lua coroutine create api but works in the context of the lua coroutines created by ngx lua this api was first usable in the context of init by lua since the 0 9 2 this api was first introduced in the v0 6 0 release back to toc coroutine resume syntax ok coroutine resume co context rewrite by lua access by lua content by lua init by lua ngx timer header filter by lua body filter by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua resumes the executation of a user lua coroutine object previously yielded or just created similar to the standard lua coroutine resume api but works in the context of the lua coroutines created by ngx lua this api was first usable in the context of init by lua since the 0 9 2 this api was first introduced in the v0 6 0 release back to toc coroutine yield syntax coroutine yield context rewrite by lua access by lua content by lua init by lua ngx timer header filter by lua body filter by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua yields the execution of the current user lua coroutine similar to the standard lua coroutine yield api but works in the context of the lua coroutines created by ngx lua this api was first usable in the context of init by lua since the 0 9 2 this api was first introduced in the v0 6 0 release back to toc coroutine wrap syntax co coroutine wrap f context rewrite by lua access by lua content by lua init by lua ngx timer header filter by lua body filter by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua similar to the standard lua coroutine wrap api but works in the context of the lua coroutines created by ngx lua this api was first usable in the context of init by lua since the 0 9 2 this api was first introduced in the v0 6 0 release back to toc coroutine running syntax co coroutine running context rewrite by lua access by lua content by lua init by lua ngx timer header filter by lua body filter by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua identical to the standard lua coroutine running api this api was first usable in the context of init by lua since the 0 9 2 this api was first enabled in the v0 6 0 release back to toc coroutine status syntax status coroutine status co context rewrite by lua access by lua content by lua init by lua ngx timer header filter by lua body filter by lua ssl certificate by lua ssl session fetch by lua ssl session store by lua identical to the standard lua coroutine status api this api was first usable in the context of init by lua since the 0 9 2 this api was first enabled in the v0 6 0 release back to toc obsolete sections this section is just holding obsolete documentation sections that have been either renamed or removed so that existing links over the web are still valid back to toc special pcre sequences this section has been renamed to special escaping sequences