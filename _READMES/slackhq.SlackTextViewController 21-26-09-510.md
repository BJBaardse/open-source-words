slacktextviewcontroller important notice please update to 1 9 to avoid any risk of app rejection more details in 361 a drop in uiviewcontroller subclass with a growing text input view and other useful messaging features meant to be a replacement for uitableviewcontroller uicollectionviewcontroller this library is used in slacks ios app it was built to fit our needs but is flexible enough to be reused by others wanting to build great messaging apps for ios feature list core works out of the box with uitableview or uicollectionview or uiscrollview growing text view with line count limit support flexible ui built with auto layout customizable provides left and right button and toolbar outlets tap gesture for dismissing the keyboard external keyboard commands support undo redo with keyboard commands and uimenucontroller text appending apis additional autocomplete mode by registering any prefix key edit mode markdown formatting typing indicator display shake gesture for clearing text view multimedia pasting png gif mov etc inverted mode for displaying cells upside down using catransform a necessary hack for some messaging apps yes true by default so beware your entire cells might be flipped tap gesture for dismissing the keyboard panning gesture for sliding down up the keyboard hideable textinputbar dynamic type for adjusting automatically the text input bar height based on the font size bouncy animations compatibility carthage cocoapods objective c swift ios 7 8 9 iphone ipad storyboard uipopovercontroller uitabbarcontroller container view controller auto rotation ipad multitasking ios 9 only localization installation with cocoapods ruby pod slacktextviewcontroller with carthage swift github slackhq slacktextviewcontroller manually there are two ways to do this copy and drag the source folder to your project or compile the project located in builder slacktextviewcontroller xcodeproj to create a slacktextviewcontroller framework package you could also link the library into your project how to use subclassing slktextviewcontroller is meant to be subclassed like you would normally do with uitableviewcontroller or uicollectionviewcontroller or uiscrollview this pattern is a convenient way of extending uiviewcontroller slacktextviewcontroller manages a lot behind the scenes while still providing the ability to add custom behaviours you may override methods and decide to call super and perform additional logic or not to call super and override default logic start by creating a new subclass of slktextviewcontroller in the init overriding method if you wish to use the uitableview version call obj c objc super initwithtableviewstyle uitableviewstyleplain swift swift super init tableviewstyle plain or the uicollectionview version obj c objc super initwithcollectionviewlayout uicollectionviewflowlayout new swift swift super init collectionviewlayout uicollectionviewflowlayout or the uiscrollview version obj c objc super initwithscrollview self mystrongscrollview swift swift super init scrollview self mystrongscrollview protocols like uitableviewdelegate and uitableviewdatasource are already setup for you you will be able to call whatever delegate and data source methods you need for customising your control calling super init will call super initwithtableviewstyle uitableviewstyleplain by default storyboard when using slacktextviewcontroller with storyboards instead of overriding the traditional initwithcoder you will need to override any of the two custom methods below this approach helps preserving the exact same features from the programatic approach but also limits the edition of the nib of your slktextviewcontroller subclass since it doesnt layout subviews from the nib subviews are still initialized and layed out programatically if you wish to use the uitableview version call obj c objc uitableviewstyle tableviewstyleforcoder nscoder decoder return uitableviewstyleplain swift swift override class func tableviewstyleforcoder decoder nscoder uitableviewstyle return plain or the uicollectionview version obj c objc uicollectionviewlayout collectionviewlayoutforcoder nscoder decoder return uicollectionviewflowlayout new swift swift override class func collectionviewlayoutforcoder decoder nscoder uicollectionviewlayout return uicollectionviewflowlayout sample project check out the sample project everything is demod there there are 2 main examples different targets for testing the programatic and storyboard approaches and a swift example most of the features are implemented for you to quickly start using them feel free to contribute features growing text view the text view expands automatically when a new line is required until it reaches its maxnumberoflinesvalue you may change this propertys value in the textview by default the number of lines is set to best fit each device dimensions iphone 4 480pts 4 lines iphone 5 6 568pts 6 lines ipad 768pts 8 lines on iphone devices in landscape orientation the maximum number of lines is changed to fit the available space inverted mode some layouts may require to show from bottom to top and new subviews are inserted from the bottom to enable this you must use the inverted flag property default is yes true this will actually invert the entire scrollview object make sure to apply the same transformation to every subview in the case of uitableview the best place for adjusting the transformation is in its data source methods like obj c objc uitableviewcell tableview uitableview tableview cellforrowatindexpath nsindexpath indexpath uitableviewcell cell self tableview dequeuereusablecellwithidentifier kcellidentifier cell transform self tableview transform swift swift override func tableview tableview uitableview cellforrowatindexpath indexpath nsindexpath uitableviewcell if let cell tableview dequeuereusablecellwithidentifier kcellidentifier cell transform self tableview transform autocompletion we use autocompletion for many things names channels emoji and more to set up autocompletion in your app follow these simple steps 1 registration you must first register all the prefixes youd like to support for autocompletion detection obj c objc self registerprefixesforautocompletion swift swift self registerprefixesforautocompletion 2 processing every time a new character is inserted in the text view the nearest word to the caret will be processed and verified if it contains any of the registered prefixes once the prefix has been detected didchangeautocompletionprefix andword will be called this is the perfect place to populate your data source and show hide the autocompletion view so you must override it in your subclass to be able to perform additional tasks default returns no obj c objc void didchangeautocompletionprefix nsstring prefix andword nsstring word nsarray array nsarray arraywitharray self channels if prefix isequaltostring word length 0 self searchresult array filteredarrayusingpredicate nspredicate predicatewithformat self beginswith c word bool show self searchresult count 0 self showautocompletionview show swift swift override func didchangeautocompletionprefix prefix string andword word string let array nsarray self channels if prefix word characters count 0 self searchresult array filteredarrayusingpredicate nspredicate format self beginswith c word let show self searchresult count 0 self showautocompletionview show the autocompletion view is a uitableview instance so you will need to use uitableviewdatasource to populate its cells you have complete freedom for customizing the cells you dont need to call reloaddata yourself since it will be invoked automatically right after calling the showautocompletionview method 3 layout the maximum height of the autocompletion view is set to 140 pts by default you can update this value anytime so the view automatically adjusts based on the amount of displayed cells obj c objc cgfloat heightforautocompletionview cgfloat cellheight 34 0 return cellheight self searchresult count swift swift override func heightforautocompletionview cgfloat let cellheight cgfloat 34 return cellheight cgfloat self searchresult count 4 confirmation if the user selects any autocompletion view cell on tableview didselectrowatindexpath you must call acceptautocompletionwithstring to commit autocompletion that method expects a string matching the selected item that you would like to be inserted in the text view obj c objc void tableview uitableview tableview didselectrowatindexpath nsindexpath indexpath if tableview isequal self autocompletionview nsmutablestring item self searchresult indexpath row mutablecopy item appendstring adding a space helps dismissing the auto completion view self acceptautocompletionwithstring item keepprefix yes swift swift override func tableview tableview uitableview didselectrowatindexpath indexpath nsindexpath if tableview isequal self autocompletionview var item self searchresult indexpath row item adding a space helps dismissing the auto completion view self acceptautocompletionwithstring item the autocompletion view will automatically be dismissed and the chosen string will be inserted in the text view replacing the detected prefix and word you can always call cancelautocompletion to exit the autocompletion mode and refresh the ui edit mode to enable edit mode you simply need to call edittext and the text input will switch to edit mode removing both left and right buttons extending the input bar a bit higher with accept and cancel buttons both of this buttons are accessible in the slktextinputbar instance for customisation to capture the accept or cancel events you must override the following methods obj c objc void didcommittextediting id sender nsstring message self textview text copy self messages removeobjectatindex 0 self messages insertobject message atindex 0 self tableview reloaddata super didcommittextediting sender void didcanceltextediting id sender super didcanceltextediting sender swift swift override func didcommittextediting sender anyobject let message string self textview text self messages removeatindex 0 self messages insert message atindex 0 self tableview reloaddata super didcommittextediting sender override func didcanceltextediting sender anyobject super didcanceltextediting sender notice that you must call super at some point so the text input exits the edit mode re adjusting the layout and clearing the text view use the editing property to know if the editing mode is on markdown formatting you can register markdown formatting symbols so they can easily be used to wrap a text selection with the help of the native contextual menu aka uimenucontroller this feature doesnt take care of the rendering of the markdown its sole purpose is to ease the formatting tools to the user optionally you can enable autocompleteformatting so any pending markdown closure symbol can be added automatically after double tapping on the keyboard spacebar just like the native gesture to add a sentence period the sentence period is still being added as a fallback 1 registration you must first register the formatting symbol and assign a title string to be used in the menu controller item obj c objc self textview registermarkdownformattingsymbol withtitle bold swift swift self textview registermarkdownformattingsymbol withtitle bold 2 customisation futher more you can customise some of the behavior for special formatting cases using the uitextviewdelegate methods in the following example we dont present the quote formatting in the contextual menu when the text selection isnt a paragraph obj c objc bool textview slktextview textview shouldofferformattingforsymbol nsstring symbol if symbol isequaltostring nsrange selection textview selectedrange the quote formatting only applies new paragraphs if selection location 0 selection length 0 return yes or older paragraphs too nsstring prevstring textview text substringwithrange nsmakerange selection location 1 1 if nscharacterset newlinecharacterset characterismember prevstring characteratindex 0 return yes return no return super textview textview shouldofferformattingforsymbol symbol in this other method implementation we dont want to allow auto completion for the quote formatting since it doesnt require a closure obj c objc bool textview slktextview textview shouldinsertsuffixforformattingwithsymbol nsstring symbol prefixrange nsrange prefixrange if symbol isequaltostring return no return super textview textview shouldinsertsuffixforformattingwithsymbol symbol prefixrange prefixrange typing indicator optionally you can enable a simple typing indicator which will be displayed right above the text input it shows the name of the people that are typing and if more than 2 it will display several are typing message to enable the typing indicator just call obj c objc self typingindicatorview insertusername john swift swift self typingindicatorview insertusername john and the view will automatically be animated on top of the text input after a default interval of 6 seconds if the same name hasnt been assigned once more the view will be dismissed with animation you can remove names from the list by calling obj c objc self typingindicatorview removeusername john swift swift self typingindicatorview removeusername john you can also dismiss it by calling obj c objc self typingindicatorview dismissindicator swift swift self typingindicatorview dismissindicator panning gesture dismissing the keyboard with a panning gesture is enabled by default with the keyboardpanningenabled property you can always disable it if youd like you can extend the verticalpangesture behaviors with the uigesturerecognizerdelegate methods hideable textinputbar sometimes you may need to hide the text input bar very similar to uinavigationviewcontrollers api simply do obj c objc self settextinputbarhidden yes animated yes swift swift self settextinputbarhidden true animated true shake gesture a shake gesture to clear text is enabled by default with the undoshakingenabled property you can optionally override willrequestundo to implement your ui to ask the users if he would like to clean the text views text if there is not text entered the method will not be called if you dont override willrequestundo and undoshakingenabled is set to yes true a system alert will be shown external keyboard there a few basic key commands enabled by default cmd z undo shift cmd z redo return key calls didpressrightbutton or didcommittextediting if in edit mode shift cmd return key line break escape key exits edit mode or auto completion mode or dismisses the keyboard up down arrows vertical cursor movement to add additional key commands simply override keycommands and append supers array obj c objc nsarray keycommands nsmutablearray commands nsmutablearray arraywitharray super keycommands edit last message commands addobject uikeycommand keycommandwithinput uikeyinputuparrow modifierflags 0 action selector editlastmessage return commands swift swift override var keycommands uikeycommand var commands super keycommands edit last message let command uikeycommand input uikeyinputuparrow modifierflags command action editlastmessage commands append command return commands there are also a set of useful flags for keyboard special detections such as isexternalkeyboarddetected iskeyboardundocked typingsuggestionenabled and istrackpadenabled ios 9 only dynamic type dynamic type is enabled by default with the dynamictypeenabled property you can always disable it if youd like but the text input bar would still adjust to best fit the font size of the text view xcode templates we have prepared a set of useful xcode templates so you can quickly start using slacktextviewcontroller to install them open up your terminal and type bash sh slacktextviewcontroller file\ templates install sh these templates are also available in alcatraz