what is xnu xnu kernel is part of the darwin operating system for use in os x and ios operating systems xnu is an acronym for xnu is not unix xnu is a hybrid kernel combining the mach kernel developed at carnegie mellon university with components from freebsd and c api for writing drivers called iokit xnu runs on i386 x86 64 for both single processor and multi processor configurations xnu source tree config configurations for exported apis for supported architecture and platform setup basic set of tools used for configuring the kernel versioning and kextsymbol management external headers headers sourced from other projects to avoid dependency cycles when building these headers should be regularly synced when source is updated libkern c iokit library code for handling of drivers and kexts libsa kernel bootstrap code for startup libsyscall syscall library interface for userspace programs libkdd source for user library for parsing kernel data like kernel chunked data makedefs top level rules and defines for kernel build osfmk mach kernel based subsystems pexpert platform specific code like interrupt handling atomics etc security mandatory access check policy interfaces and related implementation bsd bsd subsystems code tools a set of utilities for testing debugging and profiling kernel how to build xnu building development kernel the xnu make system can build kernel based on kernel configs arch configs variables as arguments here is the syntax make sdkroot sdkroot arch configs arch kernel configs variant where \ path to macos sdk on disk defaults to \ can be debug development release profile and configures compilation flags and asserts throughout kernel code \ can be valid arch to build for e g i386 or x86 64 to build a kernel for the same architecture as running os just type make make sdkroot macosx internal additionally there is support for configuring architectures through arch configs and kernel configurations with kernel configs make sdkroot macosx internal arch configs x86 64 kernel configs development make sdkroot macosx internal arch configs x86 64 kernel configs release development debug note by default architecture is set to the build machine architecture and the default kernel config is set to build for development this will also create a bootable image kernel config and a kernel binary with symbols kernel config unstripped to build with release kernel configurationmake kernel configs release sdkroot path to sdk building fat kernel binary define architectures in your environment or when running a make command make arch configs i386 x86 64 exporthdrs all other makefile options make makejobs j8 this will use 8 processes during the build the default is 2x the number of active cpus make j8 the standard command line option is also accepted make w trace recursive make invocations useful in combination with verbose yes make build lto 0 build without llvm link time optimization make remotebuild user remotehost perform build on remote host make build json compilation database 1 build clang json compilation database the xnu build system can optionally output color formatted build output to enable this you can either set the xnu logcolors environment variable to y or you can pass logcolors y to the make command debug information formats by default a dwarf debug information repository is created during the install phase this is a bundle named kernel development \ dsym to select the older stabs debug information format where debug information is embedded in the kernel development unstripped image set the build stabs environment variable export build stabs 1 make building kernelcaches to test the xnu kernel you need to build a kernelcache that links the kexts and kernel together into a single bootable image to build a kernelcache you can use the following mechanisms using automatic kernelcache generation with kextd the kextd daemon keeps watching for changing in system library extensions directory so you can setup new kernel as cp build obj development x86 64 kernel development system library kernels touch system library extensions ps e grep kextd manually invoking kextcache to build new kernelcache kextcache q z a x86 64 l n c var tmp kernelcache test k var tmp kernel test system library extensions running kernelcache on target machine the development kernel and iboot supports configuring boot arguments so that we can safely boot into test kernel and if things go wrong safely fall back to previously used kernelcache following are the steps to get such a setup create kernel cache using the kextcache command as kernelcache test copy exiting boot configurations to alternate file cp library preferences systemconfiguration com apple boot plist next boot plist update the kernelcache and boot args for your setup plutil insert kernel cache string kernelcache test next boot plist plutil replace kernel flags string debug 0x144 v kernelsuffix test next boot plist copy the new config to library preferences systemconfiguration cp next boot plist library preferences systemconfiguration boot plist bless the volume with new configs sudo n bless mount setboot nextonly options config boot the nextonly flag specifies that use the boot plist configs only for one boot so if the kernel panics you can easily power reboot and recover back to original kernel creating tags and cscope set up your build environment and from the top directory run make tags this will build ctags and etags on a case sensitive volume only ctags on case insensitive make tags this will build etags make cscope this will build cscope database coding styles reindenting files source files can be reindented using clang format setup in clang format xnu follows a variant of webkit style for source code formatting please refer to format styles at webkit website further options about style options is available at clang docs note clang format binary may not be part of base installation it can be compiled from llvm clang sources and is reachable in path from the top directory run make reindent reindent all source files using clang format how to install a new header file from xnu to install iokit headers see additional comments in iokit iokit makefile xnu installs header files at the following locations a dstroot system library frameworks kernel framework headers b dstroot system library frameworks kernel framework privateheaders c dstroot usr include d dstroot system library frameworks system framework privateheaders kernel framework is used by kernel extensions \ the system framework and usr include are used by user level applications \ the header files in frameworks privateheaders are only available for apple internal development the directory containing the header file should have a makefile that creates the list of files that should be installed at different locations if you are adding first header file in a directory you will need to create makefile similar to xnu bsd sys makefile add your header file to the correct file list depending on where you want to install it the default locations where the header files are installed from each file list are a datafiles to make header file available in user level dstroot usr include b private datafiles to make header file available to apple internal in user level dstroot system library frameworks system framework privateheaders c kernelfiles to make header file available in kernel level dstroot system library frameworks kernel framework headers dstroot system library frameworks kernel framework privateheaders d private kernelfiles to make header file available to apple internal for kernel extensions dstroot system library frameworks kernel framework privateheaders the makefile combines the file lists mentioned above into different install lists which are used by build system to install the header files if the install list that you are interested does not exist create it by adding the appropriate file lists the default install lists its member file lists and their default location are described below a install mi list installs header file to a location that is available to everyone in user level locations dstroot usr include definition install mi list datafiles b install mi lcl list installs header file to a location that is available for apple internal in user level locations dstroot system library frameworks system framework privateheaders definition install mi lcl list private datafiles c install kf mi list installs header file to location that is available to everyone for kernel extensions locations dstroot system library frameworks kernel framework headers definition install kf mi list kernelfiles d install kf mi lcl list installs header file to location that is available for apple internal for kernel extensions locations dstroot system library frameworks kernel framework privateheaders definition install kf mi lcl list kernelfiles private kernelfiles e export mi list exports header file to all of xnu bsd osfmk etc for compilation only does not install anything into the sdk definition export mi list kernelfiles private kernelfiles if you want to install the header file in a sub directory of the paths described in 1 specify the directory name using two variables install mi dir and export mi dir as follows install mi dir dirname export mi dir dirname a single header file can exist at different locations using the steps mentioned above however it might not be desirable to make all the code in the header file available at all the locations for example you want to export a function only to kernel level but not user level you can use c languages pre processor directive ifdef endif ifndef to control the text generated before a header file is installed the kernel only includes the code if the conditional macro is true and strips out code for false conditions from the header file some pre defined macros and their descriptions are a private if true code is available to all of the xnu kernel and is not available in kernel extensions and user level header files the header files installed in all the paths described above in 1 will not have code enclosed within this macro b kernel private if true code is available to all of the xnu kernel and apple internal kernel extensions c bsd kernel private if true code is available to the xnu bsd part of the kernel and is not available to rest of the kernel kernel extensions and user level header files the header files installed in all the paths described above in 1 will not have code enclosed within this macro d kernel if true code is available only in kernel and kernel extensions and is not available in user level header files only the header files installed in following paths will have the code dstroot system library frameworks kernel framework headers dstroot system library frameworks kernel framework privateheaders you should check testing the kernel for details how to add a new syscall testing the kernel xnu kernel has multiple mechanisms for testing assertions the development and debug kernel configs are compiled with assertions enabled this allows developers to easily test invariants and conditions xnu power on self tests xnupost the xnupost config allows for building the kernel with basic set of test functions that are run before first user space process is launched since xnu is hybrid between mach and bsd we have two locations where tests can be added xnu osfmk tests for testing mach based kernel structures and apis bsd tests for testing bsd interfaces please follow the documentation at osfmk tests readme md user level tests the tools tests directory holds all the tests that verify syscalls and other features of the xnu kernel the make target xnu tests can be used to build all the tests supported make rc projectname xnu tests sdkroot path to sdk these tests are individual programs that can be run from terminal and report tests status by means of std posix exit codes 0 success and or stdout please read detailed documentation in tools tests unit tests readme md kernel data descriptors xnu uses different data formats for passing data in its api the most standard way is using syscall arguments but for complex data it often relies of sending memory saved by c structs this packaged data transport mechanism is fragile and leads to broken interfaces between user space programs and kernel apis libkdd directory holds user space library that can parse custom data provided by the same version of kernel the kernel chunked data format is described in detail at libkdd readme md debugging the kernel the xnu kernel supports debugging with a remote kernel debugging protocol kdp please refer documentation at technical note by default the kernel is setup to reboot on a panic to debug a live kernel the kdp server is setup to listen for udp connections over ethernet for machines without ethernet port this behavior can be altered with use of kernel boot args following are some common options debug 0x144 setups debug variables to start kdp debugserver on panic v print kernel logs on screen by default xnu only shows grey screen with boot art kdp match name en1 override default port selection for kdp supported for ethernet thunderbolt and serial debugging to debug a paniced kernel use llvm debugger lldb along with unstripped symbol rich kernel binary sh lldb kernel development unstripped and then you can connect to paniced machine with kdp remote ip addr or gdb remote hostip port commands each kernel is packaged with kernel specific debug scripts as part of the build process for security reasons these special commands and scripts do not get loaded automatically when lldb is connected to machine please add the following setting to your lldbinit if you wish to always load these macros settings set target load script from symbol file true the tools lldbmacros directory contains the source for each of these commands please follow the readme md for detailed explanation of commands and their usage