the ultimate api for ios os x auto layout â€” impressively simple immensely powerful purelayout extends uiview nsview nsarray and nslayoutconstraint with a comprehensive auto layout api that is modeled after apples own frameworks purelayout is a cross platform objective c library that works and looks great in swift it is fully backwards compatible with all versions of ios and os x that support auto layout writing auto layout code from scratch isnt easy purelayout provides a fully capable and developer friendly interface for auto layout it is designed for clarity and simplicity and takes inspiration from the autolayout ui options available in interface builder while delivering far more flexibility the api is also highly efficient as it adds only a thin layer of third party code and is engineered for maximum performance table of contents setup api cheat sheet usage sample code example apps purelayout vs the rest problems suggestions pull requests setup compatibility the current release of purelayout supports all versions of ios and os x since the introduction of auto layout on each platform in both swift and objective c with a single codebase xcode language support swift any version objective c fully compatible with xcode 7 0 minimum supported version xcode 5 0 ios fully compatible with ios 9 0 minimum deployment target ios 6 0 os x fully compatible with os x 10 11 minimum deployment target os x 10 7 using cocoapods add the pod purelayout to your podfile ruby pod purelayout run pod install from terminal then open your apps xcworkspace file to launch xcode import the purelayout h umbrella header with use frameworks in your podfile swift import purelayout objective c import purelayout purelayout h or with modules enabled import purelayout without use frameworks in your podfile swift add import purelayout h to your bridging header objective c import purelayout h thats it now go write some beautiful auto layout code using carthage add the purelayout purelayout project to your cartfile ogdl github purelayout purelayout run carthage update then follow the additional steps required to add the framework into your project import the purelayout framework module swift import purelayout objective c import purelayout purelayout h or with modules enabled import purelayout thats it now go write some beautiful auto layout code manually from github download the source files in the purelayout subdirectory add the source files to your xcode project import the purelayout h header swift add import purelayout h to your bridging header objective c import purelayout h thats it now go write some beautiful auto layout code app extensions to use purelayout in an app extension you need to do a bit of extra configuration to prevent usage of unavailable apis click here for more info releases releases are tagged in the git commit history using semantic versioning check out the releases and release notes for each version api cheat sheet this is just a handy overview of the core api methods explore the header files for the full api and find the complete documentation above the implementation of each method in the corresponding m file a couple of notes all of the public api methods are namespaced with the prefix auto which also makes it easy for xcode to autocomplete as you type methods that create constraints also automatically install activate the constraint s then return the new constraint s for you to optionally store for later adjustment or removal many methods below also have a variant which includes a relation parameter to make the constraint an inequality attributes purelayout defines view attributes that are used to create auto layout constraints here is an illustration of the most common attributes there are 5 specific attribute types which are used throughout most of the api aledge aldimension alaxis almargin available in ios 8 0 and higher only almarginaxis available in ios 8 0 and higher only additionally there is one generic attribute type alattribute which is effectively a union of all the specific types you can think of this as the supertype of all of the specific attribute types which means that it is always safe to cast a specific type to the generic alattribute type note that the reverse is not true casting a generic alattribute to a specific attribute type is unsafe uiview nsview autosetcontent compressionresistance hugging priorityforaxis autocenterinsuperview margins margins variant ios 8 0 only autoalignaxistosuperview margin axis margin variant ios 8 0 only autopinedgetosuperview edge margin withinset margin variant ios 8 0 only autopinedgestosuperview edges margins withinsets excludingedge margins variant ios 8 0 only autopinedge toedge ofview withoffset autoalignaxis tosameaxisofview withoffset withmultiplier automatchdimension todimension ofview withoffset withmultiplier autosetdimension s tosize autoconstrainattribute toattribute ofview withoffset withmultiplier autopinto top bottom layoutguideofviewcontroller withinset ios only nsarray arrays of constraints autoinstallconstraints autoremoveconstraints autoidentifyconstraints ios 7 0 os x 10 9 only arrays of views autoalignviewstoedge autoalignviewstoaxis automatchviewsdimension autosetviewsdimension tosize autosetviewsdimensionstosize autodistributeviewsalongaxis alignedto withfixedspacing insetspacing matchedsizes autodistributeviewsalongaxis alignedto withfixedsize insetspacing nslayoutconstraint autocreateandinstallconstraints autocreateconstraintswithoutinstalling autosetpriority forconstraints autosetidentifier forconstraints ios 7 0 os x 10 9 only autoidentify ios 7 0 os x 10 9 only autoinstall autoremove usage sample code swift purelayout dramatically simplifies writing auto layout code lets take a quick look at some examples using purelayout from swift heres a constraint between two views created and automatically activated using purelayout swift view1 autopinedge top toedge bottom ofview view2 without purelayout heres the equivalent code youd have to write using apples foundation api directly swift nslayoutconstraint item view1 attribute top relatedby equal toitem view2 attribute bottom multiplier 1 0 constant 0 0 active true many apis of purelayout create multiple constraints for you under the hood letting you write highly readable layout code swift 2 constraints created activated in one line logoimageview autocenterinsuperview 4 constraints created activated in one line textcontentview autopinedgestosuperviewedges with insets uiedgeinsets top 20 0 left 5 0 bottom 10 0 right 5 0 purelayout always returns the constraints it creates so you have full control swift let constraint skinnyview automatchdimension height todimension width ofview tallview purelayout supports all auto layout features including inequalities priorities layout margins identifiers and much more its a comprehensive developer friendly way to use auto layout check out the example apps below for many more demos of purelayout in use example apps open the project included in the repository requires xcode 6 or higher it contains ios example ios scheme and os x example mac scheme demos of the library being used in various scenarios the demos in the ios example app make a great introductory tutorial to purelayout run each demo review the code used to implement it then practice by making some changes of your own to the demo code each demo in the ios example app has a swift and objective c version to compile run the swift demos you must use xcode 7 0 or higher swift 2 0 and choose the example ios xcode7 scheme when you run the example app you can easily switch between using the swift and objective c versions of the demos to see the constraints in action while running the ios demos try using different device simulators rotating the device to different orientations as well as toggling the taller in call status bar in the ios simulator on os x while running the app press any key to cycle through the demos you can resize the window to see the constraints in action tips and tricks check out some tips and tricks to keep in mind when using the api purelayout vs the rest there are quite a few different ways to implement auto layout here is a quick overview of the available options apple nslayoutconstraint sdk api pros raw power cons extremely verbose tedious to write difficult to read apple visual format language pros concise convenient cons doesnt support some use cases lacks compile time checking and safety must learn syntax hard to debug apple interface builder pros visual interactive provides compile time layout checking cons difficult for complex layouts cannot dynamically set constraints at runtime encourages hardcoded magic numbers not always wysiwyg apple nslayoutanchor sdk api pros clean readable and type safe api for creating individual constraints cons only available in ios 9 0 and os x 10 11 and higher requires manually activating each constraint no api for creating multiple constraints at once purelayout pros compatible with objective c and swift codebases consistent with cocoa api style cross platform api and implementation shared across ios and os x fully backwards compatible to ios 6 os x 10 7 easy to use type safe efficient cons not the most concise expression of layout code high level auto layout libraries dsls cartography snapkit keeplayout pros very clean concise and convenient cons unique api style is foreign to apples apis mixed compatibility with objective c swift greater dependency on third party code purelayout takes a balanced approach to auto layout that makes it well suited for any project problems suggestions pull requests please open a new issue here if you run into a problem specific to purelayout have a feature request or want to share a comment note that general auto layout questions should be asked on stack overflow pull requests are encouraged and greatly appreciated please try to maintain consistency with the existing code style if youre considering taking on significant changes or additions to the project please communicate in advance by opening a new issue this allows everyone to get onboard with upcoming changes ensures that changes align with the projects design philosophy and avoids duplicated work meta originally designed built by tyler fox smileyborg currently maintained by mickey reiss mickeyreiss distributed with the mit license