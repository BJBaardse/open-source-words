fasthttp fast http implementation for go currently fasthttp is successfully used by vertamedia in a production serving up to 200k rps from more than 1 5m concurrent keep alive connections per physical server techempower benchmark round 12 results server benchmarks client benchmarks install documentation examples from docs code examples switching from net http to fasthttp fasthttp best practices tricks with byte buffers related projects faq http server performance comparison with net http in short fasthttp server is up to 10 times faster than net http below are benchmark results gomaxprocs 1 net http server gomaxprocs 1 go test bench nethttpserverget benchmem benchtime 10s benchmarknethttpserverget1reqperconn 1000000 12052 ns op 2297 b op 29 allocs op benchmarknethttpserverget2reqperconn 1000000 12278 ns op 2327 b op 24 allocs op benchmarknethttpserverget10reqperconn 2000000 8903 ns op 2112 b op 19 allocs op benchmarknethttpserverget10kreqperconn 2000000 8451 ns op 2058 b op 18 allocs op benchmarknethttpserverget1reqperconn10kclients 500000 26733 ns op 3229 b op 29 allocs op benchmarknethttpserverget2reqperconn10kclients 1000000 23351 ns op 3211 b op 24 allocs op benchmarknethttpserverget10reqperconn10kclients 1000000 13390 ns op 2483 b op 19 allocs op benchmarknethttpserverget100reqperconn10kclients 1000000 13484 ns op 2171 b op 18 allocs op fasthttp server gomaxprocs 1 go test bench kserverget benchmem benchtime 10s benchmarkserverget1reqperconn 10000000 1559 ns op 0 b op 0 allocs op benchmarkserverget2reqperconn 10000000 1248 ns op 0 b op 0 allocs op benchmarkserverget10reqperconn 20000000 797 ns op 0 b op 0 allocs op benchmarkserverget10kreqperconn 20000000 716 ns op 0 b op 0 allocs op benchmarkserverget1reqperconn10kclients 10000000 1974 ns op 0 b op 0 allocs op benchmarkserverget2reqperconn10kclients 10000000 1352 ns op 0 b op 0 allocs op benchmarkserverget10reqperconn10kclients 20000000 789 ns op 2 b op 0 allocs op benchmarkserverget100reqperconn10kclients 20000000 604 ns op 0 b op 0 allocs op gomaxprocs 4 net http server gomaxprocs 4 go test bench nethttpserverget benchmem benchtime 10s benchmarknethttpserverget1reqperconn 4 3000000 4529 ns op 2389 b op 29 allocs op benchmarknethttpserverget2reqperconn 4 5000000 3896 ns op 2418 b op 24 allocs op benchmarknethttpserverget10reqperconn 4 5000000 3145 ns op 2160 b op 19 allocs op benchmarknethttpserverget10kreqperconn 4 5000000 3054 ns op 2065 b op 18 allocs op benchmarknethttpserverget1reqperconn10kclients 4 1000000 10321 ns op 3710 b op 30 allocs op benchmarknethttpserverget2reqperconn10kclients 4 2000000 7556 ns op 3296 b op 24 allocs op benchmarknethttpserverget10reqperconn10kclients 4 5000000 3905 ns op 2349 b op 19 allocs op benchmarknethttpserverget100reqperconn10kclients 4 5000000 3435 ns op 2130 b op 18 allocs op fasthttp server gomaxprocs 4 go test bench kserverget benchmem benchtime 10s benchmarkserverget1reqperconn 4 10000000 1141 ns op 0 b op 0 allocs op benchmarkserverget2reqperconn 4 20000000 707 ns op 0 b op 0 allocs op benchmarkserverget10reqperconn 4 30000000 341 ns op 0 b op 0 allocs op benchmarkserverget10kreqperconn 4 50000000 310 ns op 0 b op 0 allocs op benchmarkserverget1reqperconn10kclients 4 10000000 1119 ns op 0 b op 0 allocs op benchmarkserverget2reqperconn10kclients 4 20000000 644 ns op 0 b op 0 allocs op benchmarkserverget10reqperconn10kclients 4 30000000 346 ns op 0 b op 0 allocs op benchmarkserverget100reqperconn10kclients 4 50000000 282 ns op 0 b op 0 allocs op http client comparison with net http in short fasthttp client is up to 10 times faster than net http below are benchmark results gomaxprocs 1 net http client gomaxprocs 1 go test bench httpclient do getendtoend benchmem benchtime 10s benchmarknethttpclientdofastserver 1000000 12567 ns op 2616 b op 35 allocs op benchmarknethttpclientgetendtoend1tcp 200000 67030 ns op 5028 b op 56 allocs op benchmarknethttpclientgetendtoend10tcp 300000 51098 ns op 5031 b op 56 allocs op benchmarknethttpclientgetendtoend100tcp 300000 45096 ns op 5026 b op 55 allocs op benchmarknethttpclientgetendtoend1inmemory 500000 24779 ns op 5035 b op 57 allocs op benchmarknethttpclientgetendtoend10inmemory 1000000 26425 ns op 5035 b op 57 allocs op benchmarknethttpclientgetendtoend100inmemory 500000 28515 ns op 5045 b op 57 allocs op benchmarknethttpclientgetendtoend1000inmemory 500000 39511 ns op 5096 b op 56 allocs op fasthttp client gomaxprocs 1 go test bench kclient do getendtoend benchmem benchtime 10s benchmarkclientdofastserver 20000000 865 ns op 0 b op 0 allocs op benchmarkclientgetendtoend1tcp 1000000 18711 ns op 0 b op 0 allocs op benchmarkclientgetendtoend10tcp 1000000 14664 ns op 0 b op 0 allocs op benchmarkclientgetendtoend100tcp 1000000 14043 ns op 1 b op 0 allocs op benchmarkclientgetendtoend1inmemory 5000000 3965 ns op 0 b op 0 allocs op benchmarkclientgetendtoend10inmemory 3000000 4060 ns op 0 b op 0 allocs op benchmarkclientgetendtoend100inmemory 5000000 3396 ns op 0 b op 0 allocs op benchmarkclientgetendtoend1000inmemory 5000000 3306 ns op 2 b op 0 allocs op gomaxprocs 4 net http client gomaxprocs 4 go test bench httpclient do getendtoend benchmem benchtime 10s benchmarknethttpclientdofastserver 4 2000000 8774 ns op 2619 b op 35 allocs op benchmarknethttpclientgetendtoend1tcp 4 500000 22951 ns op 5047 b op 56 allocs op benchmarknethttpclientgetendtoend10tcp 4 1000000 19182 ns op 5037 b op 55 allocs op benchmarknethttpclientgetendtoend100tcp 4 1000000 16535 ns op 5031 b op 55 allocs op benchmarknethttpclientgetendtoend1inmemory 4 1000000 14495 ns op 5038 b op 56 allocs op benchmarknethttpclientgetendtoend10inmemory 4 1000000 10237 ns op 5034 b op 56 allocs op benchmarknethttpclientgetendtoend100inmemory 4 1000000 10125 ns op 5045 b op 56 allocs op benchmarknethttpclientgetendtoend1000inmemory 4 1000000 11132 ns op 5136 b op 56 allocs op fasthttp client gomaxprocs 4 go test bench kclient do getendtoend benchmem benchtime 10s benchmarkclientdofastserver 4 50000000 397 ns op 0 b op 0 allocs op benchmarkclientgetendtoend1tcp 4 2000000 7388 ns op 0 b op 0 allocs op benchmarkclientgetendtoend10tcp 4 2000000 6689 ns op 0 b op 0 allocs op benchmarkclientgetendtoend100tcp 4 3000000 4927 ns op 1 b op 0 allocs op benchmarkclientgetendtoend1inmemory 4 10000000 1604 ns op 0 b op 0 allocs op benchmarkclientgetendtoend10inmemory 4 10000000 1458 ns op 0 b op 0 allocs op benchmarkclientgetendtoend100inmemory 4 10000000 1329 ns op 0 b op 0 allocs op benchmarkclientgetendtoend1000inmemory 4 10000000 1316 ns op 5 b op 0 allocs op install go get u github com valyala fasthttp switching from net http to fasthttp unfortunately fasthttp doesnt provide api identical to net http see the faq for details there is net http fasthttp handler converter but it is better to write fasthttp request handlers by hand in order to use all of the fasthttp advantages especially high performance important points fasthttp works with requesthandler functions instead of objects implementing handler interface fortunately it is easy to pass bound struct methods to fasthttp go type myhandler struct foobar string request handler in net http style i e method bound to myhandler struct func h myhandler handlefasthttp ctx fasthttp requestctx notice that we may access myhandler properties here see h foobar fmt fprintf ctx hello world requested path is q foobar is q ctx path h foobar request handler in fasthttp style i e just plain function func fasthttphandler ctx fasthttp requestctx fmt fprintf ctx hi there requesturi is q ctx requesturi pass bound struct method to fasthttp myhandler myhandler foobar foobar fasthttp listenandserve 8080 myhandler handlefasthttp pass plain function to fasthttp fasthttp listenandserve 8081 fasthttphandler the requesthandler accepts only one argument requestctx it contains all the functionality required for http request processing and response writing below is an example of a simple request handler conversion from net http to fasthttp go net http request handler requesthandler func w http responsewriter r http request switch r url path case foo foohandler w r case bar barhandler w r default http error w unsupported path http statusnotfound go the corresponding fasthttp request handler requesthandler func ctx fasthttp requestctx switch string ctx path case foo foohandler ctx case bar barhandler ctx default ctx error unsupported path fasthttp statusnotfound fasthttp allows setting response headers and writing response body in an arbitrary order there is no headers first then body restriction like in net http the following code is valid for fasthttp go requesthandler func ctx fasthttp requestctx set some headers and status code first ctx setcontenttype foo bar ctx setstatuscode fasthttp statusok then write the first part of body fmt fprintf ctx this is the first part of body\n then set more headers ctx response header set foo bar baz then write more body fmt fprintf ctx this is the second part of body\n then override already written body ctx setbody byte this is completely new body contents then update status code ctx setstatuscode fasthttp statusnotfound basically anything may be updated many times before returning from requesthandler unlike net http fasthttp doesnt put response to the wire until returning from requesthandler fasthttp doesnt provide servemux but there are more powerful third party routers and web frameworks with fasthttp support iris fasthttp routing fasthttprouter lu net http code with simple servemux is trivially converted to fasthttp code go net http code m http servemux m handlefunc foo foohandlerfunc m handlefunc bar barhandlerfunc m handle baz bazhandler http listenandserve 80 m go the corresponding fasthttp code m func ctx fasthttp requestctx switch string ctx path case foo foohandlerfunc ctx case bar barhandlerfunc ctx case baz bazhandler handlerfunc ctx default ctx error not found fasthttp statusnotfound fasthttp listenandserve 80 m net http fasthttp conversion table all the pseudocode below assumes w r and ctx have these types go var w http responsewriter r http request ctx fasthttp requestctx r body ctx postbody r url path ctx path r url ctx uri r method ctx method r header ctx request header r header get ctx request header peek r host ctx host r form ctx queryargs ctx postargs r postform ctx postargs r formvalue ctx formvalue r formfile ctx formfile r multipartform ctx multipartform r remoteaddr ctx remoteaddr r requesturi ctx requesturi r tls ctx istls r cookie ctx request header cookie r referer ctx referer r useragent ctx useragent w header ctx response header w header set ctx response header set w header set content type ctx setcontenttype w header set set cookie ctx response header setcookie w write ctx write ctx setbody ctx setbodystream ctx setbodystreamwriter w writeheader ctx setstatuscode w http hijacker hijack ctx hijack http error ctx error http fileserver fasthttp fshandler fasthttp fs http servefile fasthttp servefile http redirect ctx redirect http notfound ctx notfound http stripprefix fasthttp pathrewritefunc very important fasthttp disallows holding references to requestctx or to its members after returning from requesthandler otherwise data races are inevitable carefully inspect all the net http request handlers converted to fasthttp whether they retain references to requestctx or to its members after returning requestctx provides the following band aids for this case wrap requesthandler into timeouthandler call timeouterror before returning from requesthandler if there are references to requestctx or to its members see the example for more details use this brilliant tool race detector for detecting and eliminating data races in your program if you detected data race related to fasthttp in your program then there is high probability you forgot calling timeouterror before returning from requesthandler blind switching from net http to fasthttp wont give you performance boost while fasthttp is optimized for speed its performance may be easily saturated by slow requesthandler so profile and optimize your code after switching to fasthttp for instance use quicktemplate instead of html template see also fasthttputil fasthttpadaptor and expvarhandler performance optimization tips for multi core systems use reuseport listener run a separate server instance per cpu core with gomaxprocs 1 pin each server instance to a separate cpu core using taskset ensure the interrupts of multiqueue network card are evenly distributed between cpu cores see this article for details use go 1 6 as it provides some considerable performance improvements fasthttp best practices do not allocate objects and byte buffers just reuse them as much as possible fasthttp api design encourages this sync pool is your best friend profile your program in production go tool pprof alloc objects your program mem pprof usually gives better insights for optimization opportunities than go tool pprof your program cpu pprof write tests and benchmarks for hot paths avoid conversion between byte and string since this may result in memory allocation copy fasthttp api provides functions for both byte and string use these functions instead of converting manually between byte and string there are some exceptions see this wiki page for more details verify your tests and production code under race detector on a regular basis prefer quicktemplate instead of html template in your webserver tricks with byte buffers the following tricks are used by fasthttp use them in your code too standard go functions accept nil buffers go var both buffers are uninitialized dst byte src byte dst append dst src is legal if dst is nil and or src is nil copy dst src is legal if dst is nil and or src is nil string src is true if src is nil len src 0 is true if src is nil src src 0 works like a charm with nil src this for loop doesnt panic if src is nil for i ch range src dosomething i ch so throw away nil checks for byte buffers from you code for example go srclen 0 if src nil srclen len src becomes go srclen len src string may be appended to byte buffer with append go dst append dst foobar byte buffer may be extended to its capacity go buf make byte 100 a buf 10 len a 10 cap a 100 b a 100 is valid since cap a 100 all fasthttp functions accept nil byte buffer go statuscode body err fasthttp get nil http google com uintbuf fasthttp appenduint nil 1234 related projects fasthttp contrib various useful helpers for projects based on fasthttp iris web application framework built on top of fasthttp features speed and functionality fasthttp routing fast and powerful routing package for fasthttp servers fasthttprouter a high performance fasthttp request router that scales well lu a high performance go middleware web framework which is based on fasthttp websocket gorilla based websocket implementation for fasthttp faq why creating yet another http package instead of optimizing net http because net http api limits many optimization opportunities for example net http request object lifetime isnt limited by request handler execution time so the server must create a new request object per each request instead of reusing existing objects like fasthttp does net http headers are stored in a map string string so the server must parse all the headers convert them from byte to string and put them into the map before calling user provided request handler this all requires unnecessary memory allocations avoided by fasthttp net http client api requires creating a new response object per each request why fasthttp api is incompatible with net http because net http api limits many optimization opportunities see the answer above for more details also certain net http api parts are suboptimal for use compare net http connection hijacking to fasthttp connection hijacking compare net http request body reading to fasthttp request body reading why fasthttp doesnt support http 2 0 and websockets there are plans for adding http 2 0 and websockets support in the future in the mean time third parties may use requestctx hijack for implementing these goodies see the first third party websocket implementation on the top of fasthttp are there known net http advantages comparing to fasthttp yes net http supports http 2 0 starting from go1 6 net http api is stable while fasthttp api constantly evolves net http handles more http corner cases net http should contain less bugs since it is used and tested by much wider audience net http works on go older than 1 5 why fasthttp api prefers returning byte instead of string because byte to string conversion isnt free it requires memory allocation and copy feel free wrapping returned byte result into string if you prefer working with strings instead of byte slices but be aware that this has non zero overhead which go versions are supported by fasthttp go1 5 older versions wont be supported since their standard package miss useful functions please provide real benchmark data and sever information see this issue are there plans to add request routing to fasthttp there are no plans to add request routing into fasthttp use third party routers and web frameworks with fasthttp support iris https github com kataras iris fasthttp routing https github com qiangxue fasthttp routing fasthttprouter https github com buaazp fasthttprouter gramework https github com gramework gramework lu https github com vincentliuxiang lu see also this issue for more info i detected data race in fasthttp cool file a bug but before doing this check the following in your code make sure there are no references to requestctx or to its members after returning from requesthandler make sure you call timeouterror before returning from requesthandler if there are references to requestctx or to its members which may be accessed by other goroutines i didnt find an answer for my question here try exploring these questions