blazing fast css for your design systems and app components css blocks is an ergonomic component oriented css authoring system that compiles to high performance stylesheets by combining an opinionated authoring system build time analysis and rewriting of templates and a new type of css optimizer css blocks breathes new power and ease of use into the technologies and best practices that stylesheet developers already know and love interested in contributing or just seeing css blocks in action head over to contributing md to learn how to spin up the project table of contents toc why css blocks the ⚡️ of static analysis ⚙️ supported integrations 🎁 api features 🎨 what is a block the scope selector class selectors state selectors sub state selectors its just css ™️ mostly blocks in your templates 🏗 block composition block references object oriented features of blocks block implementation style composition block paths composition in templates block resolutions external selectors global states tocstop why css blocks with css blocks added to your project you receive 💎 one css file per component 📦 scoped styles 🔎 nearly non existent runtime 500b 🔥 blazing fast stylesheets 🚀 project wide optimization 🚨 build time css errors 🧟 dead code elimination ✨ object oriented inheritance but most importantly css blocks is ⚡️statically analyzable the ⚡️ of static analysis static analysis means css blocks can look at your project and know with certainty that any given css declaration will will not or might under certain conditions be used on any given element in your templates most stylesheet architectures have to walk a fine line between performance and maintainability tilt too far in either direction and either your users or the developers will end up paying the cost with css blocks you can focus on making sure your stylesheets are easy to maintain as your application changes and with the new css optimizer opticss the small size of your apps production stylesheets after compression will amaze you gone are the days where you spend several minutes debugging your app only to discover a subtle typo that caused a selector to not match – css blocks will give you a build error and suggest possible fixes with ide integration projects using css blocks will be able to quickly navigate to selector definitions that match your current template element and find which template elements match your current selector autocomplete class names with css blocks new resolution system cascade conflicts will be caught for you before you even know they exist and you will never have to fight a specificity war ever again css blocks is inspired by css modules bem and atomic css for a full deep dive of the project architecture i heavily recommend you review the css blocks architecture readme ⚙️ supported integrations css blocks requires deep integration with your build system and templating language to learn how to install css blocks for in your application please consult the specific docs for your templating system and build system css blocks is available for use in the following templating languages jsx react glimmer and has integrations with the following build systems webpack broccoli ember cli glimmer only dont see your preferred platform yet learn how to make your own template integration or build system integration and contribute it back 🎁 api features css blocks is under active development and there are a number of features that have not yet been implemented you can get a snapshot of the feature set state here ✅ implemented ❌ not implemented 💀 deprecated 🖌 in proposal status feature description selectors ✅ scope scope selector for component root ✅ class class selectors for component sub elements ✅ class state name state that is applied to scope and class selectors on state existence ✅ class state name value mutually exclusive sub states for scope and class selectors to be applied when a sub state value matches ❌ state name value bare state not associated with an originating element and optional substate selectors for targeting all elements in the block that possess the state an or sub state 🖌 class state name default default state value to be applied when there is no other match at rules ✅ block reference local name from file path css reference another block using a local name ✅ block debug block name to channel debug call that will print a block interface to a channel comment stderr or stdout ✅ block global block path declare a block class or state as public it may be used as a context selector in other blocks 🖌 is block block name block class can declare itself to be the root of another block in a specific state or set of states properties ✅ block name custom name provide custom block names in scope for a nicer debugging experience ✅ implements block name a block can declare that it implements one or more other blocks interfaces in its scope selector and the compiler will ensure that all of those states and classes are styled locally ✅ extends block name a block may specify it extends another block in its scope selector to inherit and extend all the class and state implementations therein 🖌 apply block path mixin style class and state composition apply other blocks styles to one of yours functions ✅ resolve block path provide an explicit resolution for a given property against another block ❌ constrain val1 val2 valn constrain this property to a list of specific values that may be set when this block is extended ❌ range min max constrain this property to a range of values that may be set when this block is extended 🎨 what is a block a block is an isolated stylesheet written in its own file that contains all rulesets for any elements and their various modes and interaction states for a discrete unit of styling – like a component or design pattern typically a single block will contain styles for a particular component or concept but it is entirely natural – and encouraged – for a template to consume multiple blocks and compose them together in the markup a block file may contain the scope selector the scope ruleset contains styles applied to the root of the scoped style subtree all other elements assigned styles from a block must be contained in the document subtree of an element assigned to the blocks scope we use the special scope pseudo class to represent these styles the scope selector may contain the special block name property so you may provide your own block name for easy debugging and bem class generation if no block name is provided we will infer the block name from the file name 💡 feature note block names if two blocks in your project have the same name css blocks will automatically generate a unique but still human readable name for bem output mode css scope block name custom block name 👆 optional more styles class selectors blocks may can contain other classes that may be applied to elements inside the scoped style sub tree these are just class selectors but they are local to that block and isolated from all other similarly named classes in other blocks css sub element other sub element together the scope selector and all declared class selectors define the full interface of stylable elements available to a blocks consumer state selectors states represent a mode or interaction state that the scope or a class – called the states originating element – may be in states are written as attribute selectors with the special state namespace css scope scope state enabled sub element sub element state is active ⁉️ what the pipe is going on here once upon a time developers fell in love with xml and thus was born xhtml a flavor of html that allowed html elements to be mixed together with elements from other xml syntaxes like svg and mathml css went along for the ride and so while many have never seen or used the feature css has support for namespaced elements and attributes in css the symbol is used to delimit between a namespace identifier assigned by the namespace at rule and the element or attribute name also called a qualified name in markup instead of a pipe symbol the colon is used to delimit a namespace identifier and a qualified name yes this is confusing but we dont make css syntax we just use it sub state selectors states on the scope selector or a class selector may contain sub states for more granular styling sub states of a state are mutually exclusive and an element may only be in one sub state of that state at any given time css scope scope state theme inverse sub element applied for any value of color including no value sub element state color applied for specific values of color sub element state color red sub element state color blue sub element state color yellow its just css ™️ mostly css blocks implements a strict subset of css this means weve intentionally restricted some of the features youre allowed to use in a block file to ensure we can optimize your stylesheets as much as possible as opticss improves we may choose to loosen some of these restrictions – keep an eye out for syntax updates as we approach the v1 0 0 release 🎉 that means you may freely use before after and all other pseudo elements hover active and all other pseudo classes media breakpoint and all other at rules the cascade and selector specificity progressive enhancement and graceful degradation 🚨 however important is forbidden – you wont be needing it the tag non state attribute id and selectors are forbidden for now the logical combinators matches not something and has are forbidden for now selectors must remain shallow in css blocks shallow selectors mean 1 only one combinator per selector css ✅ allowed scope hover my class ❌ illegal scope hover my class my class 2 the hierarchical combinators and context selector must be a scope states sub states or pseudo classes css ✅ allowed scope hover my class scope state active my class scope state color red my class ❌ illegal container hover my class container state active my class container state color red my class 3 the sibling combinators context selector must target the same class or scope used in the key selector css ✅ allowed my class my class my class hover my class my class state active my class ❌ illegal scope my class another class hover my class another class state active my class 💡 feature note global states and selectors global states have their own rules on how they can be used in block selectors keep an eye out for them a little later in this doc of course because we statically analyze and compile all your code before it ever hits the browser you will get a helpful error if any of these syntax restrictions are violated blocks in your templates every specific template integration with css blocks will have their own slightly unique syntax for how to interface with block files however they all will allow you to apply classes and states in a way that is analyzable and rewritable at build time 💡 feature note template integrations each integration implements a slightly different api ex jsx lets you import block files ember looks for through convention a stylesheet css alongside every component template check out the readme for your template language for full details however whatever the implementation is it will feel as though youre interfacing with regular css on the platform for example in glimmer you just write the classes and states exactly as you would expect when working with a normal stylesheet css scope scope state enabled button icon icon state inverse hbs scope selector is automagically applied to the templates root level element thanks glimmer section state enabled isenabled button class button div class icon state inverse isinverse div value button section there are only two 2 common sense rules to follow when using block styles in your template you may not use a block class outside of its scopes subtree two classes from the same block may not be applied to the same html element 🏗 block composition blocks styles are by design scoped to the file they are written in but we all know that in a real app your styles cant live in a vacuum as youll see below there are many methods to compose blocks together in your application however most of these methods will begin with the humble block reference block references a block may declare a dependency on another block by using a block reference at the top of your file a block reference creates a locally scoped alias where you can access the public api declared classes and states of the referenced block block references dont cause any styles to be included instead they are like an es6 import statement they make it possible to refer to the public interface of another block from within the current block adding a block reference is as simple as this css block 1 block css scope block name block 1 my class my class state my state css block 2 block css block reference other block from block 1 block css scope block name block 2 🔮 future feature node modules block resolution whether youre integrating with a 3rd party library or pulling in dependencies internal to your company at some point youll want to integrate with styles delivered via npm the resolution logic for block references to node modules hasnt yet been implemented yet but you can track progress or even help out over on github with the above code block 2 now has a local reference other block which points to block 1 we can now freely use the other block identifier inside of block 2 when we want to reference reference block 1 this comes in handy especially with features like object oriented features of blocks block implementation a blocks public interface is defined by the states and classes it styles a block may declare that it implements one or more other referenced blocks interfaces and the compiler will ensure that all the states and classes it defines are also in the implementing block in this way the compiler can guarantee it is safe to use different blocks to style the same markup in a component you do this via the special implements property in a blocks scope selector css block 1 block css scope block name block 1 my class my class state my state css block 2 block css block reference other block from block 1 block css scope block name block 2 implements other block 💡 feature note implements property the implements property is only available in the scope selector if you use it in any other selector it will be ignored however the above code will throw an error at build time bash error missing implementations for my class my class state my state from block 1 block css for the build to pass we need to implement the full public interface of block 1 in block 2 css block 2 block css block reference other block from block 1 block css scope block name block 2 implements other block my class my class state my state block inheritance a block may also choose to extend another referenced block this exposes all declared styles from the extended block on the extending block those inherited styles may then be used in a template by accessing them on the extending block and can even be augmented by re declaring the styles in the extending block you do this via the special extends property in a blocks scope selector lets say we have a component called basic form basic forms have an input element and a big green button simple enough css basic form block css button font size 1 4rem color white background color green button state disabled color 333 background color lightgray input font weight bold but as the project evolves we realize we need a new form for submitting information for a dangerous action were asked to create a new kind of form called danger form danger forms look and function exactly the same as a basic form except the button and labels are red we could re implement the entire stylesheet to create danger form but that would be a such a waste of all the hard work we already put in to basic form instead we can simply extend the basic form block and only apply the small style changes we need css danger form block css block reference basic form from basic form block css scope extends basic form button background color darkred label color darkred during rewrite references to an inherited style will translate into the class es for the directly referenced style as well as all the classes that it inherits from so developers do not need to bring the complexity of the inheritance relationship into their templates for example a reference to danger form button would result in adding both basic form button as well as danger form button to the elements list of classes when the blocks are compiled property overrides are detected and automatically resolved the selectors generated serve two purposes concatenation order independence once compiled a css block file can be concatenated in any order with other compiled block output optimization hints normally if there are selectors with the same specificity that set same property to different values on the same element the optimizer would take care not to merge those declarations such that it might cause a cascade resolution change but the selectors in the output from css blocks allows opticss to merge declarations more aggressively because it can prove that it knows the value of those selectors when combined css basic form button font size 1 4rem color white background color green basic form button disabled color 333 background color lightgray basic form input font weight bold danger form button background color darkred basic form button danger form button background color darkred danger form button disabled background color 957d7d basic form button danger form button disabled background color 957d7d basic form button disabled danger form button disabled background color 957d7d danger form label color darkred while this output is highly repetitive and may seem excessive its exactly the kind of repetition that opticss is designed to search for and remove from an authoring experience and in production its a laser focused override with no performance impact 💡 feature note extends property the extends property is only available in the scope selector if you use it in any other selector it will be ignored an extending block is able to re define any property on any style it inherits from css declarations defined in the extending block will always take priority over the definitions inherited by the same named style in the base block 🔮 future feature extension constraints sometimes properties inside of a component are so important that authors may want to constrain the values that extenders and implementors are able to set in the near future css blocks will enable this use case through the custom constrain and range css functions and possibly through other ideas like custom constraints and conflicts you can come help out over on github to make this happen faster style composition block paths as your blocks begin interacting with each other in increasingly complex ways you will find yourself needing to reference specific classes or states on another block as youll see later in this document you do this using a small query syntax called a block path block paths take the form block class state name value all sections of this selector – except the leading block name – are optional the leading block name must refer to an imported block reference at the top of the file if css blocks is unable to resolve a block path at build time you will get a friendly error message in your console all the following syntaxes are legal to select any given stylable on a referenced block stylable syntax scope block scope state block state name scope sub state block state name value class block class scope state block class state name scope sub state block class state name value 🔮 future feature block path wildcards in some situations you may want to select multiple classes states or sub states on a referenced block in the near future you will be able to do so with a wildcard syntax block block class state block class state name feel free to track progress of this feature here composition in templates every template integration will provide a way to use more than one block inside of a template the syntax for this may change depending on your templating system so please check with your specific template integrations documentation for glimmer using multiple blocks in a single template will look something like this css hoverable css scope block name hoverable box shadow 0 2px 3px rgba 0 0 0 0 2 transition box shadow 28s scope hover box shadow 0 4px 6px rgba 0 0 0 0 2 button background color rgba 255 255 255 5 color black transition background color 28s scope hover button background color rgba 255 255 255 1 css stylesheet css block reference other from hoverable css scope block name main form border 1px solid gray border radius 2px padding 16px button background color green color white height 32px width 100 hbs scope selector from stylesheet css is automagically applied to the templates wrapper element thanks glimmer section form class form other button class button other button click me button form section above we have a simple template that contains a form with a single button that says click me we style it with styles from the default block for the template stylesheet css and with styles from the referenced block hoverable css referenced in this context as other in this template we have the form element assigned the scoped root for other and we apply the button class from both blocks to the button element but wait if you try and run the css blocks build with this code youd find an error in your console bash the following property conflicts must be resolved for these co located styles template hbs 4 19 color main button stylesheet css 12 2 hoverable button hoverable css 12 2 background color main button stylesheet css 11 2 hoverable button hoverable css 11 2 woah what does this mean well if we stop and think for a second about what we just asked css blocks to do well realize that this error makes perfect sense because blocks have their own entirely independently scoped cascades and right now no block file is aware of any other blocks styles css blocks doesnt inherently know which block should take priority over another when used together so when css blocks was asked to put the button class from both the default template stylesheet and from hoverable onto the same element it noticed that both classes are claiming to set the color and background color properties – and with this we have encountered our first indeterminate cascade resolution which block should win in this situation right now the compiler has no idea to answer that css blocks needs a little help from you we are able to provide explicit cross block cascade resolutions to the compiler by using resolve lets learn how we can fix our above error by moving on to the next section block resolutions block resolutions the special resolve function provides explicit resolution guidance for properties that are in conflict across two or more block files they look like any other property declaration css selector property name resolve block path you will be asked by the css blocks compiler to add resolutions if and when two styles are found on the same element in your templates that attempt to set the same css property resolve declarations work just like progressive enhancement and graceful degradation the last declaration defined in the ruleset will win this means that declaration order matters there are two ways to resolve any given property override resolution override resolutions tell css blocks that when these two styles are used together we want this block to override the value of the other styles property here we tell css blocks to use the color value from my class instead of other selector when both styles are applied to the same element css my class color resolve other selector color red yield resolution yield resolutions tell css blocks that when these two styles are used together we want this block to yield to the value of the other styles property here we tell css blocks to use the color value from other selector instead of my selector when both styles are applied to the same element css my class color red color resolve other selector 🔮 future feature resolve all shorthand for straightforward resolutions where you just want to yield or assume full control of styling against another block feel free to use the css all property to quickly override or yield to all property conflict with another block the downside of doing this is that as new properties are added to another element you dont get a chance to review them and decide css my class color red background blue yields all conflicts to other selector all resolve other selector 💡 feature note advanced property conflicts the css blocks compiler is smart if you have dynamic classes or states in your template it will ask you to provide explicit resolutions between blocks that even only have a chance of being used together on the same element this way we can guarantee that your styles will work regardless of the state your application may find itself it css blocks is also aware of css shorthands and will ask you to resolve the lowest common denominator on conflicting shorthand longhand expressions as well so continuing with the example from the previous section – composition in templates – we can satisfy the css blocks compiler by adding in two explicit resolutions for color and background color like so css stylesheet css button override resolution background color resolve hoverable button background color green override resolution color resolve hoverable button color white here we have told css blocks that when our components button class is used with hoverables button class we want our components style declarations to win we have declared an override resolution for both properties if we were to switch around the order a bit so our background color resolution comes after our components declaration it means that when these two classes are used together hoverables button class will win but only for that property this is why you will never have to fight the cascade or use important ever again css stylesheet css button yield resolution background color green background color resolve hoverable button override resolution color resolve hoverable button color white 💡 feature note states and pseudo classes states and pseudo classes inherit all resolutions set on their containing class or scope this means that in the above example where we yield for background color and override for color the button element where both classes are used will still use hoverable button hovers background color but its color will remain white like our component styles define resolving pseudo elements it is important to note that pseudo elements do not inherit any resolutions from their container class and must be explicitly resolved in the source stylesheets when found to be in conflict so for the following two blocks where my class 1 state enabled and my class 2 are used on the same element one of the blocks will need to resolve the conflicting border width property css other my class 1 state enabled before border 1px solid red css main css block reference other from other css my class 2 before border width 2px border width resolve other my class 2 state enabled external selectors sometime a class identifier or tag name comes from an external source and the only thing you can do is use them as is in these situations the block must declare all external simple selectors it intendeds to use these simple selectors may then be used as key selectors inside this block youll get an error for any declared external selectors that arent used or if they are used in the context selector styles targeting an external selector are not rewritten and their declarations cannot be optimized style collisions on an external selector are not detected or resolved as a result it is allowed to use important on declarations targeting an external selector warning if external selectors and css block objects both target the same html element in their key selectors you will get unpredictable results its best to avoid this css external h2 some rando class foo h2 some rando class font size 32px important global states in rare occasions a block may choose to declare declare that a certain state is global these states are special in that they can be used in other blocks like they are local to that block this is most useful for global application states – like during initial application boot or when a modal is displayed ⚙️ performance note global states when you apply classes and other attributes to elements like html or body it invalidates a lot of internal caches in the browser it is still often a performance win compared to querying the document in javascript and applying classes on many elements css application block css block global state is loading block global state is saving css navigation block css block reference app from application block css gray out signout button when app is saving app state is saving signout color gray pointer events none animate the logo when app is loading data app state is loading logo animation name bounce