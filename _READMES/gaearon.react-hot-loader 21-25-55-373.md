react hot loader tweak react components in real time ⚛️⚡️ watch dan abramovs talk on hot reloading with time travel install npm install react hot loader note you can safely install react hot loader as a regular dependency instead of a dev dependency as it automatically ensures it is not executed in production and the footprint is minimal getting started add react hot loader babel to your babelrc js babelrc plugins react hot loader babel mark your root component as hot exported js app js import react from react import hot from react hot loader const app hello world export default hot module app run webpack with hot module replacement sh webpack dev server hot recipes migrating from create react app run npm run eject install react hot loader npm install save dev react hot loader in config webpack config dev js add react hot loader babel to babel loader configuration the loader should now look like js test \ js jsx include paths appsrc loader require resolve babel loader options this is a feature of babel loader for webpack not babel itself it enables caching results in node modules cache babel loader directory for faster rebuilds cachedirectory true plugins react hot loader babel mark your app src index js as hot exported js containers app js import react from react import hot from react hot loader const app hello world export default hot module app migrating from create react app without ejecting users report that it is possible to use react app rewire hot loader to setup react hot loader without ejecting follow these code examples to repeat the approach typescript when using typescript babel is not required but react hot loader will not work properly without it just add babel loader into your webpack configuration with react hot loader plugin there are 2 different ways to do it add babel after typescript js test \ tsx use loader babel loader options babelrc false plugins react hot loader babel ts loader or awesome typescript loader in this case you have to modify your tsconfig json and compile to es6 mode as long as react hot loader babel plugin does not understand es5 code json tsconfig json module commonjs target es6 as long you cannot ship es6 to production you can create a tsconfig dev json extend the base tsconfig and use dev config in dev webpack build details for ts loader for awesome typescript loader json extends tsconfig compileroptions target es6 keep in mind awesome typescript loader has a built in feature usebabel to babelify result add babel before typescript note this way requires babel 7 and babel loader 8 0 0 js test \ tsx use ts loader or awesome typescript loader loader babel loader options plugins babel plugin syntax typescript babel plugin syntax decorators babel plugin syntax jsx react hot loader babel in this case you can compile to es5 more about typescript and react hot loader we also have a full example running typescript react hot loader parcel parcel supports hot module reloading out of the box just follow step 1 and 2 of getting started we also have a full example running parcel react hot loader electron you need something to mark your modules as hot in order to use react hot loader one way of doing this with electron is to simply use webpack like any web based project might do and the general guide above describes see also this example electron app a webpack less way of doing it to use electron compile which is also used by electron forge see this example while it requires less configuration something to keep in mind is that electron compiles hmr will always reload all modules regardless of what was actually edited source maps if you use devtool source map or its equivalent source maps will be emitted to hide hot reloading code source maps slow down your project use devtool eval for best build performance hot reloading code is just one line in the beginning and one line at the end of each module so you might not need source maps at all preact react hot loader should work out of the box with preact compat but in case of pure preact you will need to configure it create configuration file setuphotloader js js import reacthotloader from react hot loader import preact from preact reacthotloader preact preact dont forget to import it preact limitations hocs and decorators as not supported yet for preact react hot loader v4 behave as v3 react native react native supports hot reloading natively as of version 0 22 using react hot loader with react native can cause unexpected issues see 824 and is not recommended code splitting if you want to use code splitting react hot loader the simplest solution is to pick one of our compatible library loadable components imported component react universal component react loadable if you use a non yet friendly library like react async component you have to mark all your loaded components as hot exported js asynchello js import asynccomponent from react async component asynccomponent could not hot reload itself const asynchello asynccomponent resolve import hello export default asynchello js hello js import hot from react hot loader const hello hello export default hot module hello module will reload itself checking element types because react hot loader creates proxied versions of your components comparing reference types of elements wont work js const element component console log element type component false react hot loader exposes a function arecomponentsequal to make it possible js import arecomponentsequal from react hot loader const element component arecomponentsequal element type component true another way compare rendered element type js const element console log element type type true better precache rendered type const element const componenttype type console log element type componenttype true but you might have to provide all required props see original issue this is most reliable way to compare components but it will not work with required props another way compare component name not all components has a name in production displayname could not exists js const element component console log element displayname component true for components you might be able to use instanceof operator js const element component console log element type instanceof component true this is something we did not solve yet webpack extracttextplugin webpack extracttextplugin is not compatible with react hot loader please disable it in development js new extracttextplugin filename styles name contenthash css disable node env production disabling a type change ❄️ it is possible to disable react hot loader for a specific component especially to enable common way to type comparison see 991 for the idea behind ⛄️ and 304 about type comparison problem js import cold from react hot loader cold somecomponent this component will ignored by react hot loader type somecomponent true if you will update cold component react hot loader will complain on error level and then react will cold replace component with a internal state lose reach hot loader cold element got updated disabling a type change for all node modules you may cold all components from node modules this will not work for hoc like redux or dynamically created components but might help in most of situations when type changes are not welcomed and modules are not expected to change js import setconfig cold from react hot loader setconfig oncomponentregister type name file file indexof node modules 0 cold type to be able to cold components from node modules you have to apply babel to node modules while this folder is usually excluded you may add one more babel loader with only one react hot loader plugin inside to solve this api hot module options mark a component as hot js import hot from react hot loader const app hello world export default hot module app appcontainer mark application as hot reloadable prefer using hot helper js import react from react import reactdom from react dom import appcontainer from react hot loader import app from containers app const render component reactdom render document getelementbyid root render app webpack hot module replacement api if module hot module hot accept containers app if you are using harmony modules modules false render app in all other cases re require app manually render require containers app arecomponentsequal component1 component2 test if two components have the same type js import arecomponentsequal from react hot loader import component1 from component1 import component2 from component2 arecomponentsequal component1 component2 true or false setconfig config set a new configuration for react hot loader available options are loglevel specify log level default to error available values are debug log warn error puresfc enable stateless functional component if disabled they will be converted to react components default value false js import setconfig from react hot loader setconfig loglevel debug migrating from v3 appcontainer vs hot prior v4 the right way to setup react hot loader was to wrap your application with appcontainer set setup module acceptance by yourself this approach is still valid but only for advanced use cases prefer using hot helper react hot loader v3 js app js import react from react const app hello world export default app js main js import react from react import reactdom from react dom import appcontainer from react hot loader import app from containers app const render component reactdom render document getelementbyid root render app webpack hot module replacement api if module hot module hot accept containers app if you are using harmony modules modules false render app in all other cases re require app manually render require containers app react hot loader v4 js app js import react from react import hot from react hot loader const app hello world export default hot module app js main js import react from react import reactdom from react dom import app from containers app reactdom render document getelementbyid root no patch required code is automatically patched you can safely remove react hot loader patch from your webpack config error reporter is gone react supports error handling out of the box since v16 using componentdidcatch you can create your own error boundary and install it after hot has been applied js import react from react import hot from react hot loader import errorboundary from errorboundary const app hello world export default hot module app known limitations and side effects not about hot hot accepts only react component stateful or stateless resulting the hotexported variant of it the hot function will setup current module to self accept itself on reload and will ignore all the changes made for non react components you may mark as many modules as you want but hotexportedcomponent should be the only used export of a hot module note please note how often we have used exported keyword hot is for exports note does nothing in production mode just passes app through new components keep executing the old code there is no way to hot update constructor code as result even new components will be born as the first ones and then grow into the last ones as of today this issue cannot be solved troubleshooting if it doesnt work in 99 of cases its a configuration issue a missing option a wrong path or port webpack is very strict about configuration and the best way to find out whats wrong is to compare your project to an already working setup check out examples bit by bit if something doesnt work in 99 of cases its an issue with your code the component didnt get registered due to hoc or decorator around it which is making it invisible to the babel plugin or webpack loader were also gathering troubleshooting recipes so send a pr if you have a lesson to share switch into debug mode debug mode adds additional warnings and can tells you why react hot loader is not working properly in your application js import setconfig from react hot loader setconfig loglevel debug contributors this project exists thanks to all the people who contribute contribute backers thank you to all our backers 🙏 become a backer sponsors support this project by becoming a sponsor your logo will show up here with a link to your website become a sponsor license mit