modern javascript cheatsheet image credits ahmad awais ⚡️ introduction motivation this document is a cheatsheet for javascript you will frequently encounter in modern projects and most contemporary sample code this guide is not intended to teach you javascript from the ground up but to help developers with basic knowledge who may struggle to get familiar with modern codebases or lets say to learn react for instance because of the javascript concepts used besides i will sometimes provide personal tips that may be debatable but will take care to mention that its a personal recommendation when i do so note most of the concepts introduced here are coming from a javascript language update es2015 often called es6 you can find new features added by this update here its very well done complementary resources when you struggle to understand a notion i suggest you look for answers on the following resources mdn mozilla developer network you dont know js book es6 features with examples wesbos blog es6 javascript basics for beginners a free udacity course reddit javascript google to find specific blog and resources stackoverflow table of contents modern javascript cheatsheet introduction motivation complementary resources table of contents notions variable declaration var const let short explanation sample code detailed explanation external resource arrow function sample code detailed explanation concision this reference useful resources function default parameter value external resource destructuring objects and arrays explanation with sample code useful resources array methods map filter reduce sample code explanation array prototype map array prototype filter array prototype reduce external resource spread operator sample code explanation in iterables like arrays function rest parameter object properties spreading external resources object property shorthand explanation external resources promises sample code explanation create the promise promise handlers usage external resources template literals sample code external resources tagged template literals external resources imports exports explanation with sample code named exports default import export external resources javascript this external resources class samples external resources extends and super keywords sample code external resources async await sample code explanation with sample code error handling external resources truthy falsy external resources anamorphisms catamporphisms anamorphisms catamorphisms external resources generators external resources static methods short explanation sample code detailed explanation calling other static methods from a static method calling static methods from non static methods external resources glossary scope variable mutation notions variable declaration var const let in javascript there are three keywords available to declare a variable and each has its differences those are var let and const short explanation variables declared with const keyword cant be reassigned while let and var can i recommend always declaring your variables with const by default and with let if you need to mutate it or reassign it later scope reassignable mutable temporal dead zone const block no yes yes let block yes yes yes var function yes yes no sample code javascript const person nick person john will raise an error person cant be reassigned javascript let person nick person john console log person john reassignment is allowed with let detailed explanation the scope of a variable roughly means where is this variable available in the code var var declared variables are function scoped meaning that when a variable is created in a function everything in that function can access that variable besides a function scoped variable created in a function cant be accessed outside this function i recommend you to picture it as if an x scoped variable meant that this variable was a property of x javascript function myfunction var myvar nick console log myvar nick myvar is accessible inside the function console log myvar throws a referenceerror myvar is not accessible outside the function still focusing on the variable scope here is a more subtle example javascript function myfunction var myvar nick if true var myvar john console log myvar john actually myvar being function scoped we just erased the previous myvar value nick for john console log myvar john see how the instructions in the if block affected this value console log myvar throws a referenceerror myvar is not accessible outside the function besides var declared variables are moved to the top of the scope at execution this is what we call var hoisting this portion of code js console log myvar undefined no error raised var myvar 2 is understood at execution like js var myvar console log myvar undefined no error raised myvar 2 let var and let are about the same but let declared variables are block scoped are not accessible before they are assigned cant be re declared in the same scope lets see the impact of block scoping taking our previous example javascript function myfunction let myvar nick if true let myvar john console log myvar john actually myvar being block scoped we just created a new variable myvar this variable is not accessible outside this block and totally independent from the first myvar created console log myvar nick see how the instructions in the if block did not affect this value console log myvar throws a referenceerror myvar is not accessible outside the function now what it means for let and const variables for not being accessible before being assigned js console log myvar raises a referenceerror let myvar 2 by contrast with var variables if you try to read or write on a let or const variable before they are assigned an error will be raised this phenomenon is often called temporal dead zone or tdz note technically let and const variables declarations are being hoisted too but not their assignation since theyre made so that they cant be used before assignation it intuitively feels like there is no hoisting but there is find out more on this very detailed explanation here if you want to know more in addition you cant re declare a let variable js let myvar 2 let myvar 3 raises a syntaxerror const const declared variables behave like let variables but also they cant be reassigned to sum it up const variables are block scoped are not accessible before being assigned cant be re declared in the same scope cant be reassigned js const myvar nick myvar john raises an error reassignment is not allowed js const myvar nick const myvar john raises an error re declaration is not allowed but there is a subtlety const variables are not immutable concretely it means that object and array const declared variables can be mutated for objects js const person name nick person name john this will work person variable is not completely reassigned but mutated console log person name john person sandra raises an error because reassignment is not allowed with const declared variables for arrays js const person person push john this will work person variable is not completely reassigned but mutated console log person 0 john person nick raises an error because reassignment is not allowed with const declared variables external resource how let and const are scoped in javascript wesbos temporal dead zone tdz demystified arrow function the es6 javascript update has introduced arrow functions which is another way to declare and use functions here are the benefits they bring more concise this is picked up from surroundings implicit return sample code concision and implicit return js function double x return x 2 traditional way console log double 2 4 js const double x x 2 same function written as an arrow function with implicit return console log double 2 4 this reference in an arrow function this is equal to the this value of the enclosing execution context basically with arrow functions you dont have to do the that this trick before calling a function inside a function anymore js function myfunc this myvar 0 settimeout this myvar console log this myvar 1 0 detailed explanation concision arrow functions are more concise than traditional functions in many ways lets review all the possible cases implicit vs explicit return an explicit return is a function where the return keyword is used in its body js function double x return x 2 this function explicitly returns x 2 return keyword is used in the traditional way of writing functions the return was always explicit but with arrow functions you can do implicit return which means that you dont need to use the keyword return to return a value js const double x return x 2 explicit return here since this function only returns something no instructions before the return keyword we can do an implicit return js const double x x 2 correct returns x 2 to do so we only need to remove the brackets and the return keyword thats why its called an implicit return the return keyword is not there but this function will indeed return x 2 note if your function does not return a value with side effects it doesnt do an explicit nor an implicit return besides if you want to implicitly return an object you must have parentheses around it since it will conflict with the block braces js const getperson name nick age 24 console log getperson name nick age 24 object implicitly returned by arrow function only one argument if your function only takes one parameter you can omit the parentheses around it if we take back the above double code js const double x x 2 this arrow function only takes one parameter parentheses around the parameter can be avoided js const double x x 2 this arrow function only takes one parameter no arguments when there is no argument provided to an arrow function you need to provide parentheses or it wont be valid syntax js parentheses are provided everything is fine const x 2 return x js no parentheses this wont work const x 2 return x this reference to understand this subtlety introduced with arrow functions you must know how this behaves in javascript in an arrow function this is equal to the this value of the enclosing execution context what it means is that an arrow function doesnt create a new this it grabs it from its surrounding instead without arrow function if you wanted to access a variable from this in a function inside a function you had to use the that this or self this trick for instance using settimeout function inside myfunc js function myfunc this myvar 0 var that this that this trick settimeout function a new this is created in this function scope that myvar console log that myvar 1 console log this myvar undefined see function declaration above 0 but with arrow function this is taken from its surrounding js function myfunc this myvar 0 settimeout this taken from surrounding meaning myfunc here this myvar console log this myvar 1 0 useful resources arrow functions introduction wesbos javascript arrow function mdn arrow function and lexical this function default parameter value starting from es2015 javascript update you can set default value to your function parameters using the following syntax js function myfunc x 10 return x console log myfunc 10 no value is provided so x default value 10 is assigned to x in myfunc console log myfunc 5 5 a value is provided so x is equal to 5 in myfunc console log myfunc undefined 10 undefined value is provided so default value is assigned to x console log myfunc null null a value null is provided see below for more details the default parameter is applied in two and only two situations no parameter provided undefined parameter provided in other words if you pass in null the default parameter wont be applied note default value assignment can be used with destructured parameters as well see next notion to see an example external resource default parameter value es6 features default parameters mdn destructuring objects and arrays destructuring is a convenient way of creating new variables by extracting some values from data stored in objects or arrays to name a few use cases destructuring can be used to destructure function parameters or this props in react projects for instance explanation with sample code object lets consider the following object for all the samples js const person firstname nick lastname anderson age 35 sex m without destructuring js const first person firstname const age person age const city person city paris with destructuring all in one line js const firstname first age city paris person thats it console log age 35 a new variable age is created and is equal to person age console log first nick a new variable first is created and is equal to person firstname console log firstname referenceerror person firstname exists but the new variable created is named first console log city paris a new variable city is created and since person city is undefined city is equal to the default value provided paris note in const age person the brackets after const keyword are not used to declare an object nor a block but is the destructuring syntax function parameters destructuring is often used to destructure objects parameters in functions without destructuring js function joinfirstlastname person const firstname person firstname const lastname person lastname return firstname lastname joinfirstlastname person nick anderson in destructuring the object parameter person we get a more concise function js function joinfirstlastname firstname lastname we create firstname and lastname variables by destructuring person parameter return firstname lastname joinfirstlastname person nick anderson destructuring is even more pleasant to use with arrow functions js const joinfirstlastname firstname lastname firstname lastname joinfirstlastname person nick anderson array lets consider the following array js const myarray a b c without destructuring js const x myarray 0 const y myarray 1 with destructuring js const x y myarray thats it console log x a console log y b useful resources es6 features destructuring assignment destructuring objects wesbos exploringjs destructuring array methods map filter reduce map filter and reduce are array methods that are coming from a programming paradigm named functional programming to sum it up array prototype map takes an array does something on its elements and returns an array with the transformed elements array prototype filter takes an array decides element by element if it should keep it or not and returns an array with the kept elements only array prototype reduce takes an array and aggregates the elements into a single value which is returned i recommend to use them as much as possible in following the principles of functional programming because they are composable concise and elegant with those three methods you can avoid the use of for and foreach loops in most situations when you are tempted to do a for loop try to do it with map filter and reduce composed you might struggle to do it at first because it requires you to learn a new way of thinking but once youve got it things get easier sample code js const numbers 0 1 2 3 4 5 6 const doublednumbers numbers map n n 2 0 2 4 6 8 10 12 const evennumbers numbers filter n n 2 0 0 2 4 6 const sum numbers reduce prev next prev next 0 21 compute total grade sum for students with grades 10 or above by composing map filter and reduce js const students name nick grade 10 name john grade 15 name julia grade 19 name nathalie grade 9 const abovetensum students map student student grade we map the students array to an array of their grades filter grade grade 10 we filter the grades array to keep those 10 or above reduce prev next prev next 0 we sum all the grades 10 or above one by one console log abovetensum 44 10 nick 15 john 19 julia nathalie below 10 is ignored explanation lets consider the following array of numbers for our examples js const numbers 0 1 2 3 4 5 6 array prototype map js const doublednumbers numbers map function n return n 2 console log doublednumbers 0 2 4 6 8 10 12 whats happening here we are using map on the numbers array the map is iterating on each element of the array and passes it to our function the goal of the function is to produce and return a new value from the one passed so that map can replace it lets extract this function to make it more clear just for this once js const doublen function n return n 2 const doublednumbers numbers map doublen console log doublednumbers 0 2 4 6 8 10 12 note you will frequently encounter this method used in combination with arrow functions js const doublednumbers numbers map n n 2 console log doublednumbers 0 2 4 6 8 10 12 numbers map doublen produces doublen 0 doublen 1 doublen 2 doublen 3 doublen 4 doublen 5 doublen 6 which is equal to 0 2 4 6 8 10 12 note if you do not need to return a new array and just want to do a loop that has side effects you might just want to use a for foreach loop instead of a map array prototype filter js const evennumbers numbers filter function n return n 2 0 true if n is par false if n isnt console log evennumbers 0 2 4 6 note you will frequently encounter this method used in combination with arrow functions js const evennumbers numbers filter n n 2 0 console log evennumbers 0 2 4 6 we are using filter on the numbers array filter is iterating on each element of the array and passes it to our function the goal of the function is to return a boolean that will determine whether the current value will be kept or not filter then returns the array with only the kept values array prototype reduce the reduce method goal is to reduce all elements of the array it iterates on into a single value how it aggregates those elements is up to you js const sum numbers reduce function acc n return acc n 0 accumulator variable value at first iteration step console log sum 21 note you will frequently encounter this method used in combination with arrow functions js const sum numbers reduce acc n acc n 0 console log sum 21 just like for map and filter methods reduce is applied on an array and takes a function as the first parameter this time though there are changes reduce takes two parameters the first parameter is a function that will be called at each iteration step the second parameter is the value of the accumulator variable acc here at the first iteration step read next point to understand function parameters the function you pass as the first parameter of reduce takes two parameters the first one acc here is the accumulator variable whereas the second parameter n is the current element the accumulator variable is equal to the return value of your function at the previous iteration step at the first step of the iteration acc is equal to the value you passed as reduce second parameter at first iteration step acc 0 because we passed in 0 as the second parameter for reduce n 0 first element of the number array function returns acc n 0 0 0 at second iteration step acc 0 because its the value the function returned at the previous iteration step n 1 second element of the number array function returns acc n 0 1 1 at third iteration step acc 1 because its the value the function returned at the previous iteration step n 2 third element of the number array function returns acc n 1 2 3 at fourth iteration step acc 3 because its the value the function returned at the previous iteration step n 3 fourth element of the number array function returns acc n 3 3 6 at last iteration step acc 15 because its the value the function returned at the previous iteration step n 6 last element of the number array function returns acc n 15 6 21 as it is the last iteration step reduce returns 21 external resource understanding map filter reduce in js spread operator the spread operator has been introduced with es2015 and is used to expand elements of an iterable like an array into places where multiple elements can fit sample code js const arr1 a b c const arr2 arr1 d e f a b c d e f js function myfunc x y params console log x console log y console log params myfunc a b c d e f a b c d e f js const x y z x 1 y 2 a 3 b 4 console log x 1 console log y 2 console log z a 3 b 4 const n x y z console log n x 1 y 2 a 3 b 4 explanation in iterables like arrays if we have the two following arrays js const arr1 a b c const arr2 arr1 d e f a b c d e f arr2 the first element is an array because arr1 is injected as is into arr2 but what we want is arr2 to be an array of letters to do so we can spread the elements of arr1 into arr2 with spread operator js const arr1 a b c const arr2 arr1 d e f a b c d e f function rest parameter in function parameters we can use the rest operator to inject parameters into an array we can loop in there is already an arguments object bound to every function that is equal to an array of all the parameters passed into the function js function myfunc for var i 0 i arguments length i console log arguments i myfunc nick anderson 10 12 6 nick anderson 10 12 6 but lets say that we want this function to create a new student with its grades and with its average grade wouldnt it be more convenient to extract the first two parameters into two separate variables and then have all the grades in an array we can iterate over thats exactly what the rest operator allows us to do js function createstudent firstname lastname grades firstname nick lastname anderson 10 12 6 takes all other parameters passed and creates a grades array variable that contains them const avggrade grades reduce acc curr acc curr 0 grades length computes average grade from grades return firstname firstname lastname lastname grades grades avggrade avggrade const student createstudent nick anderson 10 12 6 console log student firstname nick lastname anderson grades 10 12 6 avggrade 9 33 note createstudent function is bad because we dont check if grades length exists or is different from 0 but its easier to read this way so i didnt handle this case object properties spreading for this one i recommend you read previous explanations about the rest operator on iterables and function parameters js const myobj x 1 y 2 a 3 b 4 const x y z myobj object destructuring here console log x 1 console log y 2 console log z a 3 b 4 z is the rest of the object destructured myobj object minus x and y properties destructured const n x y z console log n x 1 y 2 a 3 b 4 here z object properties are spread into n external resources tc39 object rest spread spread operator introduction wesbos javascript the spread operator 6 great uses of the spread operator object property shorthand when assigning a variable to an object property if the variable name is equal to the property name you can do the following js const x 10 const myobj x console log myobj x 10 explanation usually pre es2015 when you declare a new object literal and want to use variables as object properties values you would write this kind of code js const x 10 const y 20 const myobj x x assigning x variable value to myobj x y y assigning y variable value to myobj y console log myobj x 10 console log myobj y 20 as you can see this is quite repetitive because the properties name of myobj are the same as the variable names you want to assign to those properties with es2015 when the variable name is the same as the property name you can do this shorthand js const x 10 const y 20 const myobj x y console log myobj x 10 console log myobj y 20 external resources property shorthand es6 features promises a promise is an object which can be returned synchronously from an asynchronous function ref promises can be used to avoid callback hell and they are more and more frequently encountered in modern javascript projects sample code js const fetchingposts new promise res rej get posts done posts res posts fail err rej err fetchingposts then posts console log posts catch err console log err explanation when you do an ajax request the response is not synchronous because you want a resource that takes some time to come it even may never come if the resource you have requested is unavailable for some reason 404 to handle that kind of situation es2015 has given us promises promises can have three different states pending fulfilled rejected lets say we want to use promises to handle an ajax request to fetch the resource x create the promise we firstly are going to create a promise we will use the jquery get method to do our ajax request to x js const xfetcherpromise new promise create promise using new keyword and store it into a variable function resolve reject promise constructor takes a function parameter which has resolve and reject parameters itself get x launch the ajax request done function x once the request is done resolve x resolve the promise with the x value as parameter fail function error if the request has failed reject error reject the promise with the error as parameter as seen in the above sample the promise object takes an executor function which takes two parameters resolve and reject those parameters are functions which when called are going to move the promise pending state to respectively a fulfilled and rejected state the promise is in pending state after instance creation and its executor function is executed immediately once one of the function resolve or reject is called in the executor function the promise will call its associated handlers promise handlers usage to get the promise result or error we must attach to it handlers by doing the following js xfetcherpromise then function x console log x catch function err console log err if the promise succeeds resolve is executed and the function passed as then parameter is executed if it fails reject is executed and the function passed as catch parameter is executed note if the promise has already been fulfilled or rejected when a corresponding handler is attached the handler will be called so there is no race condition between an asynchronous operation completing and its handlers being attached ref mdn external resources javascript promises for dummies jecelyn yeen javascript promise api david walsh using promises mdn what is a promise eric elliott javascript promises an introduction jake archibald promise documentation mdn template literals template literals is an expression interpolation for single and multiple line strings in other words it is a new string syntax in which you can conveniently use any javascript expressions variables for instance sample code js const name nick hello name the following expression is equal to four 2 2 hello nick the following expression is equal to four 4 external resources string interpolation es6 features es6 template strings addy osmani tagged template literals template tags are functions that can be prefixed to a template literal when a function is called this way the first parameter is an array of the strings that appear between the templates interpolated variables and the subsequent parameters are the interpolated values use a spread operator to capture all of them ref mdn note a famous library named styled components heavily relies on this feature below is a toy example on how they work js function highlight strings values const interpolation strings reduce prev current return prev current values length values shift return interpolation const condiment jam const meal toast highlighti like condiment on meal i like jam on toast a more interesting example js function comma strings values return strings reduce prev next let value values shift value value join return prev next value const snacks apples bananas cherries commai like snacks to snack on i like apples bananas cherries to snack on external resources wes bos on tagged template literals library of common template tags imports exports es6 modules are used to access variables or functions in a module explicitly exported by the modules it imports i highly recommend to take a look at mdn resources on import export see external resources below it is both straightforward and complete explanation with sample code named exports named exports are used to export several values from a module note you can only name export first class citizens that have a name js mathconstants js export const pi 3 14 export const exp 2 7 export const alpha 0 35 myfile js import pi exp from mathconstants js named import destructuring like syntax console log pi 3 14 console log exp 2 7 mysecondfile js import as constants from mathconstants js inject all exported values into constants variable console log constants pi 3 14 console log constants exp 2 7 while named imports looks like destructuring they have a different syntax and are not the same they dont support default values nor deep destructuring besides you can do aliases but the syntax is different from the one used in destructuring js import foo as bar from myfile js foo is imported and injected into a new bar variable default import export concerning the default export there is only a single default export per module a default export can be a function a class an object or anything else this value is considered the main exported value since it will be the simplest to import ref mdn js coolnumber js const ultimatenumber 42 export default ultimatenumber myfile js import number from coolnumber js default export independently from its name is automatically injected into number variable console log number 42 function exporting js sum js export default function sum x y return x y myfile js import sum from sum js const result sum 1 2 console log result 3 external resources es6 modules in bulletpoints export mdn import mdn understanding es6 modules destructuring special case import statements misunderstanding es6 modules kent c dodds modules in javascript javascript this this operator behaves differently than in other languages and is in most cases determined by how a function is called ref mdn this notion is having many subtleties and being quite hard i highly suggest you to deep dive in the external resources below thus i will provide what i personally have in mind to determine what this is equal to i have learned this tip from this article written by yehuda katz js function myfunc after each statement you find the value of this in myfunc myfunc call mystring hello mystring first call parameter value is injected into this in non strict mode myfunc hello window myfunc is syntax sugar for myfunc call window hello in strict mode myfunc hello undefined myfunc is syntax sugar for myfunc call undefined hello js var person myfunc function person myfunc call person test person object first call parameter is injected into this person myfunc test person object person myfunc is syntax sugar for person myfunc call person test var myboundfunc person myfunc bind hello creates a new function in which we inject hello in this value person myfunc test person object the bind method has no effect on the original method myboundfunc test hello myboundfunc is person myfunc with hello bound to this external resources understanding javascript function invocation and this yehuda katz javascript this mdn class javascript is a prototype based language whereas java is class based language for instance es6 has introduced javascript classes which are meant to be a syntactic sugar for prototype based inheritance and not a new class based inheritance model ref the word class is indeed error prone if you are familiar with classes in other languages if you do avoid assuming how javascript classes work on this basis and consider it an entirely different notion since this document is not an attempt to teach you the language from the ground up i will believe you know what prototypes are and how they behave if you do not see the external resouces listed below the sample code samples before es6 prototype syntax js var person function name age this name name this age age person prototype stringsentence function return hello my name is this name and im this age with es6 class syntax js class person constructor name age this name name this age age stringsentence return hello my name is this name and i am this age const myperson new person manu 23 console log myperson age 23 console log myperson stringsentence hello my name is manu and im 23 external resources for prototype understanding understanding prototypes in js yehuda katz a plain english guide to js prototypes sebastian porto inheritance and the prototype chain mdn for classes understanding es6 classes in depth nicolas bevacqua es6 features classes javascript classes mdn extends and super keywords the extends keyword is used in class declarations or class expressions to create a class which is a child of another class ref mdn the subclass inherits all the properties of the superclass and additionally can add new properties or modify the inherited ones the super keyword is used to call functions on an objects parent including its constructor super keyword must be used before the this keyword is used in constructor invoking super calls the parent class constructor if you want to pass some arguments in a classs constructor to its parents constructor you call it with super arguments if the parent class have a method even static called x you can use super x to call it in a child class sample code js class polygon constructor height width this name polygon this height height this width width gethellophrase return hi i am a this name class square extends polygon constructor length here it calls the parent class constructor with lengths provided for the polygons width and height super length length note in derived classes super must be called before you can use this leaving this out will cause a reference error this name square this length length getcustomhellophrase const polygonphrase super gethellophrase accessing parent method with super x syntax return polygonphrase with a length of this length get area return this height this width const mysquare new square 10 console log mysquare area 100 console log mysquare gethellophrase hi i am a square square inherits from polygon and has access to its methods console log mysquare getcustomhellophrase hi i am a square with a length of 10 note if we had tried to use this before calling super in square class a referenceerror would have been raised js class square extends polygon constructor length this height referenceerror super needs to be called first here it calls the parent class constructor with lengths provided for the polygons width and height super length length note in derived classes super must be called before you can use this leaving this out will cause a reference error this name square external resources extends mdn super operator mdn inheritance mdn async await in addition to promises there is a new syntax you might encounter to handle asynchronous code named async await the purpose of async await functions is to simplify the behavior of using promises synchronously and to perform some behavior on a group of promises just as promises are similar to structured callbacks async await is similar to combining generators and promises async functions always return a promise ref mdn note you must understand what promises are and how they work before trying to understand async await since they rely on it note 2 await must be used in an async function which means that you cant use await in the top level of our code since that is not inside an async function sample code js async function getgithubuser username async keyword allows usage of await in the function and means function returns a promise const response await fetch https api github com users username execution is paused here until the promise returned by fetch is resolved return response json getgithubuser mbeaudru then user console log user logging user response cannot use await syntax since this code isnt in async function catch err console log err if an error is thrown in our async function we will catch it here explanation with sample code async await is built on promises but they allow a more imperative style of code the async operator marks a function as asynchronous and will always return a promise you can use the await operator in an async function to pause execution on that line until the returned promise from the expression either resolves or rejects js async function myfunc we can use await operator because this function is async return hello world myfunc then msg console log msg hello world myfuncs return value is turned into a promise because of async operator when the return statement of an async function is reached the promise is fulfilled with the value returned if an error is thrown inside an async function the promise state will turn to rejected if no value is returned from an async function a promise is still returned and resolves with no value when execution of the async function is complete await operator is used to wait for a promise to be fulfilled and can only be used inside an async function body when encountered the code execution is paused until the promise is fulfilled note fetch is a function that returns a promise that allows to do an ajax request lets see how we could fetch a github user with promises first js function getgithubuser username return fetch https api github com users username then response response json getgithubuser mbeaudru then user console log user catch err console log err heres the async await equivalent js async function getgithubuser username promise await keyword usage allowed const response await fetch https api github com users username execution stops here until fetch promise is fulfilled return response json getgithubuser mbeaudru then user console log user catch err console log err async await syntax is particularly convenient when you need to chain promises that are interdependent for instance if you need to get a token in order to be able to fetch a blog post on a database and then the author informations note await expressions needs to be wrapped in parentheses to call its resolved values methods and properties on the same line js async function fetchpostbyid postid const token await fetch token url json token const post await fetch posts postid token token json const author await fetch users post authorid json post author author return post fetchpostbyid gzirzeo64 then post console log post catch err console log err error handling unless we add try catch blocks around await expressions uncaught exceptions – regardless of whether they were thrown in the body of your async function or while its suspended during await – will reject the promise returned by the async function using the throw statement in an async function is the same as returning a promise that rejects ref ponyfoo note promises behave the same with promises here is how you would handle the error chain js function getuser this promise will be rejected return new promise res rej rej user not found function getavatarbyusername userid return getuser userid then user user avatar function getuseravatar username return getavatarbyusername username then avatar username avatar getuseravatar mbeaudru then res console log res catch err console log err user not found the equivalent with async await js async function getuser the returned promise will be rejected throw user not found async function getavatarbyusername userid const user await getuser userid return user avatar async function getuseravatar username var avatar await getavatarbyusername username return username avatar getuseravatar mbeaudru then res console log res catch err console log err user not found external resources async await javascript info es7 async await 6 reasons why javascripts async await blows promises away javascript awaits using async await in express with node 8 async function await using async await in express with node 8 truthy falsy in javascript a truthy or falsy value is a value that is being casted into a boolean when evaluated in a boolean context an example of boolean context would be the evaluation of an if condition every value will be casted to true unless they are equal to false 0 empty string null undefined nan here are examples of boolean context if condition evaluation js if myvar myvar can be any first class citizen variable function boolean but it will be casted into a boolean because its evaluated in a boolean context after logical not operator this operator returns false if its single operand can be converted to true otherwise returns true js 0 true 0 is falsy so it returns true 0 false 0 is falsy so 0 returns true so 0 returns false false empty string is falsy so not not false equals false with the boolean object constructor js new boolean 0 false new boolean 1 true in a ternary evaluation js myvar truthy falsy myvar is evaluated in a boolean context be careful when comparing 2 values the object values that should be cast to true is not being casted to boolean but it forced to convert into a primitive value one using toprimitives specification internally when an object is compared to boolean value like true it does tostring true so js let a true a is false since tostring give back let b 1 true b is true since 1 tostring give 1 back let c 2 true c is false since 2 tostring give 2 back external resources truthy mdn falsy mdn truthy and falsy values in js josh clanton anamorphisms and catamorphisms anamorphisms anamorphisms are functions that map from some object to a more complex structure containing the type of the object it is the process of unfolding a simple structure into a more complex one consider unfolding an integer to a list of integers the integer is our initial object and the list of integers is the more complex structure sample code js function downtoone n const list for let i n i 0 i list push i return list downtoone 5 5 4 3 2 1 catamorphisms catamorphisms are the opposite of anamorphisms in that they take objects of more complex structure and fold them into simpler structures take the following example product which take a list of integers and returns a single integer sample code js function product list let product 1 for const n of list product product n return product product downtoone 5 120 external resources anamorphisms in javascript anamorphism catamorphism generators another way to write the downtoone function is to use a generator to instantiate a generator object one must use the function declaration generators are functions that can be exited and later re entered with its context variable bindings saved across re entrances for example the downtoone function above can be rewritten as js function downtoone n for let i n i 0 i yield i downtoone 5 5 4 3 2 1 generators return an iterable object when the iterators next function is called it is executed until the first yield expression which specifies the value to be returned from the iterator or with yield which delegates to another generator function when a return expression is called in the generator it will mark the generator as done and pass back as the return value further calls to next will not return any new values sample code js yield example function idmaker var index 0 while index 2 yield index index index 1 var gen idmaker gen next value 0 gen next value 1 gen next value undefined the yield expression enables a generator to call another generator function during iteration js yield example function genb i yield i 1 yield i 2 yield i 3 function gena i yield i yield genb i yield i 10 var gen gena 10 gen next value 10 gen next value 11 gen next value 12 gen next value 13 gen next value 20 js generator return example function yieldandreturn yield y return r yield unreachable var gen yieldandreturn gen next value y done false gen next value r done true gen next value undefined done true external resources mozilla mdn web docs iterators and generators static methods short explanation the static keyword is used in classes to declare static methods static methods are functions in a class that belongs to the class object and are not available to any instance of that class sample code js class repo static getname return repo name is modern js cheatsheet note that we did not have to create an instance of the repo class console log repo getname repo name is modern js cheatsheet let r new repo console log r getname uncaught typeerror r getname is not a function detailed explanation static methods can be called within another static method by using the this keyword this doesnt work for non static methods though non static methods cannot directly access static methods using the this keyword calling other static methods from a static method to call a static method from another static method the this keyword can be used like so js class repo static getname return repo name is modern js cheatsheet static modifyname return this getname added this console log repo modifyname repo name is modern js cheatsheet added this calling static methods from non static methods non static methods can call static methods in 2 ways 1 using the class name to get access to a static method from a non static method we use the class name and call the static method like a property e g classname staticmethodname js class repo static getname return repo name is modern js cheatsheet usename return repo getname and it contains some really important stuff we need to instantiate the class to use non static methods let r new repo console log r usename repo name is modern js cheatsheet and it contains some really important stuff using the constructor static methods can be called as properties on the constructor object js class repo static getname return repo name is modern js cheatsheet usename calls the static method as a property of the constructor return this constructor getname and it contains some really important stuff we need to instantiate the class to use non static methods let r new repo console log r usename repo name is modern js cheatsheet and it contains some really important stuff external resources static keyword mdn static methods javascript info static members in es6 odetocode glossary scope the context in which values and expressions are visible or can be referenced if a variable or other expression is not in the current scope then it is unavailable for use source mdn variable mutation a variable is said to have been mutated when its initial value has changed afterward js var myarray myarray push firstel myarray is being mutated a variable is said to be immutable if it cant be mutated check mdn mutable article for more details