resque resque pronounced like rescue is a redis backed library for creating background jobs placing those jobs on multiple queues and processing them later background jobs can be any ruby class or module that responds to perform your existing classes can easily be converted to background jobs or you can create new classes specifically to do work or you can do both resque is heavily inspired by delayedjob which rocks and comprises three parts a ruby library for creating querying and processing jobs a rake task for starting a worker which processes jobs a sinatra app for monitoring queues jobs and workers resque workers can be distributed between multiple machines support priorities are resilient to memory bloat leaks are optimized for ree but work on mri and jruby tell you what theyre doing and expect failure resque queues are persistent support constant time atomic push and pop thanks to redis provide visibility into their contents and store jobs as simple json packages the resque frontend tells you what workers are doing what workers are not doing what queues youre using whats in those queues provides general usage stats and helps you track failures resque now supports ruby 2 0 0 and above any future updates will not be guaranteed to work without defects on any rubies older than 2 0 0 we will also only be supporting redis 3 0 and above going forward the blog post for the backstory philosophy and history of resques beginnings please see the blog post overview resque allows you to create jobs and place them on a queue then later pull those jobs off the queue and process them resque jobs are ruby classes or modules which respond to the perform method heres an example ruby class archive queue file serve def self perform repo id branch master repo repository find repo id repo create archive branch end end the queue class instance variable determines which queue archive jobs will be placed in queues are arbitrary and created on the fly you can name them whatever you want and have as many as you want to place an archive job on the file serve queue we might add this to our applications pre existing repository class ruby class repository def async create archive branch resque enqueue archive self id branch end end now when we call repo async create archive masterbrew in our application a job will be created and placed on the file serve queue later a worker will run something like this code to process the job ruby klass args resque reserve file serve klass perform args if klass respond to perform which translates to ruby archive perform 44 masterbrew lets start a worker to run file serve jobs cd app root queue file serve rake resque work this starts one resque worker and tells it to work off the file serve queue as soon as its ready itll try to run the resque reserve code snippet above and process jobs until it cant find any more at which point it will sleep for a small period and repeatedly poll the queue for more jobs workers can be given multiple queues a queue list and run on multiple machines in fact they can be run anywhere with network access to the redis server jobs what should you run in the background anything that takes any time at all slow insert statements disk manipulating data processing etc at github we use resque to process the following types of jobs warming caches counting disk usage building tarballs building rubygems firing off web hooks creating events in the db and pre caching them building graphs deleting users updating our search index as of writing we have about 35 different types of background jobs keep in mind that you dont need a web app to use resque we just mention foreground and background because they make conceptual sense you could easily be spidering sites and sticking data which needs to be crunched later into a queue persistence jobs are persisted to queues as json objects lets take our archive example from above well run the following code to create a job ruby repo repository find 44 repo async create archive masterbrew the following json will be stored in the file serve queue javascript class archive args 44 masterbrew because of this your jobs must only accept arguments that can be json encoded so instead of doing this ruby resque enqueue archive self branch do this ruby resque enqueue archive self id branch this is why our above example and all the examples in examples uses object ids instead of passing around the objects while this is less convenient than just sticking a marshaled object in the database it gives you a slight advantage your jobs will be run against the most recent version of an object because they need to pull from the db or cache if your jobs were run against marshaled objects they could potentially be operating on a stale record with out of date information send later async want something like delayedjobs send later or the ability to use instance methods instead of just methods for jobs see the examples directory for goodies we plan to provide first class async support in a future release failure if a job raises an exception it is logged and handed off to the resque failure module failures are logged either locally in redis or using some different backend to see exceptions while developing see details below under logging for example resque ships with airbrake support to configure it put the following into an initialisation file or into your rake job ruby send errors which occur in background jobs to redis and airbrake require resque failure multiple require resque failure redis require resque failure airbrake resque failure multiple classes resque failure redis resque failure airbrake resque failure backend resque failure multiple keep this in mind when writing your jobs you may want to throw exceptions you would not normally throw in order to assist debugging workers resque workers are rake tasks that run forever they basically do this ruby start loop do if job reserve job process else sleep 5 polling frequency 5 end end shutdown starting a worker is simple heres our example from earlier queue file serve rake resque work by default resque wont know about your applications environment that is it wont be able to find and run your jobs it needs to load your application into memory if weve installed resque as a rails plugin we might run this command from our rails root queue file serve rake environment resque work this will load the environment before starting a worker alternately we can define a resque setup task with a dependency on the environment rake task ruby task resque setup environment githubs setup task looks like this ruby task resque setup environment do grit git git timeout 10 minutes end we dont want the git timeout as high as 10 minutes in our web app but in the resque workers its fine logging workers support basic logging to stdout you can control the logging threshold using resque logger level ruby config initializers resque rb resque logger level logger debug if you want resque to log to a file in rails do ruby config initializers resque rb resque logger logger new rails root join log rails env resque log process ids pids there are scenarios where its helpful to record the pid of a resque worker process use the pidfile option for easy access to the pid pidfile resque pid queue file serve rake environment resque work running in the background there are scenarios where its helpful for the resque worker to run itself in the background usually in combination with pidfile use the background option so that rake will return as soon as the worker is started pidfile resque pid background yes queue file serve \ rake environment resque work polling frequency you can pass an interval option which is a float representing the polling frequency the default is 5 seconds but for a semi active app you may want to use a smaller value interval 0 1 queue file serve rake environment resque work priorities and queue lists resque doesnt support numeric priorities but instead uses the order of queues you give it we call this list of queues the queue list lets say we add a warm cache queue in addition to our file serve queue wed now start a worker like so queues file serve warm cache rake resque work when the worker looks for new jobs it will first check file serve if it finds a job itll process it then check file serve again it will keep checking file serve until no more jobs are available at that point it will check warm cache if it finds a job itll process it then check file serve repeating the whole process in this way you can prioritize certain queues at github we start our workers with something like this queues critical archive high low rake resque work notice the archive queue it is specialized and in our future architecture will only be run from a single machine at that point well start workers on our generalized background machines with this command queues critical high low rake resque work and workers on our specialized archive machine with this command queue archive rake resque work running all queues if you want your workers to work off of every queue including new queues created on the fly you can use a splat queue rake resque work queues will be processed in alphabetical order running multiple workers at github we use god to start and stop multiple workers a sample god configuration file is included under examples god we recommend this method if youd like to run multiple workers in development mode you can do so using the resque workers rake task count 5 queue rake resque workers this will spawn five resque workers each in its own process hitting ctrl c should be sufficient to stop them all forking on certain platforms when a resque worker reserves a job it immediately forks a child process the child processes the job then exits when the child has exited successfully the worker reserves another job and repeats the process why because resque assumes chaos resque assumes your background workers will lock up run too long or have unwanted memory growth if resque workers processed jobs themselves itd be hard to whip them into shape lets say one is using too much memory you send it a signal that says shutdown after you finish processing the current job and it does so it then starts up again loading your entire application environment this adds useless cpu cycles and causes a delay in queue processing plus what if its using too much memory and has stopped responding to signals thanks to resques parent child architecture jobs that use too much memory release that memory upon completion no unwanted growth and what if a job is running too long youd need to kill 9 it then start the worker again with resques parent child architecture you can tell the parent to forcefully kill the child then immediately start processing more jobs no startup delay or wasted cycles the parent child architecture helps us keep tabs on what workers are doing too by eliminating the need to kill 9 workers we can have parents remove themselves from the global listing of workers if we just ruthlessly killed workers wed need a separate watchdog process to add and remove them to the global listing which becomes complicated workers instead handle their own state parents and children heres a parent child pair doing some work ps e o pid command grep r esque 92099 resque forked 92102 at 1253142769 92102 resque processing file serve since 1253142769 you can clearly see that process 92099 forked 92102 which has been working since 1253142769 by advertising the time they began processing you can easily use monit or god to kill stale workers when a parent process is idle it lets you know what queues it is waiting for work on ps e o pid command grep r esque 92099 resque waiting for file serve warm cache signals resque workers respond to a few different signals quit wait for child to finish processing then exit term int immediately kill child then exit usr1 immediately kill child but dont exit usr2 dont start to process any new jobs cont start to process new jobs again after a usr2 if you want to gracefully shutdown a resque worker use quit if you want to kill a stale or stuck child use usr1 processing will continue as normal unless the child was not found in that case resque assumes the parent process is in a bad state and shuts down if you want to kill a stale or stuck child and shutdown use term if you want to stop processing jobs but want to leave the worker running for example to temporarily alleviate load use usr2 to stop processing then cont to start it again signals on heroku when shutting down processes heroku sends every process a term signal at the same time by default this causes an immediate shutdown of any running job leading to frequent resque termexception errors for short running jobs a simple solution is to give a small amount of time for the job to finish before killing it resque doesnt handle this out of the box for both cedar 14 and heroku 16 you need to install the resque heroku signals addon which adds the required signal handling to make the behavior described above work related issue https github com resque resque issues 1559 to accomplish this set the following environment variables resque pre shutdown timeout the time between the parent receiving a shutdown signal term by default and it sending that signal on to the child process designed to give the child process time to complete before being forced to die term child must be set for resque pre shutdown timeout to be used after the timeout if the child is still running it will raise a resque termexception and exit resque term timeout by default you have a few seconds to handle resque termexception in your job resque term timeout and resque pre shutdown timeout must be lower than the heroku dyno timeout mysql error mysql server has gone away if your workers remain idle for too long they may lose their mysql connection depending on your version of rails we recommend the following rails 3 x in your perform method add the following line ruby class mytask def self perform activerecord base verify active connections rest of your code end end the rails doc says the following about verify active connections verify active connections and remove and disconnect connections associated with stale threads rails 4 x in your perform method instead of verify active connections use ruby class mytask def self perform activerecord base clear active connections rest of your code end end from the rails docs on clear active connections returns any connections in use by the current thread back to the pool and also returns connections to the pool cached by threads that are no longer alive activejob if youre going to need to use the database in a number of different jobs consider adding this to your applicationjob file ruby class applicationjob activejob base before perform do job activerecord base clear active connections end end the front end resque comes with a sinatra based front end for seeing whats up with your queue standalone if youve installed resque as a gem running the front end standalone is easy resque web its a thin layer around rackup so its configurable as well resque web p 8282 if you have a resque config file you want evaluated just pass it to the script as the final argument resque web p 8282 rails root config initializers resque rb you can also set the namespace directly using resque web resque web p 8282 n myapp or set the redis connection string if you need to do something like select a different database resque web p 8282 r localhost 6379 2 passenger using passenger resque ships with a config ru you can use see phusions guide apache https www phusionpassenger com library deploy apache deploy ruby nginx https www phusionpassenger com library deploy nginx deploy ruby rack urlmap if you want to load resque on a subpath possibly alongside other apps its easy to do with racks urlmap ruby require resque server run rack urlmap new \ your app new resque resque server new check examples demo config ru for a functional example including http basic auth rails 3 you can also mount resque on a subpath in your existing rails 3 app by adding require resque server to the top of your routes file or in an initializer then adding this to routes rb ruby mount resque server new at resque resque vs delayedjob how does resque compare to delayedjob and why would you choose one over the other resque supports multiple queues delayedjob supports finer grained priorities resque workers are resilient to memory leaks bloat delayedjob workers are extremely simple and easy to modify resque requires redis delayedjob requires activerecord resque can only place jsonable ruby objects on a queue as arguments delayedjob can place any ruby object on its queue as arguments resque includes a sinatra app for monitoring whats going on delayedjob can be queried from within your rails app if you want to add an interface if youre doing rails development you already have a database and activerecord delayedjob is super easy to setup and works great github used it for many months to process almost 200 million jobs choose resque if you need multiple queues you dont care dislike numeric priorities you dont need to persist every ruby object ever you have potentially huge queues you want to see whats going on you expect a lot of failure chaos you can setup redis youre not running short on ram choose delayedjob if you like numeric priorities youre not doing a gigantic amount of jobs each day your queue stays small and nimble there is not a lot failure chaos you want to easily throw anything on the queue you dont want to setup redis in no way is resque a better delayedjob so make sure you pick the tool thats best for your app resque dependencies gem install bundler bundle install installing resque in a rack app as a gem first install the gem gem install resque next include it in your application ruby require resque now start your application rackup config ru thats it you can now create resque jobs from within your app to start a worker create a rakefile in your apps root or add this to an existing rakefile ruby require your app require resque tasks if youre using rails 5 x include the following in lib tasks resque rake ruby require resque tasks task resque setup environment now queue rake resque work alternately you can define a resque setup hook in your rakefile if you dont want to load your app every time rake runs in a rails 2 x app as a gem first install the gem gem install resque next include it in your application cat config initializers load resque rb require resque now start your application script server thats it you can now create resque jobs from within your app to start a worker add this to your rakefile in rails root ruby require resque tasks now queue rake environment resque work dont forget you can define a resque setup hook in lib tasks whatever rake that loads the environment task every time in a rails 2 x app as a plugin script plugin install git github com resque resque thats it resque will automatically be available when your rails app loads to start a worker queue rake environment resque work dont forget you can define a resque setup hook in lib tasks whatever rake that loads the environment task every time in a rails 3 x or 4 x app as a gem first include it in your gemfile cat gemfile gem resque next install it with bundler bundle install now start your application rails server thats it you can now create resque jobs from within your app to start a worker add this to a file in lib tasks ex lib tasks resque rake ruby require resque tasks now queue rake environment resque work dont forget you can define a resque setup hook in lib tasks whatever rake that loads the environment task every time configuration you may want to change the redis host and port resque connects to or set various other options at startup resque has a redis setter which can be given a string or a redis object this means if youre already using redis in your app resque can re use the existing connection string resque redis localhost 6379 redis resque redis redis for our rails app we have a config initializers resque rb file where we load config resque yml by hand and set the redis information appropriately heres our config resque yml development localhost 6379 test localhost 6379 staging redis1 se github com 6379 fi localhost 6379 production env redis url and our initializer ruby rails root env rails root file dirname file rails env env rails env development config file rails root config resque yml resque config yaml load erb new io read config file result resque redis resque config rails env easy peasy why not just use rails root and rails env because this way we can tell our sinatra app about the config file rails env production resque web rails root config initializers resque rb now everyone is on the same page also you could disable jobs queueing by setting inline attribute for example if you want to run all jobs in the same process for cucumber try ruby resque inline env rails env cucumber plugins and hooks for a list of available plugins see http wiki github com resque resque plugins if youd like to write your own plugin or want to customize resque using hooks such as resque after fork see docs hooks md namespaces if youre running multiple separate instances of resque you may want to namespace the keyspaces so they do not overlap this is not unlike the approach taken by many memcached clients this feature is provided by the redis namespace library which resque uses by default to separate the keys it manages from other keys in your redis server simply use the resque redis namespace accessor ruby resque redis namespace resque github we recommend sticking this in your initializer somewhere after redis is configured demo resque ships with a demo sinatra app for creating jobs that are later processed in the background try it out by looking at the readme found at examples demo readme markdown monitoring god if youre using god to monitor resque we have provided example configs in examples god one is for starting stopping workers the other is for killing workers that have been running too long monit if youre using monit examples monit resque monit is provided free of charge this is not used by github in production so please send patches for any tweaks or improvements you can make to it questions please add them to the faq or open an issue on this repo development want to hack on resque first clone the repo and run the tests git clone git github com resque resque git cd resque rake test if the tests do not pass make sure you have redis installed correctly though we make an effort to tell you if we feel this is the case the tests attempt to start an isolated instance of redis to run against also make sure youve installed all the dependencies correctly for example try loading the redis namespace gem after youve installed it irb require rubygems true require redis namespace true if you get an error requiring any of the dependencies you may have failed to install them or be seeing load path issues contributing read contributing md first once youve made your great commits fork resque create a topic branch git checkout b my branch push to your branch git push origin my branch create a pull request from your branch thats it mailing list this mailing list is no longer maintained the archive can be found at http librelist com browser resque meta code git clone git github com resque resque git home http github com resque resque docs http rubydoc info gems resque bugs http github com resque resque issues list resque librelist com chat gems http gemcutter org gems resque this project uses semantic versioning author chris wanstrath chris ozmm org defunkt