martini note the martini framework is no longer maintained martini is a powerful package for quickly writing modular web applications services in golang language translations 繁體中文 简体中文 português brasileiro pt br español 한국어 번역 русский 日本語 french turkish german polski getting started after installing go and setting up your gopath create your first go file well call it server go go package main import github com go martini martini func main m martini classic m get func string return hello world m run then install the martini package go 1 1 or greater is required go get github com go martini martini then run your server go run server go you will now have a martini webserver running on localhost 3000 getting help join the mailing list watch the demo video ask questions on stackoverflow using the martini tag godoc documentation features extremely simple to use non intrusive design plays nice with other golang packages awesome path matching and routing modular design easy to add functionality easy to rip stuff out lots of good handlers middlewares to use great out of the box feature set fully compatible with the http handlerfunc interface default document serving e g for serving angularjs apps in html5 mode more middleware for more middleware and functionality check out the repositories in the martini contrib organization table of contents classic martini handlers routing services serving static files middleware handlers next martini env faq classic martini to get up and running quickly martini classic provides some reasonable defaults that work well for most web applications go m martini classic middleware and routing goes here m run below is some of the functionality martini classic pulls in automatically request response logging martini logger panic recovery martini recovery static file serving martini static routing martini router handlers handlers are the heart and soul of martini a handler is basically any kind of callable function go m get func println hello world return values if a handler returns something martini will write the result to the current http responsewriter as a string go m get func string return hello world http 200 hello world you can also optionally return a status code go m get func int string return 418 im a teapot http 418 im a teapot service injection handlers are invoked via reflection martini makes use of dependency injection to resolve dependencies in a handlers argument list this makes martini completely compatible with golangs http handlerfunc interface if you add an argument to your handler martini will search its list of services and attempt to resolve the dependency via type assertion go m get func res http responsewriter req http request res and req are injected by martini res writeheader 200 http 200 the following services are included with martini classic log logger global logger for martini martini context http request context martini params map string string of named params found by route matching martini routes route helper service martini route current active route http responsewriter http response writer interface http request http request routing in martini a route is an http method paired with a url matching pattern each route can take one or more handler methods go m get func show something m patch func update something m post func create something m put func replace something m delete func destroy something m options func http options m notfound func handle 404 routes are matched in the order they are defined the first route that matches the request is invoked route patterns may include named parameters accessible via the martini params service go m get hello name func params martini params string return hello params name routes can be matched with globs go m get hello func params martini params string return hello params 1 regular expressions can be used as well go m get hello p a za z func params martini params string return fmt sprintf hello s params name take a look at the go documentation for more info about regular expressions syntax route handlers can be stacked on top of each other which is useful for things like authentication and authorization go m get secret authorize func this will execute as long as authorize doesnt write a response route groups can be added too using the group method go m group books func r martini router r get id getbooks r post new newbook r put update id updatebook r delete delete id deletebook just like you can pass middlewares to a handler you can pass middlewares to groups go m group books func r martini router r get id getbooks r post new newbook r put update id updatebook r delete delete id deletebook mymiddleware1 mymiddleware2 services services are objects that are available to be injected into a handlers argument list you can map a service on a global or request level global mapping a martini instance implements the inject injector interface so mapping a service is easy go db mydatabase m martini classic m map db the service will be available to all handlers as mydatabase m run request level mapping mapping on the request level can be done in a handler via martini context go func mycustomloggerhandler c martini context req http request logger mycustomlogger req c map logger mapped as mycustomlogger mapping values to interfaces one of the most powerful parts about services is the ability to map a service to an interface for instance if you wanted to override the http responsewriter with an object that wrapped it and performed extra operations you can write the following handler go func wrapresponsewriter res http responsewriter c martini context rw newspecialresponsewriter res c mapto rw http responsewriter nil override responsewriter with our wrapper responsewriter serving static files a martini classic instance automatically serves static files from the public directory in the root of your server you can serve from more directories by adding more martini static handlers go m use martini static assets serve from the assets directory as well serving a default document you can specify the url of a local file to serve when the requested url is not found you can also specify an exclusion prefix so that certain urls are ignored this is useful for servers that serve both static files and have additional handlers defined e g rest api when doing so its useful to define the static handler as a part of the notfound chain the following example serves the index html file whenever any url is requested that does not match any local file and does not start with api v go static martini static assets martini staticoptions fallback index html exclude api v m notfound static http notfound middleware handlers middleware handlers sit between the incoming http request and the router in essence they are no different than any other handler in martini you can add a middleware handler to the stack like so go m use func do some middleware stuff you can have full control over the middleware stack with the handlers function this will replace any handlers that have been previously set go m handlers middleware1 middleware2 middleware3 middleware handlers work really well for things like logging authorization authentication sessions gzipping error pages and any other operations that must happen before or after an http request go validate an api key m use func res http responsewriter req http request if req header get x api key secret123 res writeheader http statusunauthorized next context next is an optional function that middleware handlers can call to yield the until after the other handlers have been executed this works really well for any operations that must happen after an http request go log before and after a request m use func c martini context log log logger log println before a request c next log println after a request martini env some martini handlers make use of the martini env global variable to provide special functionality for development environments vs production environments it is recommended that the martini env production environment variable to be set when deploying a martini server into a production environment faq where do i find middleware x start by looking in the martini contrib projects if it is not there feel free to contact a martini contrib team member about adding a new repo to the organization acceptlang handler for parsing the accept language http header accessflags handler to enable access control auth handlers for authentication binding handler for mapping validating a raw request into a structure cors handler that enables cors support csrf csrf protection for applications encoder encoder service for rendering data in several formats and content negotiation gzip handler for adding gzip compress to requests gorelic newrelic middleware logstasher middleware that prints logstash compatible json method http method overriding via header or form fields oauth2 handler that provides oauth 2 0 login for martini apps google sign in facebook connect and github login is supported permissions2 handler for keeping track of users login states and permissions render handler that provides a service for easily rendering json and html templates secure implements a few quick security wins sessions handler that provides a session service sessionauth handler that provides a simple way to make routes require a login and to handle user logins in the session strict strict mode strip url prefix stripping staticbin handler for serving static files from binary data throttle request rate throttling middleware vauth handlers for vender webhook authentication currently github and travisci web hoisie web gos context how do i integrate with existing servers a martini instance implements http handler so it can easily be used to serve subtrees on existing go servers for example this is a working martini app for google app engine go package hello import net http github com go martini martini func init m martini classic m get func string return hello world http handle m how do i change the port host martinis run function looks for the port and host environment variables and uses those otherwise martini will default to localhost 3000 to have more flexibility over port and host use the martini runonaddr function instead go m martini classic m runonaddr 8080 live code reload gin and fresh both live reload martini apps contributing martini is meant to be kept tiny and clean most contributions should end up in a repository in the martini contrib organization if you do have a contribution for the core of martini feel free to put up a pull request license martini is distributed by the mit license see license about inspired by express and sinatra martini is obsessively designed by none other than the code gangsta