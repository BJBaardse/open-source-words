Hyperapp Hyperapp is a JavaScript micro-framework for building web applications. Minimal — We have aggressively minimized the concepts you need to understand to be productive while remaining on par with what other frameworks can do. Pragmatic — Hyperapp holds firm on the functional programming front when managing your state, but takes a pragmatic approach to allowing for side effects, asynchronous actions, and DOM manipulations. Standalone — Do more with less. Hyperapp combines state management with a virtual DOM engine that supports keyed updates & lifecycle events — all with no dependencies. Getting Started Our first example is a counter that can be incremented or decremented. Go ahead and try it online. ```jsx import { h, app } from "hyperapp" const state = { count: 0 } const actions = { down: value => state => ({ count: state.count - value }), up: value => state => ({ count: state.count + value }) } const view = (state, actions) => ( {state.count} actions.down(1)}>- actions.up(1)}>+ ) app(state, actions, view, document.body) ``` Hyperapp consists of a two-function API. hyperapp.h returns a new virtual DOM node tree and hyperapp.app mounts a new application in the specified DOM element. Without an element, its possible to use Hyperapp "headless", which can be useful when unit testing your program. This example assumes you are using a JavaScript compiler like Babel or TypeScript and a module bundler like Parcel, Webpack, etc. If you are using JSX, all you need to do is install the JSX transform plugin and add the pragma option to your .babelrc file. json { "plugins": [["transform-react-jsx", { "pragma": "h" }]] } JSX is a language syntax extension that lets you write HTML tags interspersed with JavaScript. Because browsers dont understand JSX, we use a compiler to transform it into hyperapp.h function calls under the hood. jsx const view = (state, actions) => h("div", {}, [ h("h1", {}, state.count), h("button", { onclick: () => actions.down(1) }, "-"), h("button", { onclick: () => actions.up(1) }, "+") ]) Note that JSX is not required for building applications with Hyperapp. You can use hyperapp.h directly and without a compilation step as shown above. Other alternatives to JSX include @hyperapp/html, hyperx, t7 and ijk. Installation Install with npm or Yarn. npm i hyperapp Then with a module bundler like Rollup or Webpack, use as you would anything else. js import { h, app } from "hyperapp" If you dont want to set up a build environment, you can download Hyperapp from a CDN like unpkg.com and it will be globally available through the window.hyperapp object. We support all ES5-compliant browsers, including Internet Explorer 10 and above. html <script src="https://unpkg.com/hyperapp"></script> Overview Hyperapp applications consist of three interconnected parts: the state, view, and actions. Once initialized, your application executes in a continuous loop, taking in actions from users or from external events, updating the state, and representing changes in the view through a virtual DOM model. Think of an action as a signal that notifies Hyperapp to update the state and schedule the next view redraw. After processing an action, the new state is presented back to the user. State The state is a plain JavaScript object that describes your entire program. It consists of all the dynamic data that is moved around in the application during its execution. The state cannot be mutated once it is created. We must use actions to update it. js const state = { count: 0 } Like any JavaScript object, the state can be a nested tree of objects. We refer to nested objects in the state as partial state. A single state tree does not conflict with modularity — see Nested Actions to find out how to update deeply nested objects and split your state and actions. js const state = { top: { count: 0 }, bottom: { count: 0 } } Because Hyperapp performs a shallow merge when updating your state, the top-level state must be a plain JavaScript object, other than this, you can use any type, including arrays, ES6 Maps, Sets, Immutable.js structures, etc. Actions The only way to change the state is via actions. An action is a unary function (accepts a single argument) expecting a payload. The payload can be anything you want to pass into the action. To update the state, an action must return a partial state object. The new state will be the result of a shallow merge between this object and the current state. Under the hood, Hyperapp wires every function from your actions to schedule a view redraw whenever the state changes. js const actions = { setValue: value => ({ value }) } Instead of returning a partial state object directly, an action can return a function that takes the current state and actions as arguments and returns a partial state object. js const actions = { down: value => state => ({ count: state.count - value }), up: value => state => ({ count: state.count + value }) } State updates are always immutable. Do not mutate the state object argument within an action and return it — the results are not what you expect (e.g., the view will not be redrawn). Immutability enables time-travel debugging, helps prevent introducing hard-to-track-down bugs by making state changes more predictable, and allows cheap memoization of components using shallow equality === checks. Asynchronous Actions Actions used for side effects (writing to databases, sending a request to a server, etc.) dont need to have a return value. You may call an action from within another action or callback function. Actions which return a Promise, undefined or null will not trigger redraws or update the state. js const actions = { upLater: value => (state, actions) => { setTimeout(actions.up, 1000, value) }, up: value => state => ({ count: state.count + value }) } An action can be an async function. Because async functions return a Promise, and not a partial state object, you need to call another action in order to update the state. js const actions = { upLater: () => async (state, actions) => { await new Promise(done => setTimeout(done, 1000)) actions.up(10) }, up: value => state => ({ count: state.count + value }) } Nested Actions Actions can be nested inside namespaces. Updating deeply nested state is as easy as declaring actions inside an object in the same path as the part of the state you want to update. ```jsx const state = { counter: { count: 0 } } const actions = { counter: { down: value => state => ({ count: state.count - value }), up: value => state => ({ count: state.count + value }) } } ``` Interoperability The app function returns a copy of your actions where every function is wired to changes in the state. Exposing this object to the outside world can be useful to operate your application from another program or framework, subscribe to global events, listen to mouse and keyboard input, etc. To see this in action, modify the example from Getting Started to save the wired actions to a variable and try using them. You should see the counter update accordingly. ```jsx const main = app(state, actions, view, document.body) setInterval(main.up, 250, 1) setInterval(main.down, 500, 1) ``` Including an action returning the state argument can be useful. Because state updates are always immutable, returning a reference to the current state will not schedule a view redraw. jsx const actions = { getState: () => state => state } View Every time your application state changes, the view function is called so that you can specify how you want the DOM to look based on the new state. The view returns your specification in the form of a plain JavaScript object known as a virtual DOM and Hyperapp takes care of updating the actual DOM to match it. ```js import { h } from "hyperapp" export const view = (state, actions) => h("div", {}, [ h("h1", {}, state.count), h("button", { onclick: () => actions.down(1) }, "-"), h("button", { onclick: () => actions.up(1) }, "+") ]) ``` A virtual DOM is a description of what a DOM should look like using a tree of nested JavaScript objects known as virtual nodes. Think of it as a lightweight representation of the DOM. In the example, the view function returns an object like this. jsx { nodeName: "div", attributes: {}, children: [ { nodeName: "h1", attributes: {}, children: [0] }, { nodeName: "button", attributes: { ... }, children: ["-"] }, { nodeName: "button", attributes: { ... }, children: ["+"] } ] } The virtual DOM model allows us to write code as if the entire document is thrown away and rebuilt on each change, while we only update what actually changed. We try to do this in the least number of steps possible, by comparing the new virtual DOM against the previous one. This leads to high efficiency, since typically only a small percentage of nodes need to change, and changing real DOM nodes is costly compared to recalculating the virtual DOM. It may seem wasteful to throw away the old virtual DOM and re-create it entirely on every update — not to mention the fact that at any one time, Hyperapp is keeping two virtual DOM trees in memory, but as it turns out, browsers can create hundreds of thousands of objects very quickly. On the other hand, modifying the DOM is several orders of magnitude more expensive. Mounting To mount your application in a page, we need a DOM element. This element is referred to as the application container. Applications built with Hyperapp always have a single container. jsx app(state, actions, view, container) Hyperapp will also attempt to reuse existing elements inside the container enabling SEO optimization and improving your sites time-to-interactive. The process consists of serving a fully rendered page together with your application. Then instead of throwing away the existing content, well turn your DOM nodes into an interactive application out of the box. This is how we can recycle server-rendered content out the counter example from before. See Getting Started for the application code. ```html <!doctype html> 0 - + ``` Components A component is a pure function that returns a virtual node. Unlike the view function, components are not wired to your application state or actions. Components are dumb, reusable blocks of code that encapsulate markup, styles and behaviors that belong together. Heres a taste of how to use components in your application. The application is a typical To-Do manager. Go ahead and try it online here. ```jsx import { h } from "hyperapp" const TodoItem = ({ id, value, done, toggle }) => ( toggle({ value: done, id: id }) } {value} ) export const view = (state, actions) => ( Todo {state.todos.map(({ id, value, done }) => ( ))} ) ``` If you dont know all the attributes that you want to place in a component ahead of time, you can use the spread syntax. Note that Hyperapp components can return an array of elements as in the following example. This technique lets you group a list of children without adding extra nodes to the DOM. jsx const TodoList = ({ todos, toggle }) => todos.map(todo => <TodoItem {...todo} toggle={toggle} />) Lazy Components Components can only receive attributes and children from their parent component. Similarly to the top-level view function, lazy components are passed your application global state and actions. To create a lazy component, return a view function from a regular component. ```jsx import { h } from "hyperapp" export const Up = ({ by }) => (state, actions) => ( actions.up(by)}>+ {by} ) export const Down = ({ by }) => (state, actions) => ( actions.down(by)}>- {by} ) export const Double = () => (state, actions) => ( actions.up(state.count)}>+ {state.count} ) export const view = (state, actions) => ( {state.count} ) ``` Children Composition Components receive their children elements via the second argument, allowing you and other components to pass arbitrary children down to them. ``jsx const Box = ({ color }, children) => ( <div class={box box-${color}`}>{children} ) const HelloBox = ({ name }) => ( Hello, {name}! ) ``` Supported Attributes Supported attributes include HTML attributes, SVG attributes, DOM events, Lifecycle Events, and Keys. Note that non-standard HTML attribute names are not supported, onclick and class are valid, but onClick or className are not. Styles The style attribute expects a plain object rather than a string as in HTML. Each declaration consists of a style name property written in camelCase and a value. CSS variables are supported too. Individual style properties will be diffed and mapped against HTMLElement.style property members of the DOM element - you should therefore use the JavaScript style object property names, e.g. backgroundColor rather than background-color. ```jsx import { h } from "hyperapp" export const Jumbotron = ({ text }) => ( <div style={{ color: "white", fontSize: "32px", textAlign: center, backgroundImage: url(${imgUrl}) }} {text} ) ``` Lifecycle Events You can be notified when elements managed by the virtual DOM are created, updated or removed via lifecycle events. Use them for animation, data fetching, wrapping third party libraries, cleaning up resources, etc. Note that lifecycle events are attached to virtual DOM nodes not to components. Consider adding a key to ensure that the event is attached to a specific DOM element, rather than a recycled one. oncreate This event is fired after the element is created and attached to the DOM. Use it to manipulate the DOM node directly, make a network request, create a slide/fade in animation, etc. ```jsx import { h } from "hyperapp" export const Textbox = ({ placeholder }) => ( element.focus()} /> ) ``` onupdate This event is fired every time we update the element attributes. Use oldAttributes inside the event handler to check if any attributes changed or not. ```jsx import { h } from "hyperapp" export const Textbox = ({ placeholder }) => ( { if (oldAttributes.placeholder !== placeholder) { // Handle changes here! } }} /> ) ``` onremove This event is fired before the element is removed from the DOM. Use it to create slide/fade out animations. Call done inside the function to remove the element. This event is not called in its child elements. ```jsx import { h } from "hyperapp" export const MessageWithFadeout = ({ title }) => ( fadeout(element).then(done)}> {title} ) ``` ondestroy This event is fired after the element has been removed from the DOM, either directly or as a result of a parent being removed. Use it for invalidating timers, canceling a network request, removing global events listeners, etc. ```jsx import { h } from "hyperapp" export const Camera = ({ onerror }) => ( { navigator.mediaDevices .getUserMedia({ video: true }) .then(stream => (element.srcObject = stream)) .catch(onerror) }} ondestroy={element => element.srcObject.getTracks()[0].stop()} /> ) ``` Keys Keys helps identify nodes every time we update the DOM. By setting the key property on a virtual node, you declare that the node should correspond to a particular DOM element. This allow us to re-order the element into its new position, if the position changed, rather than risk destroying it. ```jsx import { h } from "hyperapp" export const ImageGallery = ({ images }) => images.map(({ hash, url, description }) => ( )) ``` Keys must be unique among sibling-nodes. Dont use an array index as key, if the index also specifies the order of siblings. If the position and number of items in a list is fixed, it will make no difference, but if the list is dynamic, the key will change every time the tree is rebuilt. ```jsx import { h } from "hyperapp" export const PlayerList = ({ players }) => players .slice() .sort((player, nextPlayer) => nextPlayer.score - player.score) .map(player => ( )) ``` Top-Level Nodes Keys are not registered on the top-level node of your view. If you are toggling the top-level view, and you must use keys, wrap them in an unchanging node. Links Slack Twitter Examples /r/hyperapp License Hyperapp is MIT licensed. See LICENSE.