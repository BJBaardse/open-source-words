Reactive extensions to Cocoa frameworks, built on top of ReactiveSwift. ‚ö†Ô∏è Looking for the Objective-C API? üéâ Migrating from RAC 4.x? üöÑ Release Roadmap What is ReactiveSwift? ReactiveSwift offers composable, declarative and flexible primitives that are built around the grand concept of streams of values over time. These primitives can be used to uniformly represent common Cocoa and generic programming patterns that are fundamentally an act of observation. For more information about the core primitives, see ReactiveSwift. What is ReactiveCocoa? ReactiveCocoa wraps various aspects of Cocoa frameworks with the declarative ReactiveSwift primitives. UI Bindings UI components expose [BindingTarget][]s, which accept bindings from any kind of streams of values via the <~ operator. swift // Bind the `name` property of `person` to the text value of an `UILabel`. nameLabel.reactive.text <~ person.name Note: Youll need to import ReactiveSwift as well to make use of the <~ operator. Controls and User Interactions Interactive UI components expose [Signal][]s for control events and updates in the control value upon user interactions. A selected set of controls provide a convenience, expressive binding API for [Action][]s. ``swift // UpdateallowsCookies` whenever the toggle is flipped. preferences.allowsCookies <~ toggle.reactive.isOnValues // Compute live character counts from the continuous stream of user initiated // changes in the text. textField.reactive.continuousTextValues.map { $0.characters.count } // Trigger commit whenever the button is pressed. button.reactive.pressed = CocoaAction(viewModel.commit) ``` Declarative Objective-C Dynamism Create signals that are sourced by intercepting Objective-C objects, e.g. method call interception and object deinitialization. ``swift // Notify after every timeviewWillAppear(:)` is called. let appearing = viewController.reactive.trigger(for: #selector(UIViewController.viewWillAppear(:))) // Observe the lifetime of object. object.reactive.lifetime.ended.observeCompleted(doCleanup) ``` Expressive, Safe Key Path Observation Establish key-value observations in the form of [SignalProducer][]s and DynamicPropertys, and enjoy the inherited composability. ``swift // A producer that sends the current value ofkeyPath, followed by // subsequent changes. // // Terminate the KVO observation if the lifetime ofself` ends. let producer = object.reactive.values(forKeyPath: #keyPath(key)) .take(during: self.reactive.lifetime) // A parameterized property that represents the supplied key path of the // wrapped object. It holds a weak reference to the wrapped object. let property = DynamicProperty(object: person, keyPath: #keyPath(person.name)) ``` But there are still more to be discovered and introduced. Read our in-code documentations and release notes to find out more. Getting started ReactiveCocoa supports macOS 10.9+, iOS 8.0+, watchOS 2.0+, and tvOS 9.0+. Carthage If you use Carthage to manage your dependencies, simply add ReactiveCocoa to your Cartfile: github "ReactiveCocoa/ReactiveCocoa" ~> 7.0 If you use Carthage to build your dependencies, make sure you have added ReactiveCocoa.framework, ReactiveSwift.framework, and Result.framework to the "Linked Frameworks and Libraries" section of your target, and have included them in your Carthage framework copying build phase. CocoaPods If you use CocoaPods to manage your dependencies, simply add ReactiveCocoa to your Podfile: pod ReactiveCocoa, ~> 7.0 Git submodule Add the ReactiveCocoa repository as a submodule of your applications repository. Run git submodule update --init --recursive from within the ReactiveCocoa folder. Drag and drop ReactiveCocoa.xcodeproj, Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcodeproj, and Carthage/Checkouts/Result/Result.xcodeproj into your applications Xcode project or workspace. On the ‚ÄúGeneral‚Äù tab of your application targets settings, add ReactiveCocoa.framework, ReactiveSwift.framework, and Result.framework to the ‚ÄúEmbedded Binaries‚Äù section. If your application target does not contain Swift code at all, you should also set the EMBEDDED_CONTENT_CONTAINS_SWIFT build setting to ‚ÄúYes‚Äù. Have a question? If you need any help, please visit our GitHub issues or Stack Overflow. Feel free to file an issue if you do not manage to find any solution from the archives. Release Roadmap Current Stable Release: In Development Plan of Record ABI stability release ReactiveCocoa is expected to declare library ABI stability when Swift rolls out resilence support in Swift 5. Until then, ReactiveCocoa will incrementally adopt new language features.