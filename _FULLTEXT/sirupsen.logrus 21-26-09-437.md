logrus logrus is a structured logger for go golang completely api compatible with the standard library logger seeing weird case sensitive problems its in the past been possible to import logrus as both upper and lower case due to the go package environment this caused issues in the community and we needed a standard some environments experienced problems with the upper case variant so the lower case was decided everything using logrus will need to use the lower case github com sirupsen logrus any package that isnt should be changed to fix glide see these comments for an in depth explanation of the casing issue see this comment are you interested in assisting in maintaining logrus currently i have a lot of obligations and i am unable to provide logrus with the maintainership it needs if youd like to help please reach out to me at simon at authors username dot com nicely color coded in development when a tty is attached otherwise just plain text with log setformatter log jsonformatter for easy parsing by logstash or splunk json animal walrus level info msg a group of walrus emerges from the ocean size 10 time 2014 03 10 19 57 38 562264131 0400 edt level warning msg the groups number increased tremendously number 122 omg true time 2014 03 10 19 57 38 562471297 0400 edt animal walrus level info msg a giant walrus appears size 10 time 2014 03 10 19 57 38 562500591 0400 edt animal walrus level info msg tremendously sized cow enters the ocean size 9 time 2014 03 10 19 57 38 562527896 0400 edt level fatal msg the ice breaks number 100 omg true time 2014 03 10 19 57 38 562543128 0400 edt with the default log setformatter log textformatter when a tty is not attached the output is compatible with the logfmt format text time 2015 03 26t01 27 38 04 00 level debug msg started observing beach animal walrus number 8 time 2015 03 26t01 27 38 04 00 level info msg a group of walrus emerges from the ocean animal walrus size 10 time 2015 03 26t01 27 38 04 00 level warning msg the groups number increased tremendously number 122 omg true time 2015 03 26t01 27 38 04 00 level debug msg temperature changes temperature 4 time 2015 03 26t01 27 38 04 00 level panic msg its over 9000 animal orca size 9009 time 2015 03 26t01 27 38 04 00 level fatal msg the ice breaks err 0x2082280c0 map animal orca size 9009 2015 03 26 01 27 38 441574009 0400 edt panic its over 9000 number 100 omg true exit status 1 case sensitivity the organizations name was changed to lower case and this will not be changed back if you are getting import conflicts due to case sensitivity please use the lower case import github com sirupsen logrus example the simplest way to use logrus is simply the package level exported logger go package main import log github com sirupsen logrus func main log withfields log fields animal walrus info a walrus appears note that its completely api compatible with the stdlib logger so you can replace your log imports everywhere with log github com sirupsen logrus and youll now have the flexibility of logrus you can customize it all you want go package main import os log github com sirupsen logrus func init log as json instead of the default ascii formatter log setformatter log jsonformatter output to stdout instead of the default stderr can be any io writer see below for file example log setoutput os stdout only log the warning severity or above log setlevel log warnlevel func main log withfields log fields animal walrus size 10 info a group of walrus emerges from the ocean log withfields log fields omg true number 122 warn the groups number increased tremendously log withfields log fields omg true number 100 fatal the ice breaks a common pattern is to re use fields between logging statements by re using the logrus entry returned from withfields contextlogger log withfields log fields common this is a common field other i also should be logged always contextlogger info ill be logged with common and other field contextlogger info me too for more advanced usage such as logging to multiple locations from the same application you can also create an instance of the logrus logger go package main import os github com sirupsen logrus create a new instance of the logger you can have any number of instances var log logrus new func main the api for setting attributes is a little different than the package level exported logger see godoc log out os stdout you could set this to any io writer such as a file file err os openfile logrus log os o create os o wronly 0666 if err nil log out file else log info failed to log to file using default stderr log withfields logrus fields animal walrus size 10 info a group of walrus emerges from the ocean fields logrus encourages careful structured logging through logging fields instead of long unparseable error messages for example instead of log fatalf failed to send event s to topic s with key d you should log the much more discoverable go log withfields log fields event event topic topic key key fatal failed to send event weve found this api forces you to think about logging in a way that produces much more useful logging messages weve been in countless situations where just a single added field to a log statement that was already there wouldve saved us hours the withfields call is optional in general with logrus using any of the printf family functions should be seen as a hint you should add a field however you can still use the printf family functions with logrus default fields often its helpful to have fields always attached to log statements in an application or parts of one for example you may want to always log the request id and user ip in the context of a request instead of writing log withfields log fields request id request id user ip user ip on every line you can create a logrus entry to pass around instead go requestlogger log withfields log fields request id request id user ip user ip requestlogger info something happened on that request will log request id and user ip requestlogger warn something not great happened hooks you can add hooks for logging levels for example to send errors to an exception tracking service on error fatal and panic info to statsd or log to multiple places simultaneously e g syslog logrus comes with built in hooks add those or your custom hook in init go import log github com sirupsen logrus gopkg in gemnasium logrus airbrake hook v2 the package is named airbrake logrus syslog github com sirupsen logrus hooks syslog log syslog func init use the airbrake hook to report errors that have error severity or above to an exception tracker you can create custom hooks see the hooks section log addhook airbrake newhook 123 xyz production hook err logrus syslog newsysloghook udp localhost 514 syslog log info if err nil log error unable to connect to local syslog daemon else log addhook hook note syslog hook also support connecting to local syslog ex dev log or var run syslog or var run log for the detail please check the syslog hook readme a list of currently known of service hook can be found in this wiki page level logging logrus has six logging levels debug info warning error fatal and panic go log debug useful debugging information log info something noteworthy happened log warn you should probably take a look at this log error something failed but im not quitting calls os exit 1 after logging log fatal bye calls panic after logging log panic im bailing you can set the logging level on a logger then it will only log entries with that severity or anything above it go will log anything that is info or above warn error fatal panic default log setlevel log infolevel it may be useful to set log level logrus debuglevel in a debug or verbose environment if your application has that entries besides the fields added with withfield or withfields some fields are automatically added to all logging events time the timestamp when the entry was created msg the logging message passed to info warn error fatal panic after the addfields call e g failed to send event level the logging level e g info environments logrus has no notion of environment if you wish for hooks and formatters to only be used in specific environments you should handle that yourself for example if your application has a global variable environment which is a string representation of the environment you could do go import log github com sirupsen logrus init do something here to set environment depending on an environment variable or command line flag if environment production log setformatter log jsonformatter else the textformatter is default you dont actually have to do this log setformatter log textformatter this configuration is how logrus was intended to be used but json in production is mostly only useful if you do log aggregation with tools like splunk or logstash formatters the built in logging formatters are logrus textformatter logs the event in colors if stdout is a tty otherwise without colors note to force colored output when there is no tty set the forcecolors field to true to force no colored output even if there is a tty set the disablecolors field to true for windows see github com mattn go colorable when colors are enabled levels are truncated to 4 characters by default to disable truncation set the disableleveltruncation field to true all options are listed in the generated docs logrus jsonformatter logs fields as json all options are listed in the generated docs third party logging formatters fluentdformatter formats entries that can be parsed by kubernetes and google container engine logstash logs fields as logstash events prefixed displays log entry source along with alternative layout zalgo invoking the p͉̫o̳̼̊w̖͈̰͎e̬͔̭͂r͚̼̹̲ ̫͓͉̳͈ō̠͕͖̚f̝͍̠ ͕̲̞͖͑z̖̫̤̫ͪa͉̬͈̗l͖͎g̳̥o̰̥̅ ̣͔̲̻͊̄ ̙̘̦̹̦ you can define your formatter by implementing the formatter interface requiring a format method format takes an entry entry data is a fields type map string interface with all your fields as well as the default ones see entries section above go type myjsonformatter struct log setformatter new myjsonformatter func f myjsonformatter format entry entry byte error note this doesnt include time level and message which are available on the entry consult godoc on information about those fields or read the source of the official loggers serialized err json marshal entry data if err nil return nil fmt errorf failed to marshal fields to json v err return append serialized \n nil logger as an io writer logrus can be transformed into an io writer that writer is the end of an io pipe and it is your responsibility to close it go w logger writer defer w close srv http server create a stdlib log logger that writes to logrus logger errorlog log new w 0 each line written to that writer will be printed the usual way using formatters and hooks the level for those entries is info this means that we can override the standard library logger easily go logger logrus new logger formatter logrus jsonformatter use logrus for standard log output note that log here references stdlibs log not logrus imported under the name log log setoutput logger writer rotation log rotation is not provided with logrus log rotation should be done by an external program like logrotate 8 that can compress and delete old log entries it should not be a feature of the application level logger tools tool description logrus mate logrus mate is a tool for logrus to manage loggers you can initial loggers level hook and formatter by config file the logger will generated with different config at different environment logrus viper helper an helper around logrus to wrap with spf13 viper to load configuration with fangs and to simplify logrus configuration use some behavior of logrus mate sample testing logrus has a built in facility for asserting the presence of log messages this is implemented through the test hook and provides decorators for existing logger test newlocal and test newglobal which basically just add the test hook a test logger test newnulllogger that just records log messages and does not output any go import github com sirupsen logrus github com sirupsen logrus hooks test github com stretchr testify assert testing func testsomething t testing t logger hook test newnulllogger logger error helloerror assert equal t 1 len hook entries assert equal t logrus errorlevel hook lastentry level assert equal t helloerror hook lastentry message hook reset assert nil t hook lastentry fatal handlers logrus can register one or more functions that will be called when any fatal level message is logged the registered handlers will be executed before logrus performs a os exit 1 this behavior may be helpful if callers need to gracefully shutdown unlike a panic something went wrong call which can be intercepted with a deferred recover a call to os exit 1 can not be intercepted handler func gracefully shutdown something logrus registerexithandler handler thread safety by default logger is protected by a mutex for concurrent writes the mutex is held when calling hooks and writing logs if you are sure such locking is not needed you can call logger setnolock to disable the locking situation when locking is not needed includes you have no hooks registered or hooks calling is already thread safe writing to logger out is already thread safe for example 1 logger out is protected by locks 2 logger out is a os file handler opened with o append flag and every write is smaller than 4k this allow multi thread multi process writing refer to http www notthewizard com 2014 06 17 are files appends really atomic