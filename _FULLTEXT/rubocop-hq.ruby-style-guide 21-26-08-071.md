prelude role models are important officer alex j murphy robocop one thing has always bothered me as a ruby developer—python developers have a great programming style reference pep 8 and we never got an official guide documenting ruby coding style and best practices and i do believe that style matters i also believe that a great hacker community such as ruby has should be quite capable of producing this coveted document this guide started its life as our internal company ruby coding guidelines written by yours truly at some point i decided that the work i was doing might be interesting to members of the ruby community in general and that the world had little need for another internal company guideline but the world could certainly benefit from a community driven and community sanctioned set of practices idioms and style prescriptions for ruby programming since the inception of the guide ive received a lot of feedback from members of the exceptional ruby community around the world thanks for all the suggestions and the support together we can make a resource beneficial to each and every ruby developer out there by the way if youre into rails you might want to check out the complementary ruby on rails style guide the ruby style guide this ruby style guide recommends best practices so that real world ruby programmers can write code that can be maintained by other real world ruby programmers a style guide that reflects real world usage gets used while a style guide that holds to an ideal that has been rejected by the people it is supposed to help risks not getting used at all—no matter how good it is the guide is separated into several sections of related rules ive tried to add the rationale behind the rules if its omitted ive assumed its pretty obvious i didnt come up with all the rules out of nowhere—they are mostly based on my extensive career as a professional software engineer feedback and suggestions from members of the ruby community and various highly regarded ruby programming resources such as programming ruby and the ruby programming language there are some areas in which there is no clear consensus in the ruby community regarding a particular style like string literal quoting spacing inside hash literals dot position in multi line method chaining etc in such scenarios all popular styles are acknowledged and its up to you to pick one and apply it consistently this style guide evolves over time as additional conventions are identified and past conventions are rendered obsolete by changes in ruby itself many projects have their own coding style guidelines often derived from this guide in the event of any conflicts such project specific guides take precedence for that project you can generate a pdf or an html copy of this guide using pandoc rubocop is a code analyzer based on this style guide translations of the guide are available in the following languages chinese simplified chinese traditional egyptian arabic french japanese korean portuguese pt br russian spanish vietnamese table of contents source code layout syntax naming comments comment annotations magic comments classes modules exceptions collections numbers strings date time regular expressions percent literals metaprogramming misc tools source code layout nearly everybody is convinced that every style but their own is ugly and unreadable leave out the but their own and theyre probably right jerry coffin on indentation use utf 8 as the source file encoding link use two spaces per indentation level aka soft tabs no hard tabs link ruby bad four spaces def some method do something end good def some method do something end use unix style line endings bsd solaris linux macos users are covered by default windows users have to be extra careful link if youre using git you might want to add the following configuration setting to protect your project from windows line endings creeping in bash git config global core autocrlf true dont use to separate statements and expressions as a corollary—use one expression per line link ruby bad puts foobar superfluous semicolon puts foo puts bar two expressions on the same line good puts foobar puts foo puts bar puts foo bar this applies to puts in particular prefer a single line format for class definitions with no body link ruby bad class fooerror standarderror end okish class fooerror standarderror end good fooerror class new standarderror avoid single line methods although they are somewhat popular in the wild there are a few peculiarities about their definition syntax that make their use undesirable at any rate—there should be no more than one expression in a single line method link ruby bad def too much something something else end okish notice that the first is required def no braces method body end okish notice that the second is optional def no braces method body end okish valid syntax but no makes it kind of hard to read def some method body end good def some method body end one exception to the rule are empty body methods ruby good def no op end use spaces around operators after commas colons and semicolons whitespace might be mostly irrelevant to the ruby interpreter but its proper use is the key to writing easily readable code link ruby sum 1 2 a b 1 2 class fooerror standarderror end there are a few exceptions one is the exponent operator ruby bad e m c 2 good e m c 2 another exception is the slash in rational literals ruby bad o scale 1 48r good o scale 1 48r another exception is the safe navigation operator ruby bad foo bar foo bar foo bar good foo bar no spaces after or before use spaces around and before link ruby bad some arg other 1 2 3 each e puts e good some arg other 1 2 3 each e puts e and deserve a bit of clarification since they are used for block and hash literals as well as string interpolation for hash literals two styles are considered acceptable the first variant is slightly more readable and arguably more popular in the ruby community in general the second variant has the advantage of adding visual difference between block and hash literals whichever one you pick—apply it consistently ruby good space after and before one 1 two 2 good no space after and before one 1 two 2 with interpolated expressions there should be no padded spacing inside the braces ruby bad from user first name user last name good from user first name user last name no space after link ruby bad something good something no space inside range literals link ruby bad 1 3 a z good 1 3 a z indent when as deep as case this is the style established in both the ruby programming language and programming ruby historically it is derived from the fact that case and switch statements are not blocks hence should not be indented and the when and else keywords are labels compiled in the c language they are litterally labels for jmp calls link ruby bad case when song name misty puts not again when song duration 120 puts too long when time now hour 21 puts its too late else song play end good case when song name misty puts not again when song duration 120 puts too long when time now hour 21 puts its too late else song play end when assigning the result of a conditional expression to a variable preserve the usual alignment of its branches link ruby bad pretty convoluted kind case year when 1850 1889 then blues when 1890 1909 then ragtime when 1910 1929 then new orleans jazz when 1930 1939 then swing when 1940 1950 then bebop else jazz end result if some cond calc something else calc something else end good its apparent whats going on kind case year when 1850 1889 then blues when 1890 1909 then ragtime when 1910 1929 then new orleans jazz when 1930 1939 then swing when 1940 1950 then bebop else jazz end result if some cond calc something else calc something else end good and a bit more width efficient kind case year when 1850 1889 then blues when 1890 1909 then ragtime when 1910 1929 then new orleans jazz when 1930 1939 then swing when 1940 1950 then bebop else jazz end result if some cond calc something else calc something else end use empty lines between method definitions and also to break up methods into logical paragraphs internally link ruby def some method data initialize options data manipulate data result end def some method result end dont use several empty lines in a row link ruby bad it has two empty lines some method some method good some method some method use empty lines around access modifiers link ruby bad class foo attr reader foo def foo do something end end good class foo attr reader foo def foo do something end end dont use empty lines around method class module block bodies link ruby bad class foo def foo begin do something do something end rescue something end end end good class foo def foo begin do something do something end rescue something end end end avoid comma after the last parameter in a method call especially when the parameters are not on separate lines link ruby bad easier to move add remove parameters but still not preferred some method size count color bad some method size count color good some method size count color use spaces around the operator when assigning default values to method parameters link ruby bad def some method arg1 default arg2 nil arg3 do something end good def some method arg1 default arg2 nil arg3 do something end while several ruby books suggest the first style the second is much more prominent in practice and arguably a bit more readable avoid line continuation \ where not required in practice avoid using line continuations for anything but string concatenation link ruby bad result 1 \ 2 good but still ugly as hell result 1 \ 2 long string first part of the long string \ and second part of the long string adopt a consistent multi line method chaining style there are two popular styles in the ruby community both of which are considered good—leading option a and trailing option b link option a when continuing a chained method invocation on another line keep the on the second line ruby bad need to consult first line to understand second line one two three four good its immediately clear whats going on the second line one two three four option b when continuing a chained method invocation on another line include the on the first line to indicate that the expression continues ruby bad need to read ahead to the second line to know that the chain continues one two three four good its immediately clear that the expression continues beyond the first line one two three four a discussion on the merits of both alternative styles can be found here align the parameters of a method call if they span more than one line when aligning parameters is not appropriate due to line length constraints single indent for the lines after the first is also acceptable link ruby starting point line is too long def send mail source mailer deliver to bob example com from us example com subject important message body source text end bad double indent def send mail source mailer deliver to bob example com from us example com subject important message body source text end good def send mail source mailer deliver to bob example com from us example com subject important message body source text end good normal indent def send mail source mailer deliver to bob example com from us example com subject important message body source text end align the elements of array literals spanning multiple lines link ruby bad single indent menu item w spam spam spam spam spam spam spam spam baked beans spam spam spam spam spam good menu item w spam spam spam spam spam spam spam spam baked beans spam spam spam spam spam good menu item w spam spam spam spam spam spam spam spam baked beans spam spam spam spam spam add underscores to large numeric literals to improve their readability link ruby bad how many 0s are there num 1000000 good much easier to parse for the human brain num 1 000 000 prefer smallcase letters for numeric literal prefixes 0o for octal 0x for hexadecimal and 0b for binary do not use 0d prefix for decimal literals link ruby bad num 01234 num 0o1234 num 0x12ab num 0b10101 num 0d1234 num 0d1234 good easier to separate digits from the prefix num 0o1234 num 0x12ab num 0b10101 num 1234 use yard and its conventions for api documentation link limit lines to 80 characters link avoid trailing whitespace link end each file with a newline link dont use block comments they cannot be preceded by whitespace and are not as easy to spot as regular comments link ruby bad begin comment line another comment line end good comment line another comment line syntax use only to reference constants this includes classes and modules and constructors like array or nokogiri html do not use for regular method invocation link ruby bad someclass some method some object some method good someclass some method some object some method somemodule someclass some const somemodule someclass do not use to define class methods link ruby bad class foo def self some method end end good class foo def self some method end end use def with parentheses when there are parameters omit the parentheses when the method doesnt accept any parameters link ruby bad def some method body omitted end good def some method body omitted end bad def some method with parameters param1 param2 body omitted end good def some method with parameters param1 param2 body omitted end use parentheses around the arguments of method invocations especially if the first argument begins with an open parenthesis as in f 3 2 1 link ruby bad x math sin y good x math sin y bad array delete e good array delete e bad temperance person new temperance 30 good temperance person new temperance 30 always omit parentheses for method calls with no arguments ruby bad kernel exit 2 even fork test upcase good kernel exit 2 even fork test upcase methods that are part of an internal dsl e g rake rails rspec ruby bad validates name presence true good validates name presence true methods that have keyword status in ruby ruby class person bad attr reader name age good attr reader name age body omitted end can omit parentheses for methods that have keyword status in ruby but are not declarative ruby good puts temperance age system ls also good puts temperance age system ls define optional arguments at the end of the list of arguments ruby has some unexpected results when calling methods that have optional arguments at the front of the list link ruby bad def some method a 1 b 2 c d puts a b c d end some method w x 1 2 w x some method w x y w 2 x y some method w x y z w x y z good def some method c d a 1 b 2 puts a b c d end some method w x 1 2 w x some method w x y y 2 w x some method w x y z y z w x avoid the use of parallel assignment for defining variables parallel assignment is allowed when it is the return of a method call used with the splat operator or when used to swap variable assignment parallel assignment is less readable than separate assignment link ruby bad a b c d foo bar baz foobar good a foo b bar c baz d foobar good swapping variable assignment swapping variable assignment is a special case because it will allow you to swap the values that are assigned to each variable a foo b bar a b b a puts a bar puts b foo good method return def multi return 1 2 end first second multi return good use with splat first list 1 2 3 4 first 1 list 2 3 4 hello array hello hello a 1 3 1 2 3 avoid the use of unnecessary trailing underscore variables during parallel assignment named underscore variables are to be preferred over underscore variables because of the context that they provide trailing underscore variables are necessary when there is a splat variable defined on the left side of the assignment and the splat variable is not an underscore link ruby bad foo one two three four five unnecessary assignment that does not provide useful information first second foo split first foo split first foo split good foo one two three four five the underscores are needed to show that you want all elements except for the last number of underscore elements beginning foo split beginning something foo split a foo split a b foo split unnecessary assignment to an unused variable but the assignment provides us with useful information first second foo split first second foo split first ending foo split do not use for unless you know exactly why most of the time iterators should be used instead for is implemented in terms of each so youre adding a level of indirection but with a twist—for doesnt introduce a new scope unlike each and variables defined in its block will be visible outside it link ruby arr 1 2 3 bad for elem in arr do puts elem end note that elem is accessible outside of the for loop elem 3 good arr each elem puts elem elem is not accessible outside eachs block elem nameerror undefined local variable or method elem do not use then for multi line if unless link ruby bad if some condition then body omitted end good if some condition body omitted end always put the condition on the same line as the if unless in a multi line conditional link ruby bad if some condition do something do something else end good if some condition do something do something else end favor the ternary operator over if then else end constructs its more common and obviously more concise link ruby bad result if some condition then something else something else end good result some condition something something else use one expression per branch in a ternary operator this also means that ternary operators must not be nested prefer if else constructs in these cases link ruby bad some condition nested condition nested something nested something else something else good if some condition nested condition nested something nested something else else something else end do not use if x use the ternary operator instead link ruby bad result if some condition something else something else end good result some condition something something else leverage the fact that if and case are expressions which return a result link ruby bad if condition result x else result y end good result if condition x else y end use when x then for one line cases the alternative syntax when x has been removed as of ruby 1 9 link do not use when x see the previous rule link use instead of not link ruby bad parentheses are required because of op precedence x not something good x something avoid the use of link converts a value to boolean but you dont need this explicit conversion in the condition of a control expression using it only obscures your intention if you want to do a nil check use nil instead ruby bad x test obscure nil check if x body omitted end good x test if x body omitted end the and and or keywords are banned the minimal added readability is just not worth the high probability of introducing subtle bugs for boolean expressions always use and instead for flow control use if and unless and are also acceptable but less clear link ruby bad boolean expression ok got needed arguments and arguments are valid control flow document save or raise failed to save document good boolean expression ok got needed arguments arguments are valid control flow raise failed to save document unless document save ok control flow document save raise failed to save document avoid multi line the ternary operator use if unless instead link favor modifier if unless usage when you have a single line body another good alternative is the usage of control flow link ruby bad if some condition do something end good do something if some condition another good option some condition do something avoid modifier if unless usage at the end of a non trivial multi line block link ruby bad 10 times do multi line body omitted end if some condition good if some condition 10 times do multi line body omitted end end avoid nested modifier if unless while until usage favor if appropriate link ruby bad do something if other condition if some condition good do something if some condition other condition favor unless over if for negative conditions or control flow link ruby bad do something if some condition bad do something if not some condition good do something unless some condition another good option some condition do something do not use unless with else rewrite these with the positive case first link ruby bad unless success puts failure else puts success end good if success puts success else puts failure end dont use parentheses around the condition of a control expression link ruby bad if x 10 body omitted end good if x 10 body omitted end note that there is an exception to this rule namely safe assignment in condition do not use while until condition do for multi line while until link ruby bad while x 5 do body omitted end until x 5 do body omitted end good while x 5 body omitted end until x 5 body omitted end favor modifier while until usage when you have a single line body link ruby bad while some condition do something end good do something while some condition favor until over while for negative conditions link ruby bad do something while some condition good do something until some condition use kernel loop instead of while until when you need an infinite loop link ruby bad while true do something end until false do something end good loop do do something end use kernel loop with break rather than begin end until or begin end while for post loop tests link ruby bad begin puts val val 1 end while val 0 good loop do puts val val 1 break unless val 0 end omit the outer braces around an implicit options hash link ruby bad user set name john age 45 permissions read true good user set name john age 45 permissions read true omit both the outer braces and parentheses for methods that are part of an internal dsl link ruby class person activerecord base bad validates name presence true length within 1 10 good validates name presence true length within 1 10 end use the proc invocation shorthand when the invoked method is the only operation of a block link ruby bad names map name name upcase good names map upcase prefer over do end for single line blocks avoid using for multi line blocks multi line chaining is always ugly always use do end for control flow and method definitions e g in rakefiles and certain dsls avoid do end when chaining link ruby names w bozhidar steve sarah bad names each do name puts name end good names each name puts name bad names select do name name start with s end map name name upcase good names select name name start with s map upcase some will argue that multi line chaining would look ok with the use of but they should ask themselves—is this code really readable and can the blocks contents be extracted into nifty methods consider using explicit block argument to avoid writing block literal that just passes its arguments to another block beware of the performance impact though as the block gets converted to a proc link ruby require tempfile bad def with tmp dir dir mktmpdir do tmp dir dir chdir tmp dir dir yield dir block just passes arguments end end good def with tmp dir block dir mktmpdir do tmp dir dir chdir tmp dir block end end with tmp dir do dir puts dir is accessible as a parameter and pwd is set dir end avoid return where not required for flow of control link ruby bad def some method some arr return some arr size end good def some method some arr some arr size end avoid self where not required it is only required when calling a self write accessor methods named after reserved words or overloadable operators link ruby bad def ready if self last reviewed at self last updated at self worker update self content self options self status in progress end self status verified end good def ready if last reviewed at last updated at worker update content options self status in progress end status verified end as a corollary avoid shadowing methods with local variables unless they are both equivalent link ruby class foo attr accessor options ok def initialize options self options options both options and self options are equivalent here end bad def do something options unless options when later output self options message end end good def do something params unless params when later output options message end end end dont use the return value of an assignment in conditional expressions unless the assignment is wrapped in parentheses this is a fairly popular idiom among rubyists thats sometimes referred to as safe assignment in condition link ruby bad a warning if v array grep foo do something v some code end good mri would still complain but rubocop wont if v array grep foo do something v some code end good v array grep foo if v do something v some code end use shorthand self assignment operators whenever applicable link ruby bad x x y x x y x x y x x y x x y x x y good x y x y x y x y x y x y use to initialize variables only if theyre not already initialized link ruby bad name name name bozhidar bad name bozhidar unless name good set name to bozhidar only if its nil or false name bozhidar dont use to initialize boolean variables consider what would happen if the current value happened to be false link ruby bad would set enabled to true even if it was false enabled true good enabled true if enabled nil use to preprocess variables that may or may not exist using will change the value only if it exists removing the need to check its existence with if link ruby bad if something something something downcase end bad something something something downcase nil ok something something downcase if something good something something something downcase better something something downcase avoid explicit use of the case equality operator as its name implies it is meant to be used implicitly by case expressions and outside of them it yields some pretty confusing code link ruby bad array something 1 100 7 something some string good something is a array 1 100 include 7 some string something do not use eql when using will do the stricter comparison semantics provided by eql are rarely needed in practice link ruby bad eql is the same as for strings ruby eql some str good ruby some str 1 0 eql x eql makes sense here if want to differentiate between integer and float 1 avoid using perl style special variables like etc they are quite cryptic and their use in anything but one liner scripts is discouraged use the human friendly aliases provided by the english library link ruby bad unshift file dirname file good require english load path unshift file dirname file do not put a space between a method name and the opening parenthesis link ruby bad f 3 2 1 good f 3 2 1 always run the ruby interpreter with the w option so it will warn you if you forget either of the rules above link do not use nested method definitions use lambda instead nested method definitions actually produce methods in the same scope e g class as the outer method furthermore the nested method will be redefined every time the method containing its definition is invoked link ruby bad def foo x def bar y body omitted end bar x end good the same as the previous but no bar redefinition on every foo call def bar y body omitted end def foo x bar x end also good def foo x bar y bar call x end use the new lambda literal syntax for single line body blocks use the lambda method for multi line blocks link ruby bad l lambda a b a b l call 1 2 correct but looks extremely awkward l a b do tmp a 7 tmp b 50 end good l a b a b l call 1 2 l lambda do a b tmp a 7 tmp b 50 end dont omit the parameter parentheses when defining a stabby lambda with parameters link ruby bad l x y something x y good l x y something x y omit the parameter parentheses when defining a stabby lambda with no parameters link ruby bad l something good l something prefer proc over proc new link ruby bad p proc new n puts n good p proc n puts n prefer proc call over proc or proc for both lambdas and procs link ruby bad looks similar to enumeration access l v puts v l 1 also bad uncommon syntax l v puts v l 1 good l v puts v l call 1 prefix with unused block parameters and local variables its also acceptable to use just although its a bit less descriptive this convention is recognized by the ruby interpreter and tools like rubocop and will suppress their unused variable warnings link ruby bad result hash map k v v 1 def something x unused var used var something else x some code end good result hash map k v v 1 def something x unused var used var something else x some code end good result hash map v v 1 def something x used var something else x some code end use stdout stderr stdin instead of stdout stderr stdin stdout stderr stdin are constants and while you can actually reassign possibly to redirect some stream constants in ruby youll get an interpreter warning if you do so link use warn instead of stderr puts apart from being more concise and clear warn allows you to suppress warnings if you need to by setting the warn level to 0 via w0 link favor the use of sprintf and its alias format over the fairly cryptic string method link ruby bad d d 20 10 20 10 good sprintf d d 20 10 20 10 good sprintf d d first 20 second 10 20 10 format d d 20 10 20 10 good format d d first 20 second 10 20 10 when using named format string tokens favor name s over name because it encodes information about the type of the value link ruby bad format hello name name john good format hello s name john favor the use of array join over the fairly cryptic array with a string argument link ruby bad w one two three one two three good w one two three join one two three use array instead of explicit array check or var when dealing with a variable you want to treat as an array but youre not certain its an array link ruby bad paths paths unless paths is a array paths each path do something path bad always creates a new array instance paths each path do something path good and a bit more readable array paths each path do something path use ranges or comparable between instead of complex comparison logic when possible link ruby bad do something if x 1000 x 2000 good do something if 1000 2000 include x good do something if x between 1000 2000 favor the use of predicate methods to explicit comparisons with numeric comparisons are ok link ruby bad if x 2 0 end if x 2 1 end if x nil end good if x even end if x odd end if x nil end if x zero end if x 0 end dont do explicit non nil checks unless youre dealing with boolean values link ruby bad do something if something nil do something if something nil good do something if something good dealing with a boolean def value set some boolean nil end avoid the use of begin blocks link do not use end blocks use kernel at exit instead link ruby bad end puts goodbye good at exit puts goodbye avoid the use of flip flops link avoid use of nested conditionals for flow of control link prefer a guard clause when you can assert invalid data a guard clause is a conditional statement at the top of a function that bails out as soon as it can ruby bad def compute thing thing if thing foo update with bar thing foo if thing foo bar partial compute thing else re compute thing end end end good def compute thing thing return unless thing foo update with bar thing foo return re compute thing unless thing foo bar partial compute thing end prefer next in loops instead of conditional blocks ruby bad 0 1 2 3 each do item if item 1 puts item end end good 0 1 2 3 each do item next unless item 1 puts item end prefer map over collect find over detect select over find all reduce over inject and size over length this is not a hard requirement if the use of the alias enhances readability its ok to use it the rhyming methods are inherited from smalltalk and are not common in other programming languages the reason the use of select is encouraged over find all is that it goes together nicely with reject and its name is pretty self explanatory link dont use count as a substitute for size for enumerable objects other than array it will iterate the entire collection in order to determine its size link ruby bad some hash count good some hash size use flat map instead of map flatten this does not apply for arrays with a depth greater than 2 i e if users first songs a b c then use map flatten rather than flat map flat map flattens the array by 1 whereas flatten flattens it all the way link ruby bad all songs users map songs flatten uniq good all songs users flat map songs uniq prefer reverse each to reverse each because some classes that include enumerable will provide an efficient implementation even in the worst case where a class does not provide a specialized implementation the general implementation inherited from enumerable will be at least as efficient as using reverse each link ruby bad array reverse each good array reverse each naming the only real difficulties in programming are cache invalidation and naming things phil karlton name identifiers in english link ruby bad identifier using non ascii characters заплата 1 000 bad identifier is a bulgarian word written with latin letters instead of cyrillic zaplata 1 000 good salary 1 000 use snake case for symbols methods and variables link ruby bad some symbol somesymbol somesymbol somevar 5 var 10 10 def somemethod some code end def somemethod some code end good some symbol some var 5 var10 10 def some method some code end do not separate numbers from letters on symbols methods and variables link ruby bad some sym 1 some var 1 1 def some method 1 some code end good some sym1 some var1 1 def some method1 some code end use camelcase for classes and modules keep acronyms like http rfc xml uppercase link ruby bad class someclass some code end class some class some code end class somexml some code end class xmlsomething some code end good class someclass some code end class somexml some code end class xmlsomething some code end use snake case for naming files e g hello world rb link use snake case for naming directories e g lib hello world hello world rb link aim to have just a single class module per source file name the file name as the class module but replacing camelcase with snake case link use screaming snake case for other constants link ruby bad someconst 5 good some const 5 the names of predicate methods methods that return a boolean value should end in a question mark i e array empty methods that dont return a boolean shouldnt end in a question mark link avoid prefixing predicate methods with the auxiliary verbs such as is does or can these words are redundant and inconsistent with the style of boolean methods in the ruby core library such as empty and include link ruby bad class person def is tall true end def can play basketball false end def does like candy true end end good class person def tall true end def basketball player false end def likes candy true end end the names of potentially dangerous methods i e methods that modify self or the arguments exit doesnt run the finalizers like exit does etc should end with an exclamation mark if there exists a safe version of that dangerous method link ruby bad there is no matching safe method class person def update end end good class person def update end end good class person def update end def update end end define the non bang safe method in terms of the bang dangerous one if possible link ruby class array def flatten once res each do e e each f res f end replace res end def flatten once dup flatten once end end when defining binary operators name the parameter other and are exceptions to the rule since their semantics are different link ruby def other body omitted end comments good code is its own best documentation as youre about to add a comment ask yourself how can i improve the code so that this comment isnt needed improve the code and then document it to make it even clearer steve mcconnell write self documenting code and ignore the rest of this section seriously link write comments in english link use one space between the leading character of the comment and the text of the comment link comments longer than a word are capitalized and use punctuation use one space after periods link avoid superfluous comments link ruby bad counter 1 increments counter by one keep existing comments up to date an outdated comment is worse than no comment at all link good code is like a good joke it needs no explanation — old programmers maxim through russ olsen avoid writing comments to explain bad code refactor the code to make it self explanatory do or do not—there is no try yoda link comment annotations annotations should usually be written on the line immediately above the relevant code link the annotation keyword is followed by a colon and a space then a note describing the problem link if multiple lines are required to describe the problem subsequent lines should be indented three spaces after the one general plus two for indentation purpose link ruby def bar fixme this has crashed occasionally since v3 2 1 it may be related to the barbazutil upgrade baz quux end in cases where the problem is so obvious that any documentation would be redundant annotations may be left at the end of the offending line with no note this usage should be the exception and not the rule link ruby def bar sleep 100 optimize end use todo to note missing features or functionality that should be added at a later date link use fixme to note broken code that needs to be fixed link use optimize to note slow or inefficient code that may cause performance problems link use hack to note code smells where questionable coding practices were used and should be refactored away link use review to note anything that should be looked at to confirm it is working as intended for example review are we sure this is how the client does x currently link use other custom annotation keywords if it feels appropriate but be sure to document them in your projects readme or similar link magic comments place magic comments above all code and documentation in a file except shebangs which are discussed next ruby bad some documentation about person frozen string literal true class person end good frozen string literal true some documentation about person class person end place magic comments below shebangs when they are present in a file link ruby bad frozen string literal true usr bin env ruby app parse argv good usr bin env ruby frozen string literal true app parse argv use one magic comment per line if you need multiple link ruby bad frozen string literal true encoding ascii 8bit good frozen string literal true encoding ascii 8bit separate magic comments from code and documentation with a blank line link ruby bad frozen string literal true some documentation for person class person some code end good frozen string literal true some documentation for person class person some code end classes modules use a consistent structure in your class definitions link ruby class person extend and include go first extend somemodule include anothermodule inner classes customerror class new standarderror constants are next some constant 20 afterwards we have attribute macros attr reader name followed by other macros if any validates name public class methods are next in line def self some method end initialization goes between class methods and other instance methods def initialize end followed by other public instance methods def some method end protected and private methods are grouped near the end protected def some protected method end private def some private method end end split multiple mixins into separate statements link ruby bad class person include foo bar end good class person multiple mixins go in separate statements include foo include bar end dont nest multi line classes within classes try to have such nested classes each in their own file in a folder named like the containing class link ruby bad foo rb class foo class bar 30 methods inside end class car 20 methods inside end 30 methods inside end good foo rb class foo 30 methods inside end foo bar rb class foo class bar 30 methods inside end end foo car rb class foo class car 20 methods inside end end define and reopen namespaced classes and modules using explicit nesting using the scope resolution operator can lead to surprising constant lookups due to rubys lexical scoping which depends on the module nesting at the point of definition link ruby module utilities class queue end end bad class utilities store module nesting utilities store def initialize refers to the top level queue class because utilities isnt in the current nesting chain queue queue new end end good module utilities class waitinglist module nesting utilities waitinglist utilities def initialize queue queue new refers to utilities queue end end end prefer modules to classes with only class methods classes should be used only when it makes sense to create instances out of them link ruby bad class someclass def self some method body omitted end def self some other method body omitted end end good module somemodule module function def some method body omitted end def some other method body omitted end end favor the use of module function over extend self when you want to turn a modules instance methods into class methods link ruby bad module utilities extend self def parse something string do stuff here end def other utility method number string do some more stuff end end good module utilities module function def parse something string do stuff here end def other utility method number string do some more stuff end end when designing class hierarchies make sure that they conform to the liskov substitution principle link try to make your classes as solid as possible link always supply a proper to s method for classes that represent domain objects link ruby class person attr reader first name last name def initialize first name last name first name first name last name last name end def to s first name last name end end use the attr family of functions to define trivial accessors or mutators link ruby bad class person def initialize first name last name first name first name last name last name end def first name first name end def last name last name end end good class person attr reader first name last name def initialize first name last name first name first name last name last name end end for accessors and mutators avoid prefixing method names with get and set it is a ruby convention to use attribute names for accessors readers and attr name for mutators writers link ruby bad class person def get name first name last name end def set name name first name last name name split end end good class person def name first name last name end def name name first name last name name split end end avoid the use of attr use attr reader and attr accessor instead link ruby bad creates a single attribute accessor deprecated in ruby 1 9 attr something true attr one two three behaves as attr reader good attr accessor something attr reader one two three consider using struct new which defines the trivial accessors constructor and comparison operators for you link ruby good class person attr accessor first name last name def initialize first name last name first name first name last name last name end end better person struct new first name last name do end dont extend an instance initialized by struct new extending it introduces a superfluous class level and may also introduce weird errors if the file is required multiple times link ruby bad class person struct new first name last name end good person struct new first name last name consider adding factory methods to provide additional sensible ways to create instances of a particular class link ruby class person def self create options hash body omitted end end prefer duck typing over inheritance link ruby bad class animal abstract method def speak end end extend superclass class duck animal def speak puts quack quack end end extend superclass class dog animal def speak puts bau bau end end good class duck def speak puts quack quack end end class dog def speak puts bau bau end end avoid the usage of class variables due to their nasty behavior in inheritance link ruby class parent class var parent def self print class var puts class var end end class child parent class var child end parent print class var will print child as you can see all the classes in a class hierarchy actually share one class variable class instance variables should usually be preferred over class variables assign proper visibility levels to methods private protected in accordance with their intended usage dont go off leaving everything public which is the default after all were coding in ruby now not in python link indent the public protected and private methods as much as the method definitions they apply to leave one blank line above the visibility modifier and one blank line below in order to emphasize that it applies to all methods below it link ruby class someclass def public method some code end private def private method some code end def another private method some code end end use def self method to define class methods this makes the code easier to refactor since the class name is not repeated link ruby class testclass bad def testclass some method body omitted end good def self some other method body omitted end also possible and convenient when you have to define many class methods class self def first method body omitted end def second method etc body omitted end end end prefer alias when aliasing methods in lexical class scope as the resolution of self in this context is also lexical and it communicates clearly to the user that the indirection of your alias will not be altered at runtime or by any subclass unless made explicit link ruby class westerner def first name names first end alias given name first name end since alias like def is a keyword prefer bareword arguments over symbols or strings in other words do alias foo bar not alias foo bar also be aware of how ruby handles aliases and inheritance an alias references the method that was resolved at the time the alias was defined it is not dispatched dynamically ruby class fugitive westerner def first name nobody end end in this example fugitive given name would still call the original westerner first name method not fugitive first name to override the behavior of fugitive given name as well youd have to redefine it in the derived class ruby class fugitive westerner def first name nobody end alias given name first name end always use alias method when aliasing methods of modules classes or singleton classes at runtime as the lexical scope of alias leads to unpredictability in these cases link ruby module mononymous def self included other other class eval alias method full name given name end end class sting westerner include mononymous end when class or module methods call other such methods omit the use of a leading self or own name followed by a when calling other such methods this is often seen in service classes or other similar concepts where a class is treated as though it were a function this convention tends to reduce repetitive boilerplate in such classes link ruby class testclass bad more work when class renamed method moved def self call param1 param2 testclass new param1 call param2 end bad more verbose than necessary def self call param1 param2 self new param1 call param2 end good def self call param1 param2 new param1 call param2 end other methods end exceptions prefer raise over fail for exceptions link ruby bad fail someexception message good raise someexception message dont specify runtimeerror explicitly in the two argument version of raise link ruby bad raise runtimeerror message good signals a runtimeerror by default raise message prefer supplying an exception class and a message as two separate arguments to raise instead of an exception instance link ruby bad raise someexception new message note that there is no way to doraise someexception new message backtrace good raise someexception message consistent with raise someexception message backtrace do not return from an ensure block if you explicitly return from a method inside an ensure block the return will take precedence over any exception being raised and the method will return as if no exception had been raised at all in effect the exception will be silently thrown away link ruby bad def foo raise ensure return very bad idea end use implicit begin blocks where possible link ruby bad def foo begin main logic goes here rescue failure handling goes here end end good def foo main logic goes here rescue failure handling goes here end mitigate the proliferation of begin blocks by using contingency methods a term coined by avdi grimm link ruby bad begin something that might fail rescue ioerror handle ioerror end begin something else that might fail rescue ioerror handle ioerror end good def with io error handling yield rescue ioerror handle ioerror end with io error handling something that might fail with io error handling something else that might fail dont suppress exceptions link ruby bad begin an exception occurs here rescue someerror the rescue clause does absolutely nothing end bad do something rescue nil avoid using rescue in its modifier form link ruby bad this catches exceptions of standarderror class and its descendant classes read file rescue handle error good this catches only the exceptions of errno enoent class and its descendant classes def foo read file rescue errno enoent ex handle error ex end dont use exceptions for flow of control link ruby bad begin n d rescue zerodivisionerror puts cannot divide by 0 end good if d zero puts cannot divide by 0 else n d end avoid rescuing the exception class this will trap signals and calls to exit requiring you to kill 9 the process link ruby bad begin calls to exit and kill signals will be caught except kill 9 exit rescue exception puts you didnt really want to exit right exception handling end good begin a blind rescue rescues from standarderror not exception as many programmers assume rescue e exception handling end also good begin an exception occurs here rescue standarderror e exception handling end put more specific exceptions higher up the rescue chain otherwise theyll never be rescued from link ruby bad begin some code rescue standarderror e some handling rescue ioerror e some handling that will never be executed end good begin some code rescue ioerror e some handling rescue standarderror e some handling end release external resources obtained by your program in an ensure block link ruby f file open testfile begin process rescue handle error ensure f close if f end use versions of resource obtaining methods that do automatic resource cleanup when possible link ruby bad you need to close the file descriptor explicitly f file open testfile some action on the file f close good the file descriptor is closed automatically file open testfile do f some action on the file end favor the use of exceptions from the standard library over introducing new exception classes link collections prefer literal array and hash creation notation unless you need to pass parameters to their constructors that is link ruby bad arr array new hash hash new good arr arr array new 10 hash hash hash new 0 prefer w to the literal array syntax when you need an array of words non empty strings without spaces and special characters in them apply this rule only to arrays with two or more elements link ruby bad states draft open closed good states w draft open closed prefer i to the literal array syntax when you need an array of symbols and you dont need to maintain ruby 1 9 compatibility apply this rule only to arrays with two or more elements link ruby bad states draft open closed good states i draft open closed avoid comma after the last item of an array or hash literal especially when the items are not on separate lines link ruby bad easier to move add remove items but still not preferred values 1001 2020 3333 bad values 1001 2020 3333 good values 1001 2020 3333 avoid the creation of huge gaps in arrays link ruby arr arr 100 1 now you have an array with lots of nils when accessing the first or last element from an array prefer first or last over 0 or 1 link use set instead of array when dealing with unique elements set implements a collection of unordered values with no duplicates this is a hybrid of arrays intuitive inter operation facilities and hashs fast lookup link prefer symbols instead of strings as hash keys link ruby bad hash one 1 two 2 three 3 good hash one 1 two 2 three 3 avoid the use of mutable objects as hash keys link use the ruby 1 9 hash literal syntax when your hash keys are symbols link ruby bad hash one 1 two 2 three 3 good hash one 1 two 2 three 3 dont mix the ruby 1 9 hash syntax with hash rockets in the same hash literal when youve got keys that are not symbols stick to the hash rockets syntax link ruby bad a 1 b 2 good a 1 b 2 use hash key instead of hash has key and hash value instead of hash has value link ruby bad hash has key test hash has value value good hash key test hash value value use hash each key instead of hash keys each and hash each value instead of hash values each link ruby bad hash keys each k p k hash values each v p v hash each k v p k hash each k v p v good hash each key k p k hash each value v p v use hash fetch when dealing with hash keys that should be present link ruby heroes batman bruce wayne superman clark kent bad if we make a mistake we might not spot it right away heroes batman bruce wayne heroes supermann nil good fetch raises a keyerror making the problem obvious heroes fetch supermann introduce default values for hash keys via hash fetch as opposed to using custom logic link ruby batman name bruce wayne is evil false bad if we just use operator with falsy value we wont get the expected result batman is evil true true good fetch works correctly with falsy values batman fetch is evil true false prefer the use of the block instead of the default value in hash fetch if the code that has to be evaluated may have side effects or be expensive link ruby batman name bruce wayne bad if we use the default value we eager evaluate it so it can slow the program down if done multiple times batman fetch powers obtain batman powers obtain batman powers is an expensive call good blocks are lazy evaluated so only triggered in case of keyerror exception batman fetch powers obtain batman powers use hash values at when you need to retrieve several values consecutively from a hash link ruby bad email data email username data nickname good email username data values at email nickname rely on the fact that as of ruby 1 9 hashes are ordered link do not modify a collection while traversing it link when accessing elements of a collection avoid direct access via n by using an alternate form of the reader method if it is supplied this guards you from calling on nil link ruby bad regexp last match 1 good regexp last match 1 when providing an accessor for a collection provide an alternate form to save users from checking for nil before accessing an element in the collection link ruby bad def awesome things awesome things end good def awesome things index nil if index awesome things awesome things index else awesome things end end numbers use integer to check type of an integer number since fixnum is platform dependent checking against it will return different results on 32 bit and 64 bit machines link ruby timestamp time now to i bad timestamp is a fixnum timestamp is a bignum good timestamp is a integer prefer to use ranges when generating random numbers instead of integers with offsets since it clearly states your intentions imagine simulating a roll of a dice link ruby bad rand 6 1 good rand 1 6 strings prefer string interpolation and string formatting instead of string concatenation link ruby bad email with name user name user email good email with name user name user email good email with name format s s user name user email adopt a consistent string literal quoting style there are two popular styles in the ruby community both of which are considered good—single quotes by default option a and double quotes by default option b link option a prefer single quoted strings when you dont need string interpolation or special symbols such as \t \n etc ruby bad name bozhidar name de\andre good name bozhidar name deandre option b prefer double quotes unless your string literal contains or escape characters you want to suppress ruby bad name bozhidar sarcasm i \ like\ it good name bozhidar sarcasm i like it the string literals in this guide are aligned with the first style dont use the character literal syntax x since ruby 1 9 its basically redundant— x would interpreted as x a string with a single character in it link ruby bad char c good char c dont leave out around instance and global variables being interpolated into a string link ruby class person attr reader first name last name def initialize first name last name first name first name last name last name end bad valid but awkward def to s first name last name end good def to s first name last name end end global 0 bad puts global global good puts global global dont use object to s on interpolated objects its invoked on them automatically link ruby bad message this is the result to s good message this is the result avoid using string when you need to construct large data chunks instead use string concatenation mutates the string instance in place and is always faster than string which creates a bunch of new string objects link ruby bad html html page title paragraphs each do paragraph html paragraph end good and also fast html html page title paragraphs each do paragraph html paragraph end dont use string gsub in scenarios in which you can use a faster and more specialized alternative link ruby url http example com str lisp case rules bad url gsub http https str gsub good url sub http https str tr when using heredocs for multi line strings keep in mind the fact that they preserve leading whitespace its a good practice to employ some margin based on which to trim the excessive whitespace link ruby code end gsub \s \ def test some method other method end end def test\n some method\n other method\nend\n use ruby 2 3s squiggly heredocs for nicely indented multi line strings link ruby bad using powerpack string strip margin code ruby strip margin def test some method other method end ruby also bad code ruby def test some method other method end ruby good code ruby def test some method other method end ruby use descriptive delimiters for heredocs delimiters add valuable information about the heredoc content and as an added bonus some editors can highlight code within heredocs if the correct delimiter is used link ruby bad code end def foo bar end end good code ruby def foo bar end ruby good code summary an imposing black structure provides a connection between the past and the future in this enigmatic adaptation of a short story by revered sci fi author arthur c clarke summary date time prefer time now over time new when retrieving the current system time link dont use datetime unless you need to account for historical calendar reform—and if you do explicitly specify the start argument to clearly state your intentions link ruby bad uses datetime for current time datetime now good uses time for current time time now bad uses datetime for modern date datetime iso8601 2016 06 29 good uses date for modern date date iso8601 2016 06 29 good uses datetime with start argument for historical date datetime iso8601 1751 04 23 date england regular expressions some people when confronted with a problem think i know ill use regular expressions now they have two problems jamie zawinski dont use regular expressions if you just need plain text search in string string text link for simple constructions you can use regexp directly through string index link ruby match string regexp get content of matched regexp first group string text grp 1 get content of captured group string text grp 1 replace string text replace use non capturing groups when you dont use the captured result link ruby bad first second good first second dont use the cryptic perl legacy variables denoting last regexp group matches 1 2 etc use regexp last match n instead link ruby regexp string bad process 1 good process regexp last match 1 avoid using numbered groups as it can be hard to track what they contain named groups can be used instead link ruby bad regexp string some code process regexp last match 1 good regexp string some code process meaningful var character classes have only a few special characters you should care about \ so dont escape or brackets in link be careful with and as they match start end of line not string endings if you want to match the whole string use \a and \z not to be confused with \z which is the equivalent of \n \z link ruby string some injection\nusername string username matches string \ausername\z doesnt match use x modifier for complex regexps this makes them more readable and you can add some useful comments just be careful as spaces are ignored link ruby regexp start some text \s white space char group first group alt1 alt2 some alternation end x for complex replacements sub gsub can be used with a block or a hash link ruby words foo bar words sub f f f foo bar words gsub \w word word capitalize foo bar percent literals use its a shorthand for q for single line strings which require both interpolation and embedded double quotes for multi line strings prefer heredocs link ruby bad no interpolation needed some text should be some text bad no double quotes this is quality style should be this is quality style bad multiple lines \n exclamation \n should be a heredoc good requires interpolation has quotes single line name avoid or the equivalent q unless you have a string with both and in it regular string literals are more readable and should be preferred unless a lot of characters would have to be escaped in them link ruby bad name q bruce wayne time q 8 oclock question q what did you say good name bruce wayne time 8 oclock question what did you say quote q what did you say use r only for regular expressions matching at least one character link ruby bad r \s good r r blog 2011 avoid the use of x unless youre going to invoke a command with backquotes in it which is rather unlikely link ruby bad date x date good date date echo x echo date avoid the use of s it seems that the community has decided some string is the preferred way to create a symbol with spaces in it link use the braces that are the most appropriate for the various kinds of percent literals link for string literals q q for array literals w i w i as it is aligned with the standard array literals for regexp literals r since parentheses often appear inside regular expressions thats why a less common character with is usually the best delimiter for r literals for all other literals e g s x ruby bad q tests king john said good q tests king john said bad w one two three i one two three good w one two three i one two three bad r \w \d r \w 1 2 \d 2 5 good r \w \d r \w 1 2 \d 2 5 metaprogramming avoid needless metaprogramming link do not mess around in core classes when writing libraries do not monkey patch them link the block form of class eval is preferable to the string interpolated form link when you use the string interpolated form always supply file and line so that your backtraces make sense ruby class eval def use relative model naming true end file line define method is preferable to class eval def when using class eval or other eval with string interpolation add a comment block showing its appearance if interpolated a practice used in rails code link ruby from activesupport lib active support core ext string output safety rb unsafe string methods each do unsafe method if string respond to unsafe method class eval eot file line 1 def unsafe method params block def capitalize params block to str unsafe method params block to str capitalize params block end end def unsafe method params def capitalize params dirty true dirty true super super end end eot end end avoid using method missing for metaprogramming because backtraces become messy the behavior is not listed in methods and misspelled method calls might silently work e g nukes launch state false consider using delegation proxy or define method instead if you must use method missing link be sure to also define respond to missing only catch methods with a well defined prefix such as find by —make your code as assertive as possible call super at the end of your statement delegate to assertive non magical methods ruby bad def method missing meth params block if find by meth lots of code to do a find by else super end end good def method missing meth params block if find by meth find by prop params block else super end end best of all though would to define method as each findable attribute is declared prefer public send over send so as not to circumvent private protected visibility link ruby we have an activemodel organization that includes concern activatable module activatable extend activesupport concern included do before create create token end private def reset token some code end def create token some code end def activate some code end end class organization activerecord base include activatable end linux organization organization find bad violates privacy linux organization send reset token good should throw an exception linux organization public send reset token prefer send over send as send may overlap with existing methods link ruby require socket u1 udpsocket new u1 bind 127 0 0 1 4913 u2 udpsocket new u2 connect 127 0 0 1 4913 wont send a message to the receiver obj instead it will send a message via udp socket u2 send sleep 0 will actually send a message to the receiver obj u2 send misc write ruby w safe code link avoid hashes as optional parameters does the method do too much object initializers are exceptions for this rule link avoid methods longer than 10 loc lines of code ideally most methods will be shorter than 5 loc empty lines do not contribute to the relevant loc link avoid parameter lists longer than three or four parameters link if you really need global methods add them to kernel and make them private link use module instance variables instead of global variables link ruby bad foo bar 1 good module foo class self attr accessor bar end end foo bar 1 use optionparser for parsing complex command line options and ruby s for trivial command line options link code in a functional way avoiding mutation when that makes sense link ruby a 1 2 3 each i a i 2 bad a 1 2 3 map i i 2 good a 1 2 3 each i a i i 17 bad a 1 2 3 reduce h i h i i 17 h good a 1 2 3 each with object i h h i i 17 good do not mutate parameters unless that is the purpose of the method link avoid more than three levels of block nesting link be consistent in an ideal world be consistent with these guidelines link use common sense link tools here are some tools to help you automatically check ruby code against this guide rubocop rubocop is a ruby code style checker based on this style guide rubocop already covers a significant portion of the guide supports both mri 1 9 and mri 2 0 and has good emacs integration rubymine rubymines code inspections are partially based on this guide contributing the guide is still a work in progress—some rules are lacking examples some rules dont have examples that illustrate them clearly enough improving such rules is a great and simple way to help the ruby community in due time these issues will hopefully be addressed—just keep them in mind for now nothing written in this guide is set in stone its my desire to work together with everyone interested in ruby coding style so that we could ultimately create a resource that will be beneficial to the entire ruby community feel free to open tickets or send pull requests with improvements thanks in advance for your help you can also support the project and rubocop with financial contributions via patreon how to contribute its easy just follow the contribution guidelines license this work is licensed under a creative commons attribution 3 0 unported license spread the word a community driven style guide is of little use to a community that doesnt know about its existence tweet about the guide share it with your friends and colleagues every comment suggestion or opinion we get makes the guide just a little bit better and we want to have the best possible guide dont we cheers bozhidar