if a function cannot return a value or throw an exception without blocking it can return a promise instead a promise is an object that represents the return value or the thrown exception that the function may eventually provide a promise can also be used as a proxy for a remote object to overcome latency on the first pass promises can mitigate the “pyramid of doom” the situation where code marches to the right faster than it marches forward javascript step1 function value1 step2 value1 function value2 step3 value2 function value3 step4 value3 function value4 do something with value4 with a promise library you can flatten the pyramid javascript q fcall promisedstep1 then promisedstep2 then promisedstep3 then promisedstep4 then function value4 do something with value4 catch function error handle any error from all above steps done with this approach you also get implicit error propagation just like try catch and finally an error in promisedstep1 will flow all the way to the catch function where its caught and handled here promisedstepn is a version of stepn that returns a promise the callback approach is called an “inversion of control” a function that accepts a callback instead of a return value is saying “dont call me ill call you ” promises un invert the inversion cleanly separating the input arguments from control flow arguments this simplifies the use and creation of apis particularly variadic rest and spread arguments getting started the q module can be loaded as a script tag creating a q global variable 2 5 kb minified and gzipped a node js and commonjs module available in npm as the q package an amd module a component as microjs q using bower as q 1 4 1 using nuget as q q can exchange promises with jquery dojo when js winjs and more resources our wiki contains a number of useful resources including a method by method q api reference a growing examples gallery showing how q can be used to make everything better from xhr to database access to accessing the flickr api q is there for you there are many libraries that produce and consume q promises for everything from file system database access or rpc to templating for a list of some of the more popular ones see libraries if you want materials that introduce the promise concept generally and the below tutorial isnt doing it for you check out our collection of presentations blog posts and podcasts a guide for those coming from jquerys deferred wed also love to have you join the q continuum mailing list tutorial promises have a then method which you can use to get the eventual return value fulfillment or thrown exception rejection javascript promisemesomething then function value function reason if promisemesomething returns a promise that gets fulfilled later with a return value the first function the fulfillment handler will be called with the value however if the promisemesomething function gets rejected later by a thrown exception the second function the rejection handler will be called with the exception note that resolution of a promise is always asynchronous that is the fulfillment or rejection handler will always be called in the next turn of the event loop i e process nexttick in node this gives you a nice guarantee when mentally tracing the flow of your code namely that then will always return before either handler is executed in this tutorial we begin with how to consume and work with promises well talk about how to create them and thus create functions like promisemesomething that return promises below propagation the then method returns a promise which in this example im assigning to outputpromise javascript var outputpromise getinputpromise then function input function reason the outputpromise variable becomes a new promise for the return value of either handler since a function can only either return a value or throw an exception only one handler will ever be called and it will be responsible for resolving outputpromise if you return a value in a handler outputpromise will get fulfilled if you throw an exception in a handler outputpromise will get rejected if you return a promise in a handler outputpromise will “become” that promise being able to become a new promise is useful for managing delays combining results or recovering from errors if the getinputpromise promise gets rejected and you omit the rejection handler the error will go to outputpromise javascript var outputpromise getinputpromise then function value if the input promise gets fulfilled and you omit the fulfillment handler the value will go to outputpromise javascript var outputpromise getinputpromise then null function error q promises provide a fail shorthand for then when you are only interested in handling the error javascript var outputpromise getinputpromise fail function error if you are writing javascript for modern engines only or using coffeescript you may use catch instead of fail promises also have a fin function that is like a finally clause the final handler gets called with no arguments when the promise returned by getinputpromise either returns a value or throws an error the value returned or error thrown by getinputpromise passes directly to outputpromise unless the final handler fails and may be delayed if the final handler returns a promise javascript var outputpromise getinputpromise fin function close files database connections stop servers conclude tests if the handler returns a value the value is ignored if the handler throws an error the error passes to outputpromise if the handler returns a promise outputpromise gets postponed the eventual value or error has the same effect as an immediate return value or thrown error a value would be ignored an error would be forwarded if you are writing javascript for modern engines only or using coffeescript you may use finally instead of fin chaining there are two ways to chain promises you can chain promises either inside or outside handlers the next two examples are equivalent javascript return getusername then function username return getuser username then function user if we get here without an error the value returned here or the exception thrown here resolves the promise returned by the first line javascript return getusername then function username return getuser username then function user if we get here without an error the value returned here or the exception thrown here resolves the promise returned by the first line the only difference is nesting its useful to nest handlers if you need to capture multiple input values in your closure javascript function authenticate return getusername then function username return getuser username chained because we will not need the user name in the next event then function user return getpassword nested because we need both user and password next then function password if user passwordhash hash password throw new error cant authenticate combination you can turn an array of promises into a promise for the whole fulfilled array using all javascript return q all eventualadd 2 2 eventualadd 10 20 if you have a promise for an array you can use spread as a replacement for then the spread function “spreads” the values over the arguments of the fulfillment handler the rejection handler will get called at the first sign of failure that is whichever of the received promises fails first gets handled by the rejection handler javascript function eventualadd a b return q spread a b function a b return a b but spread calls all initially so you can skip it in chains javascript return getusername then function username return username getuser username spread function username user the all function returns a promise for an array of values when this promise is fulfilled the array contains the fulfillment values of the original promises in the same order as those promises if one of the given promises is rejected the returned promise is immediately rejected not waiting for the rest of the batch if you want to wait for all of the promises to either be fulfilled or rejected you can use allsettled javascript q allsettled promises then function results results foreach function result if result state fulfilled var value result value else var reason result reason the any function accepts an array of promises and returns a promise that is fulfilled by the first given promise to be fulfilled or rejected if all of the given promises are rejected javascript q any promises then function first any of the promises was fulfilled function error all of the promises were rejected sequences if you have a number of promise producing functions that need to be run sequentially you can of course do so manually javascript return foo initialval then bar then baz then qux however if you want to run a dynamically constructed sequence of functions youll want something like this javascript var funcs foo bar baz qux var result q initialval funcs foreach function f result result then f return result you can make this slightly more compact using reduce javascript return funcs reduce function sofar f return sofar then f q initialval or you could use the ultra compact version javascript return funcs reduce q when q initialval handling errors one sometimes unintuitive aspect of promises is that if you throw an exception in the fulfillment handler it will not be caught by the error handler javascript return foo then function value throw new error cant bar function error we only get here if foo fails to see why this is consider the parallel between promises and try catch we are try ing to execute foo the error handler represents a catch for foo while the fulfillment handler represents code that happens after the try catch block that code then needs its own try catch block in terms of promises this means chaining your rejection handler javascript return foo then function value throw new error cant bar fail function error we get here with either foos error or bars error progress notification its possible for promises to report their progress e g for tasks that take a long time like a file upload not all promises will implement progress notifications but for those that do you can consume the progress values using a third parameter to then javascript return uploadfile then function success uploading the file function err there was an error and we get the reason for error function progress we get notified of the uploads progress as it is executed like fail q also provides a shorthand for progress callbacks called progress javascript return uploadfile progress function progress we get notified of the uploads progress the end when you get to the end of a chain of promises you should either return the last promise or end the chain since handlers catch errors its an unfortunate pattern that the exceptions can go unobserved so either return it javascript return foo then function return bar or end it javascript foo then function return bar done ending a promise chain makes sure that if an error doesnt get handled before the end it will get rethrown and reported this is a stopgap we are exploring ways to make unhandled errors visible without any explicit handling the beginning everything above assumes you get a promise from somewhere else this is the common case every once in a while you will need to create a promise from scratch using q fcall you can create a promise from a value using q fcall this returns a promise for 10 javascript return q fcall function return 10 you can also use fcall to get a promise for an exception javascript return q fcall function throw new error cant do it as the name implies fcall can call functions or even promised functions this uses the eventualadd function above to add two numbers javascript return q fcall eventualadd 2 2 using deferreds if you have to interface with asynchronous functions that are callback based instead of promise based q provides a few shortcuts like q nfcall and friends but much of the time the solution will be to use deferreds javascript var deferred q defer fs readfile foo txt utf 8 function error text if error deferred reject new error error else deferred resolve text return deferred promise note that a deferred can be resolved with a value or a promise the reject function is a shorthand for resolving with a rejected promise javascript this deferred reject new error cant do it is shorthand for var rejection q fcall function throw new error cant do it deferred resolve rejection this is a simplified implementation of q delay javascript function delay ms var deferred q defer settimeout deferred resolve ms return deferred promise this is a simplified implementation of q timeout javascript function timeout promise ms var deferred q defer q when promise deferred resolve delay ms then function deferred reject new error timed out return deferred promise finally you can send a progress notification to the promise with deferred notify for illustration this is a wrapper for xml http requests in the browser note that a more thorough implementation would be in order in practice javascript function requestoktext url var request new xmlhttprequest var deferred q defer request open get url true request onload onload request onerror onerror request onprogress onprogress request send function onload if request status 200 deferred resolve request responsetext else deferred reject new error status code was request status function onerror deferred reject new error cant xhr json stringify url function onprogress event deferred notify event loaded event total return deferred promise below is an example of how to use this requestoktext function javascript requestoktext http localhost 3000 then function responsetext if the http response returns 200 ok log the response text console log responsetext function error if theres an error or a non 200 status code log the error console error error function progress log the progress as it comes in console log request progress math round progress 100 using q promise this is an alternative promise creation api that has the same power as the deferred concept but without introducing another conceptual entity rewriting the requestoktext example above using q promise javascript function requestoktext url return q promise function resolve reject notify var request new xmlhttprequest request open get url true request onload onload request onerror onerror request onprogress onprogress request send function onload if request status 200 resolve request responsetext else reject new error status code was request status function onerror reject new error cant xhr json stringify url function onprogress event notify event loaded event total if requestoktext were to throw an exception the returned promise would be rejected with that thrown exception as the rejection reason the middle if you are using a function that may return a promise but just might return a value if it doesnt need to defer you can use the “static” methods of the q library the when function is the static equivalent for then javascript return q when valueorpromise function value function error all of the other methods on a promise have static analogs with the same name the following are equivalent javascript return q all a b javascript return q fcall function return a b all when working with promises provided by other libraries you should convert it to a q promise not all promise libraries make the same guarantees as q and certainly dont provide all of the same methods most libraries only provide a partially functional then method this thankfully is all we need to turn them into vibrant q promises javascript return q ajax then function if there is any chance that the promise you receive is not a q promise as provided by your library you should wrap it using a q function you can even use q invoke as a shorthand javascript return q invoke ajax then function over the wire a promise can serve as a proxy for another object even a remote object there are methods that allow you to optimistically manipulate properties or call functions all of these interactions return promises so they can be chained direct manipulation using a promise as a proxy value foo promise get foo value foo value promise put foo value delete value foo promise del foo value foo args promise post foo args value foo args promise invoke foo args value args promise fapply args value args promise fcall args if the promise is a proxy for a remote object you can shave round trips by using these functions instead of then to take advantage of promises for remote objects check out q connection even in the case of non remote objects these methods can be used as shorthand for particularly simple fulfillment handlers for example you can replace javascript return q fcall function return foo bar foo baz then function value return value 0 foo with javascript return q fcall function return foo bar foo baz get 0 get foo adapting node if youre working with functions that make use of the node js callback pattern where callbacks are in the form of function err result q provides a few useful utility functions for converting between them the most straightforward are probably q nfcall and q nfapply node function call apply for calling node js style functions and getting back a promise javascript return q nfcall fs readfile foo txt utf 8 return q nfapply fs readfile foo txt utf 8 if you are working with methods instead of simple functions you can easily run in to the usual problems where passing a method to another function—like q nfcall— un binds the method from its owner to avoid this you can either use function prototype bind or some nice shortcut methods we provide javascript return q ninvoke redisclient get user 1 id return q npost redisclient get user 1 id you can also create reusable wrappers with q denodeify or q nbind javascript var readfile q denodeify fs readfile return readfile foo txt utf 8 var redisclientget q nbind redisclient get redisclient return redisclientget user 1 id finally if youre working with raw deferred objects there is a makenoderesolver method on deferreds that can be handy javascript var deferred q defer fs readfile foo txt utf 8 deferred makenoderesolver return deferred promise long stack traces q comes with optional support for “long stack traces ” wherein the stack property of error rejection reasons is rewritten to be traced along asynchronous jumps instead of stopping at the most recent one as an example js function thedepthsofmyprogram q delay 100 done function explode throw new error boo thedepthsofmyprogram usually would give a rather unhelpful stack trace looking something like error boo at explode path to test js 3 11 at fulfilled path to test js q 54 at resolvedvalue promisedispatch done path to q js 823 30 at makepromise promise promisedispatch path to q js 496 13 at pending path to q js 397 39 at process startup processnexttick process tickcallback node js 244 9 but if you turn this feature on by setting js q longstacksupport true then the above code gives a nice stack trace to the tune of error boo at explode path to test js 3 11 from previous event at thedepthsofmyprogram path to test js 2 16 at object anonymous path to test js 7 1 note how you can see the function that triggered the async operation in the stack trace this is very helpful for debugging as otherwise you end up getting only the first line plus a bunch of q internals with no sign of where the operation started in node js this feature can also be enabled through the q debug environment variable q debug 1 node server js this will enable long stack support in every instance of q this feature does come with somewhat serious performance and memory overhead however if youre working with lots of promises or trying to scale a server to many users you should probably keep it off but in development go for it tests you can view the results of the q test suite in your browser license copyright 2009–2017 kristopher michael kowal and contributors mit license enclosed