sinatra sinatra is a dsl for quickly creating web applications in ruby with minimal effort ruby myapp rb require sinatra get do hello world end install the gem shell gem install sinatra and run with shell ruby myapp rb view at http localhost 4567 the code you changed will not take effect until you restart the server please restart the server every time you change or use sinatra reloader it is recommended to also run gem install thin which sinatra will pick up if available table of contents sinatra table of contents routes conditions return values custom route matchers static files views templates literal templates available template languages haml templates erb templates builder templates nokogiri templates sass templates scss templates less templates liquid templates markdown templates textile templates rdoc templates asciidoc templates radius templates markaby templates rabl templates slim templates creole templates mediawiki templates coffeescript templates stylus templates yajl templates wlang templates accessing variables in templates templates with yield and nested layouts inline templates named templates associating file extensions adding your own template engine using custom logic for template lookup filters helpers using sessions session secret security session config choosing your own session middleware halting passing triggering another route setting body status code and headers streaming responses logging mime types generating urls browser redirect cache control sending files accessing the request object attachments dealing with date and time looking up template files configuration configuring attack protection available settings environments error handling not found error rack middleware testing sinatra base middleware libraries and modular apps modular vs classic style serving a modular application using a classic style application with a config ru when to use a config ru using sinatra as middleware dynamic application creation scopes and binding application class scope request instance scope delegation scope command line multi threading requirement the bleeding edge with bundler versioning further reading routes in sinatra a route is an http method paired with a url matching pattern each route is associated with a block ruby get do show something end post do create something end put do replace something end patch do modify something end delete do annihilate something end options do appease something end link do affiliate something end unlink do separate something end routes are matched in the order they are defined the first route that matches the request is invoked routes with trailing slashes are different from the ones without ruby get foo do does not match get foo end route patterns may include named parameters accessible via the params hash ruby get hello name do matches get hello foo and get hello bar params name is foo or bar hello params name end you can also access named parameters via block parameters ruby get hello name do n matches get hello foo and get hello bar params name is foo or bar n stores params name hello n end route patterns may also include splat or wildcard parameters accessible via the params splat array ruby get say to do matches say hello to world params splat hello world end get download do matches download path to file xml params splat path to file xml end or with block parameters ruby get download do path ext path ext path to file xml end route matching with regular expressions ruby get \ hello\ \w do hello params captures first end or with a block parameter ruby get r hello \w do c matches get meta hello world get hello world 1234 etc hello c end route patterns may have optional parameters ruby get posts format do matches get posts and any extension get posts json get posts xml etc end routes may also utilize query parameters ruby get posts do matches get posts title foo author bar title params title author params author uses title and author variables query is optional to the posts route end by the way unless you disable the path traversal attack protection see below the request path might be modified before matching against your routes you may customize the mustermann options used for a given route by passing in a mustermann opts hash ruby get \a posts\z mustermann opts type regexp check anchors false do matches posts exactly with explicit anchoring if you match an anchored pattern clap your hands end it looks like a condition but it isnt one these options will be merged into the global mustermann opts hash described below conditions routes may include a variety of matching conditions such as the user agent ruby get foo agent songbird \d \d \d\ do youre using songbird version params agent 0 end get foo do matches non songbird browsers end other available conditions are host name and provides ruby get host name admin do admin area access denied end get provides html do haml index end get provides rss atom xml do builder feed end provides searches the requests accept header you can easily define your own conditions ruby set probability value condition rand value get win a car probability 0 1 do you won end get win a car do sorry you lost end for a condition that takes multiple values use a splat ruby set auth do roles notice the splat here condition do unless logged in roles any role current user in role role redirect login 303 end end end get my account auth user admin do your account details end get only admin auth admin do only admins are allowed here end return values the return value of a route block determines at least the response body passed on to the http client or at least the next middleware in the rack stack most commonly this is a string as in the above examples but other values are also accepted you can return any object that would either be a valid rack response rack body object or http status code an array with three elements status fixnum headers hash response body responds to each an array with two elements status fixnum response body responds to each an object that responds to each and passes nothing but strings to the given block a fixnum representing the status code that way we can for instance easily implement a streaming example ruby class stream def each 100 times i yield i \n end end get stream new you can also use the stream helper method described below to reduce boiler plate and embed the streaming logic in the route custom route matchers as shown above sinatra ships with built in support for using string patterns and regular expressions as route matches however it does not stop there you can easily define your own matchers ruby class allbutpattern match struct new captures def initialize except except except captures match new end def match str captures unless except str end end def all but pattern allbutpattern new pattern end get all but index do end note that the above example might be over engineered as it can also be expressed as ruby get do pass if request path info index end or using negative look ahead ruby get r index do end static files static files are served from the public directory you can specify a different location by setting the public folder option ruby set public folder file dirname file static note that the public directory name is not included in the url a file public css style css is made available as http example com css style css use the static cache control setting see below to add cache control header info views templates each template language is exposed via its own rendering method these methods simply return a string ruby get do erb index end this renders views index erb instead of a template name you can also just pass in the template content directly ruby get do code time now erb code end templates take a second argument the options hash ruby get do erb index layout post end this will render views index erb embedded in the views post erb default is views layout erb if it exists any options not understood by sinatra will be passed on to the template engine ruby get do haml index format html5 end you can also set options per template language in general ruby set haml format html5 get do haml index end options passed to the render method override options set via set available options locals list of locals passed to the document handy with partials example erb foo locals foo bar default encoding string encoding to use if uncertain defaults to settings default encoding views views folder to load templates from defaults to settings views layout whether to use a layout true or false if its a symbol specifies what template to use example erb index layout request xhr content type content type the template produces default depends on template language scope scope to render template under defaults to the application instance if you change this instance variables and helper methods will not be available layout engine template engine to use for rendering the layout useful for languages that do not support layouts otherwise defaults to the engine used for the template example set rdoc layout engine erb layout options special options only used for rendering the layout example set rdoc layout options views views layouts templates are assumed to be located directly under the views directory to use a different views directory ruby set views settings root templates one important thing to remember is that you always have to reference templates with symbols even if theyre in a subdirectory in this case use subdir template or subdir template to sym you must use a symbol because otherwise rendering methods will render any strings passed to them directly literal templates ruby get do haml div title hello world end renders the template string you can optionally specify path and line for a clearer backtrace if there is a filesystem path or line associated with that string ruby get do haml div title hello world path examples file haml line 3 end available template languages some languages have multiple implementations to specify what implementation to use and to be thread safe you should simply require it first ruby require rdiscount or require bluecloth get markdown index haml templates dependency haml file extension haml example haml index format html5 erb templates dependency erubis or erb included in ruby file extensions erb rhtml or erubis erubis only example erb index builder templates dependency builder file extension builder example builder xml xml em hi it also takes a block for inline templates see example nokogiri templates dependency nokogiri file extension nokogiri example nokogiri xml xml em hi it also takes a block for inline templates see example sass templates dependency sass file extension sass example sass stylesheet style expanded scss templates dependency sass file extension scss example scss stylesheet style expanded less templates dependency less file extension less example less stylesheet liquid templates dependency liquid file extension liquid example liquid index locals key value since you cannot call ruby methods except for yield from a liquid template you almost always want to pass locals to it markdown templates dependency anyone of rdiscount redcarpet bluecloth kramdown maruku file extensions markdown mkd and md example markdown index layout engine erb it is not possible to call methods from markdown nor to pass locals to it you therefore will usually use it in combination with another rendering engine ruby erb overview locals text markdown introduction note that you may also call the markdown method from within other templates ruby h1 hello from haml p markdown greetings since you cannot call ruby from markdown you cannot use layouts written in markdown however it is possible to use another rendering engine for the template than for the layout by passing the layout engine option textile templates dependency redcloth file extension textile example textile index layout engine erb it is not possible to call methods from textile nor to pass locals to it you therefore will usually use it in combination with another rendering engine ruby erb overview locals text textile introduction note that you may also call the textile method from within other templates ruby h1 hello from haml p textile greetings since you cannot call ruby from textile you cannot use layouts written in textile however it is possible to use another rendering engine for the template than for the layout by passing the layout engine option rdoc templates dependency rdoc file extension rdoc example rdoc readme layout engine erb it is not possible to call methods from rdoc nor to pass locals to it you therefore will usually use it in combination with another rendering engine ruby erb overview locals text rdoc introduction note that you may also call the rdoc method from within other templates ruby h1 hello from haml p rdoc greetings since you cannot call ruby from rdoc you cannot use layouts written in rdoc however it is possible to use another rendering engine for the template than for the layout by passing the layout engine option asciidoc templates dependency asciidoctor file extension asciidoc adoc and ad example asciidoc readme layout engine erb since you cannot call ruby methods directly from an asciidoc template you almost always want to pass locals to it radius templates dependency radius file extension radius example radius index locals key value since you cannot call ruby methods directly from a radius template you almost always want to pass locals to it markaby templates dependency markaby file extension mab example markaby h1 welcome it also takes a block for inline templates see example rabl templates dependency rabl file extension rabl example rabl index slim templates dependency slim lang file extension slim example slim index creole templates dependency creole file extension creole example creole wiki layout engine erb it is not possible to call methods from creole nor to pass locals to it you therefore will usually use it in combination with another rendering engine ruby erb overview locals text creole introduction note that you may also call the creole method from within other templates ruby h1 hello from haml p creole greetings since you cannot call ruby from creole you cannot use layouts written in creole however it is possible to use another rendering engine for the template than for the layout by passing the layout engine option mediawiki templates dependency wikicloth file extension mediawiki and mw example mediawiki wiki layout engine erb it is not possible to call methods from mediawiki markup nor to pass locals to it you therefore will usually use it in combination with another rendering engine ruby erb overview locals text mediawiki introduction note that you may also call the mediawiki method from within other templates ruby h1 hello from haml p mediawiki greetings since you cannot call ruby from mediawiki you cannot use layouts written in mediawiki however it is possible to use another rendering engine for the template than for the layout by passing the layout engine option coffeescript templates dependency coffeescript and a way to execute javascript file extension coffee example coffee index stylus templates dependency stylus and a way to execute javascript file extension styl example stylus index before being able to use stylus templates you need to load stylus and stylus tilt first ruby require sinatra require stylus require stylus tilt get do stylus example end yajl templates dependency yajl ruby file extension yajl example yajl index locals key qux callback present variable resource the template source is evaluated as a ruby string and the resulting json variable is converted using to json ruby json foo bar json baz key the callback and variable options can be used to decorate the rendered object javascript var resource foo bar baz qux present resource wlang templates dependency wlang file extension wlang example wlang index locals key value since calling ruby methods is not idiomatic in wlang you almost always want to pass locals to it layouts written in wlang and yield are supported though accessing variables in templates templates are evaluated within the same context as route handlers instance variables set in route handlers are directly accessible by templates ruby get id do foo foo find params id haml h1 foo name end or specify an explicit hash of local variables ruby get id do foo foo find params id haml h1 bar name locals bar foo end this is typically used when rendering templates as partials from within other templates templates with yield and nested layouts a layout is usually just a template that calls yield such a template can be used either through the template option as described above or it can be rendered with a block as follows ruby erb post layout false do erb index end this code is mostly equivalent to erb index layout post passing blocks to rendering methods is most useful for creating nested layouts ruby erb main layout layout false do erb admin layout do erb user end end this can also be done in fewer lines of code with ruby erb admin layout layout main layout do erb user end currently the following rendering methods accept a block erb haml liquid slim wlang also the general render method accepts a block inline templates templates may be defined at the end of the source file ruby require sinatra get do haml index end end layout html yield index div title hello world note inline templates defined in the source file that requires sinatra are automatically loaded call enable inline templates explicitly if you have inline templates in other source files named templates templates may also be defined using the top level template method ruby template layout do html\n yield\n end template index do div title hello world end get do haml index end if a template named layout exists it will be used each time a template is rendered you can individually disable layouts by passing layout false or disable them by default via set haml layout false ruby get do haml index layout request xhr end associating file extensions to associate a file extension with a template engine use tilt register for instance if you like to use the file extension tt for textile templates you can do the following ruby tilt register tt tilt textile adding your own template engine first register your engine with tilt then create a rendering method ruby tilt register myat myawesometemplateengine helpers do def myat args render myat args end end get do myat index end renders views index myat learn more about tilt using custom logic for template lookup to implement your own template lookup mechanism you can write your own find template method ruby configure do set views views a views b end def find template views name engine block array views each do v super v name engine block end end filters before filters are evaluated before each request within the same context as the routes will be and can modify the request and response instance variables set in filters are accessible by routes and templates ruby before do note hi request path info foo bar baz end get foo do note hi params splat bar baz end after filters are evaluated after each request within the same context as the routes will be and can also modify the request and response instance variables set in before filters and routes are accessible by after filters ruby after do puts response status end note unless you use the body method rather than just returning a string from the routes the body will not yet be available in the after filter since it is generated later on filters optionally take a pattern causing them to be evaluated only if the request path matches that pattern ruby before protected do authenticate end after create slug do slug session last slug slug end like routes filters also take conditions ruby before agent songbird do end after blog host name example com do end helpers use the top level helpers method to define helper methods for use in route handlers and templates ruby helpers do def bar name name bar end end get name do bar params name end alternatively helper methods can be separately defined in a module ruby module fooutils def foo name name foo end end module barutils def bar name name bar end end helpers fooutils barutils the effect is the same as including the modules in the application class using sessions a session is used to keep state during requests if activated you have one session hash per user session ruby enable sessions get do value session value inspect end get value do session value params value end session secret security to improve security the session data in the cookie is signed with a session secret using hmac sha1 this session secret should optimally be a cryptographically secure random value of an appropriate length which for hmac sha1 is greater than or equal to 64 bytes 512 bits 128 hex characters you would be advised not to use a secret that is less than 32 bytes of randomness 256 bits 64 hex characters it is therefore very important that you dont just make the secret up but instead use a secure random number generator to create it humans are extremely bad at generating random values by default a 32 byte secure random session secret is generated for you by sinatra but it will change with every restart of your application if you have multiple instances of your application and you let sinatra generate the key each instance would then have a different session key which is probably not what you want for better security and usability its recommended that you generate a secure random secret and store it in an environment variable on each host running your application so that all of your application instances will share the same secret you should periodically rotate this session secret to a new value here are some examples of how you might create a 64 byte secret and set it session secret generation text ruby e require securerandom puts securerandom hex 64 99ae8af snip ec0f262ac session secret generation bonus points use the sysrandom gem to prefer use of system rng facilities to generate random values instead of userspace openssl which mri ruby currently defaults to text gem install sysrandom building native extensions this could take a while successfully installed sysrandom 1 x 1 gem installed ruby e require sysrandom securerandom puts securerandom hex 64 99ae8af snip ec0f262ac session secret environment variable set a session secret environment variable for sinatra to the value you generated make this value persistent across reboots of your host since the method for doing this will vary across systems this is for illustrative purposes only bash echo export session secret 99ae8af snip ec0f262ac bashrc session secret app config setup your app config to fail safe to a secure random secret if the session secret environment variable is not available for bonus points use the sysrandom gem here as well ruby require securerandom or require sysrandom securerandom set session secret env fetch session secret securerandom hex 64 session config if you want to configure it further you may also store a hash with options in the sessions setting ruby set sessions domain foo com to share your session across other apps on subdomains of foo com prefix the domain with a like this instead ruby set sessions domain foo com choosing your own session middleware note that enable sessions actually stores all data in a cookie this might not always be what you want storing lots of data will increase your traffic for instance you can use any rack session middleware in order to do so one of the following methods can be used ruby enable sessions set session store rack session pool or to set up sessions with a hash of options ruby set sessions expire after 2592000 set session store rack session pool another option is to not call enable sessions but instead pull in your middleware of choice as you would any other middleware it is important to note that when using this method session based protection will not be enabled by default the rack middleware to do that will also need to be added ruby use rack session pool expire after 2592000 use rack protection remotetoken use rack protection sessionhijacking see configuring attack protection for more information halting to immediately stop a request within a filter or route use ruby halt you can also specify the status when halting ruby halt 410 or the body ruby halt this will be the body or both ruby halt 401 go away with headers ruby halt 402 content type text plain revenge it is of course possible to combine a template with halt ruby halt erb error passing a route can punt processing to the next matching route using pass ruby get guess who do pass unless params who frank you got me end get guess do you missed end the route block is immediately exited and control continues with the next matching route if no matching route is found a 404 is returned triggering another route sometimes pass is not what you want instead you would like to get the result of calling another route simply use call to achieve this ruby get foo do status headers body call env merge path info bar status headers body map upcase end get bar do bar end note that in the example above you would ease testing and increase performance by simply moving bar into a helper used by both foo and bar if you want the request to be sent to the same application instance rather than a duplicate use call instead of call check out the rack specification if you want to learn more about call setting body status code and headers it is possible and recommended to set the status code and response body with the return value of the route block however in some scenarios you might want to set the body at an arbitrary point in the execution flow you can do so with the body helper method if you do so you can use that method from there on to access the body ruby get foo do body bar end after do puts body end it is also possible to pass a block to body which will be executed by the rack handler this can be used to implement streaming see return values similar to the body you can also set the status code and headers ruby get foo do status 418 headers \ allow brew post get propfind when refresh refresh 20 https ietf org rfc rfc2324 txt body im a tea pot end like body headers and status with no arguments can be used to access their current values streaming responses sometimes you want to start sending out data while still generating parts of the response body in extreme examples you want to keep sending data until the client closes the connection you can use the stream helper to avoid creating your own wrapper ruby get do stream do out out its gonna be legen \n sleep 0 5 out wait for it \n sleep 1 out dary \n end end this allows you to implement streaming apis server sent events and can be used as the basis for websockets it can also be used to increase throughput if some but not all content depends on a slow resource note that the streaming behavior especially the number of concurrent requests highly depends on the web server used to serve the application some servers might not even support streaming at all if the server does not support streaming the body will be sent all at once after the block passed to stream finishes executing streaming does not work at all with shotgun if the optional parameter is set to keep open it will not call close on the stream object allowing you to close it at any later point in the execution flow this only works on evented servers like thin and rainbows other servers will still close the stream ruby long polling set server thin connections get subscribe do register a clients interest in server events stream keep open do out connections out purge dead connections connections reject closed end end post message do connections each do out notify client that a new message has arrived out params message \n indicate client to connect again out close end acknowledge message received end its also possible for the client to close the connection when trying to write to the socket because of this its recommended to check out closed before trying to write logging in the request scope the logger helper exposes a logger instance ruby get do logger info loading data end this logger will automatically take your rack handlers logging settings into account if logging is disabled this method will return a dummy object so you do not have to worry about it in your routes and filters note that logging is only enabled for sinatra application by default so if you inherit from sinatra base you probably want to enable it yourself ruby class myapp sinatra base configure production development do enable logging end end to avoid any logging middleware to be set up set the logging setting to nil however keep in mind that logger will in that case return nil a common use case is when you want to set your own logger sinatra will use whatever it will find in env rack logger mime types when using send file or static files you may have mime types sinatra doesnt understand use mime type to register them by file extension ruby configure do mime type foo text foo end you can also use it with the content type helper ruby get do content type foo foo foo foo end generating urls for generating urls you should use the url helper method for instance in haml ruby a href url foo foo it takes reverse proxies and rack routers into account if present this method is also aliased to to see below for an example browser redirect you can trigger a browser redirect with the redirect helper method ruby get foo do redirect to bar end any additional parameters are handled like arguments passed to halt ruby redirect to bar 303 redirect http www google com wrong place buddy you can also easily redirect back to the page the user came from with redirect back ruby get foo do do something end get bar do do something redirect back end to pass arguments with a redirect either add them to the query ruby redirect to bar sum 42 or use a session ruby enable sessions get foo do session secret foo redirect to bar end get bar do session secret end cache control setting your headers correctly is the foundation for proper http caching you can easily set the cache control header like this ruby get do cache control public cache it end pro tip set up caching in a before filter ruby before do cache control public must revalidate max age 60 end if you are using the expires helper to set the corresponding header cache control will be set automatically for you ruby before do expires 500 public must revalidate end to properly use caches you should consider using etag or last modified it is recommended to call those helpers before doing any heavy lifting as they will immediately flush a response if the client already has the current version in its cache ruby get article id do article article find params id last modified article updated at etag article sha1 erb article end it is also possible to use a weak etag ruby etag article sha1 weak these helpers will not do any caching for you but rather feed the necessary information to your cache if you are looking for a quick reverse proxy caching solution try rack cache ruby require rack cache require sinatra use rack cache get do cache control public max age 36000 sleep 5 hello end use the static cache control setting see below to add cache control header info to static files according to rfc 2616 your application should behave differently if the if match or if none match header is set to depending on whether the resource requested is already in existence sinatra assumes resources for safe like get and idempotent like put requests are already in existence whereas other resources for instance post requests are treated as new resources you can change this behavior by passing in a new resource option ruby get create do etag new resource true article create erb new article end if you still want to use a weak etag pass in a kind option ruby etag new resource true kind weak sending files to return the contents of a file as the response you can use the send file helper method ruby get do send file foo png end it also takes options ruby send file foo png type jpg the options are filename file name to be used in the response defaults to the real file name last modified value for last modified header defaults to the files mtime type value for content type header guessed from the file extension if missing disposition value for content disposition header possible values nil default attachment and inline length value for content length header defaults to file size status status code to be sent useful when sending a static file as an error page if supported by the rack handler other means than streaming from the ruby process will be used if you use this helper method sinatra will automatically handle range requests accessing the request object the incoming request object can be accessed from request level filter routes error handlers through the request method ruby app running on http example com example get foo do t w text css text html application javascript request accept text html request accept text xml true request preferred type t text html request body request body sent by the client see below request scheme http request script name example request path info foo request port 80 request request method get request query string request content length length of request body request media type media type of request body request host example com request get true similar methods for other verbs request form data false request some param value of some param parameter is a shortcut to the params hash request referrer the referrer of the client or request user agent user agent used by agent condition request cookies hash of browser cookies request xhr is this an ajax request request url http example com example foo request path example foo request ip client ip address request secure false would be true over ssl request forwarded true if running behind a reverse proxy request env raw env hash handed in by rack end some options like script name or path info can also be written ruby before request path info get do all requests end up here end the request body is an io or stringio object ruby post api do request body rewind in case someone already read it data json parse request body read hello data name end attachments you can use the attachment helper to tell the browser the response should be stored on disk rather than displayed in the browser ruby get do attachment store it end you can also pass it a file name ruby get do attachment info txt store it end dealing with date and time sinatra offers a time for helper method that generates a time object from the given value it is also able to convert datetime date and similar classes ruby get do pass if time now time for dec 23 2016 still time end this method is used internally by expires last modified and akin you can therefore easily extend the behavior of those methods by overriding time for in your application ruby helpers do def time for value case value when yesterday then time now 246060 when tomorrow then time now 246060 else super end end end get do last modified yesterday expires tomorrow hello end looking up template files the find template helper is used to find template files for rendering ruby find template settings views foo tilt haml do file puts could be file end this is not really useful but it is useful that you can actually override this method to hook in your own lookup mechanism for instance if you want to be able to use more than one view directory ruby set views views templates helpers do def find template views name engine block array views each v super v name engine block end end another example would be using different directories for different engines ruby set views sass views sass haml templates default views helpers do def find template views name engine block folder views detect k v engine tilt k folder views default super folder name engine block end end you can also easily wrap this up in an extension and share with others note that find template does not check if the file really exists but rather calls the given block for all possible paths this is not a performance issue since render will use break as soon as a file is found also template locations and content will be cached if you are not running in development mode you should keep that in mind if you write a really crazy method configuration run once at startup in any environment ruby configure do setting one option set option value setting multiple options set a 1 b 2 same as set option true enable option same as set option false disable option you can also have dynamic settings with blocks set css dir file join views css end run only when the environment app env environment variable is set to production ruby configure production do end run when the environment is set to either production or test ruby configure production test do end you can access those options via settings ruby configure do set foo bar end get do settings foo true settings foo bar end configuring attack protection sinatra is using rack protection to defend your application against common opportunistic attacks you can easily disable this behavior which will open up your application to tons of common vulnerabilities ruby disable protection to skip a single defense layer set protection to an options hash ruby set protection except path traversal you can also hand in an array in order to disable a list of protections ruby set protection except path traversal session hijacking by default sinatra will only set up session based protection if sessions have been enabled see using sessions sometimes you may want to set up sessions outside of the sinatra app such as in the config ru or with a separate rack builder instance in that case you can still set up session based protection by passing the session option ruby set protection session true available settings absolute redirects if disabled sinatra will allow relative redirects however sinatra will no longer conform with rfc 2616 http 1 1 which only allows absolute redirects enable if your app is running behind a reverse proxy that has not been set up properly note that the url helper will still produce absolute urls unless you pass in false as the second parameter disabled by default add charset mime types the content type helper will automatically add the charset info to you should add to it rather than overriding this option settings add charset application foobar app file path to the main application file used to detect project root views and public folder and inline templates bind ip address to bind to default 0 0 0 0 or localhost if your environment is set to development only used for built in server default encoding encoding to assume if unknown defaults to utf 8 dump errors display errors in the log environment current environment defaults to env app env or development if not available logging use the logger lock places a lock around every request only running processing on request per ruby process concurrently enabled if your app is not thread safe disabled by default method override use method magic to allow put delete forms in browsers that dont support it mustermann opts a default hash of options to pass to mustermann new when compiling routing paths port port to listen on only used for built in server prefixed redirects whether or not to insert request script name into redirects if no absolute path is given that way redirect foo would behave like redirect to foo disabled by default protection whether or not to enable web attack protections see protection section above public dir alias for public folder see below public folder path to the folder public files are served from only used if static file serving is enabled see static setting below inferred from app file setting if not set quiet disables logs generated by sinatras start and stop commands false by default reload templates whether or not to reload templates between requests enabled in development mode root path to project root folder inferred from app file setting if not set raise errors raise exceptions will stop application enabled by default when environment is set to test disabled otherwise run if enabled sinatra will handle starting the web server do not enable if using rackup or other means running is the built in server running now do not change this setting server server or list of servers to use for built in server order indicates priority default depends on ruby implementation server settings if you are using a webrick web server presumably for your development environment you can pass a hash of options to server settings such as sslenable or sslverifyclient however web servers such as puma and thin do not support this so you can set server settings by defining it as a method when you call configure sessions enable cookie based sessions support using rack session cookie see using sessions section for more information session store the rack session middleware used defaults to rack session cookie see using sessions section for more information show exceptions show a stack trace in the browser when an exception happens enabled by default when environment is set to development disabled otherwise can also be set to after handler to trigger app specified error handling before showing a stack trace in the browser static whether sinatra should handle serving static files disable when using a server able to do this on its own disabling will boost performance enabled by default in classic style disabled for modular apps static cache control when sinatra is serving static files set this to add cache control headers to the responses uses the cache control helper disabled by default use an explicit array when setting multiple values set static cache control public max age 300 threaded if set to true will tell thin to use eventmachine defer for processing the request traps whether sinatra should handle system signals views path to the views folder inferred from app file setting if not set x cascade whether or not to set the x cascade header if no route matches defaults to true environments there are three predefined environments development production and test environments can be set through the app env environment variable the default value is development in the development environment all templates are reloaded between requests and special not found and error handlers display stack traces in your browser in the production and test environments templates are cached by default to run different environments set the app env environment variable shell app env production ruby my app rb you can use predefined methods development test and production to check the current environment setting ruby get do if settings development development else not development end end error handling error handlers run within the same context as routes and before filters which means you get all the goodies it has to offer like haml erb halt etc not found when a sinatra notfound exception is raised or the responses status code is 404 the not found handler is invoked ruby not found do this is nowhere to be found end error the error handler is invoked any time an exception is raised from a route block or a filter but note in development it will only run if you set the show exceptions option to after handler ruby set show exceptions after handler the exception object can be obtained from the sinatra error rack variable ruby error do sorry there was a nasty error env sinatra error message end custom errors ruby error mycustomerror do so what happened was env sinatra error message end then if this happens ruby get do raise mycustomerror something bad end you get this so what happened was something bad alternatively you can install an error handler for a status code ruby error 403 do access forbidden end get secret do 403 end or a range ruby error 400 510 do boom end sinatra installs special not found and error handlers when running under the development environment to display nice stack traces and additional debugging information in your browser rack middleware sinatra rides on rack a minimal standard interface for ruby web frameworks one of racks most interesting capabilities for application developers is support for middleware components that sit between the server and your application monitoring and or manipulating the http request response to provide various types of common functionality sinatra makes building rack middleware pipelines a cinch via a top level use method ruby require sinatra require my custom middleware use rack lint use mycustommiddleware get hello do hello world end the semantics of use are identical to those defined for the rack builder dsl most frequently used from rackup files for example the use method accepts multiple variable args as well as blocks ruby use rack auth basic do username password username admin password secret end rack is distributed with a variety of standard middleware for logging debugging url routing authentication and session handling sinatra uses many of these components automatically based on configuration so you typically dont have to use them explicitly you can find useful middleware in rack rack contrib or in the rack wiki testing sinatra tests can be written using any rack based testing library or framework rack test is recommended ruby require my sinatra app require minitest autorun require rack test class myapptest minitest test include rack test methods def app sinatra application end def test my default get assert equal hello world last response body end def test with params get meet name frank assert equal hello frank last response body end def test with user agent get http user agent songbird assert equal youre using songbird last response body end end note if you are using sinatra in the modular style replace sinatra application above with the class name of your app sinatra base middleware libraries and modular apps defining your app at the top level works well for micro apps but has considerable drawbacks when building reusable components such as rack middleware rails metal simple libraries with a server component or even sinatra extensions the top level assumes a micro app style configuration e g a single application file public and views directories logging exception detail page etc thats where sinatra base comes into play ruby require sinatra base class myapp sinatra base set sessions true set foo bar get do hello world end end the methods available to sinatra base subclasses are exactly the same as those available via the top level dsl most top level apps can be converted to sinatra base components with two modifications your file should require sinatra base instead of sinatra otherwise all of sinatras dsl methods are imported into the main namespace put your apps routes error handlers filters and options in a subclass of sinatra base sinatra base is a blank slate most options are disabled by default including the built in server see configuring settings for details on available options and their behavior if you want behavior more similar to when you define your app at the top level also known as classic style you can subclass sinatra application ruby require sinatra base class myapp sinatra application get do hello world end end modular vs classic style contrary to common belief there is nothing wrong with the classic style if it suits your application you do not have to switch to a modular application the main disadvantage of using the classic style rather than the modular style is that you will only have one sinatra application per ruby process if you plan to use more than one switch to the modular style there is no reason you cannot mix the modular and the classic styles if switching from one style to the other you should be aware of slightly different default settings setting classic modular modular app file file loading sinatra file subclassing sinatra base file subclassing sinatra application run 0 app file false false logging true false true method override true false true inline templates true false true static true file exist public folder true serving a modular application there are two common options for starting a modular app actively starting with run ruby my app rb require sinatra base class myapp sinatra base app code here start the server if ruby file executed directly run if app file 0 end start with shell ruby my app rb or with a config ru file which allows using any rack handler ruby config ru run with rackup require my app run myapp run shell rackup p 4567 using a classic style application with a config ru write your app file ruby app rb require sinatra get do hello world end and a corresponding config ru ruby require app run sinatra application when to use a config ru a config ru file is recommended if you want to deploy with a different rack handler passenger unicorn heroku you want to use more than one subclass of sinatra base you want to use sinatra only for middleware and not as an endpoint there is no need to switch to a config ru simply because you switched to the modular style and you dont have to use the modular style for running with a config ru using sinatra as middleware not only is sinatra able to use other rack middleware any sinatra application can in turn be added in front of any rack endpoint as middleware itself this endpoint could be another sinatra application or any other rack based application rails hanami roda ruby require sinatra base class loginscreen sinatra base enable sessions get login haml login post login do if params name admin params password admin session user name params name else redirect login end end end class myapp sinatra base middleware will run before filters use loginscreen before do unless session user name halt access denied please login end end get hello session user name end dynamic application creation sometimes you want to create new applications at runtime without having to assign them to a constant you can do this with sinatra new ruby require sinatra base my app sinatra new get hi my app run it takes the application to inherit from as an optional argument ruby config ru run with rackup require sinatra base controller sinatra new do enable logging helpers myhelpers end map a do run sinatra new controller get a end map b do run sinatra new controller get b end this is especially useful for testing sinatra extensions or using sinatra in your own library this also makes using sinatra as middleware extremely easy ruby require sinatra base use sinatra do get end run railsproject application scopes and binding the scope you are currently in determines what methods and variables are available application class scope every sinatra application corresponds to a subclass of sinatra base if you are using the top level dsl require sinatra then this class is sinatra application otherwise it is the subclass you created explicitly at class level you have methods like get or before but you cannot access the request or session objects as there is only a single application class for all requests options created via set are methods at class level ruby class myapp sinatra base hey im in the application scope set foo 42 foo 42 get foo do hey im no longer in the application scope end end you have the application scope binding inside your application class body methods defined by extensions the block passed to helpers procs blocks used as value for set the block passed to sinatra new you can reach the scope object the class like this via the object passed to configure blocks configure c settings from within the request scope request instance scope for every incoming request a new instance of your application class is created and all handler blocks run in that scope from within this scope you can access the request and session objects or call rendering methods like erb or haml you can access the application scope from within the request scope via the settings helper ruby class myapp sinatra base hey im in the application scope get define route name do request scope for define route name value 42 settings get params name do request scope for params name value nil not the same request end route defined end end you have the request scope binding inside get head post put delete options patch link and unlink blocks before and after filters helper methods templates views delegation scope the delegation scope just forwards methods to the class scope however it does not behave exactly like the class scope as you do not have the class binding only methods explicitly marked for delegation are available and you do not share variables state with the class scope read you have a different self you can explicitly add method delegations by calling sinatra delegator delegate method name you have the delegate scope binding inside the top level binding if you did require sinatra an object extended with the sinatra delegator mixin have a look at the code for yourself heres the sinatra delegator mixin being extending the main object command line sinatra applications can be run directly shell ruby myapp rb h x q e environment p port o host s handler options are h help p set the port default is 4567 o set the host default is 0 0 0 0 e set the environment default is development s specify rack server handler default is thin q turn on quiet mode for server default is off x turn on the mutex lock default is off multi threading paraphrasing from this stackoverflow answer by konstantin sinatra doesnt impose any concurrency model but leaves that to the underlying rack handler server like thin puma or webrick sinatra itself is thread safe so there wont be any problem if the rack handler uses a threaded model of concurrency this would mean that when starting the server youd have to specify the correct invocation method for the specific rack handler the following example is a demonstration of how to start a multi threaded thin server ruby app rb require sinatra base class app sinatra base get do hello world end end app run to start the server the command would be shell thin threaded start requirement the following ruby versions are officially supported ruby 2 2 2 2 is fully supported and recommended there are currently no plans to drop official support for it rubinius rubinius is officially supported rubinius 2 x it is recommended to gem install puma jruby the latest stable release of jruby is officially supported it is not recommended to use c extensions with jruby it is recommended to gem install trinidad versions of ruby prior to 2 2 2 are no longer supported as of sinatra 2 0 we also keep an eye on upcoming ruby versions the following ruby implementations are not officially supported but still are known to run sinatra older versions of jruby and rubinius ruby enterprise edition macruby maglev ironruby ruby 1 9 0 and 1 9 1 but we do recommend against using those not being officially supported means if things only break there and not on a supported platform we assume its not our issue but theirs we also run our ci against ruby head future releases of mri but we cant guarantee anything since it is constantly moving expect upcoming 2 x releases to be fully supported sinatra should work on any operating system supported by the chosen ruby implementation if you run macruby you should gem install control tower sinatra currently doesnt run on cardinal smallruby blueruby or any ruby version prior to 2 2 the bleeding edge if you would like to use sinatras latest bleeding edge code feel free to run your application against the master branch it should be rather stable we also push out prerelease gems from time to time so you can do a shell gem install sinatra pre to get some of the latest features with bundler if you want to run your application with the latest sinatra using bundler is the recommended way first install bundler if you havent shell gem install bundler then in your project directory create a gemfile ruby source https rubygems org gem sinatra github sinatra sinatra other dependencies gem haml for instance if you use haml note that you will have to list all your applications dependencies in the gemfile sinatras direct dependencies rack and tilt will however be automatically fetched and added by bundler now you can run your app like this shell bundle exec ruby myapp rb versioning sinatra follows semantic versioning both semver and semvertag further reading project website additional documentation news and links to other resources contributing find a bug need help have a patch issue tracker twitter mailing list irc sinatra on freenode sinatra friends on slack get an invite sinatra book cookbook tutorial sinatra recipes community contributed recipes api documentation for the latest release or the current head on rubydoc ci server