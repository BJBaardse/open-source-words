Minikube ![BuildStatus Widget] ![CodeCovWidget] ![GoReport Widget] What is Minikube? Minikube is a tool that makes it easy to run Kubernetes locally. Minikube runs a single-node Kubernetes cluster inside a VM on your laptop for users looking to try out Kubernetes or develop with it day-to-day. Installation macOS shell brew cask install minikube Linux shell curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ Windows Download the minikube-windows-amd64.exe file, rename it to minikube.exe and add it to your path. Linux Continuous Integration without VM Support Example with kubectl installation: ```shell curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl && chmod +x kubectl export MINIKUBE_WANTUPDATENOTIFICATION=false export MINIKUBE_WANTREPORTERRORPROMPT=false export MINIKUBE_HOME=$HOME export CHANGE_MINIKUBE_NONE_USER=true mkdir -p $HOME/.kube touch $HOME/.kube/config export KUBECONFIG=$HOME/.kube/config sudo -E ./minikube start --vm-driver=none this for loop waits until kubectl can access the api server that Minikube has created for i in {1..150}; do # timeout for 5 minutes ./kubectl get po &> /dev/null if [ $? -ne 1 ]; then break fi sleep 2 done kubectl commands are now able to interact with Minikube cluster ``` Other Ways to Install [Linux] Arch Linux AUR Fedora/CentOS/Red Hat COPR openSUSE/SUSE Linux Enterprise [Windows] Chocolatey Minikube Version Management The asdf tool offers version management for a wide range of languages and tools. On macOS, asdf is available via Homebrew and can be installed with brew install asdf. Then, the Minikube plugin itself can be installed with asdf plugin-add minikube. A specific version of Minikube can be installed with asdf install minikube <version>. The tool allows you to switch versions for projects using a .tool-versions file inside the project. An asdf plugin exists for kubectl as well. We also released a Debian package and Windows installer on our releases page. If you maintain a Minikube package, please feel free to add it here. Requirements kubectl macOS Hyperkit driver, xhyve driver, VirtualBox, or VMware Fusion Linux VirtualBox or KVM NOTE: Minikube also supports a --vm-driver=none option that runs the Kubernetes components on the host and not in a VM. Docker is required to use this driver but no hypervisor. If you use --vm-driver=none, be sure to specify a bridge network for docker. Otherwise it might change between network restarts, causing loss of connectivity to your cluster. Windows VirtualBox or Hyper-V VT-x/AMD-v virtualization must be enabled in BIOS Internet connection on first run Quickstart Heres a brief demo of Minikube usage. If you want to change the VM driver add the appropriate --vm-driver=xxx flag to minikube start. Minikube supports the following drivers: virtualbox vmwarefusion KVM2 KVM (deprecated in favor of KVM2) hyperkit xhyve hyperv none (Linux-only) - this driver can be used to run the Kubernetes cluster components on the host instead of in a VM. This can be useful for CI workloads which do not support nested virtualization. ```shell $ minikube start Starting local Kubernetes v1.7.5 cluster... Starting VM... SSH-ing files into VM... Setting up certs... Starting cluster components... Connecting to cluster... Setting up kubeconfig... Kubectl is now configured to use the cluster. $ kubectl run hello-minikube --image=k8s.gcr.io/echoserver:1.4 --port=8080 deployment "hello-minikube" created $ kubectl expose deployment hello-minikube --type=NodePort service "hello-minikube" exposed We have now launched an echoserver pod but we have to wait until the pod is up before curling/accessing it via the exposed service. To check whether the pod is up and running we can use the following: $ kubectl get pod NAME READY STATUS RESTARTS AGE hello-minikube-3383150820-vctvh 1/1 ContainerCreating 0 3s We can see that the pod is still being created from the ContainerCreating status $ kubectl get pod NAME READY STATUS RESTARTS AGE hello-minikube-3383150820-vctvh 1/1 Running 0 13s We can see that the pod is now Running and we will now be able to curl it: $ curl $(minikube service hello-minikube --url) CLIENT VALUES: client_address=192.168.99.1 command=GET real path=/ ... $ kubectl delete service hello-minikube service "hello-minikube" deleted $ kubectl delete deployment hello-minikube deployment "hello-minikube" deleted $ minikube stop Stopping local Kubernetes cluster... Machine stopped. ``` Interacting With Your Cluster kubectl The minikube start command creates a "kubectl context" called "minikube". This context contains the configuration to communicate with your Minikube cluster. Minikube sets this context to default automatically, but if you need to switch back to it in the future, run: kubectl config use-context minikube, or pass the context on each command like this: kubectl get pods --context=minikube. Dashboard To access the Kubernetes Dashboard, run this command in a shell after starting Minikube to get the address: shell minikube dashboard Services To access a service exposed via a node port, run this command in a shell after starting Minikube to get the address: shell minikube service [-n NAMESPACE] [--url] NAME Design Minikube uses libmachine for provisioning VMs, and localkube (originally written and donated to this project by Redspread) for running the cluster. For more information about Minikube, see the proposal. Additional Links Advanced Topics and Tutorials Contributing Development Guide Community #minikube on Kubernetes Slack kubernetes-users mailing list (If you are posting to the list, please prefix your subject with "minikube: ")