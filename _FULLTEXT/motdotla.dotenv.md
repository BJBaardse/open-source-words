dotenv Dotenv is a zero-dependency module that loads environment variables from a .env file into process.env. Storing configuration in the environment separate from code is based on The Twelve-Factor App methodology. Install ```bash with npm npm install dotenv or with Yarn yarn add dotenv ``` Usage As early as possible in your application, require and configure dotenv. javascript require(dotenv).config() Create a .env file in the root directory of your project. Add environment-specific variables on new lines in the form of NAME=VALUE. For example: dosini DB_HOST=localhost DB_USER=root DB_PASS=s1mpl3 Thats it. process.env now has the keys and values you defined in your .env file. javascript const db = require(db) db.connect({ host: process.env.DB_HOST, username: process.env.DB_USER, password: process.env.DB_PASS }) Preload You can use the --require (-r) command line option to preload dotenv. By doing this, you do not need to require and load dotenv in your application code. This is the preferred approach when using import instead of require. bash $ node -r dotenv/config your_script.js The configuration options below are supported as command line arguments in the format dotenv_config_<option>=value bash $ node -r dotenv/config your_script.js dotenv_config_path=/custom/path/to/your/env/vars Config Alias: load config will read your .env file, parse the contents, assign it to process.env, and return an Object with a parsed key containing the loaded content or an error key if it failed. ```js const result = dotenv.config() if (result.error) { throw result.error } console.log(result.parsed) ``` You can additionally, pass options to config. Options Path Default: path.resolve(process.cwd(), .env) You can specify a custom path if your file containing environment variables is named or located differently. js require(dotenv).config({path: /full/custom/path/to/your/env/vars}) Encoding Default: utf8 You may specify the encoding of your file containing environment variables using this option. js require(dotenv).config({encoding: base64}) Parse The engine which parses the contents of your file containing environment variables is available to use. It accepts a String or Buffer and will return an Object with the parsed keys and values. js const dotenv = require(dotenv) const buf = Buffer.from(BASIC=basic) const config = dotenv.parse(buf) // will return an object console.log(typeof config, config) // object { BASIC : basic } Rules The parsing engine currently supports the following rules: BASIC=basic becomes {BASIC: basic} empty lines are skipped lines beginning with # are treated as comments empty values become empty strings (EMPTY= becomes {EMPTY: }) single and double quoted values are escaped (SINGLE_QUOTE=quoted becomes {SINGLE_QUOTE: "quoted"}) new lines are expanded if in double quotes (MULTILINE="new\nline" becomes {MULTILINE: new line} - inner quotes are maintained (think JSON) (JSON={"foo": "bar"} becomes {JSON:"{\"foo\": \"bar\"}") - whitespace is removed from both ends of the value (see more on trim) (FOO=" some value " becomes {FOO: some value}) FAQ Should I commit my .env file? No. We strongly recommend against committing your .env file to version control. It should only include environment-specific values such as database passwords or API keys. Your production database should have a different password than your development database. Should I have multiple .env files? No. We strongly recommend against having a "main" .env file and an "environment" .env file like .env.test. Your config should vary between deploys, and you should not be sharing values between environments. In a twelve-factor app, env vars are granular controls, each fully orthogonal to other env vars. They are never grouped together as “environments”, but instead are independently managed for each deploy. This is a model that scales up smoothly as the app naturally expands into more deploys over its lifetime. – The Twelve-Factor App What happens to environment variables that were already set? We will never modify any environment variables that have already been set. In particular, if there is a variable in your .env file which collides with one that already exists in your environment, then that variable will be skipped. This behavior allows you to override all .env configurations with a machine-specific environment, although it is not recommended. If you want to override process.env you can do something like this: javascript const fs = require(fs) const dotenv = require(dotenv) const envConfig = dotenv.parse(fs.readFileSync(.env.override)) for (var k in envConfig) { process.env[k] = envConfig[k] } Can I customize/write plugins for dotenv? For dotenv@2.x.x: Yes. dotenv.config() now returns an object representing the parsed .env file. This gives you everything you need to continue setting values on process.env. For example: js var dotenv = require(dotenv) var variableExpansion = require(dotenv-expand) const myEnv = dotenv.config() variableExpansion(myEnv) What about variable expansion? For dotenv@2.x.x: Use dotenv-expand. For dotenv@1.x.x: We havent been presented with a compelling use case for expanding variables and believe it leads to env vars that are not "fully orthogonal" as The Twelve-Factor App outlines.[1][2] Please open an issue if you have a compelling use case. How do I use dotenv with import? ES2015 and beyond offers modules that allow you to export any top-level function, class, var, let, or const. When you run a module containing an import declaration, the modules it imports are loaded first, then each module body is executed in a depth-first traversal of the dependency graph, avoiding cycles by skipping anything already executed. – ES6 In Depth: Modules You must run dotenv.config() before referencing any environment variables. Heres an example of problematic code: errorReporter.js: ```js import { Client } from best-error-reporting-service export const client = new Client(process.env.BEST_API_KEY) ``` index.js: ```js import dotenv from dotenv import errorReporter from ./errorReporter dotenv.config() errorReporter.client.report(new Error(faq example)) ``` client will not be configured correctly because it was constructed before dotenv.config() was executed. There are (at least) 3 ways to make this work. Preload dotenv: node --require dotenv/config index.js (Note: you do not need to import dotenv with this approach) Import dotenv/config instead of dotenv (Note: you do not need to call dotenv.config() and must pass options via the command line with this approach) Create a separate file that will execute config first as outlined in this comment on #133 Contributing Guide See CONTRIBUTING.md Change Log See CHANGELOG.md License See LICENSE Whos using dotenv Heres just a few of many repositories using dotenv: jaws node-lambda resume-cli phant adafruit-io-node mockbin and many more... Go well with dotenv Heres some projects that expand on dotenv. Check them out. require-environment-variables dotenv-safe envalid lookenv run.env dotenv-webpack