 the art of node an introduction to node js this document is intended for readers who know at least a little bit of a couple of things a scripting language like javascript ruby python perl etc if you arent a programmer yet then it is probably easier to start by reading javascript for cats cat2 git and github these are the open source collaboration tools that people in the node community use to share modules you just need to know the basics here are three great intro tutorials 1 2 3 table of contents learn node interactively understanding node core modules callbacks events streams modules and npm client side development with npm going with the grain learn node interactively in addition to reading this guide its super important to also bust out your favorite text editor and actually write some node code i always find that when i just read some code in a book it never really clicks but learning by writing code is a good way to grasp new programming concepts nodeschool io nodeschool io is a series of free open source interactive workshops that teach you the principles of node js and beyond learn you the node js is the introductory nodeschool io workshop its a set of programming problems that introduce you to common node patterns it comes packaged as a command line program you can install it with npm install npm install learnyounode g start the menu learnyounode understanding node node js is an open source project designed to help you write javascript programs that talk to networks file systems or other i o input output reading writing sources thats it it is just a simple and stable i o platform that you are encouraged to build modules on top of what are some examples of i o here is a diagram of an application that i made with node that shows many i o sources if you dont understand all of the different things in the diagram it is completely okay the point is to show that a single node process the hexagon in the middle can act as the broker between all of the different i o endpoints orange and purple represent i o usually building these kinds of systems is either difficult to code but yields super fast results like writing your web servers from scratch in c easy to code but not very speedy robust like when someone tries to upload a 5gb file and your server crashes nodes goal is to strike a balance between these two relatively easy to understand and use and fast enough for most use cases node isnt either of the following a web framework like rails or django though it can be used to make such things a programming language it uses javascript but node isnt its own language instead node is somewhere in the middle it is designed to be simple and therefore relatively easy to understand and use useful for i o based programs that need to be fast and or handle lots of connections at a lower level node can be described as a tool for writing two major types of programs network programs using the protocols of the web http tcp udp dns and ssl programs that read and write data to the filesystem or local processes memory what is an i o based program here are some common i o sources databases e g mysql postgresql mongodb redis couchdb apis e g twitter facebook apple push notifications http websocket connections from users of a web app files image resizer video editor internet radio node does i o in a way that is asynchronous which lets it handle lots of different things simultaneously for example if you go down to a fast food joint and order a cheeseburger they will immediately take your order and then make you wait around until the cheeseburger is ready in the meantime they can take other orders and start cooking cheeseburgers for other people imagine if you had to wait at the register for your cheeseburger blocking all other people in line from ordering while they cooked your burger this is called blocking i o because all i o cooking cheeseburgers happens one at a time node on the other hand is non blocking which means it can cook many cheeseburgers at once here are some fun things made easy with node thanks to its non blocking nature control flying quadcopters write irc chat bots create walking biped robots core modules firstly i would recommend that you get node installed on your computer the easiest way is to visit nodejs org and click install node has a small core group of modules commonly referred to as node core that are presented as the public api that you are intended to write programs with for working with file systems there is the fs module and for networks there are modules like net tcp http dgram udp in addition to fs and network modules there are a number of other base modules in node core there is a module for asynchronously resolving dns queries called dns a module for getting os specific information like the tmpdir location called os a module for allocating binary chunks of memory called buffer some modules for parsing urls and paths url querystring path etc most if not all of the modules in node core are there to support nodes main use case writing fast programs that talk to file systems or networks node handles i o with callbacks events streams and modules if you learn how these four things work then you will be able to go into any module in node core and have a basic understanding about how to interface with it callbacks this is the most important topic to understand if you want to understand how to use node nearly everything in node uses callbacks they werent invented by node they are just part of the javascript language callbacks are functions that are executed asynchronously or at a later time instead of the code reading top to bottom procedurally async programs may execute different functions at different times based on the order and speed that earlier functions like http requests or file system reads happen the difference can be confusing since determining if a function is asynchronous or not depends a lot on context here is a simple synchronous example meaning you can read the code top to bottom just like a book js var mynumber 1 function addone mynumber define the function addone run the function console log mynumber logs out 2 the code here defines a function and then on the next line calls that function without waiting for anything when the function is called it immediately adds 1 to the number so we can expect that after we call the function the number should be 2 this is the expectation of synchronous code it sequentially runs top to bottom node however uses mostly asynchronous code lets use node to read our number from a file called number txt js var fs require fs require is a special function provided by node var mynumber undefined we dont know what the number is yet since it is stored in a file function addone fs readfile number txt function donereading err filecontents mynumber parseint filecontents mynumber addone console log mynumber logs out undefined this line gets run before readfile is done why do we get undefined when we log out the number this time in this code we use the fs readfile method which happens to be an asynchronous method usually things that have to talk to hard drives or networks will be asynchronous if they just have to access things in memory or do some work on the cpu they will be synchronous the reason for this is that i o is reallyyy reallyyy sloowwww a ballpark figure would be that talking to a hard drive is about 100 000 times slower than talking to memory e g ram when we run this program all of the functions are immediately defined but they dont all execute immediately this is a fundamental thing to understand about async programming when addone is called it kicks off a readfile and then moves on to the next thing that is ready to execute if there is nothing to execute node will either wait for pending fs network operations to finish or it will stop running and exit to the command line when readfile is done reading the file this may take anywhere from milliseconds to seconds to minutes depending on how fast the hard drive is it will run the donereading function and give it an error if there was an error and the file contents the reason we got undefined above is that nowhere in our code exists logic that tells the console log statement to wait until the readfile statement finishes before it prints out the number if you have some code that you want to be able to execute over and over again or at a later time the first step is to put that code inside a function then you can call the function whenever you want to run your code it helps to give your functions descriptive names callbacks are just functions that get executed at some later time the key to understanding callbacks is to realize that they are used when you dont know when some async operation will complete but you do know where the operation will complete — the last line of the async function the top to bottom order that you declare callbacks does not necessarily matter only the logical hierarchical nesting of them first you split your code up into functions and then use callbacks to declare if one function depends on another function finishing the fs readfile method is provided by node is asynchronous and happens to take a long time to finish consider what it does it has to go to the operating system which in turn has to go to the file system which lives on a hard drive that may or may not be spinning at thousands of revolutions per minute then it has to use a magnetic head to read data and send it back up through the layers back into your javascript program you give readfile a function known as a callback that it will call after it has retrieved the data from the file system it puts the data it retrieved into a javascript variable and calls your function callback with that variable in this case the variable is called filecontents because it contains the contents of the file that was read think of the restaurant example at the beginning of this tutorial at many restaurants you get a number to put on your table while you wait for your food these are a lot like callbacks they tell the server what to do after your cheeseburger is done lets put our console log statement into a function and pass it in as a callback js var fs require fs var mynumber undefined function addone callback fs readfile number txt function donereading err filecontents mynumber parseint filecontents mynumber callback function logmynumber console log mynumber addone logmynumber now the logmynumber function can get passed in as an argument that will become the callback variable inside the addone function after readfile is done the callback variable will be invoked callback only functions can be invoked so if you pass in anything other than a function it will cause an error when a function gets invoked in javascript the code inside that function will immediately get executed in this case our log statement will execute since callback is actually logmynumber remember just because you define a function it doesnt mean it will execute you have to invoke a function for that to happen to break down this example even more here is a timeline of events that happen when we run this program 1 the code is parsed which means if there are any syntax errors they would make the program break during this initial phase fs and mynumber are declared as variables while addone and logmynumber are declared as functions note that these are just declarations neither function has been called nor invoked yet 2 when the last line of our program gets executed addone is invoked with the logmynumber function passed as its callback argument invoking addone will first run the asynchronous fs readfile function this part of the program takes a while to finish 3 with nothing to do node idles for a bit as it waits for readfile to finish if there was anything else to do during this time node would be available for work 4 as soon as readfile finishes it executes its callback donereading which parses filecontents for an integer called mynumber increments mynumber and then immediately invokes the function that addone passed in its callback logmynumber perhaps the most confusing part of programming with callbacks is how functions are just objects that can be stored in variables and passed around with different names giving simple and descriptive names to your variables is important in making your code readable by others generally speaking in node programs when you see a variable like callback or cb you can assume it is a function you may have heard the terms evented programming or event loop they refer to the way that readfile is implemented node first dispatches the readfile operation and then waits for readfile to send it an event that it has completed while it is waiting node can go check on other things inside node there is a list of things that are dispatched but havent reported back yet so node loops over the list again and again checking to see if they are finished after they finished they get processed e g any callbacks that depended on them finishing will get invoked here is a pseudocode version of the above example js function addone thenrunthisfunction waitaminuteasync function waitedaminute thenrunthisfunction addone function thisgetsrunafteraddonefinishes imagine you had 3 async functions a b and c each one takes 1 minute to run and after it finishes it calls a callback that gets passed in the first argument if you wanted to tell node start running a then run b after a finishes and then run c after b finishes it would look like this js a function b function c when this code gets executed a will immediately start running then a minute later it will finish and call b then a minute later it will finish and call c and finally 3 minutes later node will stop running since there would be nothing more to do there are definitely more elegant ways to write the above example but the point is that if you have code that has to wait for some other async code to finish then you express that dependency by putting your code in functions that get passed around as callbacks the design of node requires you to think non linearly consider this list of operations read a file process that file if you were to turn this into pseudocode you would end up with this var file readfile processfile file this kind of linear step by step in order code isnt the way that node works if this code were to get executed then readfile and processfile would both get executed at the same exact time this doesnt make sense since readfile will take a while to complete instead you need to express that processfile depends on readfile finishing this is exactly what callbacks are for and because of the way that javascript works you can write this dependency many different ways js var fs require fs fs readfile movie mp4 finishedreading function finishedreading error moviedata if error return console error error do something with the moviedata but you could also structure your code like this and it would still work js var fs require fs function finishedreading error moviedata if error return console error error do something with the moviedata fs readfile movie mp4 finishedreading or even like this js var fs require fs fs readfile movie mp4 function finishedreading error moviedata if error return console error error do something with the moviedata events in node if you require the events module you can use the so called event emitter that node itself uses for all of its apis that emit things events are a common pattern in programming known more widely as the observer pattern or pub sub publish subscribe whereas callbacks are a one to one relationship between the thing waiting for the callback and the thing calling the callback events are the same exact pattern except with a many to many api the easiest way to think about events is that they let you subscribe to things you can say when x do y whereas with plain callbacks it is do x then y here are few common use cases for using events instead of plain callbacks chat room where you want to broadcast messages to many listeners game server that needs to know when new players connect disconnect move shoot and jump game engine where you want to let game developers subscribe to events like on jump function a low level web server that wants to expose an api to easily hook into events that happen like on incomingrequest or on servererror if we were trying to write a module that connects to a chat server using only callbacks it would look like this js var chatclient require my chat client function onconnect have the ui show we are connected function onconnectionerror error show error to the user function ondisconnect tell user that they have been disconnected function onmessage message show the chat room message in the ui chatclient connect http mychatserver com onconnect onconnectionerror ondisconnect onmessage as you can see this is really cumbersome because of all of the functions that you have to pass in a specific order to the connect function writing this with events would look like this js var chatclient require my chat client connect chatclient on connect function have the ui show we are connected chatclient on connectionerror function show error to the user chatclient on disconnect function tell user that they have been disconnected chatclient on message function show the chat room message in the ui this approach is similar to the pure callback approach but introduces the on method which subscribes a callback to an event this means you can choose which events you want to subscribe to from the chatclient you can also subscribe to the same event multiple times with different callbacks js var chatclient require my chat client connect chatclient on message logmessage chatclient on message storemessage function logmessage message console log message function storemessage message mydatabase save message streams early on in the node project the file system and network apis had their own separate patterns for dealing with streaming i o for example files in a file system have things called file descriptors so the fs module had to have extra logic to keep track of these things whereas the network modules didnt have such a concept despite minor differences in semantics like these at a fundamental level both groups of code were duplicating a lot of functionality when it came to reading data in and out the team working on node realized that it would be confusing to have to learn two sets of semantics to essentially do the same thing so they made a new api called the stream and made all the network and file system code use it the whole point of node is to make it easy to deal with file systems and networks so it made sense to have one pattern that was used everywhere the good news is that most of the patterns like these there are only a few anyway have been figured out at this point and it is very unlikely that node will change that much in the future there are already two great resources that you can use to learn about node streams one is the stream adventure see the learn node interactively section and the other is a reference called the stream handbook stream handbook stream handbook is a guide similar to this one that contains a reference for everything you could possibly need to know about streams modules node core is made up of about two dozen modules some lower level ones like events and stream some higher level ones like http and crypto this design is intentional node core is supposed to be small and the modules in core should be focused on providing tools for working with common i o protocols and formats in a way that is cross platform for everything else there is npm anyone can create a new node module that adds some functionality and publish it to npm as of the time of this writing there are 34 000 modules on npm how to find a module imagine you are trying to convert pdf files into txt files the best place to start is by doing npm search pdf there are a ton of results npm is quite popular and you will usually be able to find multiple potential solutions if you go through each module and whittle down the results into a more narrow set filtering out things like pdf generation modules youll end up with these hummus c pdf manipulator mimeograph api on a conglomeration of tools poppler tesseract imagemagick etc pdftotextjs wrapper around pdftotext pdf text extract another wrapper around pdftotext pdf extract wrapper around pdftotext pdftk tesseract ghostscript pdfutils poppler wrapper scissors pdftk ghostscript wrapper w high level api textract pdftotext wrapper pdfiijs pdf to inverted index using textiijs and poppler pdf2json pure js pdf to json a lot of the modules have overlapping functionality but present alternate apis and most of them require external dependencies like apt get install poppler here are some different ways to interpret the modules pdf2json is the only one that is written in pure javascript which means it is the easiest to install especially on low power devices like the raspberry pi or on windows where native code might not be cross platform modules like mimeograph hummus and pdf extract each combine multiple lower level modules to expose a high level api a lot of modules seem to sit on top of the pdftotext poppler unix command line tools lets compare the differences between pdftotextjs and pdf text extract both of which are are wrappers around the pdftotext utility both of these were updated relatively recently have github repositories linked this is very important have readmes have at least some number of people installing them every week are liberally licensed anyone can use them just looking at the package json module statistics its hard to get a feeling about which one might be the right choice lets compare the readmes both have simple descriptions ci badges installation instructions clear examples and instructions for running the tests great but which one do we use lets compare the code pdftotextjs is around 110 lines of code and pdf text extract is around 40 but both essentially boil down to this line var child shell exec pdftotext self options additional join does this make one any better than the other hard to say its important to actually read the code and make your own conclusions if you find a module you like use npm star modulename to give npm feedback about modules that you had a positive experience with modular development workflow npm is different from most package managers in that it installs modules into a folder inside of other existing modules the previous sentence might not make sense right now but it is the key to npms success many package managers install things globally for instance if you apt get install couchdb on debian linux it will try to install the latest stable version of couchdb if you are trying to install couchdb as a dependency of some other piece of software and that software needs an older version of couchdb you have to uninstall the newer version of couchdb and then install the older version you cant have two versions of couchdb installed because debian only knows how to install things into one place its not just debian that does this most programming language package managers work this way too to address the global dependencies problem described above there have been virtual environment developed like virtualenv for python or bundler for ruby these just split your environment up in to many virtual environments one for each project but inside each environment dependencies are still globally installed virtual environments dont always solve the problem sometimes they just multiply it by adding additional layers of complexity with npm installing global modules is an anti pattern just like how you shouldnt use global variables in your javascript programs you also shouldnt install global modules unless you need a module with an executable binary to show up in your global path but you dont always need to do this more on this later how require works when you call require some module in node here is what happens if a file called some module js exists in the current folder node will load that otherwise node looks in the current folder for a node modules folder with a some module folder in it if it doesnt find it it will go up one folder and repeat step 2 this cycle repeats until node reaches the root folder of the filesystem at which point it will then check any global module folders e g usr local node modules on mac os and if it still doesnt find some module it will throw an exception heres a visual example when the current working directory is subsubfolder and require foo is called node will look for the folder called subsubfolder node modules in this case it wont find it the folder there is mistakenly called my modules then node will go up one folder and try again meaning it then looks for subfolder b node modules which also doesnt exist third try is a charm though as folder node modules does exist and has a folder called foo inside of it if foo wasnt in there node would continue its search up the directory tree note that if called from subfolder b node will never find subfolder a node modules it can only see folder node modules on its way up the tree one of the benefits of npms approach is that modules can install their dependent modules at specific known working versions in this case the module foo is quite popular there are three copies of it each one inside its parent module folder the reasoning for this could be that each parent module needed a different version of foo e g folder needs foo 0 0 1 subfolder a needs foo 0 2 1 etc heres what happens when we fix the folder naming error by changing my modules to the correct name node modules to test out which module actually gets loaded by node you can use the require resolve some module command which will show you the path to the module that node finds as a result of the tree climbing process require resolve can be useful when double checking that the module that you think is getting loaded is actually getting loaded sometimes there is another version of the same module closer to your current working directory than the one you intend to load how to write a module now that you know how to find modules and require them you can start writing your own modules the simplest possible module node modules are radically lightweight here is one of the simplest possible node modules package json js name number one version 1 0 0 index js js module exports 1 by default node tries to load module index js when you require module any other file name wont work unless you set the main field of package json to point to it put both of those files in a folder called number one the name in package json must match the folder name and youll have a working node module calling the function require number one returns the value of whatever module exports is set to inside the module an even quicker way to create a module is to run these commands sh mkdir my module cd my module git init git remote add git github com yourusername my module git npm init running npm init will create a valid package json for you and if you run it in an existing git repo it will set the repositories field inside package json automatically as well adding dependencies a module can list any other modules from npm or github in the dependencies field of package json to install the request module as a new dependency and automatically add it to package json run this from your module root directory sh npm install save request this installs a copy of request into the closest node modules folder and makes our package json look something like this id number one version 1 0 0 dependencies request 2 22 0 by default npm install will grab the latest published version of a module client side development with npm a common misconception about npm is that since it has node in the name that it must only be used for server side js modules this is completely untrue npm actually stands for node packaged modules e g modules that node packages together for you the modules themselves can be whatever you want they are just a folder of files wrapped up in a tar gz and a file called package json that declares the module version and a list of all modules that are dependencies of the module as well as their version numbers so the working versions get installed automatically its turtles all the way down module dependencies are just modules and those modules can have dependencies etc etc etc browserify is a utility written in node that tries to convert any node module into code that can be run in browsers not all modules work browsers cant do things like host an http server but a lot of modules on npm will work to try out npm in the browser you can use requirebin an app i made that takes advantage of browserify cdn which internally uses browserify but returns the output through http instead of the command line which is how browserify is usually used try putting this code into requirebin and then hit the preview button js var reverse require ascii art reverse makes a visible html console require console log show true var coolbear \n o o \n y \n \n \n 7 1 \n \n \n setinterval function console log coolbear 1000 settimeout function setinterval function console log reverse coolbear 1000 500 or check out a more complicated example feel free to change the code and see what happens going with the grain like any good tool node is best suited for a certain set of use cases for example rails the popular web framework is great for modeling complex business logic e g using code to represent real life business objects like accounts loan itineraries and inventories while it is technically possible to do the same type of thing using node there would be definite drawbacks since node is designed for solving i o problems and it doesnt know much about business logic each tool focuses on different problems hopefully this guide will help you gain an intuitive understanding of the strengths of node so that you know when it can be useful to you what is outside of nodes scope fundamentally node is just a tool used for managing i o across file systems and networks and it leaves other more fancy functionality up to third party modules here are some things that are outside the scope of node web frameworks there are a number of web frameworks built on top of node framework meaning a bundle of solutions that attempts to address some high level problem like modeling business logic but node is not a web framework web frameworks that are written using node dont always make the same kind of decisions about adding complexity abstractions and tradeoffs that node does and may have other priorities language syntax node uses javascript and doesnt change anything about it felix geisendörfer has a pretty good write up of the node style here language abstraction when possible node will use the simplest possible way of accomplishing something the fancier you make your javascript the more complexity and tradeoffs you introduce programming is hard especially in js where there are 1000 solutions to every problem it is for this reason that node tries to always pick the simplest most universal option if you are solving a problem that calls for a complex solution and you are unsatisfied with the vanilla js solutions that node implements you are free to solve it inside your app or module using whichever abstractions you prefer a great example of this is nodes use of callbacks early on node experimented with a feature called promises that added a number of features to make async code appear more linear it was taken out of node core for a few reasons they are more complex than callbacks they can be implemented in userland distributed on npm as third party modules consider one of the most universal and basic things that node does reading a file when you read a file you want to know when errors happen like when your hard drive dies in the middle of your read if node had promises everyone would have to branch their code like this js fs readfile movie mp4 then function data do stuff with data error function error handle error this adds complexity and not everyone wants that instead of two separate functions node just uses a single callback function here are the rules when there is no error pass null as the first argument when there is an error pass it as the first argument the rest of the arguments can be used for anything usually data or responses since most stuff in node is reading or writing things hence the node callback style js fs readfile movie mp4 function err data handle error do stuff with data threads fibers non event based concurrency solutions note if you dont know what these things mean then you will likely have an easier time learning node since unlearning things is just as much work as learning things node uses threads internally to make things fast but doesnt expose them to the user if you are a technical user wondering why node is designed this way then you should 100 read about the design of libuv the c i o layer that node is built on top of license creative commons attribution license do whatever just attribute me http creativecommons org licenses by 2 0 donate icon is from the noun project