A tool for managing JavaScript projects with multiple packages. About Getting Started How It Works Troubleshooting Commands init bootstrap add publish updated clean diff ls run exec import link Misc Lerna.json Flags About Splitting up large codebases into separate independently versioned packages is extremely useful for code sharing. However, making changes across many repositories is messy and difficult to track, and testing across repositories gets complicated really fast. To solve these (and many other) problems, some projects will organize their codebases into multi-package repositories (sometimes called monorepos). Projects like Babel, React, Angular, Ember, Meteor, Jest, and many others develop all of their packages within a single repository. Lerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm. Lerna can also reduce the time and space requirements for numerous copies of packages in development and build environments - normally a downside of dividing a project into many separate NPM package. See the hoist documentation for details. What does a Lerna repo look like? Theres actually very little to it. You have a file system that looks like this: my-lerna-repo/ package.json packages/ package-1/ package.json package-2/ package.json What can Lerna do? The two primary commands in Lerna are lerna bootstrap and lerna publish. bootstrap will link dependencies in the repo together. publish will help publish any updated packages. Getting Started The instructions below are for Lerna 2.x. We recommend using it instead of 1.x for a new Lerna project. Check the wiki if you need to see the 1.x README. Lets start by installing Lerna globally with npm. sh $ npm install --global lerna Next well create a new folder: sh $ mkdir lerna-repo $ cd lerna-repo And now lets turn it into a Lerna repo: sh $ lerna init This will create a lerna.json configuration file as well as a packages folder, so your folder should now look like this: lerna-repo/ packages/ package.json lerna.json How It Works Lerna allows you to manage your project using one of two modes: Fixed or Independent. Fixed/Locked mode (default) Fixed mode Lerna projects operate on a single version line. The version is kept in the lerna.json file at the root of your project under the version key. When you run lerna publish, if a module has been updated since the last time a release was made, it will be updated to the new version youre releasing. This means that you only publish a new version of a package when you need to. This is the mode that Babel is currently using. Use this if you want to automatically tie all package versions together. One issue with this approach is that a major change in any package will result in all packages having a new major version. Independent mode (--independent) Independent mode Lerna projects allows maintainers to increment package versions independently of each other. Each time you publish, you will get a prompt for each package that has changed to specify if its a patch, minor, major or custom change. Independent mode allows you to more specifically update versions for each package and makes sense for a group of components. Combining this mode with something like semantic-release would make it less painful. (There is work on this already at atlassian/lerna-semantic-release). The version key in lerna.json is ignored in independent mode. Troubleshooting If you encounter any issues while using Lerna please check out our Troubleshooting document where you might find the answer to your problem. Frequently asked questions See FAQ.md. Commands init sh $ lerna init Create a new Lerna repo or upgrade an existing repo to the current version of Lerna. Lerna assumes the repo has already been initialized with git init. When run, this command will: Add lerna as a devDependency in package.json if it doesnt already exist. Create a lerna.json config file to store the version number. Example output on a new git repo: sh $ lerna init lerna info version v2.0.0 lerna info Updating package.json lerna info Creating lerna.json lerna success Initialized Lerna files --independent, -i sh $ lerna init --independent This flag tells Lerna to use independent versioning mode. --exact sh $ lerna init --exact By default, lerna init will use a caret range when adding or updating the local version of lerna, just like npm install --save-dev lerna. To retain the lerna 1.x behavior of "exact" comparison, pass this flag. It will configure lerna.json to enforce exact match for all subsequent executions. json { "command": { "init": { "exact": true } }, "version": "0.0.0" } bootstrap sh $ lerna bootstrap Bootstrap the packages in the current Lerna repo. Installs all of their dependencies and links any cross-dependencies. When run, this command will: npm install all external dependencies of each package. Symlink together all Lerna packages that are dependencies of each other. npm run prepublish in all bootstrapped packages. npm run prepare in all bootstrapped packages. lerna bootstrap respects the --ignore, --ignore-scripts, --scope and --include-filtered-dependencies flags (see Flags). Pass extra arguments to npm client by placing them after --: sh $ lerna bootstrap -- --production --no-optional May also be configured in lerna.json: js { ... "npmClient": "yarn", "npmClientArgs": ["--production", "--no-optional"] } --ci This runs lerna bootstrap with npm ci as opposed to npm install. The specifics of this command can be found in the NPM documentation here How bootstrap works Lets use babel as an example. babel-generator and source-map (among others) are dependencies of babel-core. babel-cores package.json lists both these packages as keys in dependencies, as shown below. add sh $ lerna add <package>[@version] [--dev] Add local or remote package as dependency to packages in the current Lerna repo. When run, this command will: Add package to each applicable package. Applicable are packages that are not package and are in scope Bootstrap packages with changes to their manifest file (package.json) lerna add respects the --ignore, --scope and --include-filtered-dependencies flags (see Flags). Examples lerna add module-1 --scope=module-2 # Install module-1 to module-2 lerna add module-1 --scope=module-2 --dev # Install module-1 to module-2 in devDependencies lerna add module-1 # Install module-1 in all modules except module-1 lerna add babel-core # Install babel-core in all modules js // babel-core package.json { "name": "babel-core", ... "dependencies": { ... "babel-generator": "^6.9.0", ... "source-map": "^0.5.0" } } Lerna checks if each dependency is also part of the Lerna repo. In this example, babel-generator can be an internal dependency, while source-map is always an external dependency. The version of babel-generator in the package.json of babel-core is satisfied by packages/babel-generator, passing for an internal dependency. source-map is npm installed (or yarned) like normal. packages/babel-core/node_modules/babel-generator symlinks to packages/babel-generator This allows nested directory imports Notes: When a dependency version in a package is not satisfied by a package of the same name in the repo, it will be npm installed (or yarned) like normal. Dist-tags, like latest, do not satisfy semver ranges. Circular dependencies result in circular symlinks which may impact your editor/IDE. Webstorm locks up when circular symlinks are present. To prevent this, add node_modules to the list of ignored files and folders in Preferences | Editor | File Types | Ignored files and folders. publish sh $ lerna publish Publish packages in the current Lerna project. When run, this command does the following: Creates a new release of the packages that have been updated. Prompts for a new version. Creates a new git commit/tag in the process of publishing to npm. More specifically, this command will: Run the equivalent of lerna updated to determine which packages need to be published. If necessary, increment the version key in lerna.json. Update the package.json of all updated packages to their new versions. Update all dependencies of the updated packages with the new versions, specified with a caret (^). Create a new git commit and tag for the new version. Publish updated packages to npm. Lerna wont publish packages which are marked as private ("private": true in the package.json). Note: to publish scoped packages, you need to add the following to each package.json: json "publishConfig": { "access": "public" } --exact sh $ lerna publish --exact When run with this flag, publish will specify updated dependencies in updated packages exactly (with no punctuation), instead of as semver compatible (with a ^). For more information, see the package.json dependencies documentation. --npm-tag [tagname] sh $ lerna publish --npm-tag=next When run with this flag, publish will publish to npm with the given npm dist-tag (defaults to latest). This option can be used to publish a prerelease or beta version. Note: the latest tag is the one that is used when a user runs npm install my-package. To install a different tag, a user can run npm install my-package@prerelease. --canary, -c sh $ lerna publish --canary $ lerna publish --canary=beta When run with this flag, publish publishes packages in a more granular way (per commit). Before publishing to npm, it creates the new version tag by taking the current version, bumping it to the next minor version, adding the provided meta suffix (defaults to alpha) and appending the current git sha (ex: 1.0.0 becomes 1.1.0-alpha.81e3b443). The intended use case for this flag is a per commit level release or nightly release. --conventional-commits sh $ lerna publish --conventional-commits When run with this flag, publish will use the Conventional Commits Specification to determine the version bump and generate CHANGELOG --changelog-preset sh $ lerna publish --conventional-commits --changelog-preset angular-bitbucket By default, the changelog preset is set to angular. In some cases you might want to change either use a another preset or a custom one. Presets are names of built-in or installable configuration for conventional changelog. Presets may be passed as the full name of the package, or the auto-expanded suffix (e.g., angular is expanded to conventional-changelog-angular). --git-remote [remote] sh $ lerna publish --git-remote upstream When run with this flag, publish will push the git changes to the specified remote instead of origin. --skip-git sh $ lerna publish --skip-git When run with this flag, publish will publish to npm without running any of the git commands. Only publish to npm; skip committing, tagging, and pushing git changes (this only affects publish). --skip-npm sh $ lerna publish --skip-npm When run with this flag, publish will update all package.json package versions and dependency versions, but it will not actually publish the packages to npm. This flag can be combined with --skip-git to just update versions and dependencies, without committing, tagging, pushing or publishing. Only update versions and dependencies; dont actually publish (this only affects publish). --force-publish [packages] ```sh $ lerna publish --force-publish=package-2,package-4 force publish all packages $ lerna publish --force-publish=* ``` When run with this flag, publish will force publish the specified packages (comma-separated) or all packages using *. This will skip the lerna updated check for changed packages and forces a package that didnt have a git diff change to be updated. --yes ```sh $ lerna publish --canary --yes skips Are you sure you want to publish the above changes? ``` When run with this flag, publish will skip all confirmation prompts. Useful in Continuous integration (CI) to automatically answer the publish confirmation prompt. --cd-version ```sh $ lerna publish --cd-version (major | minor | patch | premajor | preminor | prepatch | prerelease) uses the next semantic version(s) value and this skips Select a new version for... prompt ``` When run with this flag, publish will skip the version selection prompt (in independent mode) and use the next specified semantic version. You must still use the --yes flag to avoid all prompts. This is useful when build systems need to publish without command prompts. Works in both normal and independent modes. If you have any packages with a prerelease version number (e.g. 2.0.0-beta.3) and you run lerna publish with --cd-version and a non-prerelease version increment (major / minor / patch), it will publish those packages in addition to the packages that have changed since the last release. --preid ```sh $ lerna publish --cd-version=prerelease uses the next semantic prerelease version, e.g. 1.0.0 => 1.0.0-0 $ lerna publish --cd-version=prepatch --preid=next uses the next semantic prerelease version with a specific prerelease identifier, e.g. 1.0.0 => 1.0.1-next.0 ``` When run with this flag, lerna publish --cd-version will increment premajor, preminor, prepatch, or prerelease versions using the specified prerelease identifier. --repo-version ```sh $ lerna publish --repo-version 1.0.1 applies version and skips Select a new version for... prompt ``` When run with this flag, publish will skip the version selection prompt and use the specified version. Useful for bypassing the user input prompt if you already know which version to publish. --message, -m [msg] ```sh $ lerna publish -m "chore(release): publish %s" commit message = "chore(release): publish v1.0.0" $ lerna publish -m "chore(release): publish %v" commit message = "chore(release): publish 1.0.0" $ lerna publish -m "chore(release): publish" --independent commit message = "chore(release): publish - package-1@3.0.1 - package-2@1.5.4" ``` When run with this flag, publish will use the provided message when committing the version updates for publication. Useful for integrating lerna into projects that expect commit messages to adhere to certain guidelines, such as projects which use commitizen and/or semantic-release. If the message contains %s, it will be replaced with the new global version version number prefixed with a "v". If the message contains %v, it will be replaced with the new global version version number without the leading "v". Note that this only applies when using the default "fixed" versioning mode, as there is no "global" version when using --independent. This can be configured in lerna.json, as well: json { "command": { "publish": { "message": "chore(release): publish %s" } } } --amend ```sh $ lerna publish --amend commit message is retained, and git push is skipped. ``` When run with this flag, publish will perform all changes on the current commit, instead of adding a new one. This is useful during Continuous integration (CI), to reduce the number of commits in the projects history. In order to prevent unintended overwrites, this command will skip git push. --allow-branch [glob] Lerna allows you to specify a glob or an array of globs in your lerna.json that your current branch needs to match to be publishable. You can use this flag to override this setting. If your lerna.json contains something like this: json { "command": { "publish": { "allowBranch": "master" } } } json { "command": { "publish": { "allowBranch": ["master", "feature/*"] } } } and you are not on the branch master lerna will prevent you from publishing. To force a publish despite this config, pass the --allow-branch flag: sh $ lerna publish --allow-branch my-new-feature updated sh $ lerna updated Check which packages have changed since the last release (the last git tag). Lerna determines the last git tag created and runs git diff --name-only v6.8.1 to get all files changed since that tag. It then returns an array of packages that have an updated file. Note that configuration for the publish command also affects the updated command. For example command.publish.ignoreChanges --json sh $ lerna updated --json When run with this flag, updated will return an array of objects in the following format: json [ { "name": "package", "version": "1.0.0", "private": false } ] clean sh $ lerna clean Remove the node_modules directory from all packages. lerna clean respects the --ignore, --scope, and --yes flags (see Flags). diff ```sh $ lerna diff [package?] $ lerna diff diff a specific package $ lerna diff package-name ``` Diff all packages or a single package since the last release. Similar to lerna updated. This command runs git diff. ls sh $ lerna ls List all of the public packages in the current Lerna repo. lerna ls respects the --ignore and --scope flags (see Flags). --json sh $ lerna ls --json When run with this flag, ls will return an array of objects in the following format: json [ { "name": "package", "version": "1.0.0", "private": false } ] run ```sh $ lerna run