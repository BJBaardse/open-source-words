table of contents what is grape stable release project resources installation basic usage mounting rack activerecord without rails alongside sinatra or other frameworks rails modules versioning path header accept version header param describing methods parameters params class declared include parent namespaces include missing parameter validation and coercion supported parameter types integer fixnum and coercions custom types and coercions multipart file parameters first class json types multiple allowed types validation of nested parameters dependent parameters group options alias built in validators allow blank values except values regexp mutually exclusive exactly one of at least one of all or none of nested mutually exclusive exactly one of at least one of all or none of namespace validation and coercion custom validators validation errors i18n custom validation messages presence allow blank values regexp all or none of mutually exclusive exactly one of at least one of coerce with lambdas pass symbols for i18n translations overriding attribute names with default headers routes helpers path helpers parameter documentation cookies http status code redirecting recognizing path allowed methods raising exceptions default error http status code handling 404 exception handling rescuing exceptions inside namespaces unrescuable exceptions exceptions that should be rescued explicitly rails 3 x logging api formats jsonp cors content type api data formats json and xml processors restful model representations grape entities hypermedia and roar rabl active model serializers sending raw or no data authentication basic and digest auth register custom middleware for authentication describing and inspecting an api current route and endpoint before and after anchoring using custom middleware grape middleware rails middleware remote ip writing tests writing tests with rack rspec airborne minitest writing tests with rails rspec minitest stubbing helpers reloading api changes in development reloading in rack applications reloading in rails applications performance monitoring active support instrumentation endpoint run grape endpoint render grape endpoint run filters grape endpoint run validators grape format response grape monitoring products contributing to grape license copyright what is grape grape is a rest like api framework for ruby its designed to run on rack or complement existing web application frameworks such as rails and sinatra by providing a simple dsl to easily develop restful apis it has built in support for common conventions including multiple formats subdomain prefix restriction content negotiation versioning and much more stable release youre reading the documentation for the next release of grape which should be 1 1 0 please read upgrading when upgrading from a previous version the current stable release is 1 0 3 project resources grape website documentation need help try grape google group or gitter follow us on twitter installation grape is available as a gem to install it just install the gem gem install grape if youre using bundler add the gem to gemfile gem grape run bundle install basic usage grape apis are rack applications that are created by subclassing grape api below is a simple example showing some of the more common features of grape in the context of recreating parts of the twitter api ruby module twitter class api grape api version v1 using header vendor twitter format json prefix api helpers do def current user current user user authorize env end def authenticate error 401 unauthorized 401 unless current user end end resource statuses do desc return a public timeline get public timeline do status limit 20 end desc return a personal timeline get home timeline do authenticate current user statuses limit 20 end desc return a status params do requires id type integer desc status id end route param id do get do status find params id end end desc create a status params do requires status type string desc your status end post do authenticate status create user current user text params status end desc update a status params do requires id type string desc status id requires status type string desc your status end put id do authenticate current user statuses find params id update user current user text params status end desc delete a status params do requires id type string desc status id end delete id do authenticate current user statuses find params id destroy end end end end mounting rack the above sample creates a rack application that can be run from a rackup config ru file with rackup ruby run twitter api and would respond to the following routes get api statuses public timeline get api statuses home timeline get api statuses id post api statuses put api statuses id delete api statuses id grape will also automatically respond to head and options for all get and just options for all other routes activerecord without rails if you want to use activerecord within grape you will need to make sure that activerecords connection pool is handled correctly the easiest way to achieve that is by using activerecords connectionmanagement middleware in your config ru before mounting grape e g ruby use activerecord connectionadapters connectionmanagement run twitter api alongside sinatra or other frameworks if you wish to mount grape alongside another rack framework such as sinatra you can do so easily using rack cascade ruby example config ru require sinatra require grape class api grape api get hello do hello world end end class web sinatra base get do hello world end end use rack session cookie run rack cascade new api web rails place api files into app api rails expects a subdirectory that matches the name of the ruby module and a file name that matches the name of the class in our example the file name location and directory for twitter api should be app api twitter api rb modify application rb ruby config paths add file join app api glob file join rb config autoload paths dir rails root join app api modify config routes ruby mount twitter api see below for additional code that enables reloading of api changes in development modules you can mount multiple api implementations inside another one these dont have to be different versions but may be components of the same api ruby class twitter api grape api mount twitter apiv1 mount twitter apiv2 end you can also mount on a path which is similar to using prefix inside the mounted api itself ruby class twitter api grape api mount twitter apiv1 v1 end keep in mind such declarations as before after rescue from must be placed before mount in a case where they should be inherited ruby class twitter api grape api before do header x base header will be defined for all apis that are mounted below end mount twitter users mount twitter search end versioning there are four strategies in which clients can reach your apis endpoints path header accept version header and param the default strategy is path path ruby version v1 using path using this versioning strategy clients should pass the desired version in the url curl http localhost 9292 v1 statuses public timeline header ruby version v1 using header vendor twitter currently grape only supports versioned media types in the following format vnd vendor and or resource v1234 format basically all tokens between the final and the will be interpreted as the version using this versioning strategy clients should pass the desired version in the http accept head curl h accept application vnd twitter v1 json http localhost 9292 statuses public timeline by default the first matching version is used when no accept header is supplied this behavior is similar to routing in rails to circumvent this default behavior one could use the strict option when this option is set to true a 406 not acceptable error is returned when no correct accept header is supplied when an invalid accept header is supplied a 406 not acceptable error is returned if the cascade option is set to false otherwise a 404 not found error is returned by rack if no other route matches accept version header ruby version v1 using accept version header using this versioning strategy clients should pass the desired version in the http accept version header curl h accept version v1 http localhost 9292 statuses public timeline by default the first matching version is used when no accept version header is supplied this behavior is similar to routing in rails to circumvent this default behavior one could use the strict option when this option is set to true a 406 not acceptable error is returned when no correct accept header is supplied and the cascade option is set to false otherwise a 404 not found error is returned by rack if no other route matches param ruby version v1 using param using this versioning strategy clients should pass the desired version as a request parameter either in the url query string or in the request body curl http localhost 9292 statuses public timeline apiver v1 the default name for the query parameter is apiver but can be specified using the parameter option ruby version v1 using param parameter v curl http localhost 9292 statuses public timeline v v1 describing methods you can add a description to api methods and namespaces ruby desc returns your public timeline do detail more details params api entities status documentation success api entities entity failure 401 unauthorized entities error named my named route headers xauthtoken description validates your identity required true xoptionalheader description not really needed required false end get public timeline do status limit 20 end detail a more enhanced description params define parameters directly from an entity success former entity the entity to be used to present by default this route failure former http codes a definition of the used failure http codes and entities named a helper to give a route a name and find it with this name in the documentation hash headers a definition of the used headers parameters request parameters are available through the params hash object this includes get post and put parameters along with any named parameters you specify in your route strings ruby get public timeline do status order params sort by end parameters are automatically populated from the request body on post and put for form input json and xml content types the request curl d text 140 characters http localhost 9292 statuses h content type application json v the grape endpoint ruby post statuses do status create text params text end multipart posts and puts are supported as well the request curl form image file image jpg type image jpg http localhost 9292 upload the grape endpoint ruby post upload do file in params image file end in the case of conflict between either of route string parameters get post and put parameters the contents of the request body on post and put route string parameters will have precedence params class by default parameters are available as activesupport hashwithindifferentaccess this can be changed to for example ruby hash or hashie mash for the entire api ruby class api grape api include grape extensions hashie mash parambuilder params do optional color type string end get do params color instead of params color end the class can also be overridden on individual parameter blocks using build with as follows ruby params do build with grape extensions hash parambuilder optional color type string end in the example above params color will return nil since params is a plain hash available parameter builders are grape extensions hash parambuilder grape extensions activesupport hashwithindifferentaccess parambuilder and grape extensions hashie mash parambuilder declared grape allows you to access only the parameters that have been declared by your params block it filters out the params that have been passed but are not allowed consider the following api endpoint ruby format json post users signup do declared params declared params end if you do not specify any parameters declared will return an empty hash request bash curl x post h content type application json localhost 9292 users signup d user first name first name last name last name response json declared params once we add parameters requirements grape will start returning only the declared parameters ruby format json params do requires user type hash do requires first name type string requires last name type string end end post users signup do declared params declared params end request bash curl x post h content type application json localhost 9292 users signup d user first name first name last name last name random never shown response json declared params user first name first name last name last name the returned hash is an activesupport hashwithindifferentaccess the declared method is not available to before filters as those are evaluated prior to parameter coercion include parent namespaces by default declared params includes parameters that were defined in all parent namespaces if you want to return only parameters from your current namespace you can set include parent namespaces option to false ruby format json namespace parent do params do requires parent name type string end namespace parent name do params do requires child name type string end get child name do without parent namespaces declared params include parent namespaces false with parent namespaces declared params include parent namespaces true end end end request bash curl x get h content type application json localhost 9292 parent foo bar response json without parent namespaces child name bar with parent namespaces parent name foo child name bar include missing by default declared params includes parameters that have nil values if you want to return only the parameters that are not nil you can use the include missing option by default include missing is set to true consider the following api ruby format json params do requires first name type string optional last name type string end post users signup do declared params declared params include missing false end request bash curl x post h content type application json localhost 9292 users signup d user first name first name random never shown response with include missing false json declared params user first name first name response with include missing true json declared params first name first name last name null it also works on nested hashes ruby format json params do requires user type hash do requires first name type string optional last name type string requires address type hash do requires city type string optional region type string end end end post users signup do declared params declared params include missing false end request bash curl x post h content type application json localhost 9292 users signup d user first name first name random never shown address city sf response with include missing false json declared params user first name first name address city sf response with include missing true json declared params user first name first name last name null address city zurich region null note that an attribute with a nil value is not considered missing and will also be returned when include missing is set to false request bash curl x post h content type application json localhost 9292 users signup d user first name first name last name null address city sf response with include missing false json declared params user first name first name last name null address city sf parameter validation and coercion you can define validations and coercion options for your parameters using a params block ruby params do requires id type integer optional text type string regexp \a a z \z group media type hash do requires url end optional audio type hash do requires format type symbol values mp3 wav aac ogg default mp3 end mutually exclusive media audio end put id do params id is an integer end when a type is specified an implicit validation is done after the coercion to ensure the output type is the one declared optional parameters can have a default value ruby params do optional color type string default blue optional random number type integer default random rand 1 100 optional non random number type integer default random rand 1 100 end note that default values will be passed through to any validation options specified the following example will always fail if color is not explicitly provided default values are eagerly evaluated above non random number will evaluate to the same number for each call to the endpoint of this params block to have the default evaluate lazily with each request use a lambda like random number above ruby params do optional color type string default blue values red green end the correct implementation is to ensure the default value passes all validations ruby params do optional color type string default blue values blue red green end supported parameter types the following are all valid types supported out of the box by grape integer float bigdecimal numeric date datetime time boolean string symbol rack multipart uploadedfile alias file json integer fixnum and coercions please be aware that the behavior differs between ruby 2 4 and earlier versions in ruby 2 4 values consisting of numbers are converted to integer but in earlier versions it will be treated as fixnum ruby params do requires integers type hash do requires int coerce integer end end get int do params integers int class end get int integers int 45 integer in ruby 2 4 fixnum in earlier ruby versions custom types and coercions aside from the default set of supported types listed above any class can be used as a type as long as an explicit coercion method is supplied if the type implements a class level parse method grape will use it automatically this method must take one string argument and return an instance of the correct type or raise an exception to indicate the value was invalid e g ruby class color attr reader value def initialize color value color end def self parse value fail invalid color unless w blue red green include value new value end end params do requires color type color default color new blue requires more colors type array color collections work optional unique colors type set color duplicates discarded end get stuff do params color is already a color params color value end alternatively a custom coercion method may be supplied for any type of parameter using coerce with any class or object may be given that implements a parse or call method in that order of precedence the method must accept a single string parameter and the return value must match the given type ruby params do requires passwd type string coerce with base64 method decode requires loud color type color coerce with c color parse c downcase requires obj type hash coerce with json do requires words type array string coerce with val val split \s optional time type time coerce with chronic end end example of use of coerce with with a lambda a class with a parse method could also have been used it will parse a string and return an array of integers matching the array integer type ruby params do requires values type array integer coerce with val val split \s map to i end grape will assert that coerced values match the given type and will reject the request if they do not to override this behaviour custom types may implement a parsed method that should accept a single argument and return true if the value passes type validation ruby class secureuri def self parse value uri parse value end def self parsed value value is a uri https end end params do requires secure uri type secureuri end multipart file parameters grape makes use of rack requests built in support for multipart file parameters such parameters can be declared with type file ruby params do requires avatar type file end post do params avatar filename avatar png params avatar type image png params avatar tempfile file end first class json types grape supports complex parameters given as json formatted strings using the special type json declaration json objects and arrays of objects are accepted equally with nested validation rules applied to all objects in either case ruby params do requires json type json do requires int type integer values 1 2 3 end end get do params json inspect end client get json int 1 int 1 client get json int 1 int 1 client get json int 4 http 400 client get json int 4 http 400 additionally type array json may be used which explicitly marks the parameter as an array of objects if a single object is supplied it will be wrapped ruby params do requires json type array json do requires int type integer end end get do params json each obj always works end for stricter control over the type of json structure which may be supplied use type array coerce with json or type hash coerce with json multiple allowed types variant type parameters can be declared using the types option rather than type ruby params do requires status code types integer string array integer string end get do params status code inspect end client get status code ok good ok good client get status code 300 300 client get status code w 404 not found 404 not found as a special case variant member type collections may also be declared by passing a set or array with more than one member to type ruby params do requires status codes type array integer string end get do params status codes inspect end client get status codes w 1 two 1 two validation of nested parameters parameters can be nested using group or by calling requires or optional with a block in the above example this means params media url is required along with params id and params audio format is required only if params audio is present with a block group requires and optional accept an additional option type which can be either array or hash and defaults to array depending on the value the nested parameters will be treated either as values of a hash or as values of hashes in an array ruby params do optional preferences type array do requires key requires value end requires name type hash do requires first name requires last name end end dependent parameters suppose some of your parameters are only relevant if another parameter is given grape allows you to express this relationship through the given method in your parameters block like so ruby params do optional shelf id type integer given shelf id do requires bin id type integer end end in the example above grape will use blank to check whether the shelf id param is present given also takes a proc with custom code below the param description is required only if the value of category is equal foo ruby params do optional category given category val val foo do requires description end end group options parameters options can be grouped it can be useful if you want to extract common validation or types for several parameters the example below presents a typical case when parameters share common options ruby params do requires first name type string regexp w desc first name requires middle name type string regexp w desc middle name requires last name type string regexp w desc last name end grape allows you to present the same logic through the with method in your parameters block like so ruby params do with type string regexp w do requires first name desc first name requires middle name desc middle name requires last name desc last name end end alias you can set an alias for parameters using as which can be useful when refactoring existing apis ruby resource users do params do requires email address as email requires password end post do user create declared params user takes email and password end end the value passed to as will be the key when calling params or declared params built in validators allow blank parameters can be defined as allow blank ensuring that they contain a value by default requires only validates that a parameter was sent in the request regardless its value with allow blank false empty values or whitespace only values are invalid allow blank can be combined with both requires and optional if the parameter is required it has to contain a value if its optional its possible to not send it in the request but if its being sent it has to have some value and not an empty string only whitespaces ruby params do requires username allow blank false optional first name allow blank false end values parameters can be restricted to a specific set of values with the values option ruby params do requires status type symbol values not started processing done optional numbers type array integer default 1 values 1 2 3 5 8 end supplying a range to the values option ensures that the parameter is or parameters are included in that range using range include ruby params do requires latitude type float values 90 0 90 0 requires longitude type float values 180 0 180 0 optional letters type array string values a z end note that both range endpoints have to be a kind of your type option if you dont supply the type option it will be guessed to be equal to the class of the ranges first endpoint so the following is invalid ruby params do requires invalid1 type float values 0 10 0 kind of float false optional invalid2 values 0 10 0 10 0 kind of 0 class false end the values option can also be supplied with a proc evaluated lazily with each request if the proc has arity zero i e it takes no arguments it is expected to return either a list or a range which will then be used to validate the parameter for example given a status model you may want to restrict by hashtags that you have previously defined in the hashtag model ruby params do requires hashtag type string values hashtag all map tag end alternatively a proc with arity one i e taking one argument can be used to explicitly validate each parameter value in that case the proc is expected to return a truthy value if the parameter value is valid the parameter will be considered invalid if the proc returns a falsy value or if it raises a standarderror ruby params do requires number type integer values v v even v 25 end while procs are convenient for single cases consider using custom validators in cases where a validation is used more than once except values parameters can be restricted from having a specific set of values with the except values option the except values validator behaves similarly to the values validator in that it accepts either an array a range or a proc unlike the values validator however except values only accepts procs with arity zero ruby params do requires browser except values ie6 ie7 ie8 requires port except values value 0 1024 message is not allowed requires hashtag except values hashtag forbidden list end regexp parameters can be restricted to match a specific regular expression with the regexp option if the value does not match the regular expression an error will be returned note that this is true for both requires and optional parameters ruby params do requires email regexp end the validator will pass if the parameter was sent without value to ensure that the parameter contains a value use allow blank false ruby params do requires email allow blank false regexp end mutually exclusive parameters can be defined as mutually exclusive ensuring that they arent present at the same time in a request ruby params do optional beer optional wine mutually exclusive beer wine end multiple sets can be defined ruby params do optional beer optional wine mutually exclusive beer wine optional scotch optional aquavit mutually exclusive scotch aquavit end warning never define mutually exclusive sets with any required params two mutually exclusive required params will mean params are never valid thus making the endpoint useless one required param mutually exclusive with an optional param will mean the latter is never valid exactly one of parameters can be defined as exactly one of ensuring that exactly one parameter gets selected ruby params do optional beer optional wine exactly one of beer wine end note that using default with mutually exclusive will cause multiple parameters to always have a default value and raise a grape exceptions validation mutually exclusive exception at least one of parameters can be defined as at least one of ensuring that at least one parameter gets selected ruby params do optional beer optional wine optional juice at least one of beer wine juice end all or none of parameters can be defined as all or none of ensuring that all or none of parameters gets selected ruby params do optional beer optional wine optional juice all or none of beer wine juice end nested mutually exclusive exactly one of at least one of all or none of all of these methods can be used at any nested level ruby params do requires food type hash do optional meat optional fish optional rice at least one of meat fish rice end group drink type hash do optional beer optional wine optional juice exactly one of beer wine juice end optional dessert type hash do optional cake optional icecream mutually exclusive cake icecream end optional recipe type hash do optional oil optional meat all or none of oil meat end end namespace validation and coercion namespaces allow parameter definitions and apply to every method within the namespace ruby namespace statuses do params do requires user id type integer desc a user id end namespace user id do desc retrieve a users status params do requires status id type integer desc a status id end get status id do user find params user id statuses find params status id end end end the namespace method has a number of aliases including group resource resources and segment use whichever reads the best for your api you can conveniently define a route parameter as a namespace using route param ruby namespace statuses do route param id do desc returns all replies for a status get replies do status find params id replies end desc returns a status get do status find params id end end end you can also define a route parameter type by passing to route params options ruby namespace arithmetic do route param n type integer do desc returns in power get power do params n params n end end end custom validators ruby class alphanumeric grape validations base def validate param attr name params unless params attr name \a alnum \z fail grape exceptions validation params scope full name attr name message must consist of alpha numeric characters end end end ruby params do requires text alpha numeric true end you can also create custom classes that take parameters ruby class length grape validations base def validate param attr name params unless params attr name length option fail grape exceptions validation params scope full name attr name message must be at the most option characters long end end end ruby params do requires text length 140 end you can also create custom validation that use request to validate the attribute for example if you want to have parameters that are available to only admins you can do the following ruby class admin grape validations base def validate request return if the param we are checking was not in request attrs is a list containing the attribute we are currently validating in our sample case this method once will get called with attrs being admin field and once with attrs being admin false field return unless request params key attrs first check if admin flag is set to true return unless option check if user is admin or not as an example get a token from request and check if its admin or not fail grape exceptions validation params attrs message can not set admin only field unless request headers x access token admin end end and use it in your endpoint definition as ruby params do optional admin field type string admin true optional non admin field type string optional admin false field type string admin false end every validation will have its own instance of the validator which means that the validator can have a state validation errors validation and coercion errors are collected and an exception of type grape exceptions validationerrors is raised if the exception goes uncaught it will respond with a status of 400 and an error message the validation errors are grouped by parameter name and can be accessed via grape exceptions validationerrors errors the default response from a grape exceptions validationerrors is a humanly readable string such as beer wine are mutually exclusive in the following example ruby params do optional beer optional wine optional juice exactly one of beer wine juice end you can rescue a grape exceptions validationerrors and respond with a custom response or turn the response into well formatted json for a json api that separates individual parameters and the corresponding error messages the following rescue from example produces params beer wine messages are mutually exclusive ruby format json subject rescue from grape exceptions validationerrors do e error e 400 end grape exceptions validationerrors full messages returns the validation messages as an array grape exceptions validationerrors message joins the messages to one string for responding with an array of validation messages you can use grape exceptions validationerrors full messages ruby format json subject rescue from grape exceptions validationerrors do e error messages e full messages 400 end grape returns all validation and coercion errors found by default to skip all subsequent validation checks when a specific param is found invalid use fail fast true the following example will not check if wine is present unless it finds beer ruby params do required beer fail fast true required wine end the result of empty params would be a single grape exceptions validationerrors error similarly no regular expression test will be performed if blah is blank in the following example ruby params do required blah allow blank false regexp blah fail fast true end i18n grape supports i18n for parameter related error messages but will fallback to english if translations for the default locale have not been provided see en yml for message keys custom validation messages grape supports custom validation messages for parameter related and coerce related error messages presence allow blank values regexp ruby params do requires name values value 1 10 message not in range from 1 to 10 allow blank value false message cannot be blank regexp value a z message format is invalid message is required end all or none of ruby params do optional beer optional wine optional juice all or none of beer wine juice message all params are required or none is required end mutually exclusive ruby params do optional beer optional wine optional juice mutually exclusive beer wine juice message are mutually exclusive cannot pass both params end exactly one of ruby params do optional beer optional wine optional juice exactly one of beer wine juice message exactly one are missing exactly one parameter is required mutual exclusion are mutually exclusive exactly one parameter is required end at least one of ruby params do optional beer optional wine optional juice at least one of beer wine juice message are missing please specify at least one param end coerce ruby params do requires int type value integer message type cast is invalid end with lambdas ruby params do requires name values value 1 10 to a message not in range from 1 to 10 end pass symbols for i18n translations you can pass a symbol if you want i18n translations for your custom validation messages ruby params do requires name message name required end ruby en yml en grape errors format attributes message messages name required must be present overriding attribute names you can also override attribute names ruby en yml en grape errors format attributes message messages name required must be present attributes name oops name will produce oops name must be present with default you cannot set a custom message option for default as it requires interpolation option1 value1 is incompatible with option2 value2 you can change the default error message for default by changing the incompatible option values message key inside en yml ruby params do requires name values value 1 10 to a message not in range from 1 to 10 default 5 end headers request headers are available through the headers helper or from env in their original form ruby get do error unauthorized 401 unless headers secret password swordfish end ruby get do error unauthorized 401 unless env http secret password swordfish end you can set a response header with header inside an api ruby header x robots tag noindex when raising error pass additional headers as arguments ruby error unauthorized 401 x error detail invalid token routes optionally you can define requirements for your named route parameters using regular expressions on namespace or endpoint the route will match only if all requirements are met ruby get id requirements id 0 9 do status find params id end namespace outer requirements id 0 9 do get id do end get id edit do end end helpers you can define helper methods that your endpoints can use with the helpers macro by either giving a block or an array of modules ruby module statushelpers def user info user user has statused user statuses status s end end module httpcodeshelpers def unauthorized 401 end end class api grape api define helpers with a block helpers do def current user user find params user id end end or mix in an array of modules helpers statushelpers httpcodeshelpers before do error access denied unauthorized unless current user end get info do helpers available in your endpoint and filters user info current user end end you can define reusable params using helpers ruby class api grape api helpers do params pagination do optional page type integer optional per page type integer end end desc get collection params do use pagination aliases includes use scope end get do collection page params page per params per page end end you can also define reusable params using shared helpers ruby module sharedparams extend grape api helpers params period do optional start date optional end date end params pagination do optional page type integer optional per page type integer end end class api grape api helpers sharedparams desc get collection params do use period pagination end get do collection from params start date to params end date page params page per params per page end end helpers support blocks that can help set default values the following api can return a collection sorted by id or created at in asc or desc order ruby module sharedparams extend grape api helpers params order do options optional order by type symbol values options order by default options default order by optional order type symbol values i asc desc default options default order end end class api grape api helpers sharedparams desc get a sorted collection params do use order order by i id created at default order by created at default order asc end get do collection send params order params order by end end path helpers if you need methods for generating paths inside your endpoints please see the grape route helpers gem parameter documentation you can attach additional documentation to params using a documentation hash ruby params do optional first name type string documentation example jim requires last name type string documentation example smith end cookies you can set get and delete your cookies very simply using cookies method ruby class api grape api get status count do cookies status count 0 cookies status count 1 status count cookies status count end delete status count do status count cookies delete status count end end use a hash based syntax to set more than one value ruby cookies status count value 0 expires time tomorrow domain twitter com path cookies status count value 1 delete a cookie with delete ruby cookies delete status count specify an optional path ruby cookies delete status count path http status code by default grape returns a 201 for post requests 204 for delete requests that dont return any content and 200 status code for all other requests you can use status to query and set the actual http status code ruby post do status 202 if status 200 do some thing end end you can also use one of status codes symbols that are provided by rack utils ruby post do status no content end redirecting you can redirect to a new url temporarily 302 or permanently 301 ruby redirect statuses ruby redirect statuses permanent true recognizing path you can recognize the endpoint matched with given path this api returns an instance of grape endpoint ruby class api grape api get statuses do end end api recognize path statuses allowed methods when you add a get route for a resource a route for the head method will also be added automatically you can disable this behavior with do not route head ruby class api grape api do not route head get example do only responds to get end end when you add a route for a resource a route for the options method will also be added the response to an options request will include an allow header listing the supported methods if the resource has before and after callbacks they will be executed but no other callbacks will run ruby class api grape api get rt count do rt count current user rt count end params do requires value type integer desc value to add to the rt count end put rt count do current user rt count params value to i rt count current user rt count end end shell curl v x options http localhost 3000 rt count options rt count http 1 1 http 1 1 204 no content allow options get put you can disable this behavior with do not route options if a request for a resource is made with an unsupported http method an http 405 method not allowed response will be returned if the resource has before callbacks they will be executed but no other callbacks will run shell curl x delete v http localhost 3000 rt count delete rt count http 1 1 host localhost 3000 http 1 1 405 method not allowed allow options get put raising exceptions you can abort the execution of an api method by raising errors with error ruby error access denied 401 anything that responds to to s can be given as a first argument to error ruby error not found 404 you can also return json formatted objects by raising error and passing a hash instead of a message ruby error error unexpected error detail missing widget 500 you can present documented errors with a grape entity using the the grape entity gem ruby module api class error grape entity expose code expose message end end the following example specifies the entity to use in the http codes definition ruby desc my route do failure 408 unauthorized api error end error message unauthorized 408 the following example specifies the presented entity explicitly in the error message ruby desc my route do failure 408 unauthorized end error message unauthorized with api error 408 default error http status code by default grape returns a 500 status code from error you can change this with default error status ruby class api grape api default error status 400 get example do error this should have http status code 400 end end handling 404 for grape to handle all the 404s for your api it can be useful to use a catch all in its simplest form it can be like ruby route any path do error or something else end it is very crucial to define this endpoint at the very end of your api as it literally accepts every request exception handling grape can be told to rescue all standarderror exceptions and return them in the api format ruby class twitter api grape api rescue from all end this mimics default rescue behaviour when an exception type is not provided any other exception should be rescued explicitly see below grape can also rescue from all exceptions and still use the built in exception handing this will give the same behavior as rescue from all with the addition that grape will use the exception handling defined by all exception classes that inherit grape exceptions base the intent of this setting is to provide a simple way to cover the most common exceptions and return any unexpected exceptions in the api format ruby class twitter api grape api rescue from grape exceptions end you can also rescue specific exceptions ruby class twitter api grape api rescue from argumenterror userdefinederror end in this case userdefinederror must be inherited from standarderror notice that you could combine these two approaches rescuing custom errors takes precedence for example its useful for handling all exceptions except grape validation errors ruby class twitter api grape api rescue from grape exceptions validationerrors do e error e 400 end rescue from all end the error format will match the request format see content types below custom error formatters for existing and additional types can be defined with a proc ruby class twitter api grape api error formatter txt message backtrace options env original exception error message from backtrace end you can also use a module or class ruby module customformatter def self call message backtrace options env original exception message message backtrace backtrace end end class twitter api grape api error formatter custom customformatter end you can rescue all exceptions with a code block the error wrapper automatically sets the default error code and content type ruby class twitter api grape api rescue from all do e error rescued from e class name end end optionally you can set the format status code and headers ruby class twitter api grape api format json rescue from all do e error error server error 500 content type text error end end you can also rescue all exceptions with a code block and handle the rack response at the lowest level ruby class twitter api grape api rescue from all do e rack response new e message 500 content type text error finish end end or rescue specific exceptions ruby class twitter api grape api rescue from argumenterror do e error argumenterror e message end rescue from nomethoderror do e error nomethoderror e message end end by default rescue from will rescue the exceptions listed and all their subclasses assume you have the following exception classes defined ruby module apierrors class parenterror standarderror end class childerror parenterror end end then the following rescue from clause will rescue exceptions of type apierrors parenterror and its subclasses in this case apierrors childerror ruby rescue from apierrors parenterror do e error error e class error message e message e status end to only rescue the base exception class set rescue subclasses false the code below will rescue exceptions of type runtimeerror but not its subclasses ruby rescue from runtimeerror rescue subclasses false do e error status e status message e message errors e errors e status end helpers are also available inside rescue from ruby class twitter api grape api format json helpers do def server error error error server error 500 content type text error end end rescue from all do e server error end end the rescue from block must return a rack response object call error or re raise an exception the with keyword is available as rescue from options it can be passed method name or proc object ruby class twitter api grape api format json helpers do def server error error error server error 500 content type text error end end rescue from all with server error rescue from argumenterror with rack response new rescued with a method 400 end rescuing exceptions inside namespaces you could put rescue from clauses inside a namespace and they will take precedence over ones defined in the root scope ruby class twitter api grape api rescue from argumenterror do e error outer end namespace statuses do rescue from argumenterror do e error inner end get do raise argumenterror new end end end here inner will be result of handling occured argumenterror unrescuable exceptions grape exceptions invalidversionheader which is raised when the version in the request header doesnt match the currently evaluated version for the endpoint will never be rescued from a rescue from block even a rescue from all this is because grape relies on rack to catch that error and try the next versioned route for cases where there exist identical grape endpoints with different versions exceptions that should be rescued explicitly any exception that is not subclass of standarderror should be rescued explicitly usually it is not a case for an application logic as such errors point to problems in ruby runtime this is following standard recommendations for exceptions handling rails 3 x when mounted inside containers such as rails 3 x errors such as 404 not found or 406 not acceptable will likely be handled and rendered by rails handlers for instance accessing a nonexistent route api foo raises a 404 which inside rails will ultimately be translated to an actioncontroller routingerror which most likely will get rendered to a html error page most apis will enjoy preventing downstream handlers from handling errors you may set the cascade option to false for the entire api or separately on specific version definitions which will remove the x cascade true header from api responses ruby cascade false ruby version v1 using header vendor twitter cascade false logging grape api provides a logger method which by default will return an instance of the logger class from rubys standard library to log messages from within an endpoint you need to define a helper to make the logger available in the endpoint context ruby class api grape api helpers do def logger api logger end end post statuses do logger info current user has statused end end to change the logger level ruby class api grape api self logger level logger info end you can also set your own logger ruby class mylogger def warning message puts this is a warning message end end class api grape api logger mylogger new helpers do def logger api logger end end get statuses do logger warning current user has statused end end for similar to rails request logging try the grape logging or grape middleware logger gems api formats your api can declare which content types to support by using content type if you do not specify any grape will support xml json binary and txt content types the default format is txt you can change this with default format essentially the two apis below are equivalent ruby class twitter api grape api no content type declarations so grape uses the defaults end class twitter api grape api the following declarations are equivalent to the defaults content type xml application xml content type json application json content type binary application octet stream content type txt text plain default format txt end if you declare any content type whatsoever the grape defaults will be overridden for example the following api will only support the xml and rss content types but not txt json or binary importantly this means the txt default format is not supported so make sure to set a new default format ruby class twitter api grape api content type xml application xml content type rss application xml rss default format xml end serialization takes place automatically for example you do not have to call to json in each json api endpoint implementation the response format and thus the automatic serialization is determined in the following order use the file extension if specified if the file is json choose the json format use the value of the format parameter in the query string if specified use the format set by the format option if specified attempt to find an acceptable format from the accept header use the default format if specified by the default format option default to txt for example consider the following api ruby class multipleformatapi grape api content type xml application xml content type json application json default format json get hello do hello world end end get hello with an accept header does not have an extension or a format parameter so it will respond with json the default format get hello xml has a recognized extension so it will respond with xml get hello format xml has a recognized format parameter so it will respond with xml get hello xml format json has a recognized extension which takes precedence over the format parameter so it will respond with xml get hello xls with an accept header has an extension but that extension is not recognized so it will respond with json the default format get hello xls with an accept application xml header has an unrecognized extension but the accept header corresponds to a recognized format so it will respond with xml get hello xls with an accept text plain header has an unrecognized extension and an unrecognized accept header so it will respond with json the default format you can override this process explicitly by specifying env api format in the api itself for example the following api will let you upload arbitrary files and return their contents as an attachment with the correct mime type ruby class twitter api grape api post attachment do filename params file filename content type mime types type for filename 0 to s env api format binary theres no formatter for binary data will be returned as is header content disposition attachment filename utf 8 cgi escape filename params file tempfile read end end you can have your api only respond to a single format with format if you use this the api will not respond to file extensions other than specified in format for example consider the following api ruby class singleformatapi grape api format json get hello do hello world end end get hello will respond with json get hello json will respond with json get hello xml get hello foobar or any other extension will respond with an http 404 error code get hello format xml will respond with an http 406 error code because the xml format specified by the request parameter is not supported get hello with an accept application xml header will still respond with json since it could not negotiate a recognized content type from the headers and json is the effective default the formats apply to parsing too the following api will only respond to the json content type and will not parse any other input than application json application x www form urlencoded multipart form data multipart related and multipart mixed all other requests will fail with an http 406 error code ruby class twitter api grape api format json end when the content type is omitted grape will return a 406 error code unless default format is specified the following api will try to parse any data without a content type using a json parser ruby class twitter api grape api format json default format json end if you combine format with rescue from all errors will be rendered using the same format if you do not want this behavior set the default error formatter with default error formatter ruby class twitter api grape api format json content type txt text plain default error formatter txt end custom formatters for existing and additional types can be defined with a proc ruby class twitter api grape api content type xls application vnd ms excel formatter xls object env object to xls end you can also use a module or class ruby module xlsformatter def self call object env object to xls end end class twitter api grape api content type xls application vnd ms excel formatter xls xlsformatter end built in formatters are the following json use objects to json when available otherwise call multijson dump xml use objects to xml when available usually via multixml otherwise call to s txt use objects to txt when available otherwise to s serializable hash use objects serializable hash when available otherwise fallback to json binary data will be returned as is if a body is present in a request to an api with a content type header value that is of an unsupported type a 415 unsupported media type error code will be returned by grape response statuses that indicate no content as defined by rack here will bypass serialization and the body entity though there should be none will not be modified jsonp grape supports jsonp via rack jsonp part of the rack contrib gem add rack contrib to your gemfile ruby require rack contrib class api grape api use rack jsonp format json get do hello world end end cors grape supports cors via rack cors part of the rack cors gem add rack cors to your gemfile then use the middleware in your config ru file ruby require rack cors use rack cors do allow do origins resource headers any methods get end end run twitter api content type content type is set by the formatter you can override the content type of the response at runtime by setting the content type header ruby class api grape api get home timeline js do content type application javascript var statuses end end api data formats grape accepts and parses input data sent with the post and put methods as described in the parameters section above it also supports custom data formats you must declare additional content types via content type and optionally supply a parser via parser unless a parser is already available within grape to enable a custom format such a parser can be a function or a class with a parser parsed data is available as is in env api request body without a parser data is available as is and in env api request input the following example is a trivial parser that will assign any input with the text custom content type to value the parameter will be available via params value inside the api call ruby module customparser def self call object env value object to s end end ruby content type txt text plain content type custom text custom parser custom customparser put value do params value end you can invoke the above api as follows curl x put d data http localhost 9292 value h content type text custom v you can disable parsing for a content type with nil for example parser json nil will disable json parsing altogether the request data is then available as is in env api request body json and xml processors grape uses json and activesupport xmlmini for json and xml parsing by default it also detects and supports multi json and multi xml adding those gems to your gemfile and requiring them will enable them and allow you to swap the json and xml back ends restful model representations grape supports a range of ways to present your data with some help from a generic present method which accepts two arguments the object to be presented and the options associated with it the options hash may include with which defines the entity to expose grape entities add the grape entity gem to your gemfile please refer to the grape entity documentation for more details the following example exposes statuses ruby module api module entities class status grape entity expose user name expose text documentation type string desc status update text expose ip if type full expose user type user id if status options status user public expose digest do status options digest md5 hexdigest status txt end expose replies using api status as replies end end class statuses grape api version v1 desc statuses index do params api entities status documentation end get statuses do statuses status all type current user admin full default present statuses with api entities status type type end end end you can use entity documentation directly in the params block with using entity documentation ruby module api class statuses grape api version v1 desc create a status params do requires all except ip using api entities status documentation except id end post status do status create params end end end you can present with multiple entities using an optional symbol argument ruby get statuses do statuses status all page 1 per 20 present total page 10 present per page 20 present statuses statuses with api entities status end the response will be total page 10 per page 20 statuses in addition to separately organizing entities it may be useful to put them as namespaced classes underneath the model they represent ruby class status def entity entity new self end class entity grape entity expose text user id end end if you organize your entities this way grape will automatically detect the entity class and use it to present your models in this example if you added present status new to your endpoint grape will automatically detect that there is a status entity class and use that as the representative entity this can still be overridden by using the with option or an explicit represents call you can present hash with grape presenters presenter to keep things consistent ruby get users do present id 10 name dgz with grape presenters presenter end the response will be ruby id 10 name dgz it has the same result with ruby get users do present id 10 present name dgz end hypermedia and roar you can use roar to render hal or collection json with the help of grape roar which defines a custom json formatter and enables presenting entities with grapes present keyword rabl you can use rabl templates with the help of the grape rabl gem which defines a custom grape rabl formatter active model serializers you can use active model serializers serializers with the help of the grape active model serializers gem which defines a custom grape ams formatter sending raw or no data in general use the binary format to send raw data ruby class api grape api get file do content type application octet stream file binread file bin end end you can set the response body explicitly with body ruby class api grape api get do content type text plain body hello world return value ignored end end use body false to return 204 no content without any data or content type you can also set the response to a file with file ruby class api grape api get do file path to file end end if you want a file to be streamed using rack chunked use stream ruby class api grape api get do stream path to file end end authentication basic and digest auth grape has built in basic and digest authentication the given block is executed in the context of the current endpoint authentication applies to the current namespace and any children but not parents ruby http basic do username password verify users password here test password1 username password end ruby http digest realm test api opaque app secret do username lookup the users password here user1 password1 username end register custom middleware for authentication grape can use custom middleware for authentication how to implement these middleware have a look at rack auth basic or similar implementations for registering a middleware you need the following options label the name for your authenticator to use it later middlewareclass the middlewareclass to use for authentication option lookup proc a proc with one argument to lookup the options at runtime return value is an array as parameter for the middleware example ruby grape middleware auth strategies add my auth authmiddleware options options realm auth my auth realm test api do credentials lookup the users password here user1 password1 username end use warden oauth2 or rack oauth2 for oauth2 support describing and inspecting an api grape routes can be reflected at runtime this can notably be useful for generating documentation grape exposes arrays of api versions and compiled routes each route contains a route prefix route version route namespace route method route path and route params you can add custom route settings to the route metadata with route setting ruby class twitterapi grape api version v1 desc includes custom settings route setting custom key value get do end end examine the routes at runtime ruby twitterapi versions yields v1 v2 twitterapi routes yields an array of grape route objects twitterapi routes 0 version v1 twitterapi routes 0 description includes custom settings twitterapi routes 0 settings custom key value note that route route xyz methods have been deprecated since 0 15 0 please use route xyz instead note that difference of route options and route settings the options can be referred from your route it should be set by specifing key and value on verb methods such as get post and put the settings can also be referred from your route but it should be set by specifing key and value on route setting current route and endpoint its possible to retrieve the information about the current route from within an api call with route ruby class myapi grape api desc returns a description of a parameter params do requires id type integer desc identity end get params id do route route params params id yields the parameter description end end the current endpoint responding to the request is self within the api block or env api endpoint elsewhere the endpoint has some interesting properties such as source which gives you access to the original code block of the api implementation this can be particularly useful for building a logger middleware ruby class apilogger grape middleware base def before file env api endpoint source source location 0 line env api endpoint source source location 1 logger debug api file line end end before and after blocks can be executed before or after every api call using before after before validation and after validation before and after callbacks execute in the following order before before validation validations after validation the api call after steps 4 5 and 6 only happen if validation succeeds if a request for a resource is made with an unsupported http method returning http 405 only before callbacks will be executed the remaining callbacks will be bypassed if a request for a resource is made that triggers the built in options handler only before and after callbacks will be executed the remaining callbacks will be bypassed for example using a simple before block to set a header ruby before do header x robots tag noindex end namespaces callbacks apply to each api call within and below the current namespace ruby class myapi grape api get do root blah end namespace foo do before do blah blah end get do root foo blah end namespace bar do get do root foo bar blah end end end end the behavior is then bash get root get foo root foo blah get foo bar root foo bar blah params on a namespace or whichever alias you are using will also be available when using before validation or after validation ruby class myapi grape api params do requires blah type integer end resource blah do after validation do if we reach this point validations will have passed blah declared params include missing false blah end get do blah class end end end the behavior is then bash get 123 integer get foo 400 error blah is invalid versioning when a callback is defined within a version block its only called for the routes defined in that block ruby class test grape api resource foo do version v1 using path do before do output v1 end get do output hello end end version v2 using path do before do output v2 end get do output hello end end end end the behavior is then bash get foo v1 v1 hello get foo v2 v2 hello altering responses using present in any callback allows you to add data to a response ruby class myapi grape api format json after validation do present name params name if params name end get greeting do present greeting hello end end the behavior is then bash get greeting greeting hello get greeting name alan name alan greeting hello instead of altering a response you can also terminate and rewrite it from any callback using error including after this will cause all subsequent steps in the process to not be called this includes the actual api call and any callbacks anchoring grape by default anchors all request paths which means that the request url should match from start to end to match otherwise a 404 not found is returned however this is sometimes not what you want because it is not always known upfront what can be expected from the call this is because rack mount by default anchors requests to match from the start to the end or not at all rails solves this problem by using a anchor false option in your routes in grape this option can be used as well when a method is defined for instance when your api needs to get part of an url for instance ruby class twitterapi grape api namespace statuses do get status anchor false do end end end this will match all paths starting with statuses there is one caveat though the params status parameter only holds the first part of the request url luckily this can be circumvented by using the described above syntax for path specification and using the path info rack environment variable using env path info this will hold everything that comes after the statuses part using custom middleware grape middleware you can make a custom middleware by using grape middleware base its inherited from some grape official middlewares in fact for example you can write a middleware to log application exception ruby class loggingerror grape middleware base def after return unless app response app response 0 500 env rack logger error raised error on env path info end end your middleware can overwrite application response as follows except error case ruby class overwriter grape middleware base def after 200 content type text plain overwritten end end you can add your custom middleware with use that push the middleware onto the stack and you can also control where the middleware is inserted using insert insert before and insert after ruby class customoverwriter grape middleware base def after 200 content type text plain options message end end class api grape api use overwriter insert before overwriter customoverwriter message overwritten again insert 0 customoverwriter message overwrites all other middleware get do end end rails middleware note that when youre using grape mounted on rails you dont have to use rails middleware because its already included into your middleware stack you only have to implement the helpers to access the specific env variable remote ip by default you can access remote ip with request ip this is the remote ip address implemented by rack sometimes it is desirable to get the remote ip rails style with actiondispatch remoteip add gem actionpack to your gemfile and require action dispatch middleware remote ip rb use the middleware in your api and expose a client ip helper see this documentation for additional options ruby class api grape api use actiondispatch remoteip helpers do def client ip env action dispatch remote ip to s end end get remote ip do ip client ip end end writing tests writing tests with rack use rack test and define your api as app rspec you can test a grape api with rspec by making http requests and examining the response ruby require spec helper describe twitter api do include rack test methods def app twitter api end context get api statuses public timeline do it returns an empty array of statuses do get api statuses public timeline expect last response status to eq 200 expect json parse last response body to eq end end context get api statuses id do it returns a status by id do status status create get api statuses status id expect last response body to eq status to json end end end theres no standard way of sending arrays of objects via an http get so post json data and specify the correct content type ruby describe twitter api do context post api statuses do it creates many statuses do statuses text text post api statuses statuses to json content type application json expect last response body to eq 201 end end end airborne you can test with other rspec based frameworks including airborne which uses rack test to make requests ruby require airborne airborne configure do config config rack app twitter api end describe twitter api do context get api statuses id do it returns a status by id do status status create get api statuses status id expect json status as json end end end minitest ruby require test helper class twitter apitest minitest test include rack test methods def app twitter api end def test get api statuses public timeline returns an empty array of statuses get api statuses public timeline assert last response ok assert equal json parse last response body end def test get api statuses id returns a status by id status status create get api statuses status id assert equal status to json last response body end end writing tests with rails rspec ruby describe twitter api do context get api statuses public timeline do it returns an empty array of statuses do get api statuses public timeline expect response status to eq 200 expect json parse response body to eq end end context get api statuses id do it returns a status by id do status status create get api statuses status id expect response body to eq status to json end end end in rails http request tests would go into the spec requests group you may want your api code to go into app api you can match that layout under spec by adding the following in spec rails helper rb ruby rspec configure do config config include rspec rails requestexamplegroup type request file path spec\ api end minitest ruby class twitter apitest activesupport testcase include rack test methods def app rails application end test get api statuses public timeline returns an empty array of statuses do get api statuses public timeline assert last response ok assert equal json parse last response body end test get api statuses id returns a status by id do status status create get api statuses status id assert equal status to json last response body end end stubbing helpers because helpers are mixed in based on the context when an endpoint is defined it can be difficult to stub or mock them for testing the grape endpoint before each method can help by allowing you to define behavior on the endpoint that will run before every request ruby describe an endpoint that needs helpers stubbed do before do grape endpoint before each do endpoint allow endpoint to receive helper name and return desired value end end after do grape endpoint before each nil end it stubs the helper do end end reloading api changes in development reloading in rack applications use grape reload reloading in rails applications add api paths to config application rb ruby auto load api and its subdirectories config paths add file join app api glob file join rb config autoload paths dir rails root join app api create config initializers reload api rb ruby if rails env development activesupport dependencies explicitly unloadable constants twitter api api files dir rails root join app api rb api reloader activesupport fileupdatechecker new api files do rails application reload routes end actiondispatch callbacks to prepare do api reloader execute if updated end end for rails 5 1 4 change this ruby actiondispatch callbacks to prepare do api reloader execute if updated end to this ruby activesupport reloader to prepare do api reloader execute if updated end see stackoverflow 3282655 for more information performance monitoring active support instrumentation grape has built in support for activesupport notifications which provides simple hook points to instrument key parts of your application the following are currently supported endpoint run grape the main execution of an endpoint includes filters and rendering endpoint the endpoint instance endpoint render grape the execution of the main content block of the endpoint endpoint the endpoint instance endpoint run filters grape endpoint the endpoint instance filters the filters being executed type the type of filters before before validation after validation after endpoint run validators grape the execution of validators endpoint the endpoint instance validators the validators being executed request the request being validated format response grape serialization or template rendering env the request environment formatter the formatter object e g grape formatter json see the activesupport notifications documentation for information on how to subscribe to these events monitoring products grape integrates with following third party tools new relic built in support from v3 10 0 of the official newrelic rpm gem also newrelic grape gem librato metrics grape librato gem skylight skylight gem documentation appsignal appsignal ruby gem documentation contributing to grape grape is work of hundreds of contributors youre encouraged to submit pull requests propose features and discuss issues see contributing license mit license see license for details copyright copyright c 2010 2018 michael bleigh intridea inc and contributors