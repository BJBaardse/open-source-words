interviews your personal guide to software engineering technical interviews maintainer kevin naughton jr translations 简体中文 table of contents instagram articles online judges live coding practice data structures algorithms greedy algorithms bitmasks runtime analysis video lectures interview books computer science news directory tree instagram programeme articles starting work online judges leetcode virtual judge careercup hackerrank codefights kattis hackerearth codility code forces code chef sphere online judge spoj interviewbit live coding practice pramp gainlo refdash interviewing io data structures linked list a linked list is a linear collection of data elements called nodes each pointing to the next node by means of a pointer it is a data structure consisting of a group of nodes which together represent a sequence singly linked list linked list in which each node points to the next node and the last node points to null doubly linked list linked list in which each node has two pointers p n such that p points to the previous node and n points to the next node the last nodes n pointer points to null circular linked list linked list in which each node points to the next node and the last node points back to the first node time complexity access o n search o n insert o 1 remove o 1 stack a stack is a collection of elements with two principle operations push which adds to the collection and pop which removes the most recently added element last in first out data structure lifo time complexity access o n search o n insert o 1 remove o 1 queue a queue is a collection of elements supporting two principle operations enqueue which inserts an element into the queue and dequeue which removes an element from the queue first in first out data structure fifo time complexity access o n search o n insert o 1 remove o 1 tree a tree is an undirected connected acyclic graph binary tree a binary tree is a tree data structure in which each node has at most two children which are referred to as the left child and right child full tree a tree in which every node has either 0 or 2 children perfect binary tree a binary tree in which all interior nodes have two children and all leave have the same depth complete tree a binary tree in which every level except possibly the last is full and all nodes in the last level are as far left as possible binary search tree a binary search tree sometimes called bst is a type of binary tree which maintains the property that the value in each node must be greater than or equal to any value stored in the left sub tree and less than or equal to any value stored in the right sub tree time complexity access o log n search o log n insert o log n remove o log n trie a trie sometimes called a radix or prefix tree is a kind of search tree that is used to store a dynamic set or associative array where the keys are usually strings no node in the tree stores the key associated with that node instead its position in the tree defines the key with which it is associated all the descendants of a node have a common prefix of the string associated with that node and the root is associated with the empty string fenwick tree a fenwick tree sometimes called a binary indexed tree is a tree in concept but in practice is implemented as an implicit data structure using an array given an index in the array representing a vertex the index of a vertexs parent or child is calculated through bitwise operations on the binary representation of its index each element of the array contains the pre calculated sum of a range of values and by combining that sum with additional ranges encountered during an upward traversal to the root the prefix sum is calculated time complexity range sum o log n update o log n segment tree a segment tree is a tree data structure for storing intervals or segments it allows querying which of the stored segments contain a given point time complexity range query o log n update o log n heap a heap is a specialized tree based structure data structure that satisfies the heap property if a is a parent node of b then the key the value of node a is ordered with respect to the key of node b with the same ordering applying across the entire heap a heap can be classified further as either a max heap or a min heap in a max heap the keys of parent nodes are always greater than or equal to those of the children and the highest key is in the root node in a min heap the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node time complexity access max min o 1 insert o log n remove max min o log n hashing hashing is used to map data of an arbitrary size to data of a fixed size the values returned by a hash function are called hash values hash codes or simply hashes if two keys map to the same value a collision occurs hash map a hash map is a structure that can map keys to values a hash map uses a hash function to compute an index into an array of buckets or slots from which the desired value can be found collision resolution separate chaining in separate chaining each bucket is independent and contains a list of entries for each index the time for hash map operations is the time to find the bucket constant time plus the time to iterate through the list open addressing in open addressing when a new entry is inserted the buckets are examined starting with the hashed to slot and proceeding in some sequence until an unoccupied slot is found the name open addressing refers to the fact that the location of an item is not always determined by its hash value graph a graph is an ordered pair of g v e comprising a set v of vertices or nodes together with a set e of edges or arcs which are 2 element subsets of v i e an edge is associated with two vertices and that association takes the form of the unordered pair comprising those two vertices undirected graph a graph in which the adjacency relation is symmetric so if there exists an edge from node u to node v u v then it is also the case that there exists an edge from node v to node u v u directed graph a graph in which the adjacency relation is not symmetric so if there exists an edge from node u to node v u v this does not imply that there exists an edge from node v to node u v u algorithms sorting quicksort stable no time complexity best case o nlog n worst case o n 2 average case o nlog n mergesort mergesort is also a divide and conquer algorithm it continuously divides an array into two halves recurses on both the left subarray and right subarray and then merges the two sorted halves stable yes time complexity best case o nlog n worst case o nlog n average case o nlog n bucket sort bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets each bucket is then sorted individually either using a different sorting algorithm or by recursively applying the bucket sorting algorithm time complexity best case ω n k worst case o n 2 average case θ n k radix sort radix sort is a sorting algorithm that like bucket sort distributes elements of an array into a number of buckets however radix sort differs from bucket sort by re bucketing the array after the initial pass as opposed to sorting each bucket and merging time complexity best case ω nk worst case o nk average case θ nk graph algorithms depth first search depth first search is a graph traversal algorithm which explores as far as possible along each branch before backtracking time complexity o v e breadth first search breadth first search is a graph traversal algorithm which explores the neighbor nodes first before moving to the next level neighbors time complexity o v e topological sort topological sort is the linear ordering of a directed graphs nodes such that for every edge from node u to node v u comes before v in the ordering time complexity o v e dijkstras algorithm dijkstras algorithm is an algorithm for finding the shortest path between nodes in a graph time complexity o v 2 bellman ford algorithm bellman ford algorithm is an algorithm that computes the shortest paths from a single source node to all other nodes in a weighted graph although it is slower than dijkstras it is more versatile as it is capable of handling graphs in which some of the edge weights are negative numbers time complexity best case o e worst case o v e floyd warshall algorithm floyd warshall algorithm is an algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights but no negative cycles a single execution of the algorithm will find the lengths summed weights of the shortest paths between all pairs of nodes time complexity best case o v 3 worst case o v 3 average case o v 3 prims algorithm prims algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph in other words prims find a subset of edges that forms a tree that includes every node in the graph time complexity o v 2 kruskals algorithm kruskals algorithm is also a greedy algorithm that finds a minimum spanning tree in a graph however in kruskals the graph does not have to be connected time complexity o e log v greedy algorithms greedy algorithms are algorithms that make locally optimal choices at each step in the hope of eventually reaching the globally optimal solution problems must exhibit two properties in order to implement a greedy solution optimal substructure an optimal solution to the problem contains optimal solutions to the given problems subproblems the greedy property an optimal solution is reached by greedily choosing the locally optimal choice without ever reconsidering previous choices example coin change given a target amount v cents and a list of denominations of n coins i e we have coinvalue i in cents for coin types i from 0 n 1 what is the minimum number of coins that we must use to represent amount v assume that we have an unlimited supply of coins of any type coins penny 1 cent nickel 5 cents dime 10 cents quarter 25 cents assume v 41 we can use the greedy algorithm of continuously selecting the largest coin denomination less than or equal to v subtract that coins value from v and repeat v 41 0 coins used v 16 1 coin used 41 25 16 v 6 2 coins used 16 10 6 v 1 3 coins used 6 5 1 v 0 4 coins used 1 1 0 using this algorithm we arrive at a total of 4 coins which is optimal bitmasks bitmasking is a technique used to perform operations at the bit level leveraging bitmasks often leads to faster runtime complexity and helps limit memory usage test kth bit s 1 k set kth bit s 1 k turn off kth bit s 1 k toggle kth bit s 1 k multiple by 2n s n divide by 2n s n intersection s t union s t set subtraction s t extract lowest set bit s s extract lowest unset bit s s 1 swap values x y y x x y runtime analysis big o notation big o notation is used to describe the upper bound of a particular algorithm big o is used to describe worst case scenarios little o notation little o notation is also used to describe an upper bound of a particular algorithm however little o provides a bound that is not asymptotically tight big ω omega notation big omega notation is used to provide an asymptotic lower bound on a particular algorithm little ω omega notation little omega notation is used to provide a lower bound on a particular algorithm that is not asymptotically tight theta θ notation theta notation is used to provide a bound on a particular algorithm such that it can be sandwiched between two constants one for an upper limit and one for a lower limit for sufficiently large values video lectures data structures uc berkeley data structures mit advanced data structures algorithms mit introduction to algorithms mit advanced algorithms uc berkeley algorithms interview books competitive programming 3 steven halim felix halim cracking the coding interview gayle laakmann mcdowell cracking the pm interview gayle laakmann mcdowell jackie bavaro introduction to algorithms thomas h cormen charles e leiserson ronald l rivest clifford stein computer science news hacker news lobsters directory tree ├── array │ ├── besttimetobuyandsellstock java │ ├── findthecelebrity java │ ├── gameoflife java │ ├── increasingtripletsubsequence java │ ├── insertinterval java │ ├── longestconsecutivesequence java │ ├── maximumproductsubarray java │ ├── maximumsubarray java │ ├── mergeintervals java │ ├── missingranges java │ ├── productofarrayexceptself java │ ├── rotateimage java │ ├── searchinrotatedsortedarray java │ ├── spiralmatrixii java │ ├── subsetsii java │ ├── subsets java │ ├── summaryranges java │ ├── wigglesort java │ └── wordsearch java ├── backtracking │ ├── androidunlockpatterns java │ ├── generalizedabbreviation java │ └── lettercombinationsofaphonenumber java ├── binarysearch │ ├── closestbinarysearchtreevalue java │ ├── firstbadversion java │ ├── guessnumberhigherorlower java │ ├── pow x n java │ └── sqrt x java ├── bitmanipulation │ ├── binarywatch java │ ├── countingbits java │ ├── hammingdistance java │ ├── maximumproductofwordlengths java │ ├── numberof1bits java │ ├── sumoftwointegers java │ └── utf 8validation java ├── breadthfirstsearch │ ├── binarytreelevelordertraversal java │ ├── clonegraph java │ ├── pacificatlanticwaterflow java │ ├── removeinvalidparentheses java │ ├── shortestdistancefromallbuildings java │ ├── symmetrictree java │ └── wallsandgates java ├── depthfirstsearch │ ├── balancedbinarytree java │ ├── battleshipsinaboard java │ ├── convertsortedarraytobinarysearchtree java │ ├── maximumdepthofabinarytree java │ ├── numberofislands java │ ├── populatingnextrightpointersineachnode java │ └── sametree java ├── design │ └── zigzagiterator java ├── divideandconquer │ ├── expressionaddoperators java │ └── kthlargestelementinanarray java ├── dynamicprogramming │ ├── bombenemy java │ ├── climbingstairs java │ ├── combinationsumiv java │ ├── countingbits java │ ├── editdistance java │ ├── houserobber java │ ├── paintfence java │ ├── painthouseii java │ ├── regularexpressionmatching java │ ├── sentencescreenfitting java │ ├── uniquebinarysearchtrees java │ └── wordbreak java ├── hashtable │ ├── binarytreeverticalordertraversal java │ ├── findthedifference java │ ├── groupanagrams java │ ├── groupshiftedstrings java │ ├── islandperimeter java │ ├── loggerratelimiter java │ ├── maximumsizesubarraysumequalsk java │ ├── minimumwindowsubstring java │ ├── sparsematrixmultiplication java │ ├── strobogrammaticnumber java │ ├── twosum java │ └── uniquewordabbreviation java ├── linkedlist │ ├── addtwonumbers java │ ├── deletenodeinalinkedlist java │ ├── mergeksortedlists java │ ├── palindromelinkedlist java │ ├── plusonelinkedlist java │ ├── readme md │ └── reverselinkedlist java ├── queue │ └── movingaveragefromdatastream java ├── readme md ├── sort │ ├── meetingroomsii java │ └── meetingrooms java ├── stack │ ├── binarysearchtreeiterator java │ ├── decodestring java │ ├── flattennestedlistiterator java │ └── trappingrainwater java ├── string │ ├── addbinary java │ ├── countandsay java │ ├── decodeways java │ ├── editdistance java │ ├── integertoenglishwords java │ ├── longestpalindrome java │ ├── longestsubstringwithatmostkdistinctcharacters java │ ├── minimumwindowsubstring java │ ├── multiplystring java │ ├── oneeditdistance java │ ├── palindromepermutation java │ ├── readme md │ ├── reversevowelsofastring java │ ├── romantointeger java │ ├── validpalindrome java │ └── validparentheses java ├── tree │ ├── binarytreemaximumpathsum java │ ├── binarytreepaths java │ ├── inordersuccessorinbst java │ ├── invertbinarytree java │ ├── lowestcommonancestorofabinarytree java │ ├── sumofleftleaves java │ └── validatebinarysearchtree java ├── trie │ ├── addandsearchworddatastructuredesign java │ ├── implementtrie java │ └── wordsquares java └── twopointers ├── 3sum java ├── 3sumsmaller java ├── mergesortedarray java ├── minimumsizesubarraysum java ├── movezeros java ├── removeduplicatesfromsortedarray java ├── reversestring java └── sortcolors java 18 directories 124 files