the javascript database embedded persistent or in memory database for node js nw js electron and browsers 100 javascript no binary dependency api is a subset of mongodbs and its plenty fast important note please dont submit issues for questions regarding your code only actual bugs or feature requests will be answered all others will be closed without comment also please follow the bug reporting guidelines and check the change log before submitting an already fixed bug support nedb development no time to help out you can support nedb development by sending money or bitcoins money bitcoin address 1ddzlnwpbbodpin8sizzyrgaz5iahfyb1 installation tests module name on npm and bower is nedb npm install nedb save put latest version in your package json npm test youll need the dev dependencies to launch tests bower install nedb for the browser versions which will be in browser version out api it is a subset of mongodbs api the most used operations creating loading a database persistence inserting documents finding documents basic querying operators lt lte gt gte in nin ne exists regex array fields logical operators or and not where sorting and paginating projections counting documents updating documents removing documents indexing browser version creating loading a database you can use nedb as an in memory only datastore or as a persistent datastore one datastore is the equivalent of a mongodb collection the constructor is used as follows new datastore options where options is an object with the following fields filename optional path to the file where the data is persisted if left blank the datastore is automatically considered in memory only it cannot end with a which is used in the temporary files nedb uses to perform crash safe writes inmemoryonly optional defaults to false as the name implies timestampdata optional defaults to false timestamp the insertion and last update of all documents with the fields createdat and updatedat user specified values override automatic generation usually useful for testing autoload optional defaults to false if used the database will automatically be loaded from the datafile upon creation you dont need to call loaddatabase any command issued before load is finished is buffered and will be executed when load is done onload optional if you use autoloading this is the handler called after the loaddatabase it takes one error argument if you use autoloading without specifying this handler and an error happens during load an error will be thrown afterserialization optional hook you can use to transform data after it was serialized and before it is written to disk can be used for example to encrypt data before writing database to disk this function takes a string as parameter one line of an nedb data file and outputs the transformed string which must absolutely not contain a \n character or data will be lost beforedeserialization optional inverse of afterserialization make sure to include both and not just one or you risk data loss for the same reason make sure both functions are inverses of one another some failsafe mechanisms are in place to prevent data loss if you misuse the serialization hooks nedb checks that never one is declared without the other and checks that they are reverse of one another by testing on random strings of various lengths in addition if too much data is detected as corrupt nedb will refuse to start as it could mean youre not using the deserialization hook corresponding to the serialization hook used before see below corruptalertthreshold optional between 0 and 1 defaults to 10 nedb will refuse to start if more than this percentage of the datafile is corrupt 0 means you dont tolerate any corruption 1 means you dont care comparestrings optional function comparestrings a b compares strings a and b and return 1 0 or 1 if specified it overrides default string comparison which is not well adapted to non us characters in particular accented letters native localcompare will most of the time be the right choice nodewebkitappname optional deprecated if you are using nedb from whithin a node webkit app specify its name the same one you use in the package json in this field and the filename will be relative to the directory node webkit uses to store the rest of the applications data local storage etc it works on linux os x and windows now that you can use require nw gui app datapath in node webkit to get the path to the data directory for your application you should not use this option anymore and it will be removed if you use a persistent datastore without the autoload option you need to call loaddatabase manually this function fetches the data from datafile and prepares the database dont forget it if you use a persistent datastore no command insert find update remove will be executed before loaddatabase is called so make sure to call it yourself or use the autoload option also if loaddatabase fails all commands registered to the executor afterwards will not be executed they will be registered and executed in sequence only after a successful loaddatabase javascript type 1 in memory only datastore no need to load the database var datastore require nedb db new datastore type 2 persistent datastore with manual loading var datastore require nedb db new datastore filename path to datafile db loaddatabase function err callback is optional now commands will be executed type 3 persistent datastore with automatic loading var datastore require nedb db new datastore filename path to datafile autoload true you can issue commands right away type 4 persistent datastore for a node webkit app called nwtest for example on linux the datafile will be config nwtest nedb data something db var datastore require nedb path require path db new datastore filename path join require nw gui app datapath something db of course you can create multiple datastores if you need several collections in this case its usually a good idea to use autoload for all collections db db users new datastore path to users db db robots new datastore path to robots db you need to load each database here we do it asynchronously db users loaddatabase db robots loaddatabase persistence under the hood nedbs persistence uses an append only format meaning that all updates and deletes actually result in lines added at the end of the datafile for performance reasons the database is automatically compacted i e put back in the one line per document format every time you load each database within your application you can manually call the compaction function with yourdatabase persistence compactdatafile which takes no argument it queues a compaction of the datafile in the executor to be executed sequentially after all pending operations the datastore will fire a compaction done event once compaction is finished you can also set automatic compaction at regular intervals with yourdatabase persistence setautocompactioninterval interval interval in milliseconds a minimum of 5s is enforced and stop automatic compaction with yourdatabase persistence stopautocompaction keep in mind that compaction takes a bit of time not too much 130ms for 50k records on a typical development machine and no other operation can happen when it does so most projects actually dont need to use it compaction will also immediately remove any documents whose data line has become corrupted assuming that the total percentage of all corrupted documents in that database still falls below the specified corruptalertthreshold options value durability works similarly to major databases compaction forces the os to physically flush data to disk while appends to the data file do not the os is responsible for flushing the data that guarantees that a server crash can never cause complete data loss while preserving performance the worst that can happen is a crash between two syncs causing a loss of all data between the two syncs usually syncs are 30 seconds appart so thats at most 30 seconds of data this post by antirez on redis persistence explains this in more details nedb being very close to redis aof persistence with appendfsync option set to no inserting documents the native types are string number boolean date and null you can also use arrays and subdocuments objects if a field is undefined it will not be saved this is different from mongodb which transforms undefined in null something i find counter intuitive if the document does not contain an id field nedb will automatically generated one for you a 16 characters alphanumerical string the id of a document once set cannot be modified field names cannot begin by or contain a javascript var doc hello world n 5 today new date nedbisawesome true notthere null nottobesaved undefined will not be saved fruits apple orange pear infos name nedb db insert doc function err newdoc callback is optional newdoc is the newly inserted document including its id newdoc has no key called nottobesaved since its value was undefined you can also bulk insert an array of documents this operation is atomic meaning that if one insert fails due to a unique constraint being violated all changes are rolled back javascript db insert a 5 a 42 function err newdocs two documents were inserted in the database newdocs is an array with these documents augmented with their id if there is a unique constraint on field a this will fail db insert a 5 a 42 a 5 function err err is a uniqueviolated error the database was not modified finding documents use find to look for multiple documents matching you query or findone to look for one specific document you can select documents based on field equality or use comparison operators lt lte gt gte in nin ne you can also use logical operators or and not and where see below for the syntax you can use regular expressions in two ways in basic querying in place of a string or with the regex operator you can sort and paginate results using the cursor api see below you can use standard projections to restrict the fields to appear in the results see below basic querying basic querying means are looking for documents whose fields match the ones you specify you can use regular expression to match strings you can use the dot notation to navigate inside nested documents arrays arrays of subdocuments and to match a specific element of an array javascript lets say our datastore contains the following collection id id1 planet mars system solar inhabited false satellites phobos deimos id id2 planet earth system solar inhabited true humans genders 2 eyes true id id3 planet jupiter system solar inhabited false id id4 planet omicron persei 8 system futurama inhabited true humans genders 7 id id5 completedata planets name earth number 3 name mars number 2 name pluton number 9 finding all planets in the solar system db find system solar function err docs docs is an array containing documents mars earth jupiter if no document is found docs is equal to finding all planets whose name contain the substring ar using a regular expression db find planet ar function err docs docs contains mars and earth finding all inhabited planets in the solar system db find system solar inhabited true function err docs docs is an array containing document earth only use the dot notation to match fields in subdocuments db find humans genders 2 function err docs docs contains earth use the dot notation to navigate arrays of subdocuments db find completedata planets name mars function err docs docs contains document 5 db find completedata planets name jupiter function err docs docs is empty db find completedata planets 0 name earth function err docs docs contains document 5 if we had tested against mars docs would be empty because we are matching against a specific array element you can also deep compare objects dont confuse this with dot notation db find humans genders 2 function err docs docs is empty because genders 2 is not equal to genders 2 eyes true find all documents in the collection db find function err docs the same rules apply when you want to only find one document db findone id id1 function err doc doc is the document mars if no document is found doc is null operators lt lte gt gte in nin ne exists regex the syntax is field op value where op is any comparison operator lt lte less than less than or equal gt gte greater than greater than or equal in member of value must be an array of values ne nin not equal not a member of exists checks whether the document posses the property field value should be true or false regex checks whether a string is matched by the regular expression contrary to mongodb the use of options with regex is not supported because it doesnt give you more power than regex flags basic queries are more readable so only use the regex operator when you need to use another operator with it see example below javascript lt lte gt and gte work on numbers and strings db find humans genders gt 5 function err docs docs contains omicron persei 8 whose humans have more than 5 genders 7 when used with strings lexicographical order is used db find planet gt mercury function err docs docs contains omicron persei 8 using in nin is used in the same way db find planet in earth jupiter function err docs docs contains earth and jupiter using exists db find satellites exists true function err docs docs contains only mars using regex with another operator db find planet regex ar nin jupiter earth function err docs docs only contains mars because earth was excluded from the match by nin array fields when a field in a document is an array nedb first tries to see if the query value is an array to perform an exact match then whether there is an array specific comparison function for now there is only size and elemmatch being used if not the query is treated as a query on every element and there is a match if at least one element matches size match on the size of the array elemmatch matches if at least one array element matches the query entirely javascript exact match db find satellites phobos deimos function err docs docs contains mars db find satellites deimos phobos function err docs docs is empty using an array specific comparison function elemmatch operator will provide match for a document if an element from the array field satisfies all the conditions specified with the elemmatch operator db find completedata planets elemmatch name earth number 3 function err docs docs contains documents with id 5 completedata db find completedata planets elemmatch name earth number 5 function err docs docs is empty you can use inside elemmatch query any known document query operator db find completedata planets elemmatch name earth number gt 2 function err docs docs contains documents with id 5 completedata note you cant use nested comparison functions e g size lt 5 will throw an error db find satellites size 2 function err docs docs contains mars db find satellites size 1 function err docs docs is empty if a documents field is an array matching it means matching any element of the array db find satellites phobos function err docs docs contains mars result would have been the same if query had been satellites deimos this also works for queries that use comparison operators db find satellites lt amos function err docs docs is empty since phobos and deimos are after amos in lexicographical order this also works with the in and nin operator db find satellites in moon deimos function err docs docs contains mars the earth document is not complete logical operators or and not where you can combine queries using logical operators for or and and the syntax is op query1 query2 for not the syntax is not query for where the syntax is where function object is this return a boolean javascript db find or planet earth planet mars function err docs docs contains earth and mars db find not planet earth function err docs docs contains mars jupiter omicron persei 8 db find where function return object keys this 6 function err docs docs with more than 6 properties you can mix normal queries comparison queries and logical operators db find or planet earth planet mars inhabited true function err docs docs contains earth sorting and paginating if you dont specify a callback to find findone or count a cursor object is returned you can modify the cursor with sort skip and limit and then execute it with exec callback javascript lets say the database contains these 4 documents doc1 id id1 planet mars system solar inhabited false satellites phobos deimos doc2 id id2 planet earth system solar inhabited true humans genders 2 eyes true doc3 id id3 planet jupiter system solar inhabited false doc4 id id4 planet omicron persei 8 system futurama inhabited true humans genders 7 no query used means all results are returned before the cursor modifiers db find sort planet 1 skip 1 limit 2 exec function err docs docs is doc3 doc1 you can sort in reverse order like this db find system solar sort planet 1 exec function err docs docs is doc1 doc3 doc2 you can sort on one field then another and so on like this db find sort firstfield 1 secondfield 1 you understand how this works projections you can give find and findone an optional second argument projections the syntax is the same as mongodb a 1 b 1 to return only the a and b fields a 0 b 0 to omit these two fields you cannot use both modes at the time except for id which is by default always returned and which you can choose to omit you can project on nested documents javascript same database as above keeping only the given fields db find planet mars planet 1 system 1 function err docs docs is planet mars system solar id id1 keeping only the given fields but removing id db find planet mars planet 1 system 1 id 0 function err docs docs is planet mars system solar omitting only the given fields and removing id db find planet mars planet 0 system 0 id 0 function err docs docs is inhabited false satellites phobos deimos failure using both modes at the same time db find planet mars planet 0 system 1 function err docs err is the error message docs is undefined you can also use it in a cursor way but this syntax is not compatible with mongodb db find planet mars projection planet 1 system 1 exec function err docs docs is planet mars system solar id id1 project on a nested document db findone planet earth projection planet 1 humans genders 1 exec function err doc doc is planet earth id id2 humans genders 2 counting documents you can use count to count documents it has the same syntax as find for example javascript count all planets in the solar system db count system solar function err count count equals to 3 count all documents in the datastore db count function err count count equals to 4 updating documents db update query update options callback will update all documents matching query according to the update rules query is the same kind of finding query you use with find and findone update specifies how the documents should be modified it is either a new document or a set of modifiers you cannot use both together it doesnt make sense a new document will replace the matched docs the modifiers create the fields they need to modify if they dont exist and you can apply them to subdocs available field modifiers are set to change a fields value unset to delete a field inc to increment a fields value and min max to change fields value only if provided value is less greater than current value to work on arrays you have push pop addtoset pull and the special each and slice see examples below for the syntax options is an object with two possible parameters multi defaults to false which allows the modification of several documents if set to true upsert defaults to false if you want to insert a new document corresponding to the update rules if your query doesnt match anything if your update is a simple object with no modifiers it is the inserted document in the other case the query is stripped from all operator recursively and the update is applied to it returnupdateddocs defaults to false not mongodb compatible if set to true and update is not an upsert will return the array of documents matched by the find query and updated updated documents will be returned even if the update did not actually modify them callback optional signature err numaffected affecteddocuments upsert warning the api was changed between v1 7 4 and v1 8 please refer to the change log to see the change for an upsert affecteddocuments contains the inserted document and the upsert flag is set to true for a standard update with returnupdateddocs flag set to false affecteddocuments is not set for a standard update with returnupdateddocs flag set to true and multi to false affecteddocuments is the updated document for a standard update with returnupdateddocs flag set to true and multi to true affecteddocuments is the array of updated documents note you cant change a documents id javascript lets use the same example collection as in the finding document part id id1 planet mars system solar inhabited false id id2 planet earth system solar inhabited true id id3 planet jupiter system solar inhabited false id id4 planet omicron persia 8 system futurama inhabited true replace a document by another db update planet jupiter planet pluton function err numreplaced numreplaced 1 the doc 3 has been replaced by id id3 planet pluton note that the id is kept unchanged and the document has been replaced the system and inhabited fields are not here anymore set an existing fields value db update system solar set system solar system multi true function err numreplaced numreplaced 3 field system on mars earth jupiter now has value solar system setting the value of a non existing field in a subdocument by using the dot notation db update planet mars set data satellites 2 data red true function mars document now is id id1 system solar inhabited false data satellites 2 red true not that to set fields in subdocuments you have to use dot notation using object notation will just replace the top level field db update planet mars set data satellites 3 function mars document now is id id1 system solar inhabited false data satellites 3 you lost the data red field which is probably not the intended behavior deleting a field db update planet mars unset planet true function now the document for mars doesnt contain the planet field you can unset nested fields with the dot notation of course upserting a document db update planet pluton planet pluton inhabited false upsert true function err numreplaced upsert numreplaced 1 upsert id id5 planet pluton inhabited false a new document id id5 planet pluton inhabited false has been added to the collection if you upsert with a modifier the upserted doc is the query modified by the modifier this is simpler than it sounds db update planet pluton inc distance 38 upsert true function a new document id id5 planet pluton distance 38 has been added to the collection if we insert a new document id id6 fruits apple orange pear in the collection lets see how we can modify the array field atomically push inserts new elements at the end of the array db update id id6 push fruits banana function now the fruits array is apple orange pear banana pop removes an element from the end if used with 1 or the front if used with 1 of the array db update id id6 pop fruits 1 function now the fruits array is apple orange with pop fruits 1 it would have been orange pear addtoset adds an element to an array only if it isnt already in it equality is deep checked i e addtoset will not insert an object in an array already containing the same object note that it doesnt check whether the array contained duplicates before or not db update id id6 addtoset fruits apple function the fruits array didnt change if we had used a fruit not in the array e g banana it would have been added to the array pull removes all values matching a value or even any nedb query from the array db update id id6 pull fruits apple function now the fruits array is orange pear db update id id6 pull fruits in apple pear function now the fruits array is orange each can be used to push or addtoset multiple values at once this example works the same way with addtoset db update id id6 push fruits each banana orange function now the fruits array is apple orange pear banana orange slice can be used in cunjunction with push and each to limit the size of the resulting array a value of 0 will update the array to an empty array a positive value n will keep only the n first elements a negative value n will keep only the last n elements if slice is specified but not each each is set to db update id id6 push fruits each banana slice 2 function now the fruits array is apple orange min max to update only if provided value is less greater than current value lets say the database contains this document doc id id name name value 5 db update id id1 min value 2 function the document will be updated to id id name name value 2 db update id id1 min value 8 function the document will not be modified removing documents db remove query options callback will remove all documents matching query according to options query is the same as the ones used for finding and updating options only one option for now multi which allows the removal of multiple documents if set to true default is false callback is optional signature err numremoved javascript lets use the same example collection as in the finding document part id id1 planet mars system solar inhabited false id id2 planet earth system solar inhabited true id id3 planet jupiter system solar inhabited false id id4 planet omicron persia 8 system futurama inhabited true remove one document from the collection options set to since the default for multi is false db remove id id2 function err numremoved numremoved 1 remove multiple documents db remove system solar multi true function err numremoved numremoved 3 all planets from the solar system were removed removing all documents with the match all query db remove multi true function err numremoved indexing nedb supports indexing it gives a very nice speed boost and can be used to enforce a unique constraint on a field you can index any field including fields in nested documents using the dot notation for now indexes are only used to speed up basic queries and queries using in lt lte gt and gte the indexed values cannot be of type array of object to create an index use datastore ensureindex options cb where callback is optional and get passed an error if any usually a unique constraint that was violated ensureindex can be called when you want even after some data was inserted though its best to call it at application startup the options are fieldname required name of the field to index use the dot notation to index a field in a nested document unique optional defaults to false enforce field uniqueness note that a unique index will raise an error if you try to index two documents for which the field is not defined sparse optional defaults to false dont index documents for which the field is not defined use this option along with unique if you want to accept multiple documents for which it is not defined expireafterseconds number of seconds optional if set the created index is a ttl time to live index that will automatically remove documents when the system date becomes larger than the date on the indexed field plus expireafterseconds documents where the indexed field is not specified or not a date object are ignored note the id is automatically indexed with a unique constraint no need to call ensureindex on it you can remove a previously created index with datastore removeindex fieldname cb if your datastore is persistent the indexes you created are persisted in the datafile when you load the database a second time they are automatically created for you no need to remove any ensureindex though if it is called on a database that already has the index nothing happens javascript db ensureindex fieldname somefield function err if there was an error err is not null using a unique constraint with the index db ensureindex fieldname somefield unique true function err using a sparse unique index db ensureindex fieldname somefield unique true sparse true function err format of the error message when the unique constraint is not met db insert somefield nedb function err err is null db insert somefield nedb function err err is errortype uniqueviolated key name message unique constraint violated for key name remove index on field somefield db removeindex somefield function err example of using expireafterseconds to remove documents 1 hour after their creation dbs timestampdata option is true here db ensureindex fieldname createdat expireafterseconds 3600 function err you can also use the option to set an expiration date like so db ensureindex fieldname expirationdate expireafterseconds 0 function err now all documents will expire when system time reaches the date in their expirationdate field note the ensureindex function creates the index synchronously so its best to use it at application startup its quite fast so it doesnt increase startup time much 35 ms for a collection containing 10 000 documents browser version the browser version and its minified counterpart are in the browser version out directory you only need to require nedb js or nedb min js in your html file and the global object nedb can be used right away with the same api as the server version var db new nedb create an in memory only datastore p p db insert planet earth function err db find function err docs docs contains the two planets earth and mars if you specify a filename the database will be persistent and automatically select the best storage method available indexeddb websql or localstorage depending on the browser in most cases that means a lot of data can be stored typically in hundreds of mb warning the storage system changed between v1 3 and v1 4 and is not back compatible your application needs to resync client side when you upgrade nedb nedb is compatible with all major browsers chrome safari firefox ie9 tests are in the browser version test directory files index html and testpersistence html if you fork and modify nedb you can build the browser version from the sources the build script is browser version build js performance speed nedb is not intended to be a replacement of large scale databases such as mongodb and as such was not designed for speed that said it is still pretty fast on the expected datasets especially if you use indexing on a typical not so fast dev machine for a collection containing 10 000 documents with indexing insert 10 680 ops s find 43 290 ops s update 8 000 ops s remove 11 750 ops s you can run these simple benchmarks by executing the scripts in the benchmarks folder run them with the help flag to see how they work memory footprint a copy of the whole database is kept in memory this is not much on the expected kind of datasets 20mb for 10 000 2kb documents use in other services connect nedb session is a session store for connect and express backed by nedb if you mostly use nedb for logging purposes and dont want the memory footprint of your application to grow too large you can use nedb logger to insert documents in a nedb readable database if youve outgrown nedb switching to mongodb wont be too hard as it is the same api use this utility to transfer the data from a nedb database to a mongodb collection an odm for nedb camo pull requests important i consider nedb to be feature complete i e it does everything i think it should and nothing more as a general rule i will not accept pull requests anymore except for bugfixes of course or if i get convinced i overlook a strong usecase please make sure to open an issue before spending time on any pr if you submit a pull request thanks there are a couple rules to follow though to make it manageable the pull request should be atomic i e contain only one feature if it contains more please submit multiple pull requests reviewing massive 1000 loc pull requests is extremely hard likewise if for one unique feature the pull request grows too large more than 200 loc tests not included please get in touch first please stick to the current coding style its important that the code uses a coherent style for readability do not include sylistic improvements housekeeping if you think one part deserves lots of housekeeping use a separate pull request so as not to pollute the code dont forget tests for your new feature also dont forget to run the whole test suite before submitting to make sure you didnt introduce regressions do not build the browser version in your branch ill take care of it once the code is merged update the readme accordingly last but not least keep in mind what nedbs mindset is the goal is not to be a replacement for mongodb but to have a pure js database easy to use cross platform fast and expressive enough for the target projects small and self contained apps on server desktop browser mobile sometimes its better to shoot for simplicity than for api completeness with regards to mongodb bug reporting guidelines if you report a bug thank you that said for the process to be manageable please strictly adhere to the following guidelines ill not be able to handle bug reports that dont your bug report should be a self containing gist complete with a package json for any dependencies you need i need to run through a simple git clone gist npm install node bugreport js nothing more it should use assertions to showcase the expected vs actual behavior and be hysteresis proof its quite simple in fact see this example https gist github com louischatriot 220cf6bd29c7de06a486 simplify as much as you can strip all your application specific code most of the time you will see that there is no bug but an error in your code 50 lines max if you need more read the above point and rework your bug report if youre really convinced you need more please explain precisely in the issue the code should be javascript not coffeescript bitcoins you dont have time you can support nedb by sending bitcoins to this address 1ddzlnwpbbodpin8sizzyrgaz5iahfyb1 license see license