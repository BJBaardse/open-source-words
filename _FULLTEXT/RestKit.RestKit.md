RestKit RestKit is a modern Objective-C framework for implementing RESTful web services clients on iOS and Mac OS X. It provides a powerful object mapping engine that seamlessly integrates with Core Data and a simple set of networking primitives for mapping HTTP requests and responses built on top of AFNetworking. It has an elegant, carefully designed set of APIs that make accessing and modeling RESTful resources feel almost magical. For example, heres how to access the Twitter public timeline and turn the JSON contents into an array of Tweet objects: ``` objective-c @interface RKTweet : NSObject @property (nonatomic, copy) NSNumber userID; @property (nonatomic, copy) NSString username; @property (nonatomic, copy) NSString *text; @end RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[RKTweet class]]; [mapping addAttributeMappingsFromDictionary:@{ @"user.name": @"username", @"user.id": @"userID", @"text": @"text" }]; RKResponseDescriptor responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:nil keyPath:nil statusCodes:nil]; NSURL url = [NSURL URLWithString:@"http://api.twitter.com/1/statuses/public_timeline.json"]; NSURLRequest request = [NSURLRequest requestWithURL:url]; RKObjectRequestOperation operation = [[RKObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[responseDescriptor]]; [operation setCompletionBlockWithSuccess:^(RKObjectRequestOperation operation, RKMappingResult result) { NSLog(@"The public timeline Tweets: %@", [result array]); } failure:nil]; [operation start]; ``` Getting Started Download RestKit and play with the examples for iPhone and Mac OS X First time with RestKit? Read the "Overview" section below and then check out the "Getting Acquainted with RestKit" tutorial and Object Mapping Reference documents in the wiki to jump right in. Upgrading from RestKit 0.9.x or 0.10.x? Read the "Upgrading to RestKit 0.20.x" guide in the wiki Adding RestKit to an existing AFNetworking application? Read the AFNetworking Integration document to learn details about how the frameworks fit together. Review the source code API documentation for a detailed look at the classes and APIs in RestKit. A great place to start is RKObjectManager. Still need some help? Ask questions on Stack Overflow or the mailing list, ping us on Twitter or chat with us on IRC. Overview RestKit is designed to be modular and each module strives to maintain a minimal set of dependencies across the framework and with the host platform. At the core of library sits the object mapping engine, which is responsible for transforming objects between representations (such as JSON/XML <-> local domain objects). Object Mapping Fundamentals The object mapping engine is built on top of the Key-Value Coding (KVC) informal protocol that is foundational to numerous Cocoa technologies such as key-value observing, bindings, and Core Data. Object mappings are expressed as pairs of KVC key paths that specify the source and destination attributes or relationships that are to be transformed. RestKit leverages the highly dynamic Objective-C runtime to infer the developers desired intent by examining the type of the source and destination properties and performing appropriate type transformations. For example, given a source key path of created_at that identifies a string within a parsed JSON document and a destination key path of creationDate that identifies an NSDate property on a target object, RestKit will transform the date from a string into an NSDate using an NSDateFormatter. Numerous other transformations are provided out of the box and the engine is pluggable to allow the developer to define new transformations or replace an existing transformation with a new implementation. The mapper fully supports both simple attribute as well as relationship mappings in which nested to-one or to-many child objects are mapped recursively. Through relationship mappings, one object mapping can be added to another to compose aggregate mappings that are capable of processing arbitrarily complex source documents. Object mapping is a deep topic and is explored in exhaustive detail in the Object Mapping Guide on the wiki. API Quickstart RestKit is broken into several modules that cleanly separate the mapping engine from the HTTP and Core Data integrations to provide maximum flexibility. Key classes in each module are highlighted below and each module is hyperlinked to the README.md contained within the source code. Object Mapping RKObjectMapping Encapsulates configuration for transforming object representations as expressed by key-value coding keypaths. RKAttributeMapping Specifies a desired transformation between attributes within an object or entity mapping in terms of a source and destination key path. RKRelationshipMapping Specifies a desired mapping of a nested to-one or to-many child objects in in terms of a source and destination key path and an RKObjectMapping with which to map the attributes of the child object. RKDynamicMapping Specifies a flexible mapping in which the decision about which RKObjectMapping is to be used to process a given document is deferred to run time. RKMapperOperation Provides an interface for mapping a deserialized document into a set of local domain objects. RKMappingOperation An NSOperation that performs a mapping between object representations using an RKObjectMapping. Networking RKRequestDescriptor Describes a request that can be sent from the application to a remote web application for a given object type. RKResponseDescriptor Describes an object mappable response that may be returned from a remote web application in terms of an object mapping, a key path, a SOCKit pattern for matching the URL, and a set of status codes that define the circumstances in which the mapping is appropriate for a given response. RKObjectParameterization Performs mapping of a given object into an NSDictionary representation suitable for use as the parameters of an HTTP request. RKObjectRequestOperation An NSOperation that sends an HTTP request and performs object mapping on the parsed response body using the configurations expressed in a set of RKResponseDescriptor objects. RKResponseMapperOperation An NSOperation that provides support for object mapping an NSHTTPURLResponse using a set of RKResponseDescriptor objects. RKObjectManager Captures the common patterns for communicating with a RESTful web application over HTTP using object mapping including: Centralizing RKRequestDescriptor and RKResponseDescriptor configurations Describing URL configuration with an RKRouter Serializing objects and sending requests with the serialized representations Sending requests to load remote resources and object mapping the response bodies Building multi-part form requests for objects RKRouter Generates NSURL objects from a base URL and a set of RKRoute objects describing relative paths used by the application. RKRoute Describes a single relative path for a given object type and HTTP method, the relationship of an object, or a symbolic name. Core Data RKManagedObjectStore Encapsulates Core Data configuration including an NSManagedObjectModel, a NSPersistentStoreCoordinator, and a pair of NSManagedObjectContext objects. RKEntityMapping Models a mapping for transforming an object representation into a NSManagedObject instance for a given NSEntityDescription. RKConnectionDescription Describes a mapping for establishing a relationship between Core Data entities using foreign key attributes. RKManagedObjectRequestOperation An NSOperation subclass that sends an HTTP request and performs object mapping on the parsed response body to create NSManagedObject instances, establishes relationships between objects using RKConnectionDescription objects, and cleans up orphaned objects that no longer exist in the remote backend system. RKManagedObjectImporter Provides support for bulk mapping of managed objects using RKEntityMapping objects for two use cases: Bulk importing of parsed documents into an NSPersistentStore. Generating a seed database for initializing an applications Core Data store with an initial data set upon installation. Search RKSearchIndexer Provides support for generating a full-text searchable index within Core Data for string attributes of entities within an application. RKSearchPredicate Generates an NSCompoundPredicate given a string of text that will search an index built with an RKSearchIndexer across any indexed entity. Testing RKMappingTest Provides support for unit testing object mapping configurations given a parsed document and an object or entity mapping. Expectations are configured in terms of expected key path mappings and/or expected transformation results. RKTestFixture Provides an interface for easily generating test fixture data for unit testing. RKTestFactory Provides support for creating objects for use in testing. Examples Object Request ``` objective-c // GET a single Article from /articles/1234.json and map it into an object // JSON looks like {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!"}} RKObjectMapping mapping = [RKObjectMapping mappingForClass:[Article class]]; [mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]]; NSIndexSet statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // Anything in 2xx RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/articles/:articleID" keyPath:@"article" statusCodes:statusCodes]; NSURLRequest request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://restkit.org/articles/1234.json"]]; RKObjectRequestOperation operation = [[RKObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[responseDescriptor]]; [operation setCompletionBlockWithSuccess:^(RKObjectRequestOperation operation, RKMappingResult result) { Article article = [result firstObject]; NSLog(@"Mapped the article: %@", article); } failure:^(RKObjectRequestOperation operation, NSError *error) { NSLog(@"Failed with error: %@", [error localizedDescription]); }]; [operation start]; ``` Managed Object Request ``` objective-c // GET an Article and its Categories from /articles/888.json and map into Core Data entities // JSON looks like {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!", "categories": [{"id": 1, "name": "Core Data"]} NSManagedObjectModel managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil]; RKManagedObjectStore managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel]; NSError error = nil; BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &error); if (! success) { RKLogError(@"Failed to create Application Data Directory at path %@: %@", RKApplicationDataDirectory(), error); } NSString path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"Store.sqlite"]; NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&error]; if (! persistentStore) { RKLogError(@"Failed adding persistent store at path %@: %@", path, error); } [managedObjectStore createManagedObjectContexts]; RKEntityMapping categoryMapping = [RKEntityMapping mappingForEntityForName:@"Category" inManagedObjectStore:managedObjectStore]; [categoryMapping addAttributeMappingsFromDictionary:@{ "id": "categoryID", @"name": "name" }]; RKEntityMapping articleMapping = [RKEntityMapping mappingForEntityForName:@"Article" inManagedObjectStore:managedObjectStore]; [articleMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]]; [articleMapping addPropertyMapping:[RKRelationshipMapping relationshipMappingFromKeyPath:@"categories" toKeyPath:@"categories" withMapping:categoryMapping]]; NSIndexSet statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // Anything in 2xx RKResponseDescriptor responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:articleMapping method:RKRequestMethodAny pathPattern:@"/articles/:articleID" keyPath:@"article" statusCodes:statusCodes]; NSURLRequest request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://restkit.org/articles/888.json"]]; RKManagedObjectRequestOperation operation = [[RKManagedObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[responseDescriptor]]; operation.managedObjectContext = managedObjectStore.mainQueueManagedObjectContext; operation.managedObjectCache = managedObjectStore.managedObjectCache; [operation setCompletionBlockWithSuccess:^(RKObjectRequestOperation operation, RKMappingResult result) { Article article = [result firstObject]; NSLog(@"Mapped the article: %@", article); NSLog(@"Mapped the category: %@", [article.categories anyObject]); } failure:^(RKObjectRequestOperation operation, NSError error) { NSLog(@"Failed with error: %@", [error localizedDescription]); }]; NSOperationQueue operationQueue = [NSOperationQueue new]; [operationQueue addOperation:operation]; ``` Map a Client Error Response to an NSError ``` objective-c // GET /articles/error.json returns a 422 (Unprocessable Entity) // JSON looks like {"errors": "Some Error Has Occurred"} // You can map errors to any class, but RKErrorMessage is included for free RKObjectMapping *errorMapping = [RKObjectMapping mappingForClass:[RKErrorMessage class]]; // The entire value at the source key path containing the errors maps to the message [errorMapping addPropertyMapping:[RKAttributeMapping attributeMappingFromKeyPath:nil toKeyPath:@"errorMessage"]]; NSIndexSet statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassClientError); // Any response in the 4xx status code range with an "errors" key path uses this mapping RKResponseDescriptor errorDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:errorMapping method:RKRequestMethodAny pathPattern:nil keyPath:@"errors" statusCodes:statusCodes]; NSURLRequest request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://restkit.org/articles/error.json"]]; RKObjectRequestOperation operation = [[RKObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[errorDescriptor]]; [operation setCompletionBlockWithSuccess:nil failure:^(RKObjectRequestOperation operation, NSError error) { // The description method of the class the error is mapped to is used to construct the value of the localizedDescription NSLog(@"Loaded this error: %@", [error localizedDescription]); // You can access the model object used to construct the `NSError` via the `userInfo` RKErrorMessage *errorMessage = [[error.userInfo objectForKey:RKObjectMapperErrorObjectsKey] firstObject]; }]; ``` Centralize Configuration in an Object Manager ``` objective-c // Set up Article and Error Response Descriptors // Successful JSON looks like {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!"}} RKObjectMapping mapping = [RKObjectMapping mappingForClass:[Article class]]; [mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]]; NSIndexSet statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // Anything in 2xx RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/articles" keyPath:@"article" statusCodes:statusCodes]; // Error JSON looks like {"errors": "Some Error Has Occurred"} RKObjectMapping errorMapping = [RKObjectMapping mappingForClass:[RKErrorMessage class]]; // The entire value at the source key path containing the errors maps to the message [errorMapping addPropertyMapping:[RKAttributeMapping attributeMappingFromKeyPath:nil toKeyPath:@"errorMessage"]]; NSIndexSet statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassClientError); // Any response in the 4xx status code range with an "errors" key path uses this mapping RKResponseDescriptor *errorDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:errorMapping method:RKRequestMethodAny pathPattern:nil keyPath:@"errors" statusCodes:statusCodes]; // Add our descriptors to the manager RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://restkit.org"]]; [manager addResponseDescriptorsFromArray:@[ articleDescriptor, errorDescriptor ]]; [manager getObjectsAtPath:@"/articles/555.json" parameters:nil success:^(RKObjectRequestOperation operation, RKMappingResult mappingResult) { // Handled with articleDescriptor } failure:^(RKObjectRequestOperation operation, NSError error) { // Transport error or server error handled by errorDescriptor }]; ``` Configure Core Data Integration with the Object Manager ``` objective-c NSManagedObjectModel managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil]; RKManagedObjectStore managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel]; BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &error); if (! success) { RKLogError(@"Failed to create Application Data Directory at path %@: %@", RKApplicationDataDirectory(), error); } NSString path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"Store.sqlite"]; NSPersistentStore persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&error]; if (! persistentStore) { RKLogError(@"Failed adding persistent store at path %@: %@", path, error); } [managedObjectStore createManagedObjectContexts]; RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://restkit.org"]]; manager.managedObjectStore = managedObjectStore; ``` Load a Collection of Objects at a Path objective-c RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://restkit.org"]]; [manager getObjectsAtPath:@"/articles" parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) { } failure:^(RKObjectRequestOperation *operation, NSError *error) { }]; Manage a Queue of Object Request Operations ``` objective-c RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://restkit.org"]]; NSURLRequest request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://restkit.org/articles/1234.json"]]; RKObjectRequestOperation operation = [[RKObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[responseDescriptor]]; [manager enqueueObjectRequestOperation:operation]; [manager cancelAllObjectRequestOperationsWithMethod:RKRequestMethodANY matchingPathPattern:@"/articles/:articleID\.json"]; ``` POST, PATCH, and DELETE an Object ``` objective-c RKObjectMapping responseMapping = [RKObjectMapping mappingForClass:[Article class]]; [responseMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]]; NSIndexSet statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // Anything in 2xx RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:responseMapping method:RKRequestMethodAny pathPattern:@"/articles" keyPath:@"article" statusCodes:statusCodes]; RKObjectMapping *requestMapping = [RKObjectMapping requestMapping]; // objectClass == NSMutableDictionary [requestMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]]; // For any object of class Article, serialize into an NSMutableDictionary using the given mapping and nest // under the article key path RKRequestDescriptor *requestDescriptor = [RKRequestDescriptor requestDescriptorWithMapping:requestMapping objectClass:[Article class] rootKeyPath:@"article" method:RKRequestMethodAny]; RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://restkit.org"]]; [manager addRequestDescriptor:requestDescriptor]; [manager addResponseDescriptor:articleDescriptor]; Article *article = [Article new]; article.title = @"Introduction to RestKit"; article.body = @"This is some text."; article.author = @"Blake"; // POST to create [manager postObject:article path:@"/articles" parameters:nil success:nil failure:nil]; // PATCH to update article.body = @"New Body"; [manager patchObject:article path:@"/articles/1234" parameters:nil success:nil failure:nil]; // DELETE to destroy [manager deleteObject:article path:@"/articles/1234" parameters:nil success:nil failure:nil]; ``` Configure Logging ``` objective-c // Log all HTTP traffic with request and response bodies RKLogConfigureByName("RestKit/Network", RKLogLevelTrace); // Log debugging info about Core Data RKLogConfigureByName("RestKit/CoreData", RKLogLevelDebug); // Raise logging for a block RKLogWithLevelWhileExecutingBlock(RKLogLevelTrace, ^{ // Do something that generates logs }); ``` Configure Routing ``` objective-c RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://restkit.org"]]; // Class Routing [manager.router.routeSet addRoute:[RKRoute routeWithClass:[GGSegment class] pathPattern:@"/segments/:segmentID\.json" method:RKRequestMethodGET]]; // Relationship Routing [manager.router.routeSet addRoute:[RKRoute routeWithRelationshipName:@"amenities" objectClass:[GGAirport class] pathPattern:@"/airports/:airportID/amenities.json" method:RKRequestMethodGET]]; // Named Routes [manager.router.routeSet addRoute:[RKRoute routeWithName:@"thumbs_down_review" resourcePathPattern:@"/reviews/:reviewID/thumbs_down" method:RKRequestMethodPOST]]; ``` POST an Object with a File Attachment ``` objective-c Article article = [Article new]; UIImage image = [UIImage imageNamed:@"some_image.png"]; // Serialize the Article attributes then attach a file NSMutableURLRequest *request = [[RKObjectManager sharedManager] multipartFormRequestWithObject:article method:RKRequestMethodPOST path:nil parameters:nil constructingBodyWithBlock:^(id formData) { [formData appendPartWithFileData:UIImagePNGRepresentation(image) name:@"article[image]" fileName:@"photo.png" mimeType:@"image/png"]; }]; RKObjectRequestOperation *operation = [[RKObjectManager sharedManager] objectRequestOperationWithRequest:request success:nil failure:nil]; [[RKObjectManager sharedManager] enqueueObjectRequestOperation:operation]; // NOTE: Must be enqueued rather than started ``` Enqueue a Batch of Object Request Operations ``` objective-c RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://restkit.org"]]; Airport jfk = [Airport new]; jfk.code = @"jfk"; Airport lga = [Airport new]; lga.code = @"lga"; Airport *rdu = [Airport new]; rdu.code = @"rdu"; // Enqueue a GET for /airports/jfk/weather, /airports/lga/weather, /airports/rdu/weather RKRoute *route = [RKRoute routeWithName:@"airport_weather" resourcePathPattern:@"/airports/:code/weather" method:RKRequestMethodGET]; [manager enqueueBatchOfObjectRequestOperationsWithRoute:route objects:@[ jfk, lga, rdu] progress:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) { NSLog(@"Finished %d operations", numberOfFinishedOperations); } completion:^ (NSArray *operations) { NSLog(@"All Weather Reports Loaded!"); }]; ``` Generate a Seed Database ``` objective-c NSManagedObjectModel managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil]; RKManagedObjectStore managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel]; NSError error = nil; BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &error); if (! success) { RKLogError(@"Failed to create Application Data Directory at path %@: %@", RKApplicationDataDirectory(), error); } NSString path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"Store.sqlite"]; NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&error]; if (! persistentStore) { RKLogError(@"Failed adding persistent store at path %@: %@", path, error); } [managedObjectStore createManagedObjectContexts]; RKEntityMapping *articleMapping = [RKEntityMapping mappingForEntityForName:@"Article" inManagedObjectStore:managedObjectStore]; [articleMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]]; NSString seedPath = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"MySeedDatabase.sqlite"]; RKManagedObjectImporter importer = [[RKManagedObjectImporter alloc] initWithManagedObjectModel:managedObjectStore.managedObjectModel storePath:seedPath]; // Import the files "articles.json" from the Main Bundle using our RKEntityMapping // JSON looks like {"articles": [ {"title": "Article 1", "body": "Text", "author": "Blake" ]} NSError error; NSBundle mainBundle = [NSBundle mainBundle]; [importer importObjectsFromItemAtPath:[mainBundle pathForResource:@"articles" ofType:@"json"] withMapping:articleMapping keyPath:@"articles" error:&error]; BOOL success = [importer finishImporting:&error]; if (success) { [importer logSeedingInfo]; } ``` Index and Search an Entity ``` objective-c NSManagedObjectModel managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil]; RKManagedObjectStore managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel]; NSError error = nil; BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &error); if (! success) { RKLogError(@"Failed to create Application Data Directory at path %@: %@", RKApplicationDataDirectory(), error); } NSString path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"Store.sqlite"]; NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&error]; if (! persistentStore) { RKLogError(@"Failed adding persistent store at path %@: %@", path, error); } [managedObjectStore createManagedObjectContexts]; [managedObjectStore addSearchIndexingToEntityForName:@"Article" onAttributes:@[ @"title", @"body" ]]; [managedObjectStore addInMemoryPersistentStore:nil]; [managedObjectStore createManagedObjectContexts]; [managedObjectStore startIndexingPersistentStoreManagedObjectContext]; Article *article1 = [NSEntityDescription insertNewObjectForEntityForName:@"Article" inManagedObjectContext:managedObjectStore.mainQueueManagedObjectContext]; article1.title = @"First Article"; article1.body = "This should match search"; Article *article2 = [NSEntityDescription insertNewObjectForEntityForName:@"Article" inManagedObjectContext:managedObjectStore.mainQueueManagedObjectContext]; article2.title = @"Second Article"; article2.body = "Does not"; BOOL success = [managedObjectStore.mainQueueManagedObjectContext saveToPersistentStore:nil]; RKSearchPredicate predicate = [RKSearchPredicate searchPredicateWithText:@"Match" type:NSAndPredicateType]; NSFetchRequest fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Article"]; fetchRequest.predicate = predicate; // Contains article1 due to body text containing match NSArray *matches = [managedObjectStore.mainQueueManagedObjectContext executeFetchRequest:fetchRequest error:nil]; NSLog(@"Found the matching articles: %@", matches); ``` Unit Test a Mapping ``` objective-c // JSON looks like {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!"}} RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]]; [mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]]; NSDictionary article = @{ @"article": @{ @"title": @"My Title", @"body": @"The article body", @"author": @"Blake" } }; RKMappingTest mappingTest = [[RKMappingTest alloc] initWithMapping:mapping sourceObject:article destinationObject:nil]; [mappingTest expectMappingFromKeyPath:@"title" toKeyPath:@"title" value:@"My Title"]; [mappingTest performMapping]; [mappingTest verify]; ``` Requirements RestKit requires iOS 8.0 and above or Mac OS X 10.9 and above. Several third-party open source libraries are used within RestKit, including: AFNetworking - Networking Support LibComponentLogging - Logging Support SOCKit - String <-> Object Coding iso8601parser - Support for parsing and generating ISO-8601 dates The following Cocoa frameworks must be linked into the application target for proper compilation: CFNetwork.framework on iOS CoreData.framework Security.framework MobileCoreServices.framework on iOS or CoreServices.framework on OS X And the following linker flags must be set: -ObjC -all_load ARC As of version 0.20.0, RestKit has migrated the entire codebase to ARC. If you are including the RestKit sources directly into a project that does not yet use Automatic Reference Counting, you will need to set the -fobjc-arc compiler flag on all of the RestKit source files. To do this in Xcode, go to your active target and select the "Build Phases" tab. Now select all RestKit source files, press Enter, insert -fobjc-arc and then "Done" to enable ARC for RestKit. Serialization Formats RestKit provides a pluggable interface for handling arbitrary serialization formats via the RKSerialization protocol and the RKMIMETypeSerialization class. Out of the box, RestKit supports handling the JSON format for serializing and deserializing object representations via the NSJSONSerialization class. Additional Serializations Support for additional formats and alternate serialization backends is provided via external modules that can be added to the project. Currently the following serialization implementations are available for use: JSONKit SBJSON YAJL NextiveJson XMLReader + XMLWriter Installation The recommended approach for installing RestKit is via the CocoaPods package manager, as it provides flexible dependency management and dead simple installation. For best results, it is recommended that you install via CocoaPods >= 0.19.1 using Git >= 1.8.0 installed via Homebrew. via CocoaPods Install CocoaPods if not already available: bash $ [sudo] gem install cocoapods $ pod setup Change to the directory of your Xcode project, and Create and Edit your Podfile and add RestKit: ``` bash $ cd /path/to/MyProject $ touch Podfile $ edit Podfile target "YOUR PROJECT" do platform :ios, 7.0 # Or platform :osx, 10.7 pod RestKit, ~> 0.24.0 end Testing and Search are optional components pod RestKit/Testing, ~> 0.24.0 pod RestKit/Search, ~> 0.24.0 ``` Install into your project: bash $ pod install Open your project in Xcode from the .xcworkspace file (not the usual project file) bash $ open MyProject.xcworkspace Please note that if your installation fails, it may be because you are installing with a version of Git lower than CocoaPods is expecting. Please ensure that you are running Git >= 1.8.0 by executing git --version. You can get a full picture of the installation details by executing pod install --verbose. From a Release Package or as a Git submodule Detailed installation instructions are available in the Visual Install Guide on the Wiki. Using RestKit in a Swift Project Install RestKit using one of the above methods. Then add @import RestKit; (if RestKit is built as a dynamic framework) or #import <RestKit/RestKit.h> (if RestKit is built as a static library) into the bridging header for your Swift project. To enable the Core Data functionality in RestKit, add @import CoreData; into your bridging header before you import RestKit. License RestKit is licensed under the terms of the Apache License, version 2.0. Please see the LICENSE file for full details. Credits RestKit is brought to you by Blake Watters and the RestKit team. Support is provided by the following organizations: GateGuru Two Toasters