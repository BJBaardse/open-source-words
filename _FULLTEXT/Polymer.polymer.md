Polymer ‚ÑπÔ∏è Note: This is the current stable version of the Polymer library. At Google I/O 2018 we announced a new Web Component base class, LitElement, as a successor to the PolymerElement base class in this library. If youre starting a new project, we recommend that you consider using LitElement instead. If you have a project youve built with an earlier version of the Polymer library, we recommend that you migrate to 3.0 for best compatibility with the JavaScript ecosystem. Thanks to the interoperability of Web Components, elements built with Polymer 3.0 and LitElement can be mixed and matched in the same app, so once you have updated your project to Polymer 3.0, you can migrate to LitElement incrementally, one element at a time. See our blog post on the Polymer Project roadmap for more information. Polymer lets you build encapsulated, reusable Web Components that work just like standard HTML elements, to use in building web applications. Using a Web Component built with Polymer is as simple as importing its definition then using it like any other HTML element: ```html Import a component Use it like any other HTML element Web Components! ``` Web Components are now implemented natively on Safari and Chrome (~70% of installed browsers), and run well on Firefox, Edge, and IE11 using polyfills. Read more below. Getting started The easiest way to try out Polymer is to use one of these online tools: Runs in all supported browsers: StackBlitz, Glitch Runs in browsers with JavaScript Modules: JSBin, CodePen. You can also save this HTML file to a local file and run it in any browser that supports JavaScript Modules. When youre ready to use Polymer in a project, install it via npm. To run the project in the browser, a module-compatible toolchain is required. We recommend installing the Polymer CLI to and using its development server as follows. Add Polymer to your project: npm i @polymer/polymer Create an element by extending PolymerElement and calling customElements.define with your class (see the examples below). Install the Polymer CLI: npm i -g polymer-cli Run the development server and open a browser pointing to its URL: polymer serve --npm Polymer 3.0 is published on npm using JavaScript Modules. This means it can take advantage of the standard native JavaScript module loader available in all current major browsers. However, since Polymer uses npm conventions to reference dependencies by name, a light transform to rewrite specifiers to URLs is required to run in the browser. The polymer-clis development server polymer serve, as well as polymer build (for building an optimized app for deployment) automatically handles this transform. Tools like webpack and Rollup can also be used to serve and/or bundle Polymer elements. Minimal Example Create a class that extends PolymerElement. Implement a static properties getter that describes the elements public property/attribute API (these automatically become observed attributes). Then implement a template getter that returns an HTMLTemplateElement describing the elements rendering, including encapsulated styling and any property bindings. ```html import {PolymerElement, html} from @polymer/polymer;</p> <pre><code>class MyElement extends PolymerElement { static get properties() { return { mood: String }} static get template() { return html` &lt;style&gt; .mood { color: green; } &lt;/style&gt; Web Components are &lt;span class="mood"&gt;[[mood]]&lt;/span&gt;! `; } } customElements.define(my-element, MyElement); </code></pre> ``` Overview Web components are an incredibly powerful new set of primitives baked into the web platform, and open up a whole new world of possibility when it comes to componentizing front-end code and easily creating powerful, immersive, app-like experiences on the web. Polymer is a lightweight library built on top of the web standards-based Web Components APIs, and makes it easier to build your very own custom HTML elements. Creating reusable custom elements - and using elements built by others - can make building complex web applications easier and more efficient. By being based on the Web Components APIs built in the browser (or polyfilled where needed), elements built with Polymer are: Built from the platform up Self-contained Re-usable Interoperable across frameworks Among many ways to leverage custom elements, they can be particularly useful for building reusable UI components. Instead of continually re-building a specific navigation bar or button in different frameworks and for different projects, you can define this element once using Polymer, and then reuse it throughout your project or in any future project. Polymer provides a declarative syntax to easily create your own custom elements, using all standard web technologies - define the structure of the element with HTML, style it with CSS, and add interactions to the element with JavaScript. Polymer also provides optional two-way data-binding, meaning: When properties in the model for an element get updated, the element can update itself in response. When the element is updated internally, the changes can be propagated back to the model. Polymer is designed to be flexible, lightweight, and close to the web platform - the library doesnt invent complex new abstractions and magic, but uses the best features of the web platform in straightforward ways to simply sugar the creation of custom elements. About Polymer 3.0 Polymer 3.0 is now released to stable, and introduces a major change to how Polymer is distributed: from HTML Imports on Bower, to JS modules on npm. Otherwise, the API is almost entirely backward compatible with Polymer 2.0 (the only changes are removing APIs related to HTML Imports like importHref, and converting Polymers API to be module-based rather than globals-based). Migrating to Polymer 3.0 by hand is mostly mechanical: Components should be defined in JS modules instead of in HTML Templates should be encoded in JS modules using a static get template() getter on PolymerElement subclasses using the html tagged template literal function (which parses HTMLTemplateElements out of strings in JS) rather than using <template> elements in a <dom-module> * All dependencies should be imported JS module imports rather than HTML Imports. However, the polymer-modulizer tool automates the vast majority of this migration work. Please see details on that repo for automated conversion of Polymer 2.0 apps and elements to Polymer 3.0. üëÄ Looking for Polymer v2.x? Please see the the v2 branch. üëÄ Looking for Polymer v1.x? Please see the the v1 branch. Contributing The Polymer team loves contributions from the community! Take a look at our contributing guide for more information on how to contribute. Please file issues on the Polymer issue tracker following the issue template and contributing guide issues. Communicating with the Polymer team Beyond GitHub, we try to have a variety of different lines of communication available: Blog Twitter Google+ community Mailing list Slack channel License The Polymer library uses a BSD-like license that is available here