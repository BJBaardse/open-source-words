clean code javascript table of contents introduction variables functions objects and data structures classes solid testing concurrency error handling formatting comments translation introduction software engineering principles from robert c martins book clean code adapted for javascript this is not a style guide its a guide to producing readable reusable and refactorable software in javascript not every principle herein has to be strictly followed and even fewer will be universally agreed upon these are guidelines and nothing more but they are ones codified over many years of collective experience by the authors of clean code our craft of software engineering is just a bit over 50 years old and we are still learning a lot when software architecture is as old as architecture itself maybe then we will have harder rules to follow for now let these guidelines serve as a touchstone by which to assess the quality of the javascript code that you and your team produce one more thing knowing these wont immediately make you a better software developer and working with them for many years doesnt mean you wont make mistakes every piece of code starts as a first draft like wet clay getting shaped into its final form finally we chisel away the imperfections when we review it with our peers dont beat yourself up for first drafts that need improvement beat up the code instead variables use meaningful and pronounceable variable names bad javascript const yyyymmdstr moment format yyyy mm dd good javascript const currentdate moment format yyyy mm dd ⬆ back to top use the same vocabulary for the same type of variable bad javascript getuserinfo getclientdata getcustomerrecord good javascript getuser ⬆ back to top use searchable names we will read more code than we will ever write its important that the code we do write is readable and searchable by not naming variables that end up being meaningful for understanding our program we hurt our readers make your names searchable tools like buddy js and eslint can help identify unnamed constants bad javascript what the heck is 86400000 for settimeout blastoff 86400000 good javascript declare them as capitalized named constants const milliseconds in a day 86400000 settimeout blastoff milliseconds in a day ⬆ back to top use explanatory variables bad javascript const address one infinite loop cupertino 95014 const cityzipcoderegex \ \\s \s \d 5 savecityzipcode address match cityzipcoderegex 1 address match cityzipcoderegex 2 good javascript const address one infinite loop cupertino 95014 const cityzipcoderegex \ \\s \s \d 5 const city zipcode address match cityzipcoderegex savecityzipcode city zipcode ⬆ back to top avoid mental mapping explicit is better than implicit bad javascript const locations austin new york san francisco locations foreach l dostuff dosomeotherstuff wait what is l for again dispatch l good javascript const locations austin new york san francisco locations foreach location dostuff dosomeotherstuff dispatch location ⬆ back to top dont add unneeded context if your class object name tells you something dont repeat that in your variable name bad javascript const car carmake honda carmodel accord carcolor blue function paintcar car car carcolor red good javascript const car make honda model accord color blue function paintcar car car color red ⬆ back to top use default arguments instead of short circuiting or conditionals default arguments are often cleaner than short circuiting be aware that if you use them your function will only provide default values for undefined arguments other falsy values such as false null 0 andnan will not be replaced by a default value bad javascript function createmicrobrewery name const breweryname name hipster brew co good javascript function createmicrobrewery name hipster brew co ⬆ back to top functions function arguments 2 or fewer ideally limiting the amount of function parameters is incredibly important because it makes testing your function easier having more than three leads to a combinatorial explosion where you have to test tons of different cases with each separate argument one or two arguments is the ideal case and three should be avoided if possible anything more than that should be consolidated usually if you have more than two arguments then your function is trying to do too much in cases where its not most of the time a higher level object will suffice as an argument since javascript allows you to make objects on the fly without a lot of class boilerplate you can use an object if you are finding yourself needing a lot of arguments to make it obvious what properties the function expects you can use the es2015 es6 destructuring syntax this has a few advantages when someone looks at the function signature its immediately clear what properties are being used destructuring also clones the specified primitive values of the argument object passed into the function this can help prevent side effects note objects and arrays that are destructured from the argument object are not cloned linters can warn you about unused properties which would be impossible without destructuring bad javascript function createmenu title body buttontext cancellable good javascript function createmenu title body buttontext cancellable createmenu title foo body bar buttontext baz cancellable true ⬆ back to top functions should do one thing this is by far the most important rule in software engineering when functions do more than one thing they are harder to compose test and reason about when you can isolate a function to just one action they can be refactored easily and your code will read much cleaner if you take nothing else away from this guide other than this youll be ahead of many developers bad javascript function emailclients clients clients foreach client const clientrecord database lookup client if clientrecord isactive email client good javascript function emailactiveclients clients clients filter isactiveclient foreach email function isactiveclient client const clientrecord database lookup client return clientrecord isactive ⬆ back to top function names should say what they do bad javascript function addtodate date month const date new date its hard to tell from the function name what is added addtodate date 1 good javascript function addmonthtodate month date const date new date addmonthtodate 1 date ⬆ back to top functions should only be one level of abstraction when you have more than one level of abstraction your function is usually doing too much splitting up functions leads to reusability and easier testing bad javascript function parsebetterjsalternative code const regexes const statements code split const tokens regexes foreach regex statements foreach statement const ast tokens foreach token lex ast foreach node parse good javascript function parsebetterjsalternative code const tokens tokenize code const ast lexer tokens ast foreach node parse function tokenize code const regexes const statements code split const tokens regexes foreach regex statements foreach statement tokens push return tokens function lexer tokens const ast tokens foreach token ast push return ast ⬆ back to top remove duplicate code do your absolute best to avoid duplicate code duplicate code is bad because it means that theres more than one place to alter something if you need to change some logic imagine if you run a restaurant and you keep track of your inventory all your tomatoes onions garlic spices etc if you have multiple lists that you keep this on then all have to be updated when you serve a dish with tomatoes in them if you only have one list theres only one place to update oftentimes you have duplicate code because you have two or more slightly different things that share a lot in common but their differences force you to have two or more separate functions that do much of the same things removing duplicate code means creating an abstraction that can handle this set of different things with just one function module class getting the abstraction right is critical thats why you should follow the solid principles laid out in the classes section bad abstractions can be worse than duplicate code so be careful having said this if you can make a good abstraction do it dont repeat yourself otherwise youll find yourself updating multiple places anytime you want to change one thing bad javascript function showdeveloperlist developers developers foreach developer const expectedsalary developer calculateexpectedsalary const experience developer getexperience const githublink developer getgithublink const data expectedsalary experience githublink render data function showmanagerlist managers managers foreach manager const expectedsalary manager calculateexpectedsalary const experience manager getexperience const portfolio manager getmbaprojects const data expectedsalary experience portfolio render data good javascript function showemployeelist employees employees foreach employee const expectedsalary employee calculateexpectedsalary const experience employee getexperience const data expectedsalary experience switch employee type case manager data portfolio employee getmbaprojects break case developer data githublink employee getgithublink break render data ⬆ back to top set default objects with object assign bad javascript const menuconfig title null body bar buttontext null cancellable true function createmenu config config title config title foo config body config body bar config buttontext config buttontext baz config cancellable config cancellable undefined config cancellable true createmenu menuconfig good javascript const menuconfig title order user did not include body key buttontext send cancellable true function createmenu config config object assign title foo body bar buttontext baz cancellable true config config now equals title order body bar buttontext send cancellable true createmenu menuconfig ⬆ back to top dont use flags as function parameters flags tell your user that this function does more than one thing functions should do one thing split out your functions if they are following different code paths based on a boolean bad javascript function createfile name temp if temp fs create temp name else fs create name good javascript function createfile name fs create name function createtempfile name createfile temp name ⬆ back to top avoid side effects part 1 a function produces a side effect if it does anything other than take a value in and return another value or values a side effect could be writing to a file modifying some global variable or accidentally wiring all your money to a stranger now you do need to have side effects in a program on occasion like the previous example you might need to write to a file what you want to do is to centralize where you are doing this dont have several functions and classes that write to a particular file have one service that does it one and only one the main point is to avoid common pitfalls like sharing state between objects without any structure using mutable data types that can be written to by anything and not centralizing where your side effects occur if you can do this you will be happier than the vast majority of other programmers bad javascript global variable referenced by following function if we had another function that used this name now itd be an array and it could break it let name ryan mcdermott function splitintofirstandlastname name name split splitintofirstandlastname console log name ryan mcdermott good javascript function splitintofirstandlastname name return name split const name ryan mcdermott const newname splitintofirstandlastname name console log name ryan mcdermott console log newname ryan mcdermott ⬆ back to top avoid side effects part 2 in javascript primitives are passed by value and objects arrays are passed by reference in the case of objects and arrays if your function makes a change in a shopping cart array for example by adding an item to purchase then any other function that uses that cart array will be affected by this addition that may be great however it can be bad too lets imagine a bad situation the user clicks the purchase button which calls a purchase function that spawns a network request and sends the cart array to the server because of a bad network connection the purchase function has to keep retrying the request now what if in the meantime the user accidentally clicks add to cart button on an item they dont actually want before the network request begins if that happens and the network request begins then that purchase function will send the accidentally added item because it has a reference to a shopping cart array that the additemtocart function modified by adding an unwanted item a great solution would be for the additemtocart to always clone the cart edit it and return the clone this ensures that no other functions that are holding onto a reference of the shopping cart will be affected by any changes two caveats to mention to this approach 1 there might be cases where you actually want to modify the input object but when you adopt this programming practice you will find that those cases are pretty rare most things can be refactored to have no side effects cloning big objects can be very expensive in terms of performance luckily this isnt a big issue in practice because there are great libraries that allow this kind of programming approach to be fast and not as memory intensive as it would be for you to manually clone objects and arrays bad javascript const additemtocart cart item cart push item date date now good javascript const additemtocart cart item return cart item date date now ⬆ back to top dont write to global functions polluting globals is a bad practice in javascript because you could clash with another library and the user of your api would be none the wiser until they get an exception in production lets think about an example what if you wanted to extend javascripts native array method to have a diff method that could show the difference between two arrays you could write your new function to the array prototype but it could clash with another library that tried to do the same thing what if that other library was just using diff to find the difference between the first and last elements of an array this is why it would be much better to just use es2015 es6 classes and simply extend the array global bad javascript array prototype diff function diff comparisonarray const hash new set comparisonarray return this filter elem hash has elem good javascript class superarray extends array diff comparisonarray const hash new set comparisonarray return this filter elem hash has elem ⬆ back to top favor functional programming over imperative programming javascript isnt a functional language in the way that haskell is but it has a functional flavor to it functional languages can be cleaner and easier to test favor this style of programming when you can bad javascript const programmeroutput name uncle bobby linesofcode 500 name suzie q linesofcode 1500 name jimmy gosling linesofcode 150 name gracie hopper linesofcode 1000 let totaloutput 0 for let i 0 i programmeroutput length i totaloutput programmeroutput i linesofcode good javascript const programmeroutput name uncle bobby linesofcode 500 name suzie q linesofcode 1500 name jimmy gosling linesofcode 150 name gracie hopper linesofcode 1000 const totaloutput programmeroutput map output output linesofcode reduce totallines lines totallines lines ⬆ back to top encapsulate conditionals bad javascript if fsm state fetching isempty listnode good javascript function shouldshowspinner fsm listnode return fsm state fetching isempty listnode if shouldshowspinner fsminstance listnodeinstance ⬆ back to top avoid negative conditionals bad javascript function isdomnodenotpresent node if isdomnodenotpresent node good javascript function isdomnodepresent node if isdomnodepresent node ⬆ back to top avoid conditionals this seems like an impossible task upon first hearing this most people say how am i supposed to do anything without an if statement the answer is that you can use polymorphism to achieve the same task in many cases the second question is usually well thats great but why would i want to do that the answer is a previous clean code concept we learned a function should only do one thing when you have classes and functions that have if statements you are telling your user that your function does more than one thing remember just do one thing bad javascript class airplane getcruisingaltitude switch this type case 777 return this getmaxaltitude this getpassengercount case air force one return this getmaxaltitude case cessna return this getmaxaltitude this getfuelexpenditure good javascript class airplane class boeing777 extends airplane getcruisingaltitude return this getmaxaltitude this getpassengercount class airforceone extends airplane getcruisingaltitude return this getmaxaltitude class cessna extends airplane getcruisingaltitude return this getmaxaltitude this getfuelexpenditure ⬆ back to top avoid type checking part 1 javascript is untyped which means your functions can take any type of argument sometimes you are bitten by this freedom and it becomes tempting to do type checking in your functions there are many ways to avoid having to do this the first thing to consider is consistent apis bad javascript function traveltotexas vehicle if vehicle instanceof bicycle vehicle pedal this currentlocation new location texas else if vehicle instanceof car vehicle drive this currentlocation new location texas good javascript function traveltotexas vehicle vehicle move this currentlocation new location texas ⬆ back to top avoid type checking part 2 if you are working with basic primitive values like strings and integers and you cant use polymorphism but you still feel the need to type check you should consider using typescript it is an excellent alternative to normal javascript as it provides you with static typing on top of standard javascript syntax the problem with manually type checking normal javascript is that doing it well requires so much extra verbiage that the faux type safety you get doesnt make up for the lost readability keep your javascript clean write good tests and have good code reviews otherwise do all of that but with typescript which like i said is a great alternative bad javascript function combine val1 val2 if typeof val1 number typeof val2 number typeof val1 string typeof val2 string return val1 val2 throw new error must be of type string or number good javascript function combine val1 val2 return val1 val2 ⬆ back to top dont over optimize modern browsers do a lot of optimization under the hood at runtime a lot of times if you are optimizing then you are just wasting your time there are good resources for seeing where optimization is lacking target those in the meantime until they are fixed if they can be bad javascript on old browsers each iteration with uncached list length would be costly because of list length recomputation in modern browsers this is optimized for let i 0 len list length i len i good javascript for let i 0 i list length i ⬆ back to top remove dead code dead code is just as bad as duplicate code theres no reason to keep it in your codebase if its not being called get rid of it it will still be safe in your version history if you still need it bad javascript function oldrequestmodule url function newrequestmodule url const req newrequestmodule inventorytracker apples req www inventory awesome io good javascript function newrequestmodule url const req newrequestmodule inventorytracker apples req www inventory awesome io ⬆ back to top objects and data structures use getters and setters using getters and setters to access data on objects could be better than simply looking for a property on an object why you might ask well heres an unorganized list of reasons why when you want to do more beyond getting an object property you dont have to look up and change every accessor in your codebase makes adding validation simple when doing a set encapsulates the internal representation easy to add logging and error handling when getting and setting you can lazy load your objects properties lets say getting it from a server bad javascript function makebankaccount return balance 0 const account makebankaccount account balance 100 good javascript function makebankaccount this one is private let balance 0 a getter made public via the returned object below function getbalance return balance a setter made public via the returned object below function setbalance amount validate before updating the balance balance amount return getbalance setbalance const account makebankaccount account setbalance 100 ⬆ back to top make objects have private members this can be accomplished through closures for es5 and below bad javascript const employee function name this name name employee prototype getname function getname return this name const employee new employee john doe console log employee name employee getname employee name john doe delete employee name console log employee name employee getname employee name undefined good javascript function makeemployee name return getname return name const employee makeemployee john doe console log employee name employee getname employee name john doe delete employee name console log employee name employee getname employee name john doe ⬆ back to top classes prefer es2015 es6 classes over es5 plain functions its very difficult to get readable class inheritance construction and method definitions for classical es5 classes if you need inheritance and be aware that you might not then prefer es2015 es6 classes however prefer small functions over classes until you find yourself needing larger and more complex objects bad javascript const animal function age if this instanceof animal throw new error instantiate animal withnew this age age animal prototype move function move const mammal function age furcolor if this instanceof mammal throw new error instantiate mammal with new animal call this age this furcolor furcolor mammal prototype object create animal prototype mammal prototype constructor mammal mammal prototype livebirth function livebirth const human function age furcolor languagespoken if this instanceof human throw new error instantiate human with new mammal call this age furcolor this languagespoken languagespoken human prototype object create mammal prototype human prototype constructor human human prototype speak function speak good javascript class animal constructor age this age age move class mammal extends animal constructor age furcolor super age this furcolor furcolor livebirth class human extends mammal constructor age furcolor languagespoken super age furcolor this languagespoken languagespoken speak ⬆ back to top use method chaining this pattern is very useful in javascript and you see it in many libraries such as jquery and lodash it allows your code to be expressive and less verbose for that reason i say use method chaining and take a look at how clean your code will be in your class functions simply return this at the end of every function and you can chain further class methods onto it bad javascript class car constructor make model color this make make this model model this color color setmake make this make make setmodel model this model model setcolor color this color color save console log this make this model this color const car new car ford f 150 red car setcolor pink car save good javascript class car constructor make model color this make make this model model this color color setmake make this make make note returning this for chaining return this setmodel model this model model note returning this for chaining return this setcolor color this color color note returning this for chaining return this save console log this make this model this color note returning this for chaining return this const car new car ford f 150 red setcolor pink save ⬆ back to top prefer composition over inheritance as stated famously in design patterns by the gang of four you should prefer composition over inheritance where you can there are lots of good reasons to use inheritance and lots of good reasons to use composition the main point for this maxim is that if your mind instinctively goes for inheritance try to think if composition could model your problem better in some cases it can you might be wondering then when should i use inheritance it depends on your problem at hand but this is a decent list of when inheritance makes more sense than composition your inheritance represents an is a relationship and not a has a relationship human animal vs user userdetails you can reuse code from the base classes humans can move like all animals you want to make global changes to derived classes by changing a base class change the caloric expenditure of all animals when they move bad javascript class employee constructor name email this name name this email email bad because employees have tax data employeetaxdata is not a type of employee class employeetaxdata extends employee constructor ssn salary super this ssn ssn this salary salary good javascript class employeetaxdata constructor ssn salary this ssn ssn this salary salary class employee constructor name email this name name this email email settaxdata ssn salary this taxdata new employeetaxdata ssn salary ⬆ back to top solid single responsibility principle srp as stated in clean code there should never be more than one reason for a class to change its tempting to jam pack a class with a lot of functionality like when you can only take one suitcase on your flight the issue with this is that your class wont be conceptually cohesive and it will give it many reasons to change minimizing the amount of times you need to change a class is important its important because if too much functionality is in one class and you modify a piece of it it can be difficult to understand how that will affect other dependent modules in your codebase bad javascript class usersettings constructor user this user user changesettings settings if this verifycredentials verifycredentials good javascript class userauth constructor user this user user verifycredentials class usersettings constructor user this user user this auth new userauth user changesettings settings if this auth verifycredentials ⬆ back to top open closed principle ocp as stated by bertrand meyer software entities classes modules functions etc should be open for extension but closed for modification what does that mean though this principle basically states that you should allow users to add new functionalities without changing existing code bad javascript class ajaxadapter extends adapter constructor super this name ajaxadapter class nodeadapter extends adapter constructor super this name nodeadapter class httprequester constructor adapter this adapter adapter fetch url if this adapter name ajaxadapter return makeajaxcall url then response transform response and return else if this adapter name httpnodeadapter return makehttpcall url then response transform response and return function makeajaxcall url request and return promise function makehttpcall url request and return promise good javascript class ajaxadapter extends adapter constructor super this name ajaxadapter request url request and return promise class nodeadapter extends adapter constructor super this name nodeadapter request url request and return promise class httprequester constructor adapter this adapter adapter fetch url return this adapter request url then response transform response and return ⬆ back to top liskov substitution principle lsp this is a scary term for a very simple concept its formally defined as if s is a subtype of t then objects of type t may be replaced with objects of type s i e objects of type s may substitute objects of type t without altering any of the desirable properties of that program correctness task performed etc thats an even scarier definition the best explanation for this is if you have a parent class and a child class then the base class and child class can be used interchangeably without getting incorrect results this might still be confusing so lets take a look at the classic square rectangle example mathematically a square is a rectangle but if you model it using the is a relationship via inheritance you quickly get into trouble bad javascript class rectangle constructor this width 0 this height 0 setcolor color render area setwidth width this width width setheight height this height height getarea return this width this height class square extends rectangle setwidth width this width width this height width setheight height this width height this height height function renderlargerectangles rectangles rectangles foreach rectangle rectangle setwidth 4 rectangle setheight 5 const area rectangle getarea bad returns 25 for square should be 20 rectangle render area const rectangles new rectangle new rectangle new square renderlargerectangles rectangles good javascript class shape setcolor color render area class rectangle extends shape constructor width height super this width width this height height getarea return this width this height class square extends shape constructor length super this length length getarea return this length this length function renderlargeshapes shapes shapes foreach shape const area shape getarea shape render area const shapes new rectangle 4 5 new rectangle 4 5 new square 5 renderlargeshapes shapes ⬆ back to top interface segregation principle isp javascript doesnt have interfaces so this principle doesnt apply as strictly as others however its important and relevant even with javascripts lack of type system isp states that clients should not be forced to depend upon interfaces that they do not use interfaces are implicit contracts in javascript because of duck typing a good example to look at that demonstrates this principle in javascript is for classes that require large settings objects not requiring clients to setup huge amounts of options is beneficial because most of the time they wont need all of the settings making them optional helps prevent having a fat interface bad javascript class domtraverser constructor settings this settings settings this setup setup this rootnode this settings rootnode this animationmodule setup traverse const new domtraverser rootnode document getelementsbytagname body animationmodule most of the time we wont need to animate when traversing good javascript class domtraverser constructor settings this settings settings this options settings options this setup setup this rootnode this settings rootnode this setupoptions setupoptions if this options animationmodule traverse const new domtraverser rootnode document getelementsbytagname body options animationmodule ⬆ back to top dependency inversion principle dip this principle states two essential things 1 high level modules should not depend on low level modules both should depend on abstractions 2 abstractions should not depend upon details details should depend on abstractions this can be hard to understand at first but if youve worked with angularjs youve seen an implementation of this principle in the form of dependency injection di while they are not identical concepts dip keeps high level modules from knowing the details of its low level modules and setting them up it can accomplish this through di a huge benefit of this is that it reduces the coupling between modules coupling is a very bad development pattern because it makes your code hard to refactor as stated previously javascript doesnt have interfaces so the abstractions that are depended upon are implicit contracts that is to say the methods and properties that an object class exposes to another object class in the example below the implicit contract is that any request module for an inventorytracker will have a requestitems method bad javascript class inventoryrequester constructor this req methods http requestitem item class inventorytracker constructor items this items items bad we have created a dependency on a specific request implementation we should just have requestitems depend on a request method request this requester new inventoryrequester requestitems this items foreach item this requester requestitem item const inventorytracker new inventorytracker apples bananas inventorytracker requestitems good javascript class inventorytracker constructor items requester this items items this requester requester requestitems this items foreach item this requester requestitem item class inventoryrequesterv1 constructor this req methods http requestitem item class inventoryrequesterv2 constructor this req methods ws requestitem item by constructing our dependencies externally and injecting them we can easily substitute our request module for a fancy new one that uses websockets const inventorytracker new inventorytracker apples bananas new inventoryrequesterv2 inventorytracker requestitems ⬆ back to top testing testing is more important than shipping if you have no tests or an inadequate amount then every time you ship code you wont be sure that you didnt break anything deciding on what constitutes an adequate amount is up to your team but having 100 coverage all statements and branches is how you achieve very high confidence and developer peace of mind this means that in addition to having a great testing framework you also need to use a good coverage tool theres no excuse to not write tests there are plenty of good js test frameworks so find one that your team prefers when you find one that works for your team then aim to always write tests for every new feature module you introduce if your preferred method is test driven development tdd that is great but the main point is to just make sure you are reaching your coverage goals before launching any feature or refactoring an existing one single concept per test bad javascript import assert from assert describe makemomentjsgreatagain it handles date boundaries let date date new makemomentjsgreatagain 1 1 2015 date adddays 30 assert equal 1 31 2015 date date new makemomentjsgreatagain 2 1 2016 date adddays 28 assert equal 02 29 2016 date date new makemomentjsgreatagain 2 1 2015 date adddays 28 assert equal 03 01 2015 date good javascript import assert from assert describe makemomentjsgreatagain it handles 30 day months const date new makemomentjsgreatagain 1 1 2015 date adddays 30 assert equal 1 31 2015 date it handles leap year const date new makemomentjsgreatagain 2 1 2016 date adddays 28 assert equal 02 29 2016 date it handles non leap year const date new makemomentjsgreatagain 2 1 2015 date adddays 28 assert equal 03 01 2015 date ⬆ back to top concurrency use promises not callbacks callbacks arent clean and they cause excessive amounts of nesting with es2015 es6 promises are a built in global type use them bad javascript import get from request import writefile from fs get https en wikipedia org wiki robert cecil martin requesterr response if requesterr console error requesterr else writefile article html response body writeerr if writeerr console error writeerr else console log file written good javascript import get from request import writefile from fs get https en wikipedia org wiki robert cecil martin then response return writefile article html response then console log file written catch err console error err ⬆ back to top async await are even cleaner than promises promises are a very clean alternative to callbacks but es2017 es8 brings async and await which offer an even cleaner solution all you need is a function that is prefixed in an async keyword and then you can write your logic imperatively without a then chain of functions use this if you can take advantage of es2017 es8 features today bad javascript import get from request promise import writefile from fs promise get https en wikipedia org wiki robert cecil martin then response return writefile article html response then console log file written catch err console error err good javascript import get from request promise import writefile from fs promise async function getcleancodearticle try const response await get https en wikipedia org wiki robert cecil martin await writefile article html response console log file written catch err console error err ⬆ back to top error handling thrown errors are a good thing they mean the runtime has successfully identified when something in your program has gone wrong and its letting you know by stopping function execution on the current stack killing the process in node and notifying you in the console with a stack trace dont ignore caught errors doing nothing with a caught error doesnt give you the ability to ever fix or react to said error logging the error to the console console log isnt much better as often times it can get lost in a sea of things printed to the console if you wrap any bit of code in a try catch it means you think an error may occur there and therefore you should have a plan or create a code path for when it occurs bad javascript try functionthatmightthrow catch error console log error good javascript try functionthatmightthrow catch error one option more noisy than console log console error error another option notifyuseroferror error another option reporterrortoservice error or do all three dont ignore rejected promises for the same reason you shouldnt ignore caught errors from try catch bad javascript getdata then data functionthatmightthrow data catch error console log error good javascript getdata then data functionthatmightthrow data catch error one option more noisy than console log console error error another option notifyuseroferror error another option reporterrortoservice error or do all three ⬆ back to top formatting formatting is subjective like many rules herein there is no hard and fast rule that you must follow the main point is do not argue over formatting there are tons of tools to automate this use one its a waste of time and money for engineers to argue over formatting for things that dont fall under the purview of automatic formatting indentation tabs vs spaces double vs single quotes etc look here for some guidance use consistent capitalization javascript is untyped so capitalization tells you a lot about your variables functions etc these rules are subjective so your team can choose whatever they want the point is no matter what you all choose just be consistent bad javascript const days in week 7 const daysinmonth 30 const songs back in black stairway to heaven hey jude const artists acdc led zeppelin the beatles function erasedatabase function restore database class animal class alpaca good javascript const days in week 7 const days in month 30 const songs back in black stairway to heaven hey jude const artists acdc led zeppelin the beatles function erasedatabase function restoredatabase class animal class alpaca ⬆ back to top function callers and callees should be close if a function calls another keep those functions vertically close in the source file ideally keep the caller right above the callee we tend to read code from top to bottom like a newspaper because of this make your code read that way bad javascript class performancereview constructor employee this employee employee lookuppeers return db lookup this employee peers lookupmanager return db lookup this employee manager getpeerreviews const peers this lookuppeers perfreview this getpeerreviews this getmanagerreview this getselfreview getmanagerreview const manager this lookupmanager getselfreview const review new performancereview employee review perfreview good javascript class performancereview constructor employee this employee employee perfreview this getpeerreviews this getmanagerreview this getselfreview getpeerreviews const peers this lookuppeers lookuppeers return db lookup this employee peers getmanagerreview const manager this lookupmanager lookupmanager return db lookup this employee manager getselfreview const review new performancereview employee review perfreview ⬆ back to top comments only comment things that have business logic complexity comments are an apology not a requirement good code mostly documents itself bad javascript function hashit data the hash let hash 0 length of string const length data length loop through every character in data for let i 0 i length i get character code const char data charcodeat i make the hash hash hash 5 hash char convert to 32 bit integer hash hash good javascript function hashit data let hash 0 const length data length for let i 0 i length i const char data charcodeat i hash hash 5 hash char convert to 32 bit integer hash hash ⬆ back to top dont leave commented out code in your codebase version control exists for a reason leave old code in your history bad javascript dostuff dootherstuff dosomemorestuff dosomuchstuff good javascript dostuff ⬆ back to top dont have journal comments remember use version control theres no need for dead code commented code and especially journal comments use git log to get history bad javascript 2016 12 20 removed monads didnt understand them rm 2016 10 01 improved using special monads jp 2016 02 03 removed type checking li 2015 03 14 added combine with type checking jr function combine a b return a b good javascript function combine a b return a b ⬆ back to top avoid positional markers they usually just add noise let the functions and variable names along with the proper indentation and formatting give the visual structure to your code bad javascript scope model instantiation scope model menu foo nav bar action setup const actions function good javascript scope model menu foo nav bar const actions function ⬆ back to top translation this is also available in other languages brazilian portuguese fesnt clean code javascript spanish andersontr15 clean code javascript chinese alivebao clean code js beginor clean code javascript german marcbruederlin clean code javascript korean qkraudghgh clean code javascript ko polish greg dev clean code javascript pl russian boryamogila clean code javascript ru maksugr clean code javascript vietnamese hienvd clean code javascript japanese mitsuruog clean code javascript indonesia andirkh clean code javascript ⬆ back to top