üåç ƒçe≈°tina ‚àô deutsch ‚àô ŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨ ‚àô english ‚àô espa√±ol ‚àô fran√ßais ‚àô indonesia ‚àô italiano ‚àô Êó•Êú¨Ë™û ‚àô ÌïúÍµ≠Ïñ¥ ‚àô portugu√™s ‚àô rom√¢nƒÉ ‚àô —Ä—É—Å—Å–∫–∏–π ‚àô sloven≈°ƒçina ‚àô —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ ‚àô ÁÆÄ‰Ωì‰∏≠Êñá ‚àô ÁπÅÈ´î‰∏≠Êñá the art of command line meta basics everyday use processing files and data system debugging one liners obscure but useful macos only windows only more resources disclaimer fluency on the command line is a skill often neglected or considered arcane but it improves your flexibility and productivity as an engineer in both obvious and subtle ways this is a selection of notes and tips on using the command line that weve found useful when working on linux some tips are elementary and some are fairly specific sophisticated or obscure this page is not long but if you can use and recall all the items here you know a lot this work is the result of many authors and translators some of this originally appeared on quora but it has since moved to github where people more talented than the original author have made numerous improvements please submit a question if you have a question related to the command line please contribute if you see an error or something that could be better meta scope this guide is both for beginners and the experienced the goals are breadth everything important specificity give concrete examples of the most common case and brevity avoid things that arent essential or digressions you can easily look up elsewhere every tip is essential in some situation or significantly saves time over alternatives this is written for linux with the exception of the macos only and windows only sections many of the other items apply or can be installed on other unices or macos or even cygwin the focus is on interactive bash though many tips apply to other shells and to general bash scripting it includes both standard unix commands as well as ones that require special package installs so long as they are important enough to merit inclusion notes to keep this to one page content is implicitly included by reference youre smart enough to look up more detail elsewhere once you know the idea or command to google use apt get yum dnf pacman pip or brew as appropriate to install new programs use explainshell to get a helpful breakdown of what commands options pipes etc do basics learn basic bash actually type man bash and at least skim the whole thing its pretty easy to follow and not that long alternate shells can be nice but bash is powerful and always available learning only zsh fish etc while tempting on your own laptop restricts you in many situations such as using existing servers learn at least one text based editor well the nano editor is one of the simplest for basic editing opening editing saving searching however for the power user in a text terminal there is no substitute for vim vi the hard to learn but venerable fast and full featured editor many people also use the classic emacs particularly for larger editing tasks of course any modern software developer working on an extensive project is unlikely to use only a pure text based editor and should also be familiar with modern graphical ides and tools know how to read documentation with man for the inquisitive man man lists the section numbers e g 1 is regular commands 5 is files conventions and 8 are for administration find man pages with apropos know that some commands are not executables but bash builtins and that you can get help on them with help and help d you can find out whether a command is an executable shell builtin or an alias by using type command learn about redirection of output and input using and and pipes using know overwrites the output file and appends learn about stdout and stderr learn about file glob expansion with and perhaps and and quoting and the difference between double and single quotes see more on variable expansion below be familiar with bash job management ctrl z ctrl c jobs fg bg kill etc know ssh and the basics of passwordless authentication via ssh agent ssh add etc basic file management ls and ls l in particular learn what every column in ls l means less head tail and tail f or even better less f ln and ln s learn the differences and advantages of hard versus soft links chown chmod du for a quick summary of disk usage du hs for filesystem management df mount fdisk mkfs lsblk learn what an inode is ls i or df i basic network management ip or ifconfig dig traceroute route learn and use a version control management system such as git know regular expressions well and the various flags to grep egrep the i o v a b and c options are worth knowing learn to use apt get yum dnf or pacman depending on distro to find and install packages and make sure you have pip to install python based command line tools a few below are easiest to install via pip everyday use in bash use tab to complete arguments or list all available commands and ctrl r to search through command history after pressing type to search press ctrl r repeatedly to cycle through more matches press enter to execute the found command or hit the right arrow to put the result in the current line to allow editing in bash use ctrl w to delete the last word and ctrl u to delete the content from current cursor back to the start of the line use alt b and alt f to move by word ctrl a to move cursor to beginning of line ctrl e to move cursor to end of line ctrl k to kill to the end of the line ctrl l to clear the screen see man readline for all the default keybindings in bash there are a lot for example alt cycles through previous arguments and alt expands a glob alternatively if you love vi style key bindings use set o vi and set o emacs to put it back for editing long commands after setting your editor for example export editor vim ctrl x ctrl e will open the current command in an editor for multi line editing or in vi style escape v to see recent commands use history follow with n where n is the command number to execute again there are also many abbreviations you can use the most useful probably being for last argument and for last command see history expansion in the man page however these are often easily replaced with ctrl r and alt go to your home directory with cd access files relative to your home directory with the prefix e g bashrc in sh scripts refer to the home directory as home to go back to the previous working directory cd if you are halfway through typing a command but change your mind hit alt to add a at the beginning and enter it as a comment or use ctrl a enter you can then return to it later via command history use xargs or parallel its very powerful note you can control how many items execute per line l as well as parallelism p if youre not sure if itll do the right thing use xargs echo first also i is handy examples bash find name py xargs grep some function cat hosts xargs i ssh root hostname pstree p is a helpful display of the process tree use pgrep and pkill to find or signal processes by name f is helpful know the various signals you can send processes for example to suspend a process use kill stop pid for the full list see man 7 signal use nohup or disown if you want a background process to keep running forever check what processes are listening via netstat lntp or ss plat for tcp add u for udp or lsof itcp stcp listen p n which also works on macos see also lsof and fuser for open sockets and files see uptime or w to know how long the system has been running use alias to create shortcuts for commonly used commands for example alias ll ls latr creates a new alias ll save aliases shell settings and functions you commonly use in bashrc and arrange for login shells to source it this will make your setup available in all your shell sessions put the settings of environment variables as well as commands that should be executed when you login in bash profile separate configuration will be needed for shells you launch from graphical environment logins and cron jobs synchronize your configuration files e g bashrc and bash profile among various computers with git understand that care is needed when variables and filenames include whitespace surround your bash variables with quotes e g foo prefer the 0 or print0 options to enable null characters to delimit filenames e g locate 0 pattern xargs 0 ls al or find print0 type d xargs 0 ls al to iterate on filenames containing whitespace in a for loop set your ifs to be a newline only using ifs \n in bash scripts use set x or the variant set v which logs raw input including unexpanded variables and comments for debugging output use strict modes unless you have a good reason not to use set e to abort on errors nonzero exit code use set u to detect unset variable usages consider set o pipefail too to on errors within pipes too though read up on it more if you do as this topic is a bit subtle for more involved scripts also use trap on exit or err a useful habit is to start a script like this which will make it detect and abort on common errors and print a message bash set euo pipefail trap echo error script failed see failed command above err in bash scripts subshells written with parentheses are convenient ways to group commands a common example is to temporarily move to a different working directory e g bash do something in current dir cd some other dir other command continue in original dir in bash note there are lots of kinds of variable expansion checking a variable exists name error message for example if a bash script requires a single argument just write input file 1 usage 0 input file using a default value if a variable is empty name default if you want to have an additional optional parameter added to the previous example you can use something like output file 2 logfile if 2 is omitted and thus empty output file will be set to logfile arithmetic expansion i i 1 5 sequences 1 10 trimming of strings var suffix and var prefix for example if var foo pdf then echo var pdf txt prints foo txt brace expansion using can reduce having to re type similar text and automate combinations of items this is helpful in examples like mv foo txt pdf some dir which moves both files cp somefile bak which expands to cp somefile somefile bak or mkdir p test a b c subtest 1 2 3 which expands all possible combinations and creates a directory tree brace expansion is performed before any other expansion the order of expansions is brace expansion tilde expansion parameter and variable expansion arithmetic expansion and command substitution done in a left to right fashion word splitting and filename expansion for example a range like 1 20 cannot be expressed with variables using a b use seq or a for loop instead e g seq a b or for i a i b i do done the output of a command can be treated like a file via some command known as process substitution for example compare local etc hosts with a remote one sh diff etc hosts ssh somehost cat etc hosts when writing scripts you may want to put all of your code in curly braces if the closing brace is missing your script will be prevented from executing due to a syntax error this makes sense when your script is going to be downloaded from the web since it prevents partially downloaded scripts from executing bash your code here a here document allows redirection of multiple lines of input as if from a file cat eof input on multiple lines eof in bash redirect both standard output and standard error via some command logfile 2 1 or some command logfile often to ensure a command does not leave an open file handle to standard input tying it to the terminal you are in it is also good practice to add dev null use man ascii for a good ascii table with hex and decimal values for general encoding info man unicode man utf 8 and man latin1 are helpful use screen or tmux to multiplex the screen especially useful on remote ssh sessions and to detach and re attach to a session byobu can enhance screen or tmux providing more information and easier management a more minimal alternative for session persistence only is dtach in ssh knowing how to port tunnel with l or d and occasionally r is useful e g to access web sites from a remote server it can be useful to make a few optimizations to your ssh configuration for example this ssh config contains settings to avoid dropped connections in certain network environments uses compression which is helpful with scp over low bandwidth connections and multiplex channels to the same server with a local control file tcpkeepalive yes serveraliveinterval 15 serveralivecountmax 6 compression yes controlmaster auto controlpath tmp r h p controlpersist yes a few other options relevant to ssh are security sensitive and should be enabled with care e g per subnet or host or in trusted networks stricthostkeychecking no forwardagent yes consider mosh an alternative to ssh that uses udp avoiding dropped connections and adding convenience on the road requires server side setup to get the permissions on a file in octal form which is useful for system configuration but not available in ls and easy to bungle use something like sh stat c a a n etc timezone for interactive selection of values from the output of another command use percol or fzf for interaction with files based on the output of another command like git use fpp pathpicker for a simple web server for all files in the current directory and subdirs available to anyone on your network use python m simplehttpserver 7777 for port 7777 and python 2 and python m http server 7777 for port 7777 and python 3 for running a command as another user use sudo defaults to running as root use u to specify another user use i to login as that user you will be asked for your password for switching the shell to another user use su username or su username the latter with gets an environment as if another user just logged in omitting the username defaults to root you will be asked for the password of the user you are switching to know about the 128k limit on command lines this argument list too long error is common when wildcard matching large numbers of files when this happens alternatives like find and xargs may help for a basic calculator and of course access to python in general use the python interpreter for example 2 3 5 processing files and data to locate a file by name in the current directory find iname something or similar to find a file anywhere by name use locate something but bear in mind updatedb may not have indexed recently created files for general searching through source or data files there are several options more advanced or faster than grep r including in rough order from older to newer ack ag the silver searcher and rg ripgrep to convert html to text lynx dump stdin for markdown html and all kinds of document conversion try pandoc if you must handle xml xmlstarlet is old but good for json use jq for interactive use also see jid and jiq for yaml use shyaml for excel or csv files csvkit provides in2csv csvcut csvjoin csvgrep etc for amazon s3 s3cmd is convenient and s4cmd is faster amazons aws and the improved saws are essential for other aws related tasks know about sort and uniq including uniqs u and d options see one liners below see also comm know about cut paste and join to manipulate text files many people use cut but forget about join know about wc to count newlines l characters m words w and bytes c know about tee to copy from stdin to a file and also to stdout as in ls al tee file txt for more complex calculations including grouping reversing fields and statistical calculations consider datamash know that locale affects a lot of command line tools in subtle ways including sorting order collation and performance most linux installations will set lang or other locale variables to a local setting like us english but be aware sorting will change if you change locale and know i18n routines can make sort or other commands run many times slower in some situations such as the set operations or uniqueness operations below you can safely ignore slow i18n routines entirely and use traditional byte based sort order using export lc all c you can set a specific commands environment by prefixing its invocation with the environment variable settings as in tz pacific fiji date know basic awk and sed for simple data munging see one liners for examples to replace all occurrences of a string in place in one or more files sh perl pi bak e s old string new string g my files txt to rename multiple files and or search and replace within files try repren in some cases the rename command also allows multiple renames but be careful as its functionality is not the same on all linux distributions sh full rename of filenames directories and contents foo bar repren full preserve case from foo to bar recover backup files whatever bak whatever repren renames from \ bak to \1 bak same as above using rename if available rename s \ bak bak as the man page says rsync really is a fast and extraordinarily versatile file copying tool its known for synchronizing between machines but is equally useful locally when security restrictions allow using rsync instead of scp allows recovery of a transfer without restarting from scratch it also is among the fastest ways to delete large numbers of files sh mkdir empty rsync r delete empty some dir rmdir some dir for monitoring progress when processing files use pv pycp pmonitor progress rsync progress or for block level copying dd status progress use shuf to shuffle or select random lines from a file know sorts options for numbers use n or h for handling human readable numbers e g from du h know how keys work t and k in particular watch out that you need to write k1 1 to sort by only the first field k1 means sort according to the whole line stable sort sort s can be useful for example to sort first by field 2 then secondarily by field 1 you can use sort k1 1 sort s k2 2 if you ever need to write a tab literal in a command line in bash e g for the t argument to sort press ctrl v tab or write \t the latter is better as you can copy paste it the standard tools for patching source code are diff and patch see also diffstat for summary statistics of a diff and sdiff for a side by side diff note diff r works for entire directories use diff r tree1 tree2 diffstat for a summary of changes use vimdiff to compare and edit files for binary files use hd hexdump or xxd for simple hex dumps and bvi hexedit or biew for binary editing also for binary files strings plus grep etc lets you find bits of text for binary diffs delta compression use xdelta3 to convert text encodings try iconv or uconv for more advanced use it supports some advanced unicode things for example sh displays hex codes or actual names of characters useful for debugging uconv f utf 8 t utf 8 x any hex input txt uconv f utf 8 t utf 8 x any name input txt lowercase and removes all accents by expanding and dropping them uconv f utf 8 t utf 8 x any lower any nfd nonspacing mark any nfc input txt output txt to split files into pieces see split to split by size and csplit to split by a pattern date and time to get the current date and time in the helpful iso 8601 format use date u y m dt h m sz other options are problematic to manipulate date and time expressions use dateadd datediff strptime etc from dateutils use zless zmore zcat and zgrep to operate on compressed files file attributes are settable via chattr and offer a lower level alternative to file permissions for example to protect against accidental file deletion the immutable flag sudo chattr i critical directory or file use getfacl and setfacl to save and restore file permissions for example sh getfacl r some path permissions txt setfacl restore permissions txt to create empty files quickly use truncate creates sparse file fallocate ext4 xfs btrfs and ocfs2 filesystems xfs mkfile almost any filesystems comes in xfsprogs package mkfile for unix like systems like solaris mac os system debugging for web debugging curl and curl i are handy or their wget equivalents or the more modern httpie to know current cpu disk status the classic tools are top or the better htop iostat and iotop use iostat mxz 15 for basic cpu and detailed per partition disk stats and performance insight for network connection details use netstat and ss for a quick overview of whats happening on a system dstat is especially useful for broadest overview with details use glances to know memory status run and understand the output of free and vmstat in particular be aware the cached value is memory held by the linux kernel as file cache so effectively counts toward the free value java system debugging is a different kettle of fish but a simple trick on oracles and some other jvms is that you can run kill 3 pid and a full stack trace and heap summary including generational garbage collection details which can be highly informative will be dumped to stderr logs the jdks jps jstat jstack jmap are useful sjk tools are more advanced use mtr as a better traceroute to identify network issues for looking at why a disk is full ncdu saves time over the usual commands like du sh to find which socket or process is using bandwidth try iftop or nethogs the ab tool comes with apache is helpful for quick and dirty checking of web server performance for more complex load testing try siege for more serious network debugging wireshark tshark or ngrep know about strace and ltrace these can be helpful if a program is failing hanging or crashing and you dont know why or if you want to get a general idea of performance note the profiling option c and the ability to attach to a running process p use trace child option f to avoid missing important calls know about ldd to check shared libraries etc ‚Äî but never run it on untrusted files know how to connect to a running process with gdb and get its stack traces use proc its amazingly helpful sometimes when debugging live problems examples proc cpuinfo proc meminfo proc cmdline proc xxx cwd proc xxx exe proc xxx fd proc xxx smaps where xxx is the process id or pid when debugging why something went wrong in the past sar can be very helpful it shows historic statistics on cpu memory network etc for deeper systems and performance analyses look at stap systemtap perf and sysdig check what os youre on with uname or uname a general unix kernel info or lsb release a linux distro info use dmesg whenever somethings acting really funny it could be hardware or driver issues if you delete a file and it doesnt free up expected disk space as reported by du check whether the file is in use by a process lsof grep deleted grep filename of my big file one liners a few examples of piecing together commands it is remarkably helpful sometimes that you can do set intersection union and difference of text files via sort uniq suppose a and b are text files that are already uniqued this is fast and works on files of arbitrary size up to many gigabytes sort is not limited by memory though you may need to use the t option if tmp is on a small root partition see also the note about lc all above and sorts u option left out for clarity below sh sort a b uniq c c is a union b sort a b uniq d c c is a intersect b sort a b b uniq u c c is set difference a b use grep to quickly examine the contents of all files in a directory so each line is paired with the filename or head 100 so each file has a heading this can be useful for directories filled with config settings like those in sys proc etc summing all numbers in the third column of a text file this is probably 3x faster and 3x less code than equivalent python sh awk x 3 end print x myfile to see sizes dates on a tree of files this is like a recursive ls l but is easier to read than ls lr sh find type f ls say you have a text file like a web server log and a certain value that appears on some lines such as an acct id parameter that is present in the url if you want a tally of how many requests for each acct id sh egrep o acct id 0 9 access log cut d f2 sort uniq c sort rn to continuously monitor changes use watch e g check changes to files in a directory with watch d n 2 ls rtlh tail or to network settings while troubleshooting your wifi settings with watch d n 2 ifconfig run this function to get a random tip from this document parses markdown and extracts an item sh function taocl curl s https raw githubusercontent com jlevy the art of command line master readme md sed cowsay png d pandoc f markdown t html xmlstarlet fo html dropdtd xmlstarlet sel t v html body ul li count p 0 random mod last 1 xmlstarlet unesc fmt 80 iconv t us obscure but useful expr perform arithmetic or boolean operations or evaluate regular expressions m4 simple macro processor yes print a string a lot cal nice calendar env run a command useful in scripts printenv print out environment variables useful in debugging and scripts look find english words or lines in a file beginning with a string cut paste and join data manipulation fmt format text paragraphs pr format text into pages columns fold wrap lines of text column format text fields into aligned fixed width columns or tables expand and unexpand convert between tabs and spaces nl add line numbers seq print numbers bc calculator factor factor integers gpg encrypt and sign files toe table of terminfo entries nc network debugging and data transfer socat socket relay and tcp port forwarder similar to netcat slurm network traffic visualization dd moving data between files or devices file identify type of a file tree display directories and subdirectories as a nesting tree like ls but recursive stat file info time execute and time a command timeout execute a command for specified amount of time and stop the process when the specified amount of time completes lockfile create semaphore file that can only be removed by rm f logrotate rotate compress and mail logs watch run a command repeatedly showing results and or highlighting changes when changed runs any command you specify whenever it sees file changed see inotifywait and entr as well tac print files in reverse comm compare sorted files line by line strings extract text from binary files tr character translation or manipulation iconv or uconv conversion for text encodings split and csplit splitting files sponge read all input before writing it useful for reading from then writing to the same file e g grep v something some file sponge some file units unit conversions and calculations converts furlongs per fortnight to twips per blink see also usr share units definitions units apg generates random passwords xz high ratio file compression ldd dynamic library info nm symbols from object files ab or wrk benchmarking web servers strace system call debugging mtr better traceroute for network debugging cssh visual concurrent shell rsync sync files and folders over ssh or in local file system wireshark and tshark packet capture and network debugging ngrep grep for the network layer host and dig dns lookups lsof process file descriptor and socket info dstat useful system stats glances high level multi subsystem overview iostat disk usage stats mpstat cpu usage stats vmstat memory usage stats htop improved version of top last login history w whos logged on id user group identity info sar historic system stats iftop or nethogs network utilization by socket or process ss socket statistics dmesg boot and system error messages sysctl view and configure linux kernel parameters at run time hdparm sata ata disk manipulation performance lsblk list block devices a tree view of your disks and disk partitions lshw lscpu lspci lsusb dmidecode hardware information including cpu bios raid graphics devices etc lsmod and modinfo list and show details of kernel modules fortune ddate and sl um well it depends on whether you consider steam locomotives and zippy quotations useful macos only these are items relevant only on macos package management with brew homebrew and or port macports these can be used to install on macos many of the above commands copy output of any command to a desktop app with pbcopy and paste input from one with pbpaste to enable the option key in macos terminal as an alt key such as used in the commands above like alt b alt f etc open preferences profiles keyboard and select use option as meta key to open a file with a desktop app use open or open a applications whatever app spotlight search files with mdfind and list metadata such as photo exif info with mdls be aware macos is based on bsd unix and many commands for example ps ls tail awk sed have many subtle variations from linux which is largely influenced by system v style unix and gnu tools you can often tell the difference by noting a man page has the heading bsd general commands manual in some cases gnu versions can be installed too such as gawk and gsed for gnu awk and sed if writing cross platform bash scripts avoid such commands for example consider python or perl or test carefully to get macos release information use sw vers windows only these items are relevant only on windows ways to obtain unix tools under windows access the power of the unix shell under microsoft windows by installing cygwin most of the things described in this document will work out of the box on windows 10 you can use windows subsystem for linux wsl which provides a familiar bash environment with unix command line utilities if you mainly want to use gnu developer tools such as gcc on windows consider mingw and its msys package which provides utilities such as bash gawk make and grep msys doesnt have all the features compared to cygwin mingw is particularly useful for creating native windows ports of unix tools another option to get unix look and feel under windows is cash note that only very few unix commands and command line options are available in this environment useful windows command line tools you can perform and script most windows system administration tasks from the command line by learning and using wmic native command line windows networking tools you may find useful include ping ipconfig tracert and netstat you can perform many useful windows tasks by invoking the rundll32 command cygwin tips and tricks install additional unix programs with the cygwins package manager use mintty as your command line window access the windows clipboard through dev clipboard run cygstart to open an arbitrary file through its registered application access the windows registry with regtool note that a c \ windows drive path becomes cygdrive c under cygwin and that cygwins appears under c \cygwin on windows convert between cygwin and windows style file paths with cygpath this is most useful in scripts that invoke windows programs more resources awesome shell a curated list of shell tools and resources awesome osx command line a more in depth guide for the macos command line strict mode for writing better shell scripts shellcheck a shell script static analysis tool essentially lint for bash sh zsh filenames and pathnames in shell the sadly complex minutiae on how to handle filenames correctly in shell scripts data science at the command line more commands and tools helpful for doing data science from the book of the same name disclaimer with the exception of very small tasks code is written so others can read it with power comes responsibility the fact you can do something in bash doesnt necessarily mean you should license this work is licensed under a creative commons attribution sharealike 4 0 international license