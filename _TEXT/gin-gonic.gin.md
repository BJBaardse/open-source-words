gin web framework gin is a web framework written in go golang it features a martini like api with much better performance up to 40 times faster thanks to httprouter if you need performance and good productivity you will love gin contents installation prerequisite quick start benchmarks gin v1 stable build with jsoniter api examples using get post put patch delete and options parameters in path querystring parameters multipart urlencoded form another example query post form upload files grouping routes blank gin without middleware by default using middleware how to write log file model binding and validation custom validators only bind query string bind query string or post data bind html checkboxes multipart urlencoded binding xml json and yaml rendering jsonp rendering serving static files serving data from reader html rendering multitemplate redirects custom middleware using basicauth middleware goroutines inside a middleware custom http configuration support lets encrypt run multiple service using gin graceful restart or stop build a single binary with templates bind form data request with custom struct try to bind body into different structs http2 server push testing users installation to install gin package you need to install go and set your go workspace first download and install it sh go get u github com gin gonic gin import it in your code go import github com gin gonic gin optional import net http this is required for example if using constants such as http statusok go import net http use a vendor tool like govendor go get govendor sh go get github com kardianos govendor 2 create your project folder and cd inside sh mkdir p gopath src github com myusername project cd vendor init your project and add gin sh govendor init govendor fetch github com gin gonic gin v1 2 copy a starting template inside your project sh curl https raw githubusercontent com gin gonic gin master examples basic main go main go run your project sh go run main go prerequisite now gin requires go 1 6 or later and go 1 7 will be required soon quick start sh assume the following codes in example go file cat example go go package main import github com gin gonic gin func main r gin default r get ping func c gin context c json 200 gin h message pong r run listen and serve on 0 0 0 0 8080 run example go and visit 0 0 0 0 8080 ping on browser go run example go benchmarks gin uses a custom version of httprouter see all benchmarks benchmark name 1 2 3 4 benchmarkgin githuball 30000 48375 0 0 benchmarkace githuball 10000 134059 13792 167 benchmarkbear githuball 5000 534445 86448 943 benchmarkbeego githuball 3000 592444 74705 812 benchmarkbone githuball 200 6957308 698784 8453 benchmarkdenco githuball 10000 158819 20224 167 benchmarkecho githuball 10000 154700 6496 203 benchmarkgocraftweb githuball 3000 570806 131656 1686 benchmarkgoji githuball 2000 818034 56112 334 benchmarkgojiv2 githuball 2000 1213973 274768 3712 benchmarkgojsonrest githuball 2000 785796 134371 2737 benchmarkgorestful githuball 300 5238188 689672 4519 benchmarkgorillamux githuball 100 10257726 211840 2272 benchmarkhttprouter githuball 20000 105414 13792 167 benchmarkhttptreemux githuball 10000 319934 65856 671 benchmarkkocha githuball 10000 209442 23304 843 benchmarklars githuball 20000 62565 0 0 benchmarkmacaron githuball 2000 1161270 204194 2000 benchmarkmartini githuball 200 9991713 226549 2325 benchmarkpat githuball 200 5590793 1499568 27435 benchmarkpossum githuball 10000 319768 84448 609 benchmarkr2router githuball 10000 305134 77328 979 benchmarkrivet githuball 10000 132134 16272 167 benchmarktango githuball 3000 552754 63826 1618 benchmarktigertonic githuball 1000 1439483 239104 5374 benchmarktraffic githuball 100 11383067 2659329 21848 benchmarkvulcan githuball 5000 394253 19894 609 1 total repetitions achieved in constant time higher means more confident result 2 single repetition duration ns op lower is better 3 heap memory b op lower is better 4 average allocations per repetition allocs op lower is better gin v1 stable x zero allocation router x still the fastest http router and framework from routing to writing x complete suite of unit tests x battle tested x api frozen new releases will not break your code build with jsoniter gin use encoding json as default json package but you can change to jsoniter by build from other tags sh go build tags jsoniter api examples using get post put patch delete and options go func main disable console color gin disableconsolecolor creates a gin router with default middleware logger and recovery crash free middleware router gin default router get someget getting router post somepost posting router put someput putting router delete somedelete deleting router patch somepatch patching router head somehead head router options someoptions options by default it serves on 8080 unless a port environment variable was defined router run router run 3000 for a hard coded port parameters in path go func main router gin default this handler will match user john but will not match neither user or user router get user name func c gin context name c param name c string http statusok hello s name however this one will match user john and also user john send if no other routers match user john it will redirect to user john router get user name action func c gin context name c param name action c param action message name is action c string http statusok message router run 8080 querystring parameters go func main router gin default query string parameters are parsed using the existing underlying request object the request responds to a url matching welcome firstname jane lastname doe router get welcome func c gin context firstname c defaultquery firstname guest lastname c query lastname shortcut for c request url query get lastname c string http statusok hello s s firstname lastname router run 8080 multipart urlencoded form go func main router gin default router post form post func c gin context message c postform message nick c defaultpostform nick anonymous c json 200 gin h status posted message message nick nick router run 8080 another example query post form post post id 1234 page 1 http 1 1 content type application x www form urlencoded name manu message this is great go func main router gin default router post post func c gin context id c query id page c defaultquery page 0 name c postform name message c postform message fmt printf id s page s name s message s id page name message router run 8080 id 1234 page 1 name manu message this is great upload files single file references issue 774 and detail example code go func main router gin default set a lower memory limit for multipart forms default is 32 mib router maxmultipartmemory 8 20 8 mib router post upload func c gin context single file file c formfile file log println file filename upload the file to specific dst c saveuploadedfile file dst c string http statusok fmt sprintf s uploaded file filename router run 8080 how to curl bash curl x post http localhost 8080 upload \ f file users appleboy test zip \ h content type multipart form data multiple files see the detail example code go func main router gin default set a lower memory limit for multipart forms default is 32 mib router maxmultipartmemory 8 20 8 mib router post upload func c gin context multipart form form c multipartform files form file upload for file range files log println file filename upload the file to specific dst c saveuploadedfile file dst c string http statusok fmt sprintf d files uploaded len files router run 8080 how to curl bash curl x post http localhost 8080 upload \ f upload users appleboy test1 zip \ f upload users appleboy test2 zip \ h content type multipart form data grouping routes go func main router gin default simple group v1 v1 router group v1 v1 post login loginendpoint v1 post submit submitendpoint v1 post read readendpoint simple group v2 v2 router group v2 v2 post login loginendpoint v2 post submit submitendpoint v2 post read readendpoint router run 8080 blank gin without middleware by default use go r gin new instead of go default with the logger and recovery middleware already attached r gin default using middleware go func main creates a router without any middleware by default r gin new global middleware logger middleware will write the logs to gin defaultwriter even if you set with gin mode release by default gin defaultwriter os stdout r use gin logger recovery middleware recovers from any panics and writes a 500 if there was one r use gin recovery per route middleware you can add as many as you desire r get benchmark mybenchlogger benchendpoint authorization group authorized r group authrequired exactly the same as authorized r group per group middleware in this case we use the custom created authrequired middleware just in the authorized group authorized use authrequired authorized post login loginendpoint authorized post submit submitendpoint authorized post read readendpoint nested group testing authorized group testing testing get analytics analyticsendpoint listen and serve on 0 0 0 0 8080 r run 8080 how to write log file go func main disable console color you dont need console color when writing the logs to file gin disableconsolecolor logging to a file f os create gin log gin defaultwriter io multiwriter f use the following code if you need to write the logs to file and console at the same time gin defaultwriter io multiwriter f os stdout router gin default router get ping func c gin context c string 200 pong router run 8080 model binding and validation to bind a request body into a type use model binding we currently support binding of json xml and standard form values foo bar boo baz gin uses go playground validator v8 for validation check the full docs on tags usage here note that you need to set the corresponding binding tag on all fields you want to bind for example when binding from json set json fieldname also gin provides two sets of methods for binding type must bind methods bind bindjson bindquery behavior these methods use mustbindwith under the hood if there is a binding error the request is aborted with c abortwitherror 400 err settype errortypebind this sets the response status code to 400 and the content type header is set to text plain charset utf 8 note that if you try to set the response code after this it will result in a warning gin debug warning headers were already written wanted to override status code 400 with 422 if you wish to have greater control over the behavior consider using the shouldbind equivalent method type should bind methods shouldbind shouldbindjson shouldbindquery behavior these methods use shouldbindwith under the hood if there is a binding error the error is returned and it is the developers responsibility to handle the request and error appropriately when using the bind method gin tries to infer the binder depending on the content type header if you are sure what you are binding you can use mustbindwith or shouldbindwith you can also specify that specific fields are required if a field is decorated with binding required and has a empty value when binding an error will be returned go binding from json type login struct user stringform user json user binding required password stringform password json password binding required func main router gin default example for binding json user manu password 123 router post loginjson func c gin context var json login if err c shouldbindjson json err nil if json user manu json password 123 c json http statusok gin h status you are logged in else c json http statusunauthorized gin h status unauthorized else c json http statusbadrequest gin h error err error example for binding a html form user manu password 123 router post loginform func c gin context var form login this will infer what binder to use depending on the content type header if err c shouldbind form err nil if form user manu form password 123 c json http statusok gin h status you are logged in else c json http statusunauthorized gin h status unauthorized else c json http statusbadrequest gin h error err error listen and serve on 0 0 0 0 8080 router run 8080 sample request shell curl v x post \ http localhost 8080 loginjson \ h content type application json \ d user manu post loginjson http 1 1 host localhost 8080 user agent curl 7 51 0 accept content type application json content length 18 upload completely sent off 18 out of 18 bytes http 1 1 400 bad request content type application json charset utf 8 date fri 04 aug 2017 03 51 31 gmt content length 100 error key login password error field validation for password failed on the required tag skip validate when running the above example using the above the curl command it returns error because the example use binding required for password if use binding for password then it will not return error when running the above example again custom validators it is also possible to register custom validators see the example code go package main import net http reflect time github com gin gonic gin github com gin gonic gin binding gopkg in go playground validator v8 type booking struct checkin time time form check in binding required bookabledate time format 2006 01 02 checkout time time form check out binding required gtfield checkin time format 2006 01 02 func bookabledate v validator validate topstruct reflect value currentstructorfield reflect value field reflect value fieldtype reflect type fieldkind reflect kind param string bool if date ok field interface time time ok today time now if today year date year today yearday date yearday return false return true func main route gin default if v ok binding validator engine validator validate ok v registervalidation bookabledate bookabledate route get bookable getbookable route run 8085 func getbookable c gin context var b booking if err c shouldbindwith b binding query err nil c json http statusok gin h message booking dates are valid else c json http statusbadrequest gin h error err error console curl localhost 8085 bookable check in 2018 04 16 check out 2018 04 17 message booking dates are valid curl localhost 8085 bookable check in 2018 03 08 check out 2018 03 09 error key booking checkin error field validation for checkin failed on the bookabledate tag struct level validations can also be registed this way see the struct lvl validation example to learn more only bind query string shouldbindquery function only binds the query params and not the post data see the detail information go package main import log github com gin gonic gin type person struct name string form name address string form address func main route gin default route any testing startpage route run 8085 func startpage c gin context var person person if c shouldbindquery person nil log println only bind by query string log println person name log println person address c string 200 success bind query string or post data see the detail information go package main import log import github com gin gonic gin import time type person struct name string form name address string form address birthday time time form birthday time format 2006 01 02 time utc 1 func main route gin default route get testing startpage route run 8085 func startpage c gin context var person person if get only form binding engine query used if post first checks the content type for json or xml then uses form form data see more at https github com gin gonic gin blob master binding binding go l48 if c shouldbind person nil log println person name log println person address log println person birthday c string 200 success test it with sh curl x get localhost 8085 testing name appleboy address xyz birthday 1992 03 15 bind html checkboxes see the detail information main go go type myform struct colors string form colors func formhandler c gin context var fakeform myform c shouldbind fakeform c json 200 gin h color fakeform colors form html html form action method post p check some colors p label for red red label input type checkbox name colors value red id red label for green green label input type checkbox name colors value green id green label for blue blue label input type checkbox name colors value blue id blue input type submit form result color red green blue multipart urlencoded binding go package main import github com gin gonic gin type loginform struct user string form user binding required password string form password binding required func main router gin default router post login func c gin context you can bind multipart form with explicit binding declaration c shouldbindwith form binding form or you can simply use autobinding with shouldbind method var form loginform in this case proper binding will be automatically selected if c shouldbind form nil if form user user form password password c json 200 gin h status you are logged in else c json 401 gin h status unauthorized router run 8080 test it with sh curl v form user user form password password http localhost 8080 login xml json and yaml rendering go func main r gin default gin h is a shortcut for map string interface r get somejson func c gin context c json http statusok gin h message hey status http statusok r get morejson func c gin context you also can use a struct var msg struct name string json user message string number int msg name lena msg message hey msg number 123 note that msg name becomes user in the json will output user lena message hey number 123 c json http statusok msg r get somexml func c gin context c xml http statusok gin h message hey status http statusok r get someyaml func c gin context c yaml http statusok gin h message hey status http statusok listen and serve on 0 0 0 0 8080 r run 8080 securejson using securejson to prevent json hijacking default prepends while 1 to response body if the given struct is array values go func main r gin default you can also use your own secure json prefix r securejsonprefix \n r get somejson func c gin context names string lena austin foo will output while 1 lena austin foo c securejson http statusok names listen and serve on 0 0 0 0 8080 r run 8080 jsonp using jsonp to request data from a server in a different domain add callback to response body if the query parameter callback exists go func main r gin default r get jsonp callback x func c gin context data map string interface foo bar callback is x will output x \ foo\ \ bar\ c jsonp http statusok data listen and serve on 0 0 0 0 8080 r run 8080 asciijson using asciijson to generates ascii only json with escaped non ascii chracters go func main r gin default r get somejson func c gin context data map string interface lang go语言 tag br will output lang go\u8bed\u8a00 tag \u003cbr\u003e c asciijson http statusok data listen and serve on 0 0 0 0 8080 r run 8080 serving static files go func main router gin default router static assets assets router staticfs more static http dir my file system router staticfile favicon ico resources favicon ico listen and serve on 0 0 0 0 8080 router run 8080 serving data from reader go func main router gin default router get somedatafromreader func c gin context response err http get https raw githubusercontent com gin gonic logo master color png if err nil response statuscode http statusok c status http statusserviceunavailable return reader response body contentlength response contentlength contenttype response header get content type extraheaders map string string content disposition attachment filename gopher png c datafromreader http statusok contentlength contenttype reader extraheaders router run 8080 html rendering using loadhtmlglob or loadhtmlfiles go func main router gin default router loadhtmlglob templates router loadhtmlfiles templates template1 html templates template2 html router get index func c gin context c html http statusok index tmpl gin h title main website router run 8080 templates index tmpl html html h1 title h1 html using templates with same name in different directories go func main router gin default router loadhtmlglob templates router get posts index func c gin context c html http statusok posts index tmpl gin h title posts router get users index func c gin context c html http statusok users index tmpl gin h title users router run 8080 templates posts index tmpl html define posts index tmpl html h1 title h1 p using posts index tmpl p html end templates users index tmpl html define users index tmpl html h1 title h1 p using users index tmpl p html end custom template renderer you can also use your own html template render go import html template func main router gin default html template must template parsefiles file1 file2 router sethtmltemplate html router run 8080 custom delimiters you may use custom delims go r gin default r delims r loadhtmlglob path to templates custom template funcs see the detail example code main go go import fmt html template net http time github com gin gonic gin func formatasdate t time time string year month day t date return fmt sprintf d 02d 02d year month day func main router gin default router delims router setfuncmap template funcmap formatasdate formatasdate router loadhtmlfiles fixtures basic raw tmpl router get raw func c gin context c html http statusok raw tmpl map string interface now time date 2017 07 01 0 0 0 0 time utc router run 8080 raw tmpl html date now formatasdate result date 2017 07 01 multitemplate gin allow by default use only one html template check a multitemplate render for using features like go 1 6 block template redirects issuing a http redirect is easy both internal and external locations are supported go r get test func c gin context c redirect http statusmovedpermanently http www google com issuing a router redirect use handlecontext like below go r get test func c gin context c request url path test2 r handlecontext c r get test2 func c gin context c json 200 gin h hello world custom middleware go func logger gin handlerfunc return func c gin context t time now set example variable c set example 12345 before request c next after request latency time since t log print latency access the status we are sending status c writer status log println status func main r gin new r use logger r get test func c gin context example c mustget example string it would print 12345 log println example listen and serve on 0 0 0 0 8080 r run 8080 using basicauth middleware go simulate some private data var secrets gin h foo gin h email foo bar com phone 123433 austin gin h email austin example com phone 666 lena gin h email lena guapa com phone 523443 func main r gin default group using gin basicauth middleware gin accounts is a shortcut for map string string authorized r group admin gin basicauth gin accounts foo bar austin 1234 lena hello2 manu 4321 admin secrets endpoint hit localhost 8080 admin secrets authorized get secrets func c gin context get user it was set by the basicauth middleware user c mustget gin authuserkey string if secret ok secrets user ok c json http statusok gin h user user secret secret else c json http statusok gin h user user secret no secret listen and serve on 0 0 0 0 8080 r run 8080 goroutines inside a middleware when starting new goroutines inside a middleware or handler you should not use the original context inside it you have to use a read only copy go func main r gin default r get long async func c gin context create copy to be used inside the goroutine ccp c copy go func simulate a long task with time sleep 5 seconds time sleep 5 time second note that you are using the copied context ccp important log println done in path ccp request url path r get long sync func c gin context simulate a long task with time sleep 5 seconds time sleep 5 time second since we are not using a goroutine we do not have to copy the context log println done in path c request url path listen and serve on 0 0 0 0 8080 r run 8080 custom http configuration use http listenandserve directly like this go func main router gin default http listenandserve 8080 router or go func main router gin default s http server addr 8080 handler router readtimeout 10 time second writetimeout 10 time second maxheaderbytes 1 20 s listenandserve support lets encrypt example for 1 line letsencrypt https servers go package main import log github com gin gonic autotls github com gin gonic gin func main r gin default ping handler r get ping func c gin context c string 200 pong log fatal autotls run r example1 com example2 com example for custom autocert manager go package main import log github com gin gonic autotls github com gin gonic gin golang org x crypto acme autocert func main r gin default ping handler r get ping func c gin context c string 200 pong m autocert manager prompt autocert accepttos hostpolicy autocert hostwhitelist example1 com example2 com cache autocert dircache var www cache log fatal autotls runwithmanager r m run multiple service using gin see the question and try the following example go package main import log net http time github com gin gonic gin golang org x sync errgroup var g errgroup group func router01 http handler e gin new e use gin recovery e get func c gin context c json http statusok gin h code http statusok error welcome server 01 return e func router02 http handler e gin new e use gin recovery e get func c gin context c json http statusok gin h code http statusok error welcome server 02 return e func main server01 http server addr 8080 handler router01 readtimeout 5 time second writetimeout 10 time second server02 http server addr 8081 handler router02 readtimeout 5 time second writetimeout 10 time second g go func error return server01 listenandserve g go func error return server02 listenandserve if err g wait err nil log fatal err graceful restart or stop do you want to graceful restart or stop your web server there are some ways this can be done we can use fvbock endless to replace the default listenandserve refer issue 296 for more details go router gin default router get handler endless listenandserve 4242 router an alternative to endless manners a polite go http server that shuts down gracefully graceful graceful is a go package enabling graceful shutdown of an http handler server grace graceful restart zero downtime deploy for go servers if you are using go 1 8 you may not need to use this library consider using http servers built in shutdown method for graceful shutdowns see the full graceful shutdown example with gin go build go1 8 package main import context log net http os os signal time github com gin gonic gin func main router gin default router get func c gin context time sleep 5 time second c string http statusok welcome gin server srv http server addr 8080 handler router go func service connections if err srv listenandserve err nil err http errserverclosed log fatalf listen s\n err wait for interrupt signal to gracefully shutdown the server with a timeout of 5 seconds quit make chan os signal signal notify quit os interrupt quit log println shutdown server ctx cancel context withtimeout context background 5 time second defer cancel if err srv shutdown ctx err nil log fatal server shutdown err log println server exiting build a single binary with templates you can build a server into a single binary containing templates by using go assets go func main r gin new t err loadtemplate if err nil panic err r sethtmltemplate t r get func c gin context c html http statusok html index tmpl nil r run 8080 loadtemplate loads templates embedded by go assets builder func loadtemplate template template error t template new for name file range assets files if file isdir strings hassuffix name tmpl continue h err ioutil readall file if err nil return nil err t err t new name parse string h if err nil return nil err return t nil see a complete example in the examples assets in binary directory bind form data request with custom struct the follow example using custom struct go type structa struct fielda stringform field a type structb struct nestedstruct structa fieldb string form field b type structc struct nestedstructpointer structa fieldc string form field c type structd struct nestedanonystruct struct fieldx string form field x fieldd string form field d func getdatab c gin context var b structb c bind b c json 200 gin h a b nestedstruct b b fieldb func getdatac c gin context var b structc c bind b c json 200 gin h a b nestedstructpointer c b fieldc func getdatad c gin context var b structd c bind b c json 200 gin h x b nestedanonystruct d b fieldd func main r gin default r get getb getdatab r get getc getdatac r get getd getdatad r run using the command curl command result curl http localhost 8080 getb field a hello field b world a fielda hello b world curl http localhost 8080 getc field a hello field c world a fielda hello c world curl http localhost 8080 getd field x hello field d world d world x fieldx hello note not support the follow style struct go type structx struct x struct form name x here have form type structy struct y structx form name y here hava form type structz struct z structz form name z here hava form in a word only support nested custom struct which have no form now try to bind body into different structs the normal methods for binding request body consumes c request body and they cannot be called multiple times go type forma struct foo stringjson foo xml foo binding required type formb struct bar string json bar xml bar binding required func somehandler c gin context obja forma objb formb this c shouldbind consumes c request body and it cannot be reused if erra c shouldbind obja erra nil c string http statusok the body should be forma always an error is occurred by this because c request body is eof now else if errb c shouldbind objb errb nil c string http statusok the body should be formb else for this you can use c shouldbindbodywith go func somehandler c gin context obja forma objb formb this reads c request body and stores the result into the context if erra c shouldbindbodywith obja binding json erra nil c string http statusok the body should be forma at this time it reuses body stored in the context else if errb c shouldbindbodywith objb binding json errb nil c string http statusok the body should be formb json and it can accepts other formats else if errb2 c shouldbindbodywith objb binding xml errb2 nil c string http statusok the body should be formb xml else c shouldbindbodywith stores body into the context before binding this has a slight impact to performance so you should not use this method if you are enough to call binding at once this feature is only needed for some formats json xml msgpack protobuf for other formats query form formpost formmultipart can be called by c shouldbind multiple times without any damage to performance see 1341 http2 server push http pusher is supported only go1 8 see the golang blog for detail information go package main import html template log github com gin gonic gin var html template must template new https parse html head title https test title script src assets app js script head body h1 style color red welcome ginner h1 body html func main r gin default r static assets assets r sethtmltemplate html r get func c gin context if pusher c writer pusher pusher nil use pusher push to do server push if err pusher push assets app js nil err nil log printf failed to push v err c html 200 https gin h status success listen and server in https 127 0 0 1 8080 r runtls 8080 testdata server pem testdata server key testing the net http httptest package is preferable way for http testing go package main func setuprouter gin engine r gin default r get ping func c gin context c string 200 pong return r func main r setuprouter r run 8080 test for code example above go package main import net http net http httptest testing github com stretchr testify assert func testpingroute t testing t router setuprouter w httptest newrecorder req http newrequest get ping nil router servehttp w req assert equal t 200 w code assert equal t pong w body string users awesome project lists using gin web framework drone drone is a continuous delivery platform built on docker written in go gorush a push notification server written in go