hyperapp hyperapp is a javascript micro framework for building web applications minimal — we have aggressively minimized the concepts you need to understand to be productive while remaining on par with what other frameworks can do pragmatic — hyperapp holds firm on the functional programming front when managing your state but takes a pragmatic approach to allowing for side effects asynchronous actions and dom manipulations standalone — do more with less hyperapp combines state management with a virtual dom engine that supports keyed updates lifecycle events — all with no dependencies getting started our first example is a counter that can be incremented or decremented go ahead and try it online jsx import h app from hyperapp const state count 0 const actions down value state count state count value up value state count state count value const view state actions state count actions down 1 actions up 1 app state actions view document body hyperapp consists of a two function api hyperapp h returns a new virtual dom node tree and hyperapp app mounts a new application in the specified dom element without an element its possible to use hyperapp headless which can be useful when unit testing your program this example assumes you are using a javascript compiler like babel or typescript and a module bundler like parcel webpack etc if you are using jsx all you need to do is install the jsx transform plugin and add the pragma option to your babelrc file json plugins transform react jsx pragma h jsx is a language syntax extension that lets you write html tags interspersed with javascript because browsers dont understand jsx we use a compiler to transform it into hyperapp h function calls under the hood jsx const view state actions h div h h1 state count h button onclick actions down 1 h button onclick actions up 1 note that jsx is not required for building applications with hyperapp you can use hyperapp h directly and without a compilation step as shown above other alternatives to jsx include hyperapp html hyperx t7 and ijk installation install with npm or yarn npm i hyperapp then with a module bundler like rollup or webpack use as you would anything else js import h app from hyperapp if you dont want to set up a build environment you can download hyperapp from a cdn like unpkg com and it will be globally available through the window hyperapp object we support all es5 compliant browsers including internet explorer 10 and above html script src https unpkg com hyperapp script overview hyperapp applications consist of three interconnected parts the state view and actions once initialized your application executes in a continuous loop taking in actions from users or from external events updating the state and representing changes in the view through a virtual dom model think of an action as a signal that notifies hyperapp to update the state and schedule the next view redraw after processing an action the new state is presented back to the user state the state is a plain javascript object that describes your entire program it consists of all the dynamic data that is moved around in the application during its execution the state cannot be mutated once it is created we must use actions to update it js const state count 0 like any javascript object the state can be a nested tree of objects we refer to nested objects in the state as partial state a single state tree does not conflict with modularity — see nested actions to find out how to update deeply nested objects and split your state and actions js const state top count 0 bottom count 0 because hyperapp performs a shallow merge when updating your state the top level state must be a plain javascript object other than this you can use any type including arrays es6 maps sets immutable js structures etc actions the only way to change the state is via actions an action is a unary function accepts a single argument expecting a payload the payload can be anything you want to pass into the action to update the state an action must return a partial state object the new state will be the result of a shallow merge between this object and the current state under the hood hyperapp wires every function from your actions to schedule a view redraw whenever the state changes js const actions setvalue value value instead of returning a partial state object directly an action can return a function that takes the current state and actions as arguments and returns a partial state object js const actions down value state count state count value up value state count state count value state updates are always immutable do not mutate the state object argument within an action and return it — the results are not what you expect e g the view will not be redrawn immutability enables time travel debugging helps prevent introducing hard to track down bugs by making state changes more predictable and allows cheap memoization of components using shallow equality checks asynchronous actions actions used for side effects writing to databases sending a request to a server etc dont need to have a return value you may call an action from within another action or callback function actions which return a promise undefined or null will not trigger redraws or update the state js const actions uplater value state actions settimeout actions up 1000 value up value state count state count value an action can be an async function because async functions return a promise and not a partial state object you need to call another action in order to update the state js const actions uplater async state actions await new promise done settimeout done 1000 actions up 10 up value state count state count value nested actions actions can be nested inside namespaces updating deeply nested state is as easy as declaring actions inside an object in the same path as the part of the state you want to update jsx const state counter count 0 const actions counter down value state count state count value up value state count state count value interoperability the app function returns a copy of your actions where every function is wired to changes in the state exposing this object to the outside world can be useful to operate your application from another program or framework subscribe to global events listen to mouse and keyboard input etc to see this in action modify the example from getting started to save the wired actions to a variable and try using them you should see the counter update accordingly jsx const main app state actions view document body setinterval main up 250 1 setinterval main down 500 1 including an action returning the state argument can be useful because state updates are always immutable returning a reference to the current state will not schedule a view redraw jsx const actions getstate state state view every time your application state changes the view function is called so that you can specify how you want the dom to look based on the new state the view returns your specification in the form of a plain javascript object known as a virtual dom and hyperapp takes care of updating the actual dom to match it js import h from hyperapp export const view state actions h div h h1 state count h button onclick actions down 1 h button onclick actions up 1 a virtual dom is a description of what a dom should look like using a tree of nested javascript objects known as virtual nodes think of it as a lightweight representation of the dom in the example the view function returns an object like this jsx nodename div attributes children nodename h1 attributes children 0 nodename button attributes children nodename button attributes children the virtual dom model allows us to write code as if the entire document is thrown away and rebuilt on each change while we only update what actually changed we try to do this in the least number of steps possible by comparing the new virtual dom against the previous one this leads to high efficiency since typically only a small percentage of nodes need to change and changing real dom nodes is costly compared to recalculating the virtual dom it may seem wasteful to throw away the old virtual dom and re create it entirely on every update — not to mention the fact that at any one time hyperapp is keeping two virtual dom trees in memory but as it turns out browsers can create hundreds of thousands of objects very quickly on the other hand modifying the dom is several orders of magnitude more expensive mounting to mount your application in a page we need a dom element this element is referred to as the application container applications built with hyperapp always have a single container jsx app state actions view container hyperapp will also attempt to reuse existing elements inside the container enabling seo optimization and improving your sites time to interactive the process consists of serving a fully rendered page together with your application then instead of throwing away the existing content well turn your dom nodes into an interactive application out of the box this is how we can recycle server rendered content out the counter example from before see getting started for the application code html doctype html 0 components a component is a pure function that returns a virtual node unlike the view function components are not wired to your application state or actions components are dumb reusable blocks of code that encapsulate markup styles and behaviors that belong together heres a taste of how to use components in your application the application is a typical to do manager go ahead and try it online here jsx import h from hyperapp const todoitem id value done toggle toggle value done id id value export const view state actions todo state todos map id value done if you dont know all the attributes that you want to place in a component ahead of time you can use the spread syntax note that hyperapp components can return an array of elements as in the following example this technique lets you group a list of children without adding extra nodes to the dom jsx const todolist todos toggle todos map todo todoitem todo toggle toggle lazy components components can only receive attributes and children from their parent component similarly to the top level view function lazy components are passed your application global state and actions to create a lazy component return a view function from a regular component jsx import h from hyperapp export const up by state actions actions up by by export const down by state actions actions down by by export const double state actions actions up state count state count export const view state actions state count children composition components receive their children elements via the second argument allowing you and other components to pass arbitrary children down to them jsx const box color children div class box box color children const hellobox name hello name supported attributes supported attributes include html attributes svg attributes dom events lifecycle events and keys note that non standard html attribute names are not supported onclick and class are valid but onclick or classname are not styles the style attribute expects a plain object rather than a string as in html each declaration consists of a style name property written in camelcase and a value css variables are supported too individual style properties will be diffed and mapped against htmlelement style property members of the dom element you should therefore use the javascript style object property names e g backgroundcolor rather than background color jsx import h from hyperapp export const jumbotron text div style color white fontsize 32px textalign center backgroundimage url imgurl text lifecycle events you can be notified when elements managed by the virtual dom are created updated or removed via lifecycle events use them for animation data fetching wrapping third party libraries cleaning up resources etc note that lifecycle events are attached to virtual dom nodes not to components consider adding a key to ensure that the event is attached to a specific dom element rather than a recycled one oncreate this event is fired after the element is created and attached to the dom use it to manipulate the dom node directly make a network request create a slide fade in animation etc jsx import h from hyperapp export const textbox placeholder element focus onupdate this event is fired every time we update the element attributes use oldattributes inside the event handler to check if any attributes changed or not jsx import h from hyperapp export const textbox placeholder if oldattributes placeholder placeholder handle changes here onremove this event is fired before the element is removed from the dom use it to create slide fade out animations call done inside the function to remove the element this event is not called in its child elements jsx import h from hyperapp export const messagewithfadeout title fadeout element then done title ondestroy this event is fired after the element has been removed from the dom either directly or as a result of a parent being removed use it for invalidating timers canceling a network request removing global events listeners etc jsx import h from hyperapp export const camera onerror navigator mediadevices getusermedia video true then stream element srcobject stream catch onerror ondestroy element element srcobject gettracks 0 stop keys keys helps identify nodes every time we update the dom by setting the key property on a virtual node you declare that the node should correspond to a particular dom element this allow us to re order the element into its new position if the position changed rather than risk destroying it jsx import h from hyperapp export const imagegallery images images map hash url description keys must be unique among sibling nodes dont use an array index as key if the index also specifies the order of siblings if the position and number of items in a list is fixed it will make no difference but if the list is dynamic the key will change every time the tree is rebuilt jsx import h from hyperapp export const playerlist players players slice sort player nextplayer nextplayer score player score map player top level nodes keys are not registered on the top level node of your view if you are toggling the top level view and you must use keys wrap them in an unchanging node links slack twitter examples r hyperapp license hyperapp is mit licensed see license