primitive pictures reproducing images with geometric primitives how it works a target image is provided as input the algorithm tries to find the single most optimal shape that can be drawn to minimize the error between the target image and the drawn image it repeats this process adding one shape at a time around 50 to 200 shapes are needed to reach a result that is recognizable yet artistic and abstract primitive for macos now available as a native mac application https primitive lol twitter follow primitivepic on twitter to see a new primitive picture every 30 minutes the twitter bot looks for interesting photos using the flickr api runs the algorithm using randomized parameters and posts the picture using the twitter api you can tweet a picture to the bot and it will process it for you command line usage run it on your own images first install go go get u github com fogleman primitive primitive i input png o output png n 100 small input images should be used like 256x256px you dont need the detail anyway and the code will run faster flag default description i n a input file o n a output file n n a number of shapes m 1 mode 0 combo 1 triangle 2 rect 3 ellipse 4 circle 5 rotatedrect 6 beziers 7 rotatedellipse 8 polygon rep 0 add n extra shapes each iteration with reduced search mostly good for beziers nth 1 save every nth frame only when d is in output path r 256 resize large input images to this size before processing s 1024 output image size a 128 color alpha use 0 to let the algorithm choose alpha for each shape bg avg starting background color hex j 0 number of parallel workers default uses all cores v off verbose output vv off very verbose output output formats depending on the output filename extension provided you can produce different types of output png raster output jpg raster output svg vector output gif animated output showing shapes being added requires imagemagick specifically the convert command for png and svg outputs you can also include d 03d etc in the filename in this case each frame will be saved separately you can use the o flag multiple times this way you can save both a png and an svg for example progression this gif demonstrates the iterative nature of the algorithm attempting to minimize the mean squared error by adding one shape at a time use a gif output file to generate one yourself static animation since the algorithm has a random component to it you can run it against the same input image multiple times to bring life to a static image creative constraints if youre willing to dabble in the code you can enforce constraints on the shapes to produce even more interesting results here the rectangles are constrained to point toward the sun in this picture of a pyramid sunset shape and iteration comparison matrix the matrix below shows triangles ellipses and rectangles at 50 100 and 200 iterations each how it works part ii say we have a target image this is what were working towards recreating we start with a blank canvas but we fill it with a single solid color currently this is the average color of the target image we call this new blank canvas the current image now we start evaluating shapes to evaluate a shape we draw it on top of the current image producing a new image this new image is compared to the target image to compute a score we use the root mean square error for the score current image shape new image rmse new image target image score the shapes are generated randomly we can generate a random shape and score it then we can mutate the shape by tweaking a triangle vertex tweaking an ellipse radius or center etc and score it again if the mutation improved the score we keep it otherwise we rollback to the previous state repeating this process is known as hill climbing hill climbing is prone to getting stuck in local minima so we actually do this many different times with several different starting shapes we can also generate n random shapes and pick the best one before we start hill climbing simulated annealing is another good option but in my tests i found the hill climbing technique just as good and faster at least for this particular problem once we have found a good scoring shape we add it to the current image where it will remain unchanged then we start the process again to find the next shape to draw this process is repeated as many times as desired primitives the following primitives are supported triangle rectangle axis aligned ellipse axis aligned circle rotated rectangle combo a mix of the above in a single image more shapes can be added by implementing the following interface go type shape interface rasterize scanline copy shape mutate draw dc gg context svg attrs string string features hill climbing or simulated annealing for optimization hill climbing multiple random shapes is nearly as good as annealing and faster scanline rasterization of shapes in pure go preferable for implementing the features below optimal color computation based on affected pixels for each shape color is directly computed not optimized for partial image difference for faster scoring only pixels that change need be considered anti aliased output rendering inspiration this project was originally inspired by the popular and excellent work of roger johansson genetic programming evolution of mona lisa since seeing that article when it was quite new ive tinkered with this problem here and there over the years but only now am i satisfied with my results it should be noted that there are significant differences in my implementation compared to rogers original work mine is not a genetic algorithm mine only operates on one shape at a time mine is much faster afaik and supports many types of shapes examples here are more examples from interesting photos found on flickr