carrierwave this gem provides a simple and extremely flexible way to upload files from ruby applications it works well with rack based web applications such as ruby on rails information rdoc documentation available on rubydoc info source code available on github more information known limitations and how tos available on the wiki getting help please ask the community on stack overflow for help if you have any questions please do not post usage questions on the issue tracker please report bugs on the issue tracker but read the getting help section in the wiki first installation install the latest release gem install carrierwave in rails add it to your gemfile ruby gem carrierwave 1 0 finally restart the server to apply the changes as of version 1 0 carrierwave requires rails 4 0 or higher and ruby 2 0 or higher if youre on rails 3 you should use v0 11 0 getting started start off by generating an uploader rails generate uploader avatar this should give you a file in app uploaders avatar uploader rb check out this file for some hints on how you can customize your uploader it should look something like this ruby class avataruploader carrierwave uploader base storage file end you can use your uploader class to store and retrieve files like this ruby uploader avataruploader new uploader store my file uploader retrieve from store my file png carrierwave gives you a store for permanent storage and a cache for temporary storage you can use different stores including filesystem and cloud storage most of the time you are going to want to use carrierwave together with an orm it is quite simple to mount uploaders on columns in your model so you can simply assign files and get going activerecord make sure you are loading carrierwave after loading your orm otherwise youll need to require the relevant extension manually e g ruby require carrierwave orm activerecord add a string column to the model you want to mount the uploader by creating a migration rails g migration add avatar to users avatar string rake db migrate open your model file and mount the uploader ruby class user activerecord base mount uploader avatar avataruploader end now you can cache files by assigning them to the attribute they will automatically be stored when the record is saved ruby u user new u avatar params file assign a file like this or like this file open somewhere do f u avatar f end u save u avatar url url to file png u avatar current path path to file png u avatar identifier file png note u avatar will never return nil even if there is no photo associated to it to check if a photo was saved to the model use u avatar file nil instead datamapper mongoid sequel other orm support has been extracted into separate gems carrierwave datamapper carrierwave mongoid carrierwave sequel there are more extensions listed in the wiki multiple file uploads carrierwave also has convenient support for multiple file upload fields activerecord add a column which can store an array this could be an array column or a json column for example your choice depends on what your database supports for example create a migration like this for databases with activerecord json data type support e g postgresql mysql rails g migration add avatars to users avatars json rake db migrate for database without activerecord json data type support e g sqlite rails g migration add avatars to users avatars string rake db migrate note json datatype doesnt exists in sqlite adapter thats why you can use a string datatype which will be serialized in model open your model file and mount the uploader ruby class user activerecord base mount uploaders avatars avataruploader serialize avatars json if you use sqlite add this line end make sure your file input fields are set up as multiple file fields for example in rails youll want to do something like this erb form file field avatars multiple true also make sure your upload controller permits the multiple file upload attribute pointing to an empty array in a hash for example ruby params require user permit email first name last name avatars now you can select multiple files in the upload dialog e g shift select and they will automatically be stored when the record is saved ruby u user new params user u save u avatars 0 url url to file png u avatars 0 current path path to file png u avatars 0 identifier file png changing the storage directory in order to change where uploaded files are put just override the store dir method ruby class myuploader carrierwave uploader base def store dir public my upload directory end end this works for the file storage as well as amazon s3 and rackspace cloud files define store dir as nil if youd like to store files at the root level if you store files outside the project root folder you may want to define cache dir in the same way ruby class myuploader carrierwave uploader base def cache dir tmp projectname cache end end securing uploads certain files might be dangerous if uploaded to the wrong location such as php files or other script files carrierwave allows you to specify a whitelist of allowed extensions or content types if youre mounting the uploader uploading a file with the wrong extension will make the record invalid instead otherwise an error is raised ruby class myuploader carrierwave uploader base def extension whitelist w jpg jpeg gif png end end the same thing could be done using content types lets say we need an uploader that accepts only images this can be done like this ruby class myuploader carrierwave uploader base def content type whitelist image\ end end you can use a blacklist to reject content types lets say we need an uploader that reject json files this can be done like this ruby class nojsonuploader carrierwave uploader base def content type blacklist application text application json end end filenames and unicode chars another security issue you should care for is the file names see ruby on rails security guide by default carrierwave provides only english letters arabic numerals and some symbols as white listed characters in the file name if you want to support local scripts cyrillic letters letters with diacritics and so on you have to override sanitize regexp method it should return regular expression which would match all non allowed symbols ruby carrierwave sanitizedfile sanitize regexp word \ \ \ also make sure that allowing non latin characters wont cause a compatibility issue with a third party plugins or client side software setting the content type as of v0 11 0 the mime types gem is a runtime dependency and the content type is set automatically you no longer need to do this manually adding versions often youll want to add different versions of the same file the classic example is image thumbnails there is built in support for this note you must have imagemagick and minimagick installed to do image resizing minimagick is a ruby interface for imagemagick which is a c program this is why minimagick fails on bundle install without imagemagick installed some documentation refers to rmagick instead of minimagick but minimagick is recommended to install imagemagick on osx with homebrew type the following brew install imagemagick ruby class myuploader carrierwave uploader base include carrierwave minimagick process resize to fit 800 800 version thumb do process resize to fill 200 200 end end when this uploader is used an uploaded image would be scaled to be no larger than 800 by 800 pixels the original aspect ratio will be kept a version called thumb is then created which is scaled to exactly 200 by 200 pixels if you would like to crop images to a specific height and width you can use the alternative option of resize to fill it will make sure that the width and height specified are filled only cropping if the aspect ratio requires it the uploader could be used like this ruby uploader avataruploader new uploader store my file size 1024x768 uploader url url to my file png size 800x800 uploader thumb url url to thumb my file png size 200x200 one important thing to remember is that process is called before versions are created this can cut down on processing cost it is possible to nest versions within versions ruby class myuploader carrierwave uploader base version animal do version human version monkey version llama end end conditional versions occasionally you want to restrict the creation of versions on certain properties within the model or based on the picture itself ruby class myuploader carrierwave uploader base version human if is human version monkey if is monkey version banner if is landscape private def is human picture model can program ruby end def is monkey picture model favorite food banana end def is landscape picture image minimagick image open picture path image width image height end end the model variable points to the instance object the uploader is attached to create versions from existing versions for performance reasons it is often useful to create versions from existing ones instead of using the original file if your uploader generates several versions where the next is smaller than the last it will take less time to generate from a smaller already processed image ruby class myuploader carrierwave uploader base version thumb do process resize to fill 280 280 end version small thumb from version thumb do process resize to fill 20 20 end end the option from version uses the file cached in the thumb version instead of the original version potentially resulting in faster processing making uploads work across form redisplays often youll notice that uploaded files disappear when a validation fails carrierwave has a feature that makes it easy to remember the uploaded file even in that case suppose your user model has an uploader mounted on avatar file just add a hidden field called avatar cache dont forget to add it to the attr accessible list as necessary in rails this would look like this erb form for user html multipart true do f my avatar f file field avatar f hidden field avatar cache end it might be a good idea to show the user that a file has been uploaded in the case of images a small thumbnail would be a good indicator erb form for user html multipart true do f p label my avatar label image tag user avatar url if user avatar f file field avatar f hidden field avatar cache p end removing uploaded files if you want to remove a previously uploaded file on a mounted uploader you can easily add a checkbox to the form which will remove the file when checked erb form for user html multipart true do f my avatar image tag user avatar url if user avatar f file field avatar f check box remove avatar remove avatar end if you want to remove the file manually you can call remove avatar then save the object erb user remove avatar user save true uploading files from a remote location your users may find it convenient to upload a file from a location on the internet via a url carrierwave makes this simple just add the appropriate attribute to your form and youre good to go erb form for user html multipart true do f p label my avatar url label image tag user avatar url if user avatar f text field remote avatar url p end if youre using activerecord carrierwave will indicate invalid urls and download failures automatically with attribute validation errors if you arent or you disable carrierwaves validate download option youll need to handle those errors yourself providing a default url in many cases especially when working with images it might be a good idea to provide a default url a fallback in case no file has been uploaded you can do this easily by overriding the default url method in your uploader ruby class myuploader carrierwave uploader base def default url args images fallback version name default png compact join end end or if you are using the rails asset pipeline ruby class myuploader carrierwave uploader base def default url args actioncontroller base helpers asset path fallback version name default png compact join end end recreating versions you might come to a situation where you want to retroactively change a version or add a new one you can use the recreate versions method to recreate the versions from the base file this uses a naive approach which will re upload and process the specified version or all versions if none is passed as an argument when you are generating random unique filenames you have to call save on the model after using recreate versions this is necessary because recreate versions doesnt save the new filename to the database calling save yourself will prevent that the database and file system are running out of sync ruby instance myuploader new instance recreate versions thumb large or on a mounted uploader ruby user find each do user user avatar recreate versions end note recreate versions will throw an exception on records without an image to avoid this scope the records to those with images or check if an image exists within the block if youre using activerecord recreating versions for a user avatar might look like this ruby user find each do user user avatar recreate versions if user avatar end configuring carrierwave carrierwave has a broad range of configuration options which you can configure both globally and on a per uploader basis ruby carrierwave configure do config config permissions 0666 config directory permissions 0777 config storage file end or alternatively ruby class avataruploader carrierwave uploader base permissions 0777 end if youre using rails create an initializer for this config initializers carrierwave rb if you want carrierwave to fail noisily in development you can change these configs in your environment file ruby carrierwave configure do config config ignore integrity errors false config ignore processing errors false config ignore download errors false end testing with carrierwave its a good idea to test your uploaders in isolation in order to speed up your tests its recommended to switch off processing in your tests and to use the file storage in rails you could do that by adding an initializer with ruby if rails env test or rails env cucumber carrierwave configure do config config storage file config enable processing false end end remember if you have already set storage something in your uploader the storage setting from this initializer will be ignored if you need to test your processing you should test it in isolation and enable processing only for those tests that need it carrierwave comes with some rspec matchers which you may find useful ruby require carrierwave test matchers describe myuploader do include carrierwave test matchers let user double user let uploader myuploader new user avatar before do myuploader enable processing true file open path to file f uploader store f end after do myuploader enable processing false uploader remove end context the thumb version do it scales down a landscape image to be exactly 64 by 64 pixels do expect uploader thumb to have dimensions 64 64 end end context the small version do it scales down a landscape image to fit within 200 by 200 pixels do expect uploader small to be no larger than 200 200 end end it makes the image readable only to the owner and not executable do expect uploader to have permissions 0600 end it has the correct format do expect uploader to be format png end end if youre looking for minitest asserts checkout carrierwave asserts setting the enable processing flag on an uploader will prevent any of the versions from processing as well processing can be enabled for a single version by setting the processing flag on the version like so ruby uploader thumb enable processing true fog if you want to use fog you must add in your carrierwave initializer the following lines ruby config fog provider fog fog aws etc defaults to fog config fog credentials provider specific credentials using amazon s3 fog aws is used to support amazon s3 ensure you have it in your gemfile ruby gem fog aws youll need to provide your fog credentials and a fog directory also known as a bucket in an initializer for the sake of performance it is assumed that the directory already exists so please create it if it needs to be you can also pass in additional options as documented fully in lib carrierwave storage fog rb heres a full example ruby carrierwave configure do config config fog provider fog aws required config fog credentials provider aws required aws access key id xxx required unless using use iam profile aws secret access key yyy required unless using use iam profile use iam profile true optional defaults to false region eu west 1 optional defaults to us east 1 host s3 example com optional defaults to nil endpoint https s3 example com 8080 optional defaults to nil config fog directory name of bucket required config fog public false optional defaults to true config fog attributes cache control public max age 365 days to i optional defaults to end in your uploader set the storage to fog ruby class avataruploader carrierwave uploader base storage fog end thats it you can still use the carrierwave uploader url method to return the url to the file on amazon s3 using rackspace cloud files fog is used to support rackspace cloud files ensure you have it in your gemfile ruby gem fog youll need to configure a directory also known as a container username and api key in the initializer for the sake of performance it is assumed that the directory already exists so please create it if need be using a us based account ruby carrierwave configure do config config fog provider fog rackspace storage optional defaults to fog config fog credentials provider rackspace rackspace username xxxxxx rackspace api key yyyyyy rackspace region ord optional defaults to dfw config fog directory name of directory end using a uk based account ruby carrierwave configure do config config fog provider fog rackspace storage optional defaults to fog config fog credentials provider rackspace rackspace username xxxxxx rackspace api key yyyyyy rackspace auth url fog rackspace uk auth endpoint rackspace region lon config fog directory name of directory end you can optionally include your cdn host name in the configuration this is highly recommended as without it every request requires a lookup of this information ruby config asset host http c000000 cdn rackspacecloud com in your uploader set the storage to fog ruby class avataruploader carrierwave uploader base storage fog end thats it you can still use the carrierwave uploader url method to return the url to the file on rackspace cloud files using google storage for developers fog is used to support google storage for developers ensure you have it in your gemfile ruby gem fog google gem google api client 0 8 5 0 9 gem mime types youll need to configure a directory also known as a bucket access key id and secret access key in the initializer for the sake of performance it is assumed that the directory already exists so please create it if need be please read the fog google readme on how to get credentials ruby carrierwave configure do config config fog provider fog google required config fog credentials provider google google storage access key id xxxxxx google storage secret access key yyyyyy config fog directory name of directory end in your uploader set the storage to fog ruby class avataruploader carrierwave uploader base storage fog end thats it you can still use the carrierwave uploader url method to return the url to the file on google optimized loading of fog since carrierwave doesnt know which parts of fog you intend to use it will just load the entire library unless you use e g fog aws fog google instead of fog proper if you prefer to load fewer classes into your application you need to load those parts of fog yourself before loading carrierwave in your gemfile ex ruby gem fog 1 27 require fog rackspace storage gem carrierwave a couple of notes about versions this functionality was introduced in fog v1 20 this functionality is slated for carrierwave v1 0 0 if youre not relying on gemfile entries alone and are requiring carrierwave anywhere ensure you require fog rackspace storage before it ex ruby require fog rackspace storage require carrierwave beware that this specific require is only needed when working with a fog provider that was not extracted to its own gem yet a list of the extracted providers can be found in the page of the fog organizations here when in doubt inspect fog constants to see what has been loaded dynamic asset host the asset host config property can be assigned a proc or anything that responds to call for generating the host dynamically the proc compliant object gets an instance of the current carrierwave storage fog file or carrierwave sanitizedfile as its only argument ruby carrierwave configure do config config asset host proc do file identifier some logic http identifier cdn rackspacecloud com end end using rmagick if youre uploading images youll probably want to manipulate them in some way you might want to create thumbnail images for example carrierwave comes with a small library to make manipulating images with rmagick easier youll need to include it in your uploader ruby class avataruploader carrierwave uploader base include carrierwave rmagick end the rmagick module gives you a few methods like carrierwave rmagick resize to fill which manipulate the image file in some way you can set a process callback which will call that method any time a file is uploaded there is a demonstration of convert here convert will only work if the file has the same file extension thus the use of the filename method ruby class avataruploader carrierwave uploader base include carrierwave rmagick process resize to fill 200 200 process convert png def filename super chomp file extname super png if original filename present end end check out the manipulate method which makes it easy for you to write your own manipulation methods using minimagick minimagick is similar to rmagick but performs all the operations using the mogrify command which is part of the standard imagemagick kit this allows you to have the power of imagemagick without having to worry about installing all the rmagick libraries see the minimagick site for more details https github com minimagick minimagick and the imagemagick command line options for more for whats on offer http www imagemagick org script command line options php currently the minimagick carrierwave processor provides exactly the same methods as for the rmagick processor ruby class avataruploader carrierwave uploader base include carrierwave minimagick process resize to fill 200 200 end migrating from paperclip if you are using paperclip you can use the provided compatibility module ruby class avataruploader carrierwave uploader base include carrierwave compatibility paperclip end see the documentation for carrierwave compatibility paperclip for more details be sure to use mount on to specify the correct column ruby mount uploader avatar avataruploader mount on avatar file name i18n the active record validations use the rails i18n framework add these keys to your translations file yaml errors messages carrierwave processing error failed to be processed carrierwave integrity error is not of an allowed file type carrierwave download error could not be downloaded extension whitelist error you are not allowed to upload extension files allowed types allowed types extension blacklist error you are not allowed to upload extension files prohibited types prohibited types content type whitelist error you are not allowed to upload content type files content type blacklist error you are not allowed to upload content type files rmagick processing error failed to manipulate with rmagick maybe it is not an image mini magick processing error failed to manipulate with minimagick maybe it is not an image original error e min size error file size should be greater than min size max size error file size should be less than max size the carrierwave i18n library adds support for additional locales large files by default carrierwave copies an uploaded file twice first copying the file into the cache then copying the file into the store for large files this can be prohibitively time consuming you may change this behavior by overriding either or both of the move to cache and move to store methods ruby class myuploader carrierwave uploader base def move to cache true end def move to store true end end when the move to cache and or move to store methods return true files will be moved instead of copied to the cache and store respectively this has only been tested with the local filesystem store skipping activerecord callbacks by default mounting an uploader into an activerecord model will add a few callbacks for example this code ruby class user mount uploader avatar avataruploader end will add these callbacks ruby after save store avatar before save write avatar identifier after commit remove avatar on destroy after commit mark remove avatar false on update after save store previous changes for avatar after commit remove previously stored avatar on update if you want to skip any of these callbacks eg you want to keep the existing avatar even after uploading a new one you can use activerecords skip callback method ruby class user mount uploader avatar avataruploader skip callback commit after remove previously stored avatar end contributing to carrierwave see contributing md license copyright c 2008 2015 jonas nicklas permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the software to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall the authors or copyright holders be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software